/*

Bryntum Scheduler 2.2.3
Copyright(c) 2019 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/license

*/
const productName = 'scheduler';

var support = {
  searchParams: 'URLSearchParams' in self,
  iterable: 'Symbol' in self && 'iterator' in Symbol,
  blob:
    'FileReader' in self &&
    'Blob' in self &&
    (function() {
      try {
        new Blob();
        return true;
      } catch (e) {
        return false;
      }
    })(),
  formData: 'FormData' in self,
  arrayBuffer: 'ArrayBuffer' in self
};

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ];

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
    };
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
    throw new TypeError('Invalid character in header field name');
  }
  return name.toLowerCase();
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }
  return value;
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === undefined, value: value };
    }
  };

  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }

  return iterator;
}

function Headers(headers) {
  this.map = {};

  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}

Headers.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};

Headers.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)];
};

Headers.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};

Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name));
};

Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};

Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};

Headers.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};

Headers.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items);
};

Headers.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'));
  }
  body.bodyUsed = true;
}

function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  });
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}

function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsText(blob);
  return promise;
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join('');
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}

function Body() {
  this.bodyUsed = false;

  this._initBody = function(body) {
    this._bodyInit = body;
    if (!body) {
      this._bodyText = '';
    } else if (typeof body === 'string') {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8');
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
    }
  };

  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob');
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };

    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
      } else {
        return this.blob().then(readBlobAsArrayBuffer);
      }
    };
  }

  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text');
    } else {
      return Promise.resolve(this._bodyText);
    }
  };

  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode);
    };
  }

  this.json = function() {
    return this.text().then(JSON.parse);
  };

  return this;
}

// HTTP methods whose capitalization should be normalized
var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}

function Request(input, options) {
  options = options || {};
  var body = options.body;

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read');
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }

  this.credentials = options.credentials || this.credentials || 'same-origin';
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal;
  this.referrer = null;

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests');
  }
  this._initBody(body);
}

Request.prototype.clone = function() {
  return new Request(this, { body: this._bodyInit });
};

function decode(body) {
  var form = new FormData();
  body
    .trim()
    .split('&')
    .forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
  return form;
}

function parseHeaders(rawHeaders) {
  var headers = new Headers();
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
  preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
    var parts = line.split(':');
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(':').trim();
      headers.append(key, value);
    }
  });
  return headers;
}

Body.call(Request.prototype);

function Response$1(bodyInit, options) {
  if (!options) {
    options = {};
  }

  this.type = 'default';
  this.status = options.status === undefined ? 200 : options.status;
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = 'statusText' in options ? options.statusText : 'OK';
  this.headers = new Headers(options.headers);
  this.url = options.url || '';
  this._initBody(bodyInit);
}

Body.call(Response$1.prototype);

Response$1.prototype.clone = function() {
  return new Response$1(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};

Response$1.error = function() {
  var response = new Response$1(null, { status: 0, statusText: '' });
  response.type = 'error';
  return response;
};

var redirectStatuses = [301, 302, 303, 307, 308];

Response$1.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code');
  }

  return new Response$1(null, { status: status, headers: { location: url } });
};

var DOMException$1 = self.DOMException;
try {
  new DOMException$1();
} catch (err) {
  DOMException$1 = function(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException$1.prototype = Object.create(Error.prototype);
  DOMException$1.prototype.constructor = DOMException$1;
}

function fetch$1(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init);

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException$1('Aborted', 'AbortError'));
    }

    var xhr = new XMLHttpRequest();

    function abortXhr() {
      xhr.abort();
    }

    xhr.onload = function() {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      };
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
      var body = 'response' in xhr ? xhr.response : xhr.responseText;
      resolve(new Response$1(body, options));
    };

    xhr.onerror = function() {
      reject(new TypeError('Network request failed'));
    };

    xhr.ontimeout = function() {
      reject(new TypeError('Network request failed'));
    };

    xhr.onabort = function() {
      reject(new DOMException$1('Aborted', 'AbortError'));
    };

    xhr.open(request.method, request.url, true);

    if (request.credentials === 'include') {
      xhr.withCredentials = true;
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false;
    }

    if ('responseType' in xhr && support.blob) {
      xhr.responseType = 'blob';
    }

    request.headers.forEach(function(value, name) {
      xhr.setRequestHeader(name, value);
    });

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr);

      xhr.onreadystatechange = function() {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr);
        }
      };
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  });
}

fetch$1.polyfill = true;

if (!self.fetch) {
  self.fetch = fetch$1;
  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response$1;
}

var commonjsGlobal =
  typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined'
    ? global
    : typeof self !== 'undefined'
    ? self
    : {};

(function(factory) {
  factory();
})(function() {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ('value' in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function');
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf =
      Object.setPrototypeOf ||
      function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === 'object' || typeof call === 'function')) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== 'undefined' && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  var Emitter =
    /*#__PURE__*/
    (function() {
      function Emitter() {
        _classCallCheck(this, Emitter);

        Object.defineProperty(this, 'listeners', {
          value: {},
          writable: true,
          configurable: true
        });
      }

      _createClass(Emitter, [
        {
          key: 'addEventListener',
          value: function addEventListener(type, callback) {
            if (!(type in this.listeners)) {
              this.listeners[type] = [];
            }

            this.listeners[type].push(callback);
          }
        },
        {
          key: 'removeEventListener',
          value: function removeEventListener(type, callback) {
            if (!(type in this.listeners)) {
              return;
            }

            var stack = this.listeners[type];

            for (var i = 0, l = stack.length; i < l; i++) {
              if (stack[i] === callback) {
                stack.splice(i, 1);
                return;
              }
            }
          }
        },
        {
          key: 'dispatchEvent',
          value: function dispatchEvent(event) {
            var _this = this;

            if (!(event.type in this.listeners)) {
              return;
            }

            var debounce = function debounce(callback) {
              setTimeout(function() {
                return callback.call(_this, event);
              });
            };

            var stack = this.listeners[event.type];

            for (var i = 0, l = stack.length; i < l; i++) {
              debounce(stack[i]);
            }

            return !event.defaultPrevented;
          }
        }
      ]);

      return Emitter;
    })();

  var AbortSignal =
    /*#__PURE__*/
    (function(_Emitter) {
      _inherits(AbortSignal, _Emitter);

      function AbortSignal() {
        var _this2;

        _classCallCheck(this, AbortSignal);

        _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AbortSignal).call(this)); // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and
        // we want Object.keys(new AbortController().signal) to be [] for compat with the native impl

        Object.defineProperty(_assertThisInitialized(_this2), 'aborted', {
          value: false,
          writable: true,
          configurable: true
        });
        Object.defineProperty(_assertThisInitialized(_this2), 'onabort', {
          value: null,
          writable: true,
          configurable: true
        });
        return _this2;
      }

      _createClass(AbortSignal, [
        {
          key: 'toString',
          value: function toString() {
            return '[object AbortSignal]';
          }
        },
        {
          key: 'dispatchEvent',
          value: function dispatchEvent(event) {
            if (event.type === 'abort') {
              this.aborted = true;

              if (typeof this.onabort === 'function') {
                this.onabort.call(this, event);
              }
            }

            _get(_getPrototypeOf(AbortSignal.prototype), 'dispatchEvent', this).call(this, event);
          }
        }
      ]);

      return AbortSignal;
    })(Emitter);
  var AbortController =
    /*#__PURE__*/
    (function() {
      function AbortController() {
        _classCallCheck(this, AbortController);

        // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and
        // we want Object.keys(new AbortController()) to be [] for compat with the native impl
        Object.defineProperty(this, 'signal', {
          value: new AbortSignal(),
          writable: true,
          configurable: true
        });
      }

      _createClass(AbortController, [
        {
          key: 'abort',
          value: function abort() {
            var event;

            try {
              event = new Event('abort');
            } catch (e) {
              if (typeof document !== 'undefined') {
                if (!document.createEvent) {
                  // For Internet Explorer 8:
                  event = document.createEventObject();
                  event.type = 'abort';
                } else {
                  // For Internet Explorer 11:
                  event = document.createEvent('Event');
                  event.initEvent('abort', false, false);
                }
              } else {
                // Fallback where document isn't available:
                event = {
                  type: 'abort',
                  bubbles: false,
                  cancelable: false
                };
              }
            }

            this.signal.dispatchEvent(event);
          }
        },
        {
          key: 'toString',
          value: function toString() {
            return '[object AbortController]';
          }
        }
      ]);

      return AbortController;
    })();

  if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    // These are necessary to make sure that we get correct output for:
    // Object.prototype.toString.call(new AbortController())
    AbortController.prototype[Symbol.toStringTag] = 'AbortController';
    AbortSignal.prototype[Symbol.toStringTag] = 'AbortSignal';
  }

  function polyfillNeeded(self) {
    if (self.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
      console.log('__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill');
      return true;
    } // Note that the "unfetch" minimal fetch polyfill defines fetch() without
    // defining window.Request, and this polyfill need to work on top of unfetch
    // so the below feature detection needs the !self.AbortController part.
    // The Request.prototype check is also needed because Safari versions 11.1.2
    // up to and including 12.1.x has a window.AbortController present but still
    // does NOT correctly implement abortable fetch:
    // https://bugs.webkit.org/show_bug.cgi?id=174980#c2

    return (
      (typeof self.Request === 'function' && !self.Request.prototype.hasOwnProperty('signal')) || !self.AbortController
    );
  }

  /**
   * Note: the "fetch.Request" default value is available for fetch imported from
   * the "node-fetch" package and not in browsers. This is OK since browsers
   * will be importing umd-polyfill.js from that path "self" is passed the
   * decorator so the default value will not be used (because browsers that define
   * fetch also has Request). One quirky setup where self.fetch exists but
   * self.Request does not is when the "unfetch" minimal fetch polyfill is used
   * on top of IE11; for this case the browser will try to use the fetch.Request
   * default value which in turn will be undefined but then then "if (Request)"
   * will ensure that you get a patched fetch but still no Request (as expected).
   * @param {fetch, Request = fetch.Request}
   * @returns {fetch: abortableFetch, Request: AbortableRequest}
   */

  function abortableFetchDecorator(patchTargets) {
    if ('function' === typeof patchTargets) {
      patchTargets = {
        fetch: patchTargets
      };
    }

    var _patchTargets = patchTargets,
      fetch = _patchTargets.fetch,
      _patchTargets$Request = _patchTargets.Request,
      NativeRequest = _patchTargets$Request === void 0 ? fetch.Request : _patchTargets$Request,
      NativeAbortController = _patchTargets.AbortController,
      _patchTargets$__FORCE = _patchTargets.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL,
      __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL = _patchTargets$__FORCE === void 0 ? false : _patchTargets$__FORCE;

    if (
      !polyfillNeeded({
        fetch: fetch,
        Request: NativeRequest,
        AbortController: NativeAbortController,
        __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL: __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL
      })
    ) {
      return {
        fetch: fetch,
        Request: Request
      };
    }

    var Request = NativeRequest; // Note that the "unfetch" minimal fetch polyfill defines fetch() without
    // defining window.Request, and this polyfill need to work on top of unfetch
    // hence we only patch it if it's available. Also we don't patch it if signal
    // is already available on the Request prototype because in this case support
    // is present and the patching below can cause a crash since it assigns to
    // request.signal which is technically a read-only property. This latter error
    // happens when you run the main5.js node-fetch example in the repo
    // "abortcontroller-polyfill-examples". The exact error is:
    //   request.signal = init.signal;
    //   ^
    // TypeError: Cannot set property signal of #<Request> which has only a getter

    if ((Request && !Request.prototype.hasOwnProperty('signal')) || __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
      Request = function Request(input, init) {
        var signal;

        if (init && init.signal) {
          signal = init.signal; // Never pass init.signal to the native Request implementation when the polyfill has
          // been installed because if we're running on top of a browser with a
          // working native AbortController (i.e. the polyfill was installed due to
          // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our
          // fake AbortSignal to the native fetch will trigger:
          // TypeError: Failed to construct 'Request': member signal is not of type AbortSignal.

          delete init.signal;
        }

        var request = new NativeRequest(input, init);

        if (signal) {
          Object.defineProperty(request, 'signal', {
            writable: false,
            enumerable: false,
            configurable: true,
            value: signal
          });
        }

        return request;
      };

      Request.prototype = NativeRequest.prototype;
    }

    var realFetch = fetch;

    var abortableFetch = function abortableFetch(input, init) {
      var signal = Request && Request.prototype.isPrototypeOf(input) ? input.signal : init ? init.signal : undefined;

      if (signal) {
        var abortError;

        try {
          abortError = new DOMException('Aborted', 'AbortError');
        } catch (err) {
          // IE 11 does not support calling the DOMException constructor, use a
          // regular error object on it instead.
          abortError = new Error('Aborted');
          abortError.name = 'AbortError';
        } // Return early if already aborted, thus avoiding making an HTTP request

        if (signal.aborted) {
          return Promise.reject(abortError);
        } // Turn an event into a promise, reject it once `abort` is dispatched

        var cancellation = new Promise(function(_, reject) {
          signal.addEventListener(
            'abort',
            function() {
              return reject(abortError);
            },
            {
              once: true
            }
          );
        });

        if (init && init.signal) {
          // Never pass .signal to the native implementation when the polyfill has
          // been installed because if we're running on top of a browser with a
          // working native AbortController (i.e. the polyfill was installed due to
          // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our
          // fake AbortSignal to the native fetch will trigger:
          // TypeError: Failed to execute 'fetch' on 'Window': member signal is not of type AbortSignal.
          delete init.signal;
        } // Return the fastest promise (don't need to wait for request to finish)

        return Promise.race([cancellation, realFetch(input, init)]);
      }

      return realFetch(input, init);
    };

    return {
      fetch: abortableFetch,
      Request: Request
    };
  }

  (function(self) {
    if (!polyfillNeeded(self)) {
      return;
    }

    if (!self.fetch) {
      console.warn('fetch() is not available, cannot install abortcontroller-polyfill');
      return;
    }

    var _abortableFetch = abortableFetchDecorator(self),
      fetch = _abortableFetch.fetch,
      Request = _abortableFetch.Request;

    self.fetch = fetch;
    self.Request = Request;
    Object.defineProperty(self, 'AbortController', {
      writable: true,
      enumerable: false,
      configurable: true,
      value: AbortController
    });
    Object.defineProperty(self, 'AbortSignal', {
      writable: true,
      enumerable: false,
      configurable: true,
      value: AbortSignal
    });
  })(typeof self !== 'undefined' ? self : commonjsGlobal);
});

/**
 * Keeps a map of registered widgets. Used by BryntumWidgetAdapter to create widgets using `{ type : 'xx' }`.
 * @private
 */
class BryntumWidgetAdapterRegister {
  static register(type, widgetClass) {
    const classEntry = widgetClassRegister[widgetClass];

    // Create a mapping from the type to the class
    widgetRegister[type] = widgetClass;

    // Create a mapping from the class to its type identifier(s)
    if (classEntry) {
      classEntry[type] = 1;
    } else {
      widgetClassRegister[widgetClass] = {
        [type]: 1
      };
    }
  }

  static getClass(type) {
    return widgetRegister[type];
  }

  /**
   * Determines whether the passed widget matches the passed type. So a {@link Common.widget.Combo}
   * would match any of its three registered types, `'combobox'`, '`combo'` or `'dropdown'`.
   *
   * Pass the `deep` parameter as `true` to test the class hierarchy also, so if `deep`, a
   * {@link Common.widget.Combo} would also match `'pickerfield'`, `'field'` and `'widget'`.
   *
   * Note that this is *type* matching, not querying, so patterns such as `'*'` will not match.
   * @param {Common.widget.Widget} widget The widget to test.
   * @param {String} type The stype string to test against.
   * @param {Boolean} [deep] Whether to test the widget's superclass hierarchy.
   * @returns {Boolean} `true` if the passed widget matches the passed selector.
   */
  static isType(widget, type, deep) {
    for (let widgetClass = widget.constructor; widgetClass; widgetClass = deep && Object.getPrototypeOf(widgetClass)) {
      // Find a registered entry.
      // If it's an abstract based class which was not registered (such as PickerField),
      // create an entry for it using its lowercased $name
      const classEntry =
        widgetClassRegister[widgetClass] ||
        (widgetClass.$name &&
          (widgetClassRegister[widgetClass] = {
            [widgetClass.$name.toLowerCase()]: 1
          }));

      if (classEntry && classEntry[type]) {
        return true;
      }
    }
  }

  static createWidget(type, config) {
    const widgetClass = this.getClass(type);

    if (widgetClass) {
      return new widgetClass(config);
    }

    // eslint-disable-next-line no-unreachable
    return null;
  }
}

const widgetRegister = (BryntumWidgetAdapterRegister.widgetRegister = {}),
  widgetClassRegister = (BryntumWidgetAdapterRegister.widgetClassRegister = {});
BryntumWidgetAdapterRegister._$name = 'BryntumWidgetAdapterRegister';

/**
 * @module Common/helper/IdHelper
 */

function isInstanceOfClass(instance, type) {
  const classHierarchy = instance.classHierarchy();

  for (let i = 0; i < classHierarchy.length; i++) {
    if (classHierarchy[i].$name.toLowerCase() === type) {
      return true;
    }
  }

  return false;
}

/**
 * IdHelper keeps an internal map of objects and ids, allowing easy retrieval by id. It can generate and assign
 * unique ids (in IdHelper context, not guaranteed to be unique on page), either explicitly or when registering objects
 * in its map.
 *
 * IdHelper also supplies some useful functions for querying Widgets.
 *
 * This class is not intended for application use, it is used internally by the Brytum infrastructure.
 * @internal
 * @private
 */
class IdHelper {
  /**
   * Generate a new id, using IdHelpers internal counter and a prefix
   * @param {String} prefix Id prefix
   * @returns {String} Generated id
   */
  static generateId(prefix = 'generatedId') {
    return prefix + ++IdHelper.idCounter;
  }

  /**
   * Register an object with IdHelper, assigning it a generated id if it has none. Throws if objects id is already
   * in use.
   * @param {Object} obj Any object
   * @param {String} prefix Prefix for generated id
   */
  static register(obj, prefix = '') {
    let objId = obj.id;

    if (objId == null) {
      objId = obj.id = IdHelper.generateId(prefix);
      obj.hasGeneratedId = true;
    }

    // Code editor sets `disableThrow` to not get conflicts when loading the same module again
    if (objId in IdHelper.idMap && !this.disableThrow) {
      throw new Error('Id ' + objId + ' already in use');
    }

    IdHelper.idMap[objId] = obj;
  }

  /**
   * Unregister from IdHelper, normally done on destruction
   * @param {Object} obj Object to unregister
   */
  static unregister(obj) {
    // (have to check for existence before deleting to work in Safari)
    if (IdHelper.idMap[obj.id]) delete IdHelper.idMap[obj.id];
  }

  /**
   * Get an object using id
   * @param {String} id Object id
   * @returns {*} Object or undefined if none found
   */
  static get(id) {
    return IdHelper.idMap[id];
  }

  /**
   * Analogous to document.querySelector, finds the first Bryntum widget matching the passed
   * selector. Right now, only class name (lowercased) selector strings, or
   * a filter function which returns `true` for required object are allowed:
   * ```
   * bryntum.query('grid').destroy();
   * ```
   * @param {String|Function} selector A lowercased class name, or a filter function.
   * @param {Boolean} [deep] Specify `true` to search the prototype chain (requires supplying a string `selector`). For
   *   example 'widget' would then find a Grid
   * @return {Common.widget.Widget} The first matched widget if any.
   */
  static query(selector, deep = false) {
    const idMap = IdHelper.idMap;

    for (let id in idMap) {
      if (widgetMatches(idMap[id], selector, deep)) {
        return idMap[id];
      }
    }
    return null;
  }

  /**
   * Analogous to document.querySelectorAll, finds all Bryntum widgets matching the passed
   * selector. Right now, only registered widget `type` strings, or a filter function which
   * returns `true` for required object are allowed:
   * ```
   * let allFields = bryntum.queryAll('field', true);
   * ```
   * @param {String|Function} selector A lowercased class name, or a filter function.
   * @param {Boolean} [deep] Specify `true` to search the prototype chain (requires supplying a string `selector`). For
   *   example 'widget' would then find a Grid
   * @return {Common.widget.Widget[]} The first matched widgets if any - an empty array will be returned
   * if no matches are found.
   */
  static queryAll(selector, deep = false) {
    const idMap = IdHelper.idMap,
      result = [];

    for (let id in idMap) {
      if (widgetMatches(idMap[id], selector, deep)) {
        result.push(idMap[id]);
      }
    }
    return result;
  }

  /**
   * Returns the Widget which owns the passed element (or event).
   * @param {HTMLElement|Event} element The element or event to start from
   * @param {String|Function} [type] The type of Widget to scan upwards for. The lowercase
   * class name. Or a filter function which returns `true` for the required Widget.
   * @param {HTMLElement|Number} [limit] The number of components to traverse upwards to find a
   * match of the type parameter, or the element to stop at.
   * @return {Widget} The found Widget or null.
   */
  static fromElement(element, type, limit) {
    const typeOfType = typeof type;

    // Event passed
    if (element && element instanceof Event) {
      element = element.target;
    }

    if (typeOfType === 'number' || (type && type.nodeType === 1)) {
      limit = type;
      type = null;
    }

    let target = element,
      cache = IdHelper.idMap,
      depth = 0,
      topmost,
      cmpId,
      cmp;

    if (typeof limit !== 'number') {
      topmost = limit;
      limit = Number.MAX_VALUE;
    }
    if (typeOfType === 'string') {
      type = type.toLowerCase();
    }

    while (target && target.nodeType === 1 && depth < limit && target !== topmost) {
      cmpId = (target.dataset && target.dataset.ownerCmp) || target.id;

      if (cmpId) {
        cmp = cache[cmpId];
        if (cmp) {
          if (type) {
            if (typeOfType === 'function') {
              if (type(cmp)) {
                return cmp;
              }
            } else if (widgetMatches(cmp, type) || isInstanceOfClass(cmp, type)) {
              return cmp;
            }
          } else {
            return cmp;
          }
        }

        // Increment depth on every *Widget* found
        depth++;
      }

      target = target.parentNode;
    }

    return null;
  }
}

function widgetMatches(candidate, selector, deep) {
  if (selector === '*') {
    return true;
  }
  if (typeof selector === 'function') {
    return selector(candidate);
  }
  return BryntumWidgetAdapterRegister.isType(candidate, selector, deep);
}

IdHelper.idCounter = 0;
IdHelper.idMap = {};

// Simplify querying widgets by exposing fns in bryntum ns
(window.bryntum || (window.bryntum = {})).get = IdHelper.get;
window.bryntum.IdHelper = IdHelper;
window.bryntum.query = IdHelper.query;
window.bryntum.queryAll = IdHelper.queryAll;
window.bryntum.fromElement = IdHelper.fromElement;
IdHelper._$name = 'IdHelper';

/**
 * @module Common/helper/WidgetHelper
 */

/**
 * Helper for creating widgets. Needs an adapter to do the actual work, see
 * {@link Common.adapter.widget.BryntumWidgetAdapter} which is used in examples.
 *
 * NOTE: This concept is not yet fully realized.
 */
class WidgetHelper {
  //region Adapter

  /**
   * Gets/sets the adapter used for widgets.
   * @param adapterClass Adapter class
   * @category Adapter
   */
  static set adapter(adapterClass) {
    this._adapter = new adapterClass();
  }

  static get adapter() {
    if (!this._adapter) throw new Error('No widget adapter set');
    return this._adapter;
  }

  /**
   * Checks if an adapter is assigned
   * @returns {Boolean}
   * @category Adapter
   * @readonly
   */
  static get hasAdapter() {
    return !!this._adapter;
  }

  //endregion

  //region Querying

  /**
   * Returns the widget with the specified id.
   * @param id Id of widget to find
   * @returns {Common.widget.Widget} The widget if any
   * @category Querying
   */
  static getById(id) {
    return IdHelper.get(id);
  }

  /**
   * Returns the Widget which owns the passed element (or event).
   * @param {HTMLElement|Event} element The element or event to start from
   * @param {String|Function} [type] The type of Widget to scan upwards for. The lowercase
   * class name. Or a filter function which returns `true` for the required Widget.
   * @param {HTMLElement|Number} [limit] The number of components to traverse upwards to find a
   * match of the type parameter, or the element to stop at.
   * @returns {Common.widget.Widget} The found Widget or null.
   * @category Querying
   * @typings any
   */
  static fromElement(element, type, limit) {
    return IdHelper.fromElement(element, type, limit);
  }

  //endregion

  //region Widgets

  /**
   * Create a widget.
   * @example
   * WidgetHelper.createWidget({
   *   type: 'button',
   *   icon: 'user',
   *   text: 'Edit user'
   * });
   * @param config Widget config
   * @returns {Object} The widget
   * @category Widgets
   */
  static createWidget(config = {}) {
    return this.adapter.createWidget(config);
  }

  /**
   * Appends a widget (array of widgets) to the DOM tree. If config is empty, widgets are appended to the DOM. To
   * append widget to certain position you can pass HTMLElement or its id as config, or as a config, that will be
   * applied to all passed widgets.
   *
   * Usage:
   *
   * ```javascript
   * // Will append button as last item to element with id 'container'
   * let [button] = WidgetHelper.append({ type : 'button' }, 'container');
   *
   * // Same as above, but will add two buttons
   * let [button1, button2] = WidgetHelper.append([
   *     { type : 'button' },
   *     { type : 'button' }
   *     ], { appendTo : 'container' });
   *
   * // Will append two buttons before element with id 'someElement'. Order will be preserved and all widgets will have
   * // additional class 'my-cls'
   * let [button1, button2] = WidgetHelper.append([
   *     { type : 'button' },
   *     { type : 'button' }
   *     ], {
   *         insertBefore : 'someElement',
   *         cls          : 'my-cls'
   *     });
   * ```
   *
   * @param {Object|Object[]} widget Widget config or array of such configs
   * @param {HTMLElement|String|Object} [config] Element (or element id) to which to append the widget or config to apply to all passed widgets
   * @returns {Common.widget.Widget[]} Array or widgets
   * @category Widgets
   */
  static append(widget, config) {
    widget = (Array.isArray(widget) && widget) || [widget];

    if (config instanceof HTMLElement || typeof config === 'string') {
      config = {
        appendTo: config
      };
    }

    // We want to fix position to insert into to keep order of passed widgets
    if (config.insertFirst) {
      const target =
        typeof config.insertFirst === 'string' ? document.getElementById(config.insertFirst) : config.insertFirst;

      if (target.firstChild) {
        config.insertBefore = target.firstChild;
      } else {
        config.appendTo = target;
      }
    }

    return this.adapter.appendWidgets(widget, config);
  }

  //endregion

  //region Popups

  // TODO: Implement openWindow
  // /**
  //  * Opens a window with specified widgets. Not implemented yet...
  //  * @param config
  //  * @returns {Object}
  //  * @category Popups
  //  */
  // static openWindow(config) {
  //     return this.adapter.openWindow(config);
  // }

  /**
   * Shows a popup (~tooltip) containing widgets connected to specified element.
   * @example
   * WidgetHelper.openPopup(element, {
   *   position: 'bottom center',
   *   items: [
   *      { widgetConfig }
   *   ]
   * });
   * @param element Element to connect popup to
   * @param config Config object, or string to use as html in popup
   * @returns {*|{close, widgets}}
   * @category Popups
   */
  static openPopup(element, config) {
    return this.adapter.openPopup(element, config);
  }

  /**
   * Shows a context menu connected to the specified element.
   * @example
   * WidgetHelper.showContextMenu(element, {
   *   items: [
   *      { id: 'addItem', icon: 'add', text: 'Add' },
   *      ...
   *   ],
   *   onItem: item => alert('Clicked ' + item.text)
   * });
   * @param {HTMLElement|Number[]} element Element (or a coordinate) to show the context menu for
   * @param {Object} config Context menu config, see example
   * @returns {*|{close}}
   * @category Popups
   */
  static showContextMenu(element, config) {
    return this.adapter.showContextMenu(element, config);
  }

  /**
   * Attached a tooltip to the specified element.
   * @example
   * WidgetHelper.attachTooltip(element, {
   *   text: 'Useful information goes here'
   * });
   * @param element Element to attach tooltip for
   * @param configOrText Tooltip config or tooltip string, see example and source
   * @returns {Object}
   * @category Popups
   */
  static attachTooltip(element, configOrText) {
    return this.adapter.attachTooltip(element, configOrText);
  }

  /**
   * Checks if element has tooltip attached
   *
   * @param element Element to check
   * @return {Boolean}
   * @category Popups
   */
  static hasTooltipAttached(element) {
    return this.adapter.hasTooltipAttached(element);
  }

  /**
   * Destroys any tooltip attached to an element, removes it from the DOM and unregisters any tip related listeners
   * on the element.
   *
   * @param element Element to remove tooltip from
   * @category Popups
   */
  static destroyTooltipAttached(element) {
    return this.adapter.destroyTooltipAttached(element);
  }

  //endregion

  //region Mask

  /**
   * Masks the specified element, showing a message in the mask.
   * @param element Element to mask
   * @param msg Message to show in the mask
   * @category Mask
   */
  static mask(element, msg) {
    return this.adapter.mask(element, msg);
  }

  /**
   * Unmask the specified element.
   * @param element
   * @category Mask
   */
  static unmask(element, close = true) {
    this.adapter.unmask(element);
  }

  //endregion

  //region Toast

  /**
   * Show a toast
   * @param {String} msg message to show in the toast
   * @category Mask
   */
  static toast(msg) {
    this.adapter.toast(msg);
  }

  //endregion

  //region Style

  static set defaultStyle(style) {
    this.adapter.defaultStyle = style;
  }

  static get defaultStyle() {
    return this.adapter.defaultStyle;
  }

  //endregion
}
WidgetHelper._$name = 'WidgetHelper';

/**
 * @module Common/helper/StringHelper
 */

const camelLettersRe = /([a-z])([A-Z])/g,
  escapeRegExpRe = /[.*+?^${}()|[\]\\]/g,
  idRe = /(^[^a-z]+|[^\w]+)/gi,
  replaceCamelLetters = (all, g1, g2) => {
    return g1 + '-' + g2.toLowerCase();
  },
  replaceNonIdChar = (c) => {
    if (c) {
      return `_x${c.charCodeAt(0).toString(16)}`;
    }
    return '__blank__';
  },
  hyphenateCache = {};

/**
 * Helper for string manipulation.
 */
class StringHelper {
  /**
   * Capitalizes the first letter of a string, myString -> MyString.
   * Doesn't alter the original string, use return value
   * @param string String to capitalize
   * @returns {String} Capitalized string
   */
  static capitalizeFirstLetter(string) {
    if (!string) return null;
    return string[0].toUpperCase() + string.substr(1);
  }

  /**
   * Makes the first letter of a string lowercase, MyString -> myString.
   * Doesn't alter the original string, use return value
   * @param string String to alter
   * @returns {String} Altered string
   */
  static lowercaseFirstLetter(string) {
    if (!string) return null;
    return string[0].toLowerCase() + string.substr(1);
  }

  /**
   * Converts the passed camelCased string to a hyphen-separated string. eg "minWidth" -> "min-width"
   * @param string The string to convert.
   * @return {String} The string with adjoining lower and upper case letters
   * separated by hyphens and converted to lower case.
   */
  static hyphenate(string) {
    // Cached since it is used heavily with DomHelper.sync()
    const cached = hyphenateCache[string];
    if (cached) {
      return cached;
    }
    return (hyphenateCache[string] = string.replace(camelLettersRe, replaceCamelLetters));
  }

  /**
   * Parses JSON within a try-catch.
   * @param {String} string String to parse
   * @returns {Object} Resulting object or null if parse failed
   */
  static safeJsonParse(string) {
    let parsed = null;

    try {
      parsed = JSON.parse(string);
    } catch (e) {
      console.error(e);
    }

    return parsed;
  }

  /**
   * Stringifies an object within a try-catch.
   * @param {Object} object The object to stringify
   * @returns {Object} Resulting object or null if stringify failed
   */
  static safeJsonStringify(obj) {
    let result = null;

    try {
      result = JSON.stringify(obj);
    } catch (e) {
      console.error(e);
    }

    return result;
  }

  /**
   * Creates an alphanuneric identifier from any passed string. Encodes spaces and non-alpha characters.
   * @param inString The string from which to strip non-identifier characters.
   * @return {String}
   */
  static createId(inString) {
    return String(inString).replace(idRe, replaceNonIdChar);
  }

  // https://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
  static escapeRegExp(string) {
    // $& means the whole matched string
    return string.replace(escapeRegExpRe, '\\$&');
  }
}
StringHelper._$name = 'StringHelper';

/**
 * @module Common/Base
 */

const defaultConfigSymbol = Symbol('defaultConfig'),
  propertyInitializersSymbol = Symbol('propertyInitializers'),
  classHierarchySymbol = Symbol('classHierarchy'),
  configurationSymbol = Symbol('configuration'),
  originalConfigSymbol = Symbol('originalConfig'),
  instancePropertiesSymbol = Symbol('instanceProperties');

/**
 * Base class for all configurable classes.
 *
 * Subclasses do not have to implement a constructor with its restriction of having to call super()
 * before there is a `this` reference. Subclasses instead implement a `construct` method which is
 * called by the `Base` constructor. This may call its `super` implementation at any time.
 *
 * The `Base` constructor applies all configs to properties of the new instance. The instance
 * will have been configured after the `super.construct(config)` is called.
 *
 * See the Class System documentation in the guides for more information.
 *
 * @abstract
 */
class Base {
  // defaultConfig & properties made private to not spam all other classes

  /**
   * A getter for the default configuration of this class, which can be overridden by configurations passed at construction time.
   * @member {Object} defaultConfig
   * @static
   * @category Configuration
   * @private
   */

  /**
   * A getter for the default values of internal properties for this class
   * @member {Object} properties
   * @static
   * @category Configuration
   * @private
   */

  /**
   * Base constructor, passes arguments to {@link #function-construct}.
   * @param args
   * @function constructor
   * @category Lifecycle
   */
  constructor(...args) {
    // Allow subclasses to have a pseudo constructor with "this" already set;
    this.construct(...args);

    this.afterConstruct();
  }

  /**
   * Base implementation applies configuration.
   *
   * Subclasses need only implement this if they have to initialize instance specific
   * properties required by the class. Often a `construct` method is
   * unnecessary. All initialization of incoming configuration properties can be
   * done in a `set propName` implementation.
   * @param {Object} [config] Usually called with a config object, but accepts any params
   * @category Lifecycle
   */
  construct(...args) {
    // Passing null to base construct means bypass the config system
    if (args[0] !== null) {
      this.configure(...args);
    }
    this.afterConfigure();
  }

  /**
   * Destroys the object.
   * Do not override this in subclasses. To provide class-specific destruction, implement a
   * doDestroy method. It is a lifecycle hook that will be called during destruction.
   * @category Lifecycle
   */
  destroy() {
    const me = this;

    me.isDestroying = true;
    me.doDestroy();

    Object.setPrototypeOf(this, null);

    // Clear all remaining instance properties.
    for (let key in me) {
      delete me[key];
    }
    delete me[originalConfigSymbol];

    // Only one property remains to signal why the object is inert.
    me.isDestroyed = true;
  }

  /**
   * This method is required to help `unused` getters to survive production build process. Some tools, like angular,
   * will remove `unused` code in production build, making our side-effected getters behind, breaking code heavily.
   * @private
   * @param getter Getter to evaluate
   */
  _thisIsAUsedExpression(getter) {}

  static get $name() {
    return (this.hasOwnProperty('_$name') && this._$name) || this.name;
  }

  get $name() {
    return this.constructor.$name;
  }

  /**
   * Base implementation so that all subclasses and mixins may safely call super.startConfigure.
   *
   * This is called by the Base class before setting configuration properties, but after
   * the active initial getters have been set, so all configurations are available.
   *
   * This method allows all classes in the hierarchy to force some configs to be evaluated before others.
   * @internal
   * @category Lifecycle
   * @params {Object} config The configuration object use to set the initial state.
   */
  startConfigure(config) {}

  /**
   * Base implementation so that all subclasses and mixins may safely call super.finishConfigure.
   *
   * This is called by the Base class before exiting the {@link #function-configure} method.
   *
   * At this point, all configs have been applied, but the `isConfiguring` property is still set.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * into the config phase.
   * @internal
   * @category Lifecycle
   * @params {Object} config The configuration object use to set the initial state.
   */
  finishConfigure(config) {}

  /**
   * Base implementation so that all subclasses and mixins may safely call `super.afterConfigure`. This is called by the Base class after the {@link #function-configure} method has been
   * called. At this point, all configs have been applied.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * either before or after the super.afterConstruct();
   * @internal
   * @category Lifecycle
   */
  afterConfigure() {}

  /**
   * Base implementation so that all subclasses and mixins may safely call super.afterConstruct.
   *
   * This is called by the Base class after the {@link #function-construct} method has been
   * called.
   *
   * At this point, all configs have been applied.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * either before or after the super.afterConstruct();
   * @internal
   * @function afterConstructor
   * @category Lifecycle
   */
  afterConstruct() {}

  /**
   * Provides a way of calling callbacks which may have been specified as the _name_ of a function
   * and optionally adds scope resolution.
   *
   * For example, if the callback is specified as a string, then if it is prefixed with `'this.'`
   * then the function is resolved in this object. This is useful when configuring listeners
   * at the class level.
   *
   * If the callback name is prefixed with `'up.'` then the ownership hierarchy is queried
   * using the `owner` property until an object with the named function is present, then the
   * named function is called upon that object.
   * @param {String/Function} handler The function to call, or the name of the function to call.
   * @param {Object} thisObj The `this` object of the function.
   * @param {Object[]} args The argument list to pass.
   */
  callback(fn, thisObject, args) {
    // Maintainer: do not make args ...args. This method may acquire more arguments
    if (thisObject === 'this') {
      thisObject = this;
    }

    const { handler, thisObj } = this.resolveCallback(fn, thisObject);

    return args ? handler.apply(thisObj, args) : handler.call(thisObj);
  }

  resolveCallback(handler, thisObj = this) {
    // It's a string, we find it in its own thisObj
    if (handler.substr) {
      if (handler.startsWith('up.')) {
        handler = handler.substr(3);

        // Empty loop until we find the function owner
        for (thisObj = this.owner; thisObj && !thisObj[handler]; thisObj = thisObj.owner);
      } else if (handler.startsWith('this.')) {
        thisObj = this;
      }

      handler = thisObj[handler];
    }

    return { handler, thisObj };
  }

  /**
   * Base implementation so that all subclasses and mixins may safely call super.
   * doDestroy is how all subclasses must clean themselves up. It is called by the
   * Base class *before* final destruction of the object.
   * @internal
   * @category Lifecycle
   */
  doDestroy() {}

  /**
   * Destroys the named properties if they have been initialized, and if they have a `destroy` method.
   * Deletes the property from this object. For example:
   *
   *      this.destroyProperties('store', 'resourceStore', 'eventStore', 'dependencyStore', 'assignmentStore');
   *
   * @param {String} properties The names of the properties to destroy.
   * @internal
   * @category Lifecycle
   */
  destroyProperties(...properties) {
    const me = this;

    let key, propertyValue;

    for (key of properties) {
      // If the value has *not* been pulled in from the configuration object yet
      // we must not try to access it, as that will cause the property to be initialized.
      if (key in me && (!me[configurationSymbol] || !me[configurationSymbol][key])) {
        propertyValue = me[key];
        if (propertyValue && propertyValue.destroy) {
          propertyValue.destroy();
        }
        delete me[key];
      }
    }
  }

  /**
   * Called by the Base constructor to apply configs to this instance. The must not be called.
   * @param {Object} config The configuration object from which instance properties are initialized.
   * @private
   * @category Lifecycle
   */
  configure(config = {}) {
    const me = this;

    me.initialConfig = config;

    // Important flag for setters to know whether they are being called during
    // configuration when this object is not fully alive, or whether it's being reconfgured.
    me.isConfiguring = true;

    // Assign any instance properties declared by the class.
    Object.assign(me, me.getProperties());

    // Apply configuration to default (Which is safe, because it's a chained object) from class definition.
    // Cache me.config for use by get config.
    me.setConfig((me[originalConfigSymbol] = Base.assign(me.getDefaultConfiguration(), config)), true);

    me.isConfiguring = false;
  }

  /**
   * Sets configuration options this object with all the properties passed in the parameter object.
   * Timing is taken care of. If the setter of one config is called first, and references
   * the value of another config which has not yet been set, that config will be set just
   * in time, and the *new* value will be used.
   * @param {Object} config An object containing configurations to change.
   * @category Configuration
   */
  setConfig(config, isConstructing) {
    const me = this,
      wasConfiguring = me[configurationSymbol],
      configDone = wasConfiguring ? me.configDone : (me.configDone = {}),
      instanceProperties = (me[instancePropertiesSymbol] = {});

    let key, instanceProperty;

    // Cache me.configuration for use by injected property initializers.
    me[configurationSymbol] = wasConfiguring
      ? Object.setPrototypeOf(Object.assign({}, config), wasConfiguring)
      : config;

    // For each incoming non-null configuration, create a temporary getter which will
    // pull the value in from the initialConfig so that it doesn't matter in
    // which order properties are set. You can access any property at any time.
    for (key in config) {
      // Don't default null configs inunless it's a direct property of the
      // the passed configuration. When used at construct time, defaultConfigs
      // will be prototype-chained onto the config.
      if (config[key] != null || config.hasOwnProperty(key)) {
        // If there is an existing property with a getter/setter, *not* a value
        // defined on the object for this config we must call it in our injected getter/setter.
        // Maintainer, this is testing the truthiness of the assignment, *not* a botched equality test.
        if (
          !instanceProperties[key] &&
          (instanceProperty = Reflect.getOwnPropertyDescriptor(me, key)) &&
          !('value' in instanceProperty)
        ) {
          instanceProperties[key] = instanceProperty;
        }
        // Set up a temporary instance property which will
        // Pull in the value from the initialConfig if the getter
        // is called first.
        Reflect.defineProperty(me, key, Base.createPropInitializer(key));

        if (!isConstructing) {
          configDone[key] = false;
        }
      } else {
        configDone[key] = true;
      }
    }

    if (isConstructing) {
      me.startConfigure(config);
    }

    // Set all our properties from the config object.
    // If one of the properties needs to access a property that has not
    // yet been set, the above temporary property will pull it through.
    // Can't use Object.assign because that only uses own properties.
    // config value blocks are prototype chained subclass->superclass
    for (key in config) {
      // Only push the value through if the property initializer is still present.
      // If it gets triggered to pull the configuration value in, it deleted itself.
      if (!configDone[key]) {
        me[key] = config[key];
      }
    }

    if (wasConfiguring) {
      me[configurationSymbol] = wasConfiguring;
    } else {
      delete me[configurationSymbol];
    }

    if (isConstructing) {
      me.finishConfigure(config);
    }
  }

  /**
   * Returns a *copy* of the full configuration which was used to configure this object.
   * @returns {Object} All configuration properties which were used to configure this object.
   * @category Misc
   */
  get config() {
    let result = {},
      myConfig = this[originalConfigSymbol],
      key;

    // The configuration was created as a prototype chain of the class hierarchy's
    // defaultConfig values hanging off a copy of the initialConfig object, so
    // we must loop and copy since Object.assign only copies own properties.
    for (key in myConfig) {
      result[key] = myConfig[key];
    }
    return result;
  }

  /**
   * Gets the full {@link #property-defaultConfig-static} block for this object's entire inheritance chain
   * all the way up to but not including {@link Common.Base}
   * @return {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  getDefaultConfiguration() {
    return this.constructor.getDefaultConfiguration();
  }

  /**
   * Gets the full {@link #property-defaultConfig-static} block for the entire inheritance chain for this class
   * all the way up to but not including {@link Common.Base}
   * @return {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  static getDefaultConfiguration() {
    const configDescriptor = this.getConfigDescriptor();

    return configDescriptor.needsFork
      ? this.fork(configDescriptor.defaultConfig)
      : Object.setPrototypeOf({}, configDescriptor.defaultConfig);
  }

  /**
   * Gets the full {@link #property-defaultConfig-static} block for this class's entire inheritance chain
   * all the way up to but not including {@link Common.Base}
   * @return {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  static getConfigDescriptor(shallow) {
    const me = this;

    let configDescriptor = !shallow && me.hasOwnProperty(defaultConfigSymbol) ? me[defaultConfigSymbol] : null,
      defaults,
      key,
      cls,
      value,
      superConfigDescriptor;

    if (!configDescriptor) {
      configDescriptor = {
        defaultConfig: (defaults = me.hasOwnProperty('defaultConfig') ? me.defaultConfig : {}),
        // Use 1 instead of true because below we're using |= to or up all the flags from the class hierarchy
        needsFork: 0
      };

      // Only cache top level descriptors.
      if (!shallow) {
        me[defaultConfigSymbol] = configDescriptor;
      }
      for (key in defaults) {
        value = defaults[key];

        // If any default properties are *mutable* Objects or Array we need to clone them.
        // so that instances do not share configured values.
        if (value && (value.constructor === Object || Array.isArray(value)) && !Object.isFrozen(value)) {
          // Use 1 instead of true because below we're using |= to or up all the flags from the class hierarchy
          configDescriptor.needsFork = 1;
          break;
        }
      }

      // Because of mixins being mixed into different parts of the class hiererchy,
      // we can't chain to an existing deep descriptor. We have to climb from
      // here and assemble the deep descriptor from shallow ones.
      // If any along the way need forking (have an Object or Array), so do we.
      // We chain them together because that is hundreds of times faster
      // than Object.assign: https://jsperf.com/setprototypeof-vs-object-assign/
      if (!shallow) {
        for (cls = me.superclass; cls && cls !== Base; cls = cls.superclass) {
          superConfigDescriptor = cls.getConfigDescriptor(true);
          if (Object.keys(superConfigDescriptor.defaultConfig).length) {
            configDescriptor.needsFork |= superConfigDescriptor.needsFork;
            Object.setPrototypeOf(defaults, (defaults = superConfigDescriptor.defaultConfig));
          }
        }
      }
    }

    return configDescriptor;
  }

  static fork(obj) {
    var ret, key, value;

    if (obj && obj.constructor === Object && !Object.isFrozen(obj)) {
      ret = Object.setPrototypeOf({}, obj);

      for (key in obj) {
        value = obj[key];

        if (value) {
          if (value.constructor === Object) {
            ret[key] = this.fork(value);
          } else if (value instanceof Array) {
            ret[key] = value.slice();
          }
        }
      }
    } else {
      ret = obj;
    }

    return ret;
  }

  static assign(dest, ...sources) {
    var i = 0,
      ln = sources.length,
      source,
      key;

    for (; i < ln; i++) {
      source = sources[i];

      for (key in source) {
        dest[key] = source[key];
      }
    }
    return dest;
  }

  /**
   * Gets the full {@link #property-properties-static} block for this class's entire inheritance chain
   * all the way up to but not including {@link Common.Base}
   * @return {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  getProperties() {
    const hierarchy = this.classHierarchy(),
      len = hierarchy.length;

    let result = {},
      i,
      cls;

    // TODO: if properties block does not change this could be cached? would speed up loading of big data sets into grid

    // Gather the class result in *top-down* order so that a subclass's properties
    // overrides properties from superclasses.
    //for (cls of this.classHierarchy()) { // replaced for of since it transpiles badly and this is called a lot when creating many instances
    for (i = 0; i < len; i++) {
      cls = hierarchy[i];
      // Skip classes which don't have it. We're going to ask its superclass anyway.
      if (cls.hasOwnProperty('properties')) {
        Object.assign(result, cls.properties);
      }
    }

    return result;
  }

  static get superclass() {
    return Object.getPrototypeOf(this);
  }

  static createPropInitializer(key) {
    // Because initializers for a property name are the same, cache them on the Base
    // class so that only one copy is created for each property name globally.
    var result = (this[propertyInitializersSymbol] || (this[propertyInitializersSymbol] = {}))[key];

    if (!result) {
      let initializingFlagName = 'initializing' + StringHelper.capitalizeFirstLetter(key);

      result = this[propertyInitializersSymbol][key] = {
        configurable: true,
        get() {
          const me = this,
            instanceProperty = me[instancePropertiesSymbol][key];

          // If we took over from an instance property, replace it
          if (instanceProperty) {
            Reflect.defineProperty(me, key, instanceProperty);
          }
          // Otherwise just delete the instance property who's getter we are in.
          else {
            delete me[key];
          }

          // Set the value from the configuration.
          me[initializingFlagName] = true;
          me[key] = me[configurationSymbol][key];
          me[initializingFlagName] = false;

          // The property has been *pulled* from the configuration.
          // Prevent the setting loop in configure from setting it again.
          me.configDone[key] = true;

          // Finally, allow the prototype getter to return the value.
          return me[key];
        },
        set(value) {
          const me = this,
            instanceProperty = me[instancePropertiesSymbol][key];

          // If we took over from an instance property, replace it
          if (instanceProperty) {
            Reflect.defineProperty(me, key, instanceProperty);
          }
          // Otherwise just delete the instance property who's getter we are in.
          else {
            delete me[key];
          }

          // The config has been set (some internal code may have called the setter)
          // so prevent it from being called again and overwritten with data from initialConfig.
          me.configDone[key] = true;

          // Set the property normally (Any prototype setter will be invoked)
          me[key] = value;
        }
      };
    }

    return result;
  }

  /**
   * Used by the Widget and GridFeatureManager class internally. Returns the class hierarchy of this object
   * starting from the `topClass` class (which defaults to `Base`).
   *
   * For example `classHierarchy(Widget)` on a Combo would yield `[Widget, Field, TextField, PickerField, Combo]`
   * @param {Function} [topClass] The topmost class constructor to start from.
   * @returns {Function[]} The class hierarchy of this instance.
   * @private
   * @category Configuration
   */
  classHierarchy(topClass) {
    let cls = this.constructor,
      fullClassHierarchy = cls.hasOwnProperty(classHierarchySymbol) ? cls[classHierarchySymbol] : null,
      result;

    // Collect the full class hierarchy only once.
    if (!fullClassHierarchy) {
      // Using Object.getPrototypeOf instead of Refect.getPrototypeOf because:
      // 1. The are almost the same, according to the MDN difference is handling getPrototypeOf('string')
      // 2. It allows to pass security check is salesforce environment
      for (fullClassHierarchy = cls[classHierarchySymbol] = []; cls !== Base; cls = Object.getPrototypeOf(cls)) {
        fullClassHierarchy.unshift(cls);
      }
      // Don't let anybody mutate this. It's cached.
      Object.freeze(fullClassHierarchy);
    }

    // Cut down to the requested topClass
    if (topClass) {
      for (let i = 0; !result && i < fullClassHierarchy.length; i++) {
        if (fullClassHierarchy[i] === topClass) {
          result = fullClassHierarchy.slice(i);
        }
      }
    } else {
      result = fullClassHierarchy;
    }
    return result;
  }

  /**
   * Same as {@link #function-classHierarchy} but returns array of class names obtained via $name property
   *
   * @param {Function} [topClass] The topmost class constructor to start from.
   * @returns {String[]} The class name hierarchy of this instance.
   * @private
   * @category Configuration
   */
  classNameHierarchy(topClass) {
    return this.classHierarchy(topClass).map((f) => f.$name);
  }

  /**
   * Checks if an obj is of type using object's $name property and doing string comparision of the property with the type parameter.
   *
   * @param {String} type
   * @return {Boolean}
   */
  static isOfTypeName(type) {
    return this.classNameHierarchy().includes(type);
  }
}

Base._$name = 'Base';

/**
 * @module Common/mixin/Delayable
 */

/**
 * Tracks setTimeout, setInterval and requestAnimationFrame calls and clears them on destroy.
 *
 * @example
 * someClass.setTimeout(() => console.log('hi'), 200);
 * someClass.setInterval(() => console.log('annoy'), 100);
 * // can also use named timeouts for easier tracking
 * someClass.setTimeout(() => console.log('named'), 300, 'named');
 * someClass.clearTimeout('named');
 *
 * @private
 * @mixin
 */
var Delayable = (Target) =>
  class Delayable extends (Target || Base) {
    doDestroy() {
      const me = this;

      if (me.timeoutIds) {
        Object.keys(me.timeoutIds).forEach((id) => {
          if (typeof me.timeoutIds[id] === 'function') {
            me.timeoutIds[id]();
          }
          clearTimeout(id);
        });
        me.timeoutIds = null;
      }

      if (me.timeoutMap) {
        Object.values(me.timeoutMap).forEach((id) => clearTimeout(id));
        me.timeoutMap = null;
      }

      if (me.intervalIds) {
        Object.keys(me.intervalIds).forEach((id) => clearInterval(id));
        me.intervalIds = null;
      }

      if (me.animationFrameIds) {
        Object.keys(me.animationFrameIds).forEach((id) => cancelAnimationFrame(id));
        me.animationFrameIds = null;
      }

      super.doDestroy();
    }

    /**
     * Check if a named timeout is active
     * @param name
     */
    hasTimeout(name) {
      return !!(this.timeoutMap && this.timeoutMap[name]);
    }

    /**
     * Same as native setTimeout, but will be cleared automatically on destroy. If a propertyName is supplied it will
     * be used to store the timeout id.
     * @param {Function|String} fn The function to call, or name of function in this object to call. Used as the `name` parameter if a string.
     * @param {Number} delay The milliseconds to delay the call by.
     * @param {String} name the name under which to register the timer.
     * @param {Boolean} runOnDestroy pass true if this function should be executed if the Delayable instance is destroyed while function is scheduled.
     * @returns {Number}
     */
    setTimeout(fn, delay, name, runOnDestroy = false) {
      if (typeof fn === 'string') {
        name = fn;
      }
      const me = this,
        timeoutIds = me.timeoutIds || (me.timeoutIds = {}),
        timeoutMap = me.timeoutMap || (me.timeoutMap = {}),
        timeoutId = setTimeout(() => {
          if (typeof fn === 'string') {
            fn = me[name];
          }
          fn.call(me);
          if (timeoutIds && timeoutId in timeoutIds) delete timeoutIds[timeoutId];
          if (timeoutMap && name in timeoutMap) delete timeoutMap[name];
        }, delay);

      timeoutIds[timeoutId] = runOnDestroy ? fn : true;

      if (name) {
        timeoutMap[name] = timeoutId;
      }

      return timeoutId;
    }

    /**
     * clearTimeout wrapper, either call with timeout id as normal clearTimeout or with timeout name (if you specified
     * a name to setTimeout())
     * property to null.
     * @param {Number|String} idOrName timeout id or name
     */
    clearTimeout(idOrName) {
      let id = idOrName;

      if (typeof id === 'string') {
        if (this.timeoutMap) {
          id = this.timeoutMap[idOrName];
          delete this.timeoutMap[idOrName];
        } else {
          return;
        }
      }

      clearTimeout(id);

      this.timeoutIds && delete this.timeoutIds[id];
    }

    /**
     * clearInterval wrapper
     * @param {Number} id
     */
    clearInterval(id) {
      clearInterval(id);

      this.intervalIds && delete this.intervalIds[id];
    }

    /**
     * Same as native setInterval, but will be cleared automatically on destroy
     * @param fn
     * @param delay
     * @returns {Number}
     */
    setInterval(fn, delay) {
      const me = this,
        intervalId = setInterval(fn, delay);

      if (!me.intervalIds) me.intervalIds = {};
      me.intervalIds[intervalId] = true;

      return intervalId;
    }

    /**
     * Relays to native requestAnimationFrame and adds to tracking to have call automatically canceled on destroy.
     * @param {Function} fn
     * @param {Object[]} [args] The argument list to append to those passed to the function.
     * @param {Object} [thisObj] `this` reference for the function.
     * @returns {Number}
     */
    requestAnimationFrame(fn, extraArgs, thisObj) {
      const handler = extraArgs || thisObj ? () => fn.apply(thisObj, extraArgs) : fn,
        frameId = requestAnimationFrame(handler);

      (this.animationFrameIds || (this.animationFrameIds = {}))[frameId] = true;

      return frameId;
    }

    /**
     * Creates a function which will execute once, on the next animation frame. However many time it is
     * called in one event run, it will only be scheduled to run once.
     * @param {Function|String} fn The function to call, or name of function in this object to call.
     * @param {Object[]} [args] The argument list to append to those passed to the function.
     * @param {Object} [thisObj] `this` reference for the function.
     * @param {Boolean} [cancelOutstanding] Cancel any outstanding queued invocation upon call.
     */
    createOnFrame(fn, extraArgs = [], thisObj = this, cancelOutstanding) {
      let me = this,
        rafId,
        result = (...args) => {
          // Cancel if outstanding if requested
          if (rafId && cancelOutstanding) {
            me.cancelAnimationFrame(rafId);
            rafId = null;
          }
          if (!rafId) {
            rafId = this.requestAnimationFrame(() => {
              if (typeof fn === 'string') {
                fn = thisObj[fn];
              }
              rafId = null;
              args.push(...extraArgs);
              fn.apply(thisObj, args);
            });
          }
        };

      result.cancel = () => me.cancelAnimationFrame(rafId);

      return result;
    }

    /**
     * Relays to native cancelAnimationFrame and removes from tracking.
     * @param {Number} handle
     */
    cancelAnimationFrame(handle) {
      cancelAnimationFrame(handle);

      this.animationFrameIds && delete this.animationFrameIds[handle];
    }

    /**
     * Wraps a function with another function that delays it specified amount of time, repeated calls to the wrapper
     * resets delay.
     * @param {Function|String} fn Function to buffer, or name of function in this object to call.
     * @param {Number} delay Delay in ms
     * @param {Object} [thisObj] `this` reference for the function.
     * @returns {Function} Wrapped function, call this
     */
    buffer(fn, delay, thisObj = this) {
      let timeoutId = null;

      if (typeof fn === 'string') {
        fn = thisObj[fn];
      }

      const func = (...params) => {
        func.called = false;

        if (timeoutId !== null) {
          this.clearTimeout(timeoutId);
        }

        timeoutId = this.setTimeout(() => {
          fn.call(thisObj, ...params); // this will be instance of class that we are mixed into.
          func.called = true;
        }, delay);
      };

      return func;
    }

    /**
     * Create a "debounced" function which will call on the "leading edge" of a timer period.
     * When first invoked will call immediately, but invocations after that inside its buffer
     * period will be rejected, and *one* invocation will be made after the buffer period has expired.
     *
     * This is useful for responding immediately to a first mousemove, but from then on, only
     * calling the action function on a regular timer while the mouse continues to move.
     *
     * @param {Function} fn The function to call.
     * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.
     */
    throttle(fn, buffer) {
      let me = this,
        lastCallTime = 0,
        callArgs,
        timerId,
        result;

      const invoke = () => {
        timerId = 0;
        lastCallTime = performance.now();
        fn.apply(me, callArgs);
        result.called = true;
      };

      result = (...args) => {
        let elapsed = performance.now() - lastCallTime;

        callArgs = args;

        // If it's been more then the buffer period since we invoked, we can call it now
        if (elapsed >= buffer) {
          me.clearTimeout(timerId);
          invoke();
        }
        // Otherwise, kick off a timer for the requested period.
        else if (!timerId) {
          timerId = me.setTimeout(invoke, buffer - elapsed);
          result.called = false;
        }
      };

      result.cancel = () => me.clearTimeout(timerId);

      return result;
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Common/helper/BrowserHelper
 */

/**
 * Static helper class that does browser/feature detection.
 * @internal
 */
class BrowserHelper {
  static cacheFlags() {
    const me = this;

    // os
    me._isLinux = !!navigator.platform.match(/Linux/);
    me._isMac = !!navigator.platform.match(/Mac/);
    me._isWindows = !!navigator.platform.match(/Win32/);

    // browser
    me._isIE11 = !!navigator.userAgent.match(/rv:11/);
    me._isEdge = !!navigator.userAgent.match(/Edge\//);
    // Edge user agent contain webkit too
    me._isWebkit = !!navigator.userAgent.match(/WebKit/) && !me.isEdge;
    me._isFirefox = !!navigator.userAgent.match(/Firefox/) && !me.isEdge;
    me._isChrome = !!navigator.userAgent.match(/Chrome/) && !me.isEdge;
    me._isSafari = !!navigator.userAgent.match(/Safari/) && !me.isChrome && !me.isEdge;
    me._isMobileSafari = navigator.userAgent.match(/Mobile.*Safari/);

    try {
      document.querySelector(':scope');
      // Scoped queries are not supported for custom element polyfill in firefox
      // https://app.assembla.com/spaces/bryntum/tickets/6781
      me.supportsQueryScope = !this.isFirefox;
    } catch (e) {
      me.supportsQueryScope = false;
    }

    me._supportsPassive = false;
    try {
      // If the browser asks the options object to yield its passive
      // property, we know it supports the object form options object
      // and passive listeners.
      document.addEventListener('__notvalid__', null, {
        get passive() {
          me._supportsPassive = true;
        }
      });
    } catch (e) {}

    //document.addEventListener("DOMContentLoaded", me.onDocumentReady);
  }

  // NOTE: Not allowed with CSP, moved to Grid#render()
  // /**
  //  * Feature and browser detection which requires the document to be loaded.
  //  * @private
  //  */
  // static onDocumentReady() {
  //     // Firefox includes a part of the Y scroller jutting up which is not needed.
  //     // Also need to "mitre" the horizontal scrollbar to leave the gap at the end.
  //     if (BrowserHelper.isFirefox) {
  //         CSSHelper.insertRule(`.b-virtual-scroller {height: ${DomHelper.scrollBarWidth}px;}`);
  //         CSSHelper.insertRule(`.b-virtual-scrollers {padding-right: ${DomHelper.scrollBarWidth}px;}`);
  //     }
  // }

  /**
   * Tries to determine if the user is using a touch device
   * @returns {Boolean}
   * @readonly
   */
  static get isTouchDevice() {
    if ('_isTouchDevice' in this) return this._isTouchDevice;

    return (
      'ontouchstart' in window ||
      // edge tends to always mave this with a value 2
      (!this.isEdge && navigator.maxTouchPoints > 0) ||
      // but if env is actually touchable, then window has this class present
      (this.isEdge && window.TouchEvent) ||
      navigator.msMaxTouchPoints > 0
    );
  }

  // Since touch screen detection is unreliable we should allow client to configure it, or detect first touch
  static set isTouchDevice(value) {
    this._isTouchDevice = value;
  }

  /**
   * Checks if platform is mac
   * @returns {Boolean}
   * @readonly
   */
  static get isMac() {
    return BrowserHelper._isMac;
  }

  /**
   * Checks if platform is windows
   * @returns {Boolean}
   * @readonly
   */
  static get isWindows() {
    return BrowserHelper._isWindows;
  }

  /**
   * Checks if platform is linux
   * @returns {Boolean}
   * @readonly
   */
  static get isLinux() {
    return BrowserHelper._isLinux;
  }

  /**
   * Checks if browser is IE11
   * @returns {Boolean}
   * @readonly
   */
  static get isIE11() {
    return BrowserHelper._isIE11;
  }

  /**
   * Checks if browser is Edge
   * @returns {Boolean}
   * @readonly
   */
  static get isEdge() {
    return BrowserHelper._isEdge;
  }

  /**
   * Checks if browser is Webkit
   * @returns {Boolean}
   * @readonly
   */
  static get isWebkit() {
    return BrowserHelper._isWebKit;
  }

  /**
   * Checks if browser is Chrome
   * @returns {Boolean}
   * @readonly
   */
  static get isChrome() {
    return this._isChrome;
  }

  /**
   * Find the major Chrome version
   * @returns {Number}
   * @readonly
   */
  static get chromeVersion() {
    const raw = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);

    return raw ? parseInt(raw[2], 10) : 0;
  }

  /**
   * Checks if browser is Firefox
   * @returns {Boolean}
   * @readonly
   */
  static get isFirefox() {
    return this._isFirefox;
  }

  /**
   * Checks if browser is Safari
   * @returns {Boolean}
   * @readonly
   */
  static get isSafari() {
    return this._isSafari;
  }

  /**
   * Checks if browser is mobile Safari
   * @returns {Boolean}
   * @readonly
   */
  static get isMobileSafari() {
    return this._isMobileSafari;
  }

  /**
   * Returns `true` if the browser supports passive event listeners.
   */
  static get supportsPassive() {
    return this._supportsPassive;
  }

  // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API
  static get storageAvailable() {
    let storage, x;

    try {
      storage = localStorage;
      x = '__storage_test__';

      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e) {
      return (
        e instanceof DOMException &&
        // everything except Firefox
        (e.code === 22 ||
          // Firefox
          e.code === 1014 ||
          // test name field too, because code might not be present
          // everything except Firefox
          e.name === 'QuotaExceededError' ||
          // Firefox
          e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
        // acknowledge QuotaExceededError only if there's something already stored
        storage.length !== 0
      );
    }
  }

  static setLocalStorageItem(key, value) {
    this.storageAvailable && localStorage.setItem(key, value);
  }

  static getLocalStorageItem(key) {
    return this.storageAvailable && localStorage.getItem(key);
  }

  static removeLocalStorageItem(key) {
    this.storageAvailable && localStorage.removeItem(key);
  }
}

BrowserHelper.cacheFlags();
BrowserHelper._$name = 'BrowserHelper';

/**
 * @module Common/helper/util/Rectangle
 */

const allBorders = ['border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width'],
  allPaddings = ['padding-top', 'padding-right', 'padding-bottom', 'padding-left'],
  borderNames = {
    t: 'border-top-width',
    r: 'border-right-width',
    b: 'border-bottom-width',
    l: 'border-left-width'
  },
  paddingNames = {
    t: 'padding-top',
    r: 'padding-right',
    b: 'padding-bottom',
    l: 'padding-left'
  },
  zeroBased = Object.freeze({
    x: 0,
    y: 0
  }),
  alignSpecRe = /^([trblc])(\d*)-([trblc])(\d*)$/i,
  alignPointRe = /^([trblc])(\d*)$/i,
  edgeNames = ['top', 'right', 'bottom', 'left'],
  edgeIndices = {
    t: 0,
    r: 1,
    b: 2,
    l: 3
  },
  defaultAlignments = ['b-t', 'l-r', 't-b', 'r-l'],
  zeroOffsets = Object.freeze([0, 0]),
  matchDimensions = ['width', 'height'];

// Parse a l0-r0 (That's how Menus align to their owning MenuItem) slign spec.
function parseAlign(alignSpec) {
  const parts = alignSpecRe.exec(alignSpec),
    myOffset = parseInt(parts[2] || 50),
    targetOffset = parseInt(parts[4] || 50);

  // Comments assume the Menu's alignSpec of l0-r0 is used.
  return {
    myAlignmentPoint: parts[1] + myOffset, // l0
    myEdge: parts[1], // l
    myOffset, // 0
    targetAlignmentPoint: parts[3] + targetOffset, // r0
    targetEdge: parts[3], // r
    targetOffset, // 0
    startZone: edgeIndices[parts[3]] // 1 - start trying zone 1 in TRBL order
  };
}

// Takes a result from the above function and flips edges for the axisLock config
function flipAlign(align) {
  return `${edgeNames[(edgeIndices[align.myEdge] + 2) % 4][0]}${align.myOffset}-${
    edgeNames[(edgeIndices[align.targetEdge] + 2) % 4][0]
  }${align.targetOffset}`;
}

function createOffsets(offset) {
  if (offset == null) {
    return zeroOffsets;
  } else if (typeof offset === 'number') {
    return [offset, offset];
  }

  return offset;
}

/**
 * Encapsulates rectangular areas for comparison, intersection etc.
 *
 * Note that the `right` and `bottom` properties are *exclusive*.
 *
 */
class Rectangle {
  /**
   * Returns the Rectangle in document based coordinates of the passed element.
   *
   * *Note:* If the element passed is the `document` or `window` the `window`'s
   * rectangle is returned which is always at `[0, 0]` and encompasses the
   * browser's entire document viewport.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @return {Common.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static from(element, relativeTo, ignorePageScroll = false) {
    if (element instanceof Rectangle) {
      return element;
    }

    if (relativeTo) {
      // TODO: nige should figure out if there is a better solution
      let { scrollLeft, scrollTop } = relativeTo;
      if (BrowserHelper.isEdge && relativeTo === document.body) {
        scrollLeft = scrollTop = 0;
      }
      relativeTo = Rectangle.from(relativeTo).translate(-scrollLeft, -scrollTop);
    } else {
      relativeTo = zeroBased;
    }

    // Viewport is denoted by requesting window or document.
    // document.body may overflow the viewport, so this must not be evaluated as the viewport.
    const isViewport = element === document || element === window,
      viewRect = isViewport
        ? new Rectangle(0, 0, window.innerWidth, window.innerHeight)
        : element.getBoundingClientRect(),
      scrollOffset = ignorePageScroll || isViewport ? [0, 0] : [window.pageXOffset, window.pageYOffset];

    return new Rectangle(
      viewRect.left + scrollOffset[0] - relativeTo.x,
      viewRect.top + scrollOffset[1] - relativeTo.y,
      viewRect.width,
      viewRect.height
    );
  }

  /**
   * Returns the inner Rectangle (within border) in document based coordinates
   * of the passed element.
   * @param element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @return {Common.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static inner(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);

    // Can only ask for the following styles if element is in the document.
    if (document.body.contains(element)) {
      const borders = DomHelper.getStyleValue(element, allBorders);

      result.x += parseInt(borders[borderNames.l]);
      result.y += parseInt(borders[borderNames.t]);
      result.right -= parseInt(borders[borderNames.r]);
      result.bottom -= parseInt(borders[borderNames.b]);
    }

    return result;
  }

  /**
   * Returns the content Rectangle (within border and padding) in document based coordinates
   * of the passed element.
   * @param element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @return {Common.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static content(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);

    // Can only ask for the following styles if element is in the document.
    if (document.body.contains(element)) {
      const borders = DomHelper.getStyleValue(element, allBorders),
        padding = DomHelper.getStyleValue(element, allPaddings);

      result.x += parseInt(borders[borderNames.l]) + parseInt(padding[paddingNames.l]);
      result.y += parseInt(borders[borderNames.t]) + parseInt(padding[paddingNames.t]);
      result.right -= parseInt(borders[borderNames.r]) + parseInt(padding[paddingNames.r]);
      result.bottom -= parseInt(borders[borderNames.b]) + parseInt(padding[paddingNames.b]);
    }

    return result;
  }

  /**
   * Returns the client Rectangle (within border and padding and scrollbars) in document based coordinates
   * of the passed element.
   * @param element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @return {Common.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static client(element, relativeTo, ignorePageScroll = false) {
    let result = this.content(element, relativeTo, ignorePageScroll),
      scrollbarWidth = DomHelper.scrollBarWidth,
      padding;

    if (scrollbarWidth) {
      // Capture width taken by any vertical scrollbar.
      // If there is a vertical scrollbar, shrink the box.
      // TODO: We may have to shrink from the left in RTL mode.
      if (element.scrollHeight > element.clientHeight) {
        padding = parseInt(DomHelper.getStyleValue(element, 'padding-right'));
        result.right += padding - Math.max(padding, scrollbarWidth);
      }

      // Capture height taken by any horizontal scrollbar.
      // If there is a horizontal scrollbar, shrink the box.
      if (element.scrollWidth > element.clientWidth) {
        padding = parseInt(DomHelper.getStyleValue(element, 'padding-bottom'));
        result.bottom += padding - Math.max(padding, scrollbarWidth);
      }
    }

    // The client region excluding any scrollbars.
    return result;
  }

  /**
   * Returns a new rectangle created as the union of all supplied rectangles.
   * @param {Common.helper.util.Rectangle[]} rectangles
   * @return {Common.helper.util.Rectangle}
   */
  static union(...rectangles) {
    let { x, y, right, bottom } = rectangles[0],
      current;

    if (rectangles.length > 1) {
      for (let i = 1; i < rectangles.length; i++) {
        current = rectangles[i];

        if (current.x < x) {
          x = current.x;
        }

        if (current.y < y) {
          y = current.y;
        }

        if (current.right > right) {
          right = current.right;
        }

        if (current.bottom > bottom) {
          bottom = current.bottom;
        }
      }
    }

    return new Rectangle(x, y, right - x, bottom - y);
  }

  // This class doesn't extend Base and extending doesn't seem to be
  // the way to go. Instead we duplicate smallest piece of logic here
  static get $name() {
    return (this.hasOwnProperty('_$name') && this._$name) || this.name;
  }

  get $name() {
    return this.constructor.$name;
  }

  /**
   * Constructs a Rectangle
   * @param x The X coordinate
   * @param y The Y coordinate
   * @param width The width
   * @param height The height
   */
  constructor(x, y, width, height) {
    const me = this;

    me._x = x;
    me._y = y;
    me._width = width;
    me._height = height;
  }

  /**
   * Creates a copy of this Rectangle.
   */
  clone() {
    const me = this,
      result = new Rectangle(me.x, me.y, me.width, me.height);

    result.minHeight = me.minHeight;
    result.minWidth = me.minWidth;

    return result;
  }

  /**
   * Returns `true` if this Rectangle wholly contains the passed rectangle.
   *
   * Note that a {@link Common.helper.util.Point} may be passed.
   * @param other The Rectangle to test for containment within this Rectangle
   * @return {Boolean} `true` if the other Rectangle is wholly contained within this Rectangle
   */
  contains(other) {
    const me = this;

    if (other instanceof Rectangle) {
      return other._x >= me._x && other._y >= me._y && other.right <= me.right && other.bottom <= me.bottom;
    } else {
      return false;
    }
  }

  /**
   * Checks if this Rectangle intersects the passed Rectangle
   * @param {Common.helper.util.Rectangle} other The Rectangle to intersect with this.
   * @param {Boolean} useBoolean Specify `true` to return a boolean value instead of constructing a new Rectangle
   * @return {Common.helper.util.Rectangle|Boolean} Returns the intersection Rectangle or `false` if there is no intersection.
   */
  intersect(other, useBoolean = false) {
    var me = this,
      y = Math.max(me.y, other.y),
      r = Math.min(me.right, other.right),
      b = Math.min(me.bottom, other.bottom),
      x = Math.max(me.x, other.x);

    if (b > y && r > x) {
      return useBoolean ? true : new Rectangle(x, y, r - x, b - y);
    } else {
      return false;
    }
  }

  equals(other, round = false) {
    const processor = round ? (x) => Math.round(x) : (x) => x;

    return (
      other instanceof Rectangle &&
      processor(other.x) === processor(this.x) &&
      processor(other.y) === processor(this.y) &&
      processor(other.width) === processor(this.width) &&
      processor(other.height) === processor(this.height)
    );
  }

  /**
   * Translates this Rectangle by the passed vector. Size is maintained.
   * @param {Number} x The X translation vector.
   * @param {Number} y The Y translation vector.
   * @returns This Rectangle;
   */
  translate(x, y) {
    this._x += x || 0;
    this._y += y || 0;
    return this;
  }

  /**
   * Moves this Rectangle to the passed `x`, `y` position. Size is maintained.
   * @param {Number} x The new X position.
   * @param {Number} y The new Y position.
   * @returns This Rectangle;
   */
  moveTo(x, y) {
    if (x != null) {
      this._x = x;
    }
    if (y != null) {
      this._y = y;
    }
    return this;
  }

  /**
   * Returns the vector which would translate this Rectangle (or Point) to the same position as the other Rectangle (or point)
   * @param {Common.helper.util.Rectangle/Common.helper.util.Point} other The Rectangle or Point to calculate the delta to.
   */
  getDelta(other) {
    return [other.x - this.x, other.y - this.y];
  }

  /**
   * The center point of this rectangle.
   * @property {Common.helper.util.Point}
   */
  get center() {
    return new Rectangle.Point(this.x + this.width / 2, this.y + this.height / 2);
  }

  /**
   * Get/sets the X coordinate of the Rectangle. Note that this does *not* translate the
   * Rectangle. The requested {@link #property-width} will change.
   * @property {Number}
   */
  set x(x) {
    let xDelta = x - this._x;

    this._x = x;
    this._width -= xDelta;
  }

  get x() {
    return this._x;
  }

  /**
   * Alias for x. To match DOMRect.
   * @property {Number}
   */
  set left(x) {
    this.x = x;
  }

  get left() {
    return this.x;
  }

  /**
   * Alias for y. To match DOMRect.
   * @property {Number}
   */
  set top(y) {
    this.y = y;
  }

  get top() {
    return this.y;
  }

  /**
   * Get/sets the Y coordinate of the Rectangle. Note that this does *not* translate the
   * Rectangle. The requested {@link #property-height} will change.
   * @property {Number}
   */
  set y(y) {
    let yDelta = y - this._y;

    this._y = y;
    this._height -= yDelta;
  }

  get y() {
    return this._y;
  }

  /**
   * Get/sets the width of the Rectangle. Note that the requested {@link #property-right} will change.
   * @property {Number}
   */
  set width(width) {
    this._width = width;
  }

  get width() {
    return this._width;
  }

  /**
   * Get/sets the height of the Rectangle. Note that the requested {@link #property-bottom} will change.
   * @property {Number}
   */
  set height(height) {
    this._height = height;
  }

  get height() {
    return this._height;
  }

  /**
   * Get/sets the right edge of the Rectangle. Note that the requested {@link #property-width} will change.
   *
   * The right edge value is exclusive of the calculated rectangle width. So x=0 and right=10
   * means a width of 10.
   * @property {Number}
   */
  set right(right) {
    this._width = right - this._x;
  }

  get right() {
    return this._x + this._width;
  }

  /**
   * Get/sets the bottom edge of the Rectangle. Note that the requested {@link #property-height} will change.
   *
   * The bottom edge value is exclusive of the calculated rectangle height. So y=0 and bottom=10
   * means a height of 10.
   * @property {Number}
   */
  set bottom(bottom) {
    this._height = bottom - this._y;
  }

  get bottom() {
    return this._y + this._height;
  }

  get area() {
    return this.width * this.height;
  }

  set minWidth(minWidth) {
    const me = this;

    if (isNaN(minWidth)) {
      me._minWidth = null;
    } else {
      me._minWidth = Number(minWidth);
      me.width = Math.max(me.width, me._minWidth);
    }
  }

  get minWidth() {
    return this._minWidth;
  }

  set minHeight(minHeight) {
    const me = this;

    if (isNaN(minHeight)) {
      me._minHeight = null;
    } else {
      me._minHeight = Number(minHeight);
      me.height = Math.max(me.height, me._minHeight);
    }
  }

  get minHeight() {
    return this._minHeight;
  }

  /**
   * Modifies the bounds of this Rectangle by the specified deltas.
   * @param {Number} x How much to *add* to the x position.
   * @param {Number} y  How much to *add* to the y position.
   * @param {Number} width  How much to add to the width.
   * @param {Number} height  How much to add to the height.
   * @returns This Rectangle
   */
  adjust(x, y, width, height) {
    const me = this;
    me.x += x;
    me.y += y;
    me.width += width;
    me.height += height;
    return me;
  }

  /**
   * Modifies the bounds of this rectangle by moving them by the specified amount in all directions.
   * @param {Number} amount How much to inflate
   * @returns {Common.helper.util.Rectangle} This Rectangle
   */
  inflate(amount) {
    return this.adjust(-amount, -amount, amount, amount);
  }

  /**
   * Attempts constrain this Rectangle into the passed Rectangle. If the `strict` parameter is `true`
   * then this method will return `false` if constraint could not be acheived.
   *
   * If this Rectangle has a `minHeight` or `minWidth` property, size will be adjusted while attempting to constrain.
   *
   * Right and bottom are adjusted first leaving the top and bottom sides to "win" in the case that this Rectangle overflows
   * the constrainTo Rectangle.
   * @param {Common.helper.util.Rectangle} constrainTo The Rectangle to constrain this Rectangle into if possible.
   * @param {Boolean} strict Pass `true` to return false, and leave this Rectangle unchanged if constraint
   * could not be achieved.
   * @returns This Rectangle. If `strict` is true, and constraining was not successful, `false`.
   */
  constrainTo(constrainTo, strict) {
    const me = this,
      originalHeight = me.height,
      originalY = me.y,
      minWidth = me.minWidth || me.width,
      minHeight = me.minHeight || me.height;

    if (me.height >= constrainTo.height) {
      // If we're strict, fail if we could *never* fit into available height.
      if (strict && minHeight > constrainTo.height) {
        return false;
      }
      // If we are >= constrain height, we will have to be at top edge of constrainTo
      me._y = constrainTo.y;
      me.height = constrainTo.height;
    }

    if (me.width >= constrainTo.width) {
      // If we're strict, fail if we could *never* fit into available width.
      if (strict && minWidth > constrainTo.width) {
        // Could not be constrained; undo any previous attempt with height
        me.y = originalY;
        me.height = originalHeight;
        return false;
      }
      // If we are >= constrain width, we will have to be at left edge of constrainTo
      me._x = constrainTo.x;
      me.width = constrainTo.width;
    }

    let overflow = me.bottom - constrainTo.bottom;

    // Overflowing the bottom side, translate upwards.
    if (overflow > 0) {
      me.translate(0, -overflow);
    }

    overflow = me.right - constrainTo.right;

    // Overflowing the right side, translate leftwards.
    if (overflow > 0) {
      me.translate(-overflow);
    }

    overflow = constrainTo.y - me.y;

    // Now, after possible translation upwards, we overflow the top, translate downwards.
    if (overflow > 0) {
      me.translate(0, overflow);
    }

    overflow = constrainTo.x - me.x;

    // Now, after possible translation leftwards, we overflow the left, translate rightwards.
    if (overflow > 0) {
      me.translate(overflow);
    }

    return me;
  }

  /**
   * Returns a cloned version of this Rectangle aligned to a target Rectangle, or element or {@link Common.widget.Widget}.
   * @param {Object} spec Alignment specification.
   * @param {HTMLElement|Common.widget.Widget|Common.helper.util.Rectangle} spec.target The Widget or element or Rectangle to align to.
   * @param {Number[]} [spec.anchorSize] The `[width, height]` of the anchor pointer when in `top` position. The
   * width is the baseline length, and the height is the height of the arrow. If passed, the anchor position
   * will be calculated to be at the centre of the overlap of the two aligned edges and returned in the `anchor`
   * property of the resulting Rectangle:
   *
   *     {
   *         edge: 'top',         // or 'right' or 'bottom' or 'left'
   *         x/y: offset          // dimension to translate and value to translate by.
   *     }
   *
   * @param {Object} [spec.anchorPosition] an `{ x: n, y: n }` anchor translation to be used *if the requested alignment
   * succeeds without violating constraints*. If a fallback alignment is used, the anchor will be centered in the
   * overlap of the aligned edges as usual.
   * @param {Boolean} [spec.overlap] True to allow this to overlap the target.
   * @param {String} spec.align The edge alignment specification string, specifying two points to bring together.
   * The form is `[trblc][n]-[trblc][n]. The `n` is a percentage offset
   * along that edge which defines the alignment point. This is not valid for alignment point `c`.
   * For example `t0-b0' would align this Rectangle's top left corner with the bottom left corner of the `target`.
   * @param {HTMLElement|Common.widget.Widget|Common.helper.util.Rectangle} [spec.constrainTo] The Widget or Element or Rectangle to constrain to.
   * If the requested alignment cannot be constrained (it will first shrink the resulting Rectangle according
   * to the `minWidth` and `minHeight` properties of this rectangle), then it will try aligning at other edges
   * (honouring the `axisLock` option), and pick the fallback alignment which results in the shortest translation.
   * @param {Boolean} [spec.axisLock] Specify as a truthy value to fall back to aligning against the opposite
   * edge first if the requested alignment cannot be constrained into the `constrainTo` option. If specified
   * as `'flexible'`, then fallback will continue searching for solutions on the remaining two sides.
   * @param {Number|Number[]} [spec.offset] The 'x' and 'y' offset values to create an extra margin round the target
   * to offset the aligned widget further from the target. May be configured as -ve to move the aligned widget
   * towards the target - for example producing the effect of the anchor pointer piercing the target.
   * @returns {Common.helper.util.Rectangle} A new Rectangle aligned as requested if possible, but if the requested position violates
   * the `constrainTo` Rectangle, the shortest translation from the requested position which obeys constraints will be used.
   */
  alignTo(spec) {
    // The target and constrainTo may be passed as HtmlElements or Widgets.
    // If so, extract the Rectangles without mutating the incoming spec.
    let result = this.clone(),
      target = spec.target,
      constrainTo = spec.constrainTo,
      calculatedAnchorPosition,
      zone,
      resultZone,
      constrainingToViewport;

    if (target && !(target instanceof Rectangle)) {
      target = Rectangle.from(target.element ? target.element : target);
    }
    if (constrainTo && !(constrainTo instanceof Rectangle)) {
      // Viewport is denoted by requesting window or document.
      // document.body may overflow the viewport, so this must not be evaluated as the viewport.
      constrainingToViewport = constrainTo === window || constrainTo === document;
      constrainTo = Rectangle.from(
        constrainTo.element ? constrainTo.element : constrainTo,
        null,
        spec.ignorePageScroll
      );
    }
    const me = this,
      targetOffsets = createOffsets(spec.offset),
      { align, axisLock, anchorSize, anchorPosition } = spec,
      alignSpec = parseAlign(align),
      position = spec.position || (target && target.$name === 'Point' ? target : null),
      targetConstrainRect = constrainTo && constrainTo.clone(),
      constraintZones = [],
      zoneOrder = [
        {
          zone: (zone = alignSpec.startZone),
          align
        }
      ],
      matchDimension = spec.matchSize && matchDimensions[alignSpec.startZone & 1],
      originalSize = me[matchDimension];

    // Match the size of the edge we are aligning against
    if (matchDimension && axisLock) {
      result[matchDimension] = target[matchDimension];
    }

    // Ensure we will fit before trying
    if (constrainTo) {
      result.constrainTo(constrainTo);
    }

    // If we are aligning edge-to-edge, then plan our fallback strategy when we are constrained.
    if (constrainTo && alignSpec.startZone != null) {
      // Create the list of zone numbers and alignments to try in the preferred order.
      //
      // In the case of axisLock, go through the zones by each axis.
      // So if they asked for t-b, which is zone 2,
      // the array will be [2, 0, 3, 1] (t-b, b-t, r-l, l-r)
      if (axisLock) {
        // First axis flip has to maintain the offset along that axis.
        // so align: l0-r0 has to flip to align: r0-l0. See submenu flipping when
        // constrained to the edge. It flips sides but maintains vertical position.
        zoneOrder.push({
          zone: (zone = (zone + 2) % 4),
          align: flipAlign(alignSpec)
        });

        // Only try the other axis is axisLock is 'flexible'
        if (axisLock === 'flexible') {
          zoneOrder.push({
            zone: (zone = (alignSpec.startZone + 1) % 4),
            align: defaultAlignments[zone]
          });
          zoneOrder.push({
            zone: (zone = (zone + 2) % 4),
            align: defaultAlignments[zone]
          });
        }
      }
      // Go through the zones in order from the requested start.
      // So if they asked for t-b, which is zone 2,
      // the array will be [2, 3, 0, 1] (t-b, r-l, b-t, l-r)
      else {
        for (let i = 1; i < 4; i++) {
          zoneOrder.push({
            zone: (zone = (zone + 1) % 4),
            align: defaultAlignments[zone]
          });
        }
      }
    }

    // Allow them to pass anchorPosition: {x: 10} to indicate that after a fully successful,
    // unconstrained align, the anchor should be 10px from the start.
    if (anchorPosition) {
      let pos = alignSpec.startZone & 1 ? 'y' : 'x';
      calculatedAnchorPosition = {
        [pos]: anchorPosition[pos],
        edge: edgeNames[(alignSpec.startZone + 2) % 4]
      };
    }

    // Keep the target within reach. If it's way outside, pull it back so that it's only just outside);
    if (targetConstrainRect && target) {
      targetConstrainRect.adjust(-target.width, -target.height, target.width, target.height);
      target.constrainTo(targetConstrainRect);
    }

    // As part of fallback process when fitting within constraints, result may shrink to our minima
    result.minWidth = me.minWidth;
    result.minHeight = me.minHeight;

    // We're being commanded to try to align at a position
    if (position) {
      result.moveTo(position.x, position.y);
      if (constrainTo) {
        result.constrainTo(constrainTo);
      }
    }

    // We're aligning to a Target Rectangle within a ConstrainTo Rectangle, taking into account
    // a possible anchor pointer, or x/y offsets. Here's the situation:
    //
    //                             <-- ConstrainTo Rectangle -->
    //  +-----------------------------------+--------------------+-------------------------+
    //  |                                   |                    |                         |
    //  |                                   |                    |                         |
    //  |                                   |                    |                         |
    //  |-----------------------------------+--------------------+-------------------------+
    //  |                                   |          ▼         |                         |
    //  |                                   | +----------------+ |                         |
    //  |                                   | |                | |                         |
    //  |                                   | |                | |                         |
    //  |                                   |▶|     Target     |◀|                         |
    //  |                                   | |                | |                         |
    //  |                                   | |                | |                         |
    //  |                                   | +----------------+ |                         |
    //  |                                   |          ▲         |                         |
    //  +-----------------------------------+--------------------+-------------------------|
    //  |                                   |                    |                         |
    //  |                                   |                    |                         |
    //  |                                   |                    |                         |
    //  +-----------------------------------+--------------------+-------------------------+
    //
    // Which results in the four possible constraint zones above, which we index in standard CSS order.
    //
    // Top    = 0
    // Right  = 1
    // Bottom = 2
    // Left   = 3
    //
    // If the initially requested alignment is not within the constrainTo rectangle
    // then, calculate these four, and then loop through them, beginning at the requested one,
    // quitting when we find a position which does not violate constraints. This includes
    // shrinking the aligning Rectangle towards its minima to attempt a fit.
    //
    // The final fallback, if there is no position which does not violate constraints
    // is to position in whichever of the four rectangles has the largest area shrinking overflowing
    // dimensions down to minima if specified.
    //
    else {
      // Offsets: If we are using an anchor to move away from the target, use anchor height in both dimensions.
      // It's rotated so that "height" always has the same meaning. It's the height of the arrow.
      const offsets = anchorSize ? [anchorSize[1] + targetOffsets[0], anchorSize[1] + targetOffsets[1]] : targetOffsets,
        targetPoint = target.getAlignmentPoint(alignSpec.targetAlignmentPoint, offsets),
        myPoint = result.getAlignmentPoint(alignSpec.myAlignmentPoint);

      result.translate(targetPoint[0] - myPoint[0], targetPoint[1] - myPoint[1]);

      // If an overlapping position was requested, then we are *not* trying out those four zones.
      // We just respect constraint, and that's it.
      const overlap = result.intersect(target, true);

      // If we are aligned over our target, we just obey that within any constraint.
      // No complex edge alignment attempts to fall back to.
      if (overlap) {
        if (constrainTo) {
          result.constrainTo(constrainTo);
        }
        resultZone = alignSpec.startZone;
      }
      // Aligned to outside of our target, and we need to be constrained
      else if (constrainTo && !constrainTo.contains(result)) {
        let requestedResult = result.clone(),
          solutions = [],
          zone,
          largestZone;

        // Any configured anchorPosition becomes invalid now that we're having to move the resulting zone
        // to some unpredictable new place where it fits. It will have to be calculated based upon where
        // we end up aligning.
        calculatedAnchorPosition = null;

        // Calculate the four constraint zones illustrated above.
        // Top
        constraintZones[0] = zone = constrainTo.clone();
        zone.bottom = target.y - offsets[1];

        // Right
        constraintZones[1] = zone = constrainTo.clone();
        zone.x = target.right + offsets[0];

        // Bottom
        constraintZones[2] = zone = constrainTo.clone();
        zone.y = target.bottom + offsets[1];

        // Left
        constraintZones[3] = zone = constrainTo.clone();
        zone.right = target.x - offsets[0];

        // Start from the preferred edge and see if we are able to constrain to within each rectangle
        for (let i = 0; i < zoneOrder.length; i++) {
          // Revert to incoming dimension for fallback out of axisLock
          if (matchDimension && i == 2) {
            result[matchDimension] = originalSize;
          }

          zone = constraintZones[(resultZone = zoneOrder[i].zone)];

          // Perform unconstrained alignment at the calculated alignment for the zone
          result = result.alignTo({
            target: target,
            offsets: offsets,
            align: zoneOrder[i].align
          });

          // If we are able to strictly constrain into this area, then it's one of the possible solutions.
          // We choose the solution which result in the shortest translation from the initial position.
          if (result.constrainTo(zone, true)) {
            solutions.push({
              result: result,
              zone: resultZone
            });

            // If this successful constraint is at the requested alignment, or at a fallback
            // alignment which has used min size constraints, then that's the correct solution.
            // If there's no size compromising, we have to pick the shortest translation.
            if (!largestZone || result.width < me.width || result.height < me.height) {
              result.align = zoneOrder[i].align;
              break;
            }
          }

          // Cache the largest zone we find in case we need the final fallback.
          if (!largestZone || zone.area > largestZone.area) {
            const r = result.clone();

            // And just move the result clone into the edge zone
            switch (resultZone) {
              // Top
              case 0:
                r.moveTo(null, zone.bottom - r.height);
                break;
              // Right
              case 1:
                r.moveTo(zone.left);
                break;
              // Bottom
              case 2:
                r.moveTo(null, zone.top);
                break;
              // Left
              case 3:
                r.moveTo(zone.right - r.width);
                break;
            }

            largestZone = {
              area: zone.area,
              result: r,
              zone: resultZone
            };
          }
        }

        // The loop found at least one solution
        if (solutions.length) {
          // Multiple fallbacks with no axisLock.
          // Use the solution which resulted in the shortest translation distance from the requested alignment.
          if (solutions.length > 1 && !axisLock) {
            solutions.sort((s1, s2) => {
              let s1TranslationDistance = Math.sqrt(
                  (requestedResult.x - s1.result.x) ** 2 + (requestedResult.y - s1.result.y) ** 2
                ),
                s2TranslationDistance = Math.sqrt(
                  (requestedResult.x - s2.result.x) ** 2 + (requestedResult.y - s2.result.y) ** 2
                );

              return s1TranslationDistance - s2TranslationDistance;
            });
          }
          // Initial success, or axisLock. Use first successful solution.
          result = solutions[0].result;
          resultZone = solutions[0].zone;
        }
        // No solutions found - use the largest rectangle.
        else {
          result = largestZone.result;
          resultZone = largestZone.zone;

          // When we are constraining to the viewport, we must still must be constrained,
          // even after we've given up making it align *and* constrain.
          if (constrainingToViewport) {
            result.constrainTo(constrainTo);
          }
        }
      } else {
        resultZone = alignSpec.startZone;
      }

      result.zone = resultZone;

      // If they included an anchor, calculate its position along its edge.
      // TODO: Handle the edge overlap being less than anchor width.
      if (anchorSize) {
        // If we were passed an anchorPosition, and it has remnained valid (meaning the requested
        // alignment succeeded with no constraint), then anchorPosition will be set. If not,
        // we have to calculate it based upon the aligned edge.
        if (!calculatedAnchorPosition) {
          let isLeftOrRight = resultZone & 1,
            start = isLeftOrRight ? 'y' : 'x',
            end = isLeftOrRight ? 'bottom' : 'right',
            startValue = Math.max(target[start], result[start]),
            endValue = Math.min(target[end], result[end]),
            anchorStart = startValue + (endValue - startValue) / 2 - anchorSize[0] / 2,
            anchorEnd = anchorStart + anchorSize[0];

          if (anchorEnd > result[end]) {
            anchorStart -= anchorEnd - result[end];
          }
          if (anchorStart < result[start]) {
            anchorStart += result[start] - anchorStart;
          }

          // Return an anchor property which will have an x or y property and an edge name onto which the
          // arrow should be aligned.
          calculatedAnchorPosition = {
            [start]: anchorStart - result[start],
            edge: edgeNames[(resultZone + 2) % 4]
          };
        }

        result.anchor = calculatedAnchorPosition;
      }
    }

    return result;
  }

  /**
   * Returns the `[x, y]` position of the specified anchor point of this Rectangle in <edge><offset> format.
   * for example passing "t50" will return the centre point of the top edge, passing "r0" will return the start
   * position of the right edge (the top right corner).
   *
   * Note that the offset defaults to 50, so "t" means the centre of the top edge.
   * @param {String} alignmentPoint The alignment point to calculate. Must match the RegExp `[trbl]\d*`
   * @param {Number[]} offsets The `[x, y]` offsets to add from the left/right, top/bottom edge.
   */
  getAlignmentPoint(alignmentPoint, offsets = zeroOffsets) {
    const me = this,
      parts = alignPointRe.exec(alignmentPoint),
      edge = parts[1].toLowerCase(),
      offset = Math.min(Math.max(parseInt(parts[2] || 50), 0), 100) / 100;

    switch (edge) {
      case 't':
        return [me.x + me.width * offset, me.y - offsets[1]];
      case 'r':
        return [me.right + offsets[0], me.y + me.height * offset];
      case 'b':
        return [me.x + me.width * offset, me.bottom + offsets[1]];
      case 'l':
        return [me.x - offsets[0], me.y + me.height * offset];
      case 'c':
        const center = me.center;
        return [center.x + offsets[0], center.y + offsets[1]];
    }
  }

  /**
   * Highlights this Rectangle using the highlighting effect of {@link Common.helper.DomHelper}
   * on a transient element which encapsulates the region's area.
   */
  highlight() {
    const me = this,
      highlightElement = DomHelper.createElement({
        parent: document.body,
        style: `position:absolute;z-index:9999999;pointer-events:none;
                            left:${me.x}px;top:${me.y}px;width:${me.width}px;height:${me.height}px`
      });

    return DomHelper.highlight(highlightElement).then(() => highlightElement.remove());
  }
}
Rectangle._$name = 'Rectangle';

/**
 * @module Common/helper/AjaxHelper
 */

/**
 * Simplifies Ajax requests. Uses fetch & promises.
 *
 * @example
 * AjaxHelper.get('someurl').then(response => {
 *  // process request response here
 * });
 */
class AjaxHelper {
  /**
   * Make a request (using GET) to the specified url.
   * @param {String} url Url
   * @param {Object} [options] The options for the `fetch` API. Please see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch for details
   * @param {Object} [options.queryParams] A key-value pair Object containing the params to add to the query string
   * @param {Object} [options.headers] Any headers you want to add to your request, contained within a `Headers object or an object literal with ByteString values
   * @param {Object} [options.body] Any body that you want to add to your request: this can be a Blob, BufferSource, FormData, URLSearchParams, or USVString object. Note that a request using the GET or HEAD method cannot have a body.
   * @param {Object} [options.mode] The mode you want to use for the request, e.g., cors, no-cors, or same-origin.
   * @param {Object} [options.credentials] The request credentials you want to use for the request: omit, same-origin, or include. To automatically send cookies for the current domain, this option must be provided
   * @param {Object} [options.parseJson] Specify `true` to parses the response and attach the resulting object to the `Response` object as `parsedJson`
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   */
  static get(url, options) {
    return this.fetch(url, options);
  }

  /**
   * POST data to the specified URL.
   * @param {String} url The URL
   * @param {String|Object|FormData} payload The data to post. If an object is supplied, it will be stringified
   * @param {Object} options The options for the `fetch` API. Please see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch for details
   * @param {Object} [options.queryParams] A key-value pair Object containing the params to add to the query string
   * @param {Object} [options.headers] Any headers you want to add to your request, contained within a `Headers object or an object literal with ByteString values
   * @param {Object} [options.body] Any body that you want to add to your request: this can be a Blob, BufferSource, FormData, URLSearchParams, or USVString object. Note that a request using the GET or HEAD method cannot have a body.
   * @param {Object} [options.mode] The mode you want to use for the request, e.g., cors, no-cors, or same-origin.
   * @param {Object} [options.credentials] The request credentials you want to use for the request: omit, same-origin, or include. To automatically send cookies for the current domain, this option must be provided
   * @param {Object} [options.parseJson] Specify `true` to parses the response and attach the resulting object to the `Response` object as `parsedJson`
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   */
  static post(url, payload, options = {}) {
    if (!(payload instanceof FormData) && !(typeof payload === 'string')) {
      payload = JSON.stringify(payload);
    }

    return this.fetch(
      url,
      Object.assign(
        {
          method: 'POST',
          body: payload
        },
        options
      )
    );
  }

  /**
   * Fetch the specified resource using the `fetch` API.
   * @param {String} url object to fetch
   * @param {Object} options The options for the `fetch` API. Please see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch for details
   * @param {Object} [options.method] The request method, e.g., GET, POST
   * @param {Object} [options.queryParams] A key-value pair Object containing the params to add to the query string
   * @param {Object} [options.headers] Any headers you want to add to your request, contained within a `Headers object or an object literal with ByteString values
   * @param {Object} [options.body] Any body that you want to add to your request: this can be a Blob, BufferSource, FormData, URLSearchParams, or USVString object. Note that a request using the GET or HEAD method cannot have a body.
   * @param {Object} [options.mode] The mode you want to use for the request, e.g., cors, no-cors, or same-origin.
   * @param {Object} [options.credentials] The request credentials you want to use for the request: omit, same-origin, or include. To automatically send cookies for the current domain, this option must be provided
   * @param {Object} [options.parseJson] Specify `true` to parses the response and attach the resulting object to the `Response` object as `parsedJson`
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   */
  static fetch(url, options = {}) {
    const controller = new AbortController();
    options.signal = controller.signal;

    if (!('credentitals' in options)) {
      options.credentials = 'include';
    }

    if (options.queryParams) {
      const params = Object.entries(options.queryParams);
      if (params.length) {
        url += '?' + params.map(([param, value]) => `${param}=${encodeURIComponent(value)}`).join('&');
      }
    }

    // Promise that will be resolved either when network request is finished or when json is parsed
    const promise = new Promise((resolve, reject) => {
      fetch(url, options)
        .then((response) => {
          if (options.parseJson) {
            response
              .json()
              .then((json) => {
                response.parsedJson = json;
                resolve(response);
              })
              .catch((error) => {
                response.parsedJson = null;
                response.error = error;
                reject(response);
              });
          } else {
            resolve(response);
          }
        })
        .catch((error) => {
          reject(error);
        });
    });

    promise.abort = function() {
      controller.abort();
    };

    return promise;
  }
}
AjaxHelper._$name = 'AjaxHelper';

/**
 * @module Common/helper/ArrayHelper
 */

/**
 * Helper with useful functions for handling Arrays
 * @internal
 */
class ArrayHelper {
  static clean(array) {
    return array.reduce((res, item) => {
      if (item !== null && item !== undefined && !(Array.isArray(item) && item.length === 0) && item !== '')
        res.push(item);
      return res;
    }, []);
  }

  /**
   * Remove one or more items from an array
   * @param {Array} array Array to remove from
   * @param {Object} items One or more items to remove
   * @returns {boolean} Returns true if any item was removed
   */
  static remove(array, ...items) {
    let index,
      item,
      removed = false;

    for (let i = 0; i < items.length; i++) {
      item = items[i];
      if ((index = array.indexOf(item)) !== -1) {
        array.splice(index, 1);
        removed = true;
      }
    }

    return removed;
  }

  /*
   * Calculates the insertion index of a passed object into the passed Array according
   * to the passed comparator function. Note that the passed Array *MUST* already be ordered.
   * @param {Object} item The item to calculate the insertion index for.
   * @param {Array} The array into which the item is to be inserted.
   * @param {Function} comparatorFn The comparison function. Must return -1 or 0 or 1.
   * @param {Object} comparatorFn.lhs The left object to compare.
   * @param {Object} comparatorFn.rhs The right object to compare.
   * @param {Number} index The possible correct index to try first before a binary
   * search is instigated.
   */
  static findInsertionIndex(item, array, comparatorFn = this.lexicalCompare, index) {
    const len = array.length;
    let beforeCheck, afterCheck;

    if (index < len) {
      beforeCheck = index > 0 ? comparatorFn(array[index - 1], item) : 0;
      afterCheck = index < len - 1 ? comparatorFn(item, array[index]) : 0;
      if (beforeCheck < 1 && afterCheck < 1) {
        return index;
      }
    }

    return this.binarySearch(array, item, comparatorFn);
  }

  /**
   * This method returns the index that a given item would be inserted into the
   * given (sorted) `array`. Note that the given `item` may or may not be in the
   * array. This method will return the index of where the item *should* be.
   *
   * For example:
   *
   *      var array = [ 'A', 'D', 'G', 'K', 'O', 'R', 'X' ];
   *      var index = ArrayHelper.binarySearch(array, 'E');
   *
   *      console.log('index: ' + index);
   *      // logs "index: 2"
   *
   *      array.splice(index, 0, 'E');
   *
   *      console.log('array : ' + array.join(''));
   *      // logs "array: ADEGKORX"
   *
   * @param {Object[]} array The array to search.
   * @param {Object} item The item that you want to insert into the `array`.
   * @param {Number} [begin=0] The first index in the `array` to consider.
   * @param {Number} [end=array.length] The index that marks the end of the range
   * to consider. The item at this index is *not* considered.
   * @param {Function} [compareFn] The comparison function that matches the sort
   * order of the `array`. The default `compareFn` compares items using less-than
   * and greater-than operators.
   * @return {Number} The index for the given item in the given array based on
   * the passed `compareFn`.
   */
  static binarySearch(array, item, begin = 0, end = array.length, compareFn = this.lexicalCompare) {
    const length = array.length;
    let middle, comparison;

    if (begin instanceof Function) {
      compareFn = begin;
      begin = 0;
    } else if (end instanceof Function) {
      compareFn = end;
      end = length;
    }

    --end;

    while (begin <= end) {
      middle = (begin + end) >> 1;
      comparison = compareFn(item, array[middle]);
      if (comparison >= 0) {
        begin = middle + 1;
      } else if (comparison < 0) {
        end = middle - 1;
      }
    }

    return begin;
  }

  magnitudeCompare(lhs, rhs) {
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }

  lexicalCompare(lhs, rhs) {
    lhs = String(lhs);
    rhs = String(rhs);

    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }

  /**
   * Similar to Array.prototype.fill(), but constructs a new array with the specified item count and fills it with
   * clones of the supplied item.
   * @param {Number} count Number of entries to create
   * @param {Object|Array} itemOrArray Item or array of items to clone (uses object spread to create shallow clone)
   * @param {Function} [fn] An optional function that is called for each item added, to allow processing
   * @returns {Array} A new populated array
   */
  static fill(count, itemOrArray = {}, fn = null) {
    const result = [],
      items = Array.isArray(itemOrArray) ? itemOrArray : [itemOrArray];

    for (let i = 0; i < count; i++) {
      for (let item of items) {
        // Using object spread here forces us to use more babel plugins and will make
        // react_typescript demo very difficult to setup
        const processedItem = Object.assign({}, item);

        if (fn) {
          fn(processedItem, i);
        }

        result.push(processedItem);
      }
    }
    return result;
  }

  /**
   * Populates an array with the return value from `fn`.
   * @param {Number} count Number of entries to create
   * @param {Function} fn A function that is called `count` times, return value is added to array
   * @param {Number} fn.index Current index in the array
   * @returns {Array} A new populated array
   */
  static populate(count, fn) {
    const items = [];
    for (let i = 0; i < count; i++) {
      items.push(fn(i));
    }
    return items;
  }

  /**
   * Pushes `item` on to the `array` if not already included
   * @param {Array}  array Array to push to
   * @param {Object} item Item to push if not already included
   */
  static include(array, item) {
    if (!array.includes(item)) {
      array.push(item);
    }
  }

  // Wanted to create an indexer on Stores, based on this. But turns out Proxy cannot be transpiled/polyfill for IE11
  // Keeping it for future reference
  static allowNegative(array) {
    // From https://github.com/sindresorhus/negative-array
    return new Proxy(array, {
      get(target, name, receiver) {
        if (typeof name !== 'string') {
          return Reflect.get(target, name, receiver);
        }

        const index = Number(name);

        if (Number.isNaN(index)) {
          return Reflect.get(target, name, receiver);
        }

        return target[index < 0 ? target.length + index : index];
      },
      set(target, name, value, receiver) {
        if (typeof name !== 'string') {
          return Reflect.set(target, name, value, receiver);
        }

        const index = Number(name);

        if (Number.isNaN(index)) {
          return Reflect.set(target, name, value, receiver);
        }

        target[index < 0 ? target.length + index : index] = value;

        return true;
      }
    });
  }
}
ArrayHelper._$name = 'ArrayHelper';

//TODO: Implement mon

/**
 * @module Common/mixin/Events
 */

// Used to distinguish event names from listener options in addListener object config.
const specialProperties = {
    thisObj: 1,
    detachable: 1,
    once: 1,
    detacher: 1,
    prio: 1,
    args: 1,
    _oldDestructor: 1
  },
  priorityComparator = (a, b) => b.prio - a.prio;

/**
 * Mix this into another class to enable event handling.
 *
 * ## Basic usage
 * Listeners can be added either through config:
 *
 * ```javascript
 * let button = new Button({
 *   listeners: {
 *     click: () => {},
 *     press: () => {},
 *     ...
 *   }
 * });
 * ```
 *
 * *NOTE*: Do not reuse listeners config object, use new every time:
 * ```javascript
 * // wrong
 * let config = { click : () => {} }
 * new Button({
 *     listeners : config
 * })
 * new Button({
 *     listeners : config
 * })
 * // right
 * new Button({
 *     listeners : { click : () => {} }
 * })
 * new Button({
 *     listeners : { click : () => {} }
 * })
 * ```
 *
 * Or by calling on()/addListener():
 *
 * ```javascript
 * let button = new Button();
 *
 * button.addListener('press', () => {});
 * // on is an alias for addListener
 * button.on('click', () => {});
 * ```
 *
 * This style also accepts multiple listeners in same way as when using config:
 *
 * ```javascript
 * button.on({
 *   click: () => {},
 *   press: () => {},
 *   ...
 * });
 * ```
 *
 * ## Options
 * ### Once
 * Listeners can be configured to automatically deregister after first trigger by specifing config option `once`:
 *
 * ```javascript
 * button.on({
 *   click: () => {},
 *   once: true
 * });
 * ```
 *
 * ### Priority
 * Specifying priority affects the order in which listeners are called when triggering an event. Higher prios will be
 * called before lower. Default value is 0.
 *
 * ```javascript
 * button.on({
 *   click: this.onClick,
 *   prio: 1
 * });
 * ```
 *
 * ### This reference
 * If desired, you can specify thisObj when configuring listeners. There is no need if you are using arrow functions as
 * listeners, but might be handy in other cases. Of course, you can also use bind to set `this` reference.
 *
 * ```javascript
 * button.on({
 *   click: this.onClick,
 *   thisObj: this
 * });
 *
 * // or
 *
 * button.on({
 *   click: this.onClick.bind(this)
 * });
 * ```
 *
 * ### Detacher
 * A convenient way of unregistering events is to use a detacher, a function returned when adding listeners that you
 * call later to deregister them. As of version 1.0, detachable defaults to true.
 *
 * ```javascript
 * let detacher = button.on({
 *   click: () => {},
 *   press: () => {},
 *   detachable: true
 * });
 *
 * // when you want to detach, for example in destroy()
 * detacher();
 * ```
 *
 * ### Auto detaching
 * When listeners are bound to a class instance using `thisObj`, the `thisObj`'s `doDestroy` method
 * is overridden to remove the listeners before calling the overridden doDestroy.
 *
 * ```javascript
 * class MyClass extends Base {
 *   construct() {
 *     let button = new Button({
 *       listeners: {
 *         click: () => {},
 *         thisObj: this
 *       }
 *     });
 *   }
 *
 *   doDestroy() {
 *     // clean up stuff
 *   }
 * }
 *
 * let myObj = new MyClass();
 * // clean up, also removes listeners
 * myObj.destroy();
 * ```
 *
 * ### On-functions
 * When mixing Events into another class it can be configured to call on-functions when events are triggered.
 * On-functions are functions named 'onEventname', for example 'onClick', 'onPress' declared on the class triggering
 * the event.
 *
 * ```javascript
 * // mix Events in with on-functions activated
 * let button = new Button({
 *   callOnFunctions: true,
 *
 *   onClick: () => {}
 * });
 *
 * // or add a getter in class declaration
 * ```
 *
 * ### Catching all events
 * By specifying a listener for `catchAll` a function can be notified when any event is triggered:
 *
 * ```javascript
 * const button = new Button({
 *    listeners : {
 *        catchAll(event) {
 *            // All events on the button will pass through here
 *        }
 *    }
 * });
 * ```
 *
 * @mixin
 */
var Events = (Target) =>
  class Events extends (Target || Base) {
    //region Events
    /**
     * Fires before an object is destroyed.
     * @event beforeDestroy
     * @param {Object} source The Object that is being destroyed.
     */

    /**
     * Fires when an object is destroyed.
     * @event destroy
     * @param {Object} source The Object that is being destroyed.
     */

    //endregion

    //region Config

    /**
     * Listeners can be specified in target class config.
     * ```
     * let store = new Store({
     *   listeners: {
     *     load: () => {},
     *     ...
     *   }
     * });
     * ```
     * @config {Object} listeners
     */

    destroy() {
      this.trigger('beforeDestroy');
      super.destroy();
    }

    //endregion

    //region Init

    // TODO: Check, because not sure about using @function constructor here
    /**
     * Adds configured listeners
     * @private
     * @function constructor
     */
    construct(...args) {
      super.construct(...args);

      this.processConfiguredListeners();
    }

    processConfiguredListeners(listeners = this.listeners) {
      const me = this;

      // make sure main object contains `listeners` property
      me.listeners = listeners;

      // TODO: listeners should be added first, so that any setters which fire or rely on listeners work.
      // This may also expose bugs where listeners are fired too early.
      if (me.listeners && !me.defaultListenersInitialized) {
        const ret = me.addListener(me.listeners, me);

        if (me.listeners.detachable !== false) me.listeners.detacher = ret;

        me.defaultListenersInitialized = true;
      }
    }

    /**
     * Auto detaches listeners registered from start, if set as detachable
     * @internal
     */
    doDestroy() {
      const me = this;

      me.trigger('destroy');
      if (me.listeners && me.listeners.detacher) {
        me.listeners.detacher();
      }
      me.removeAllListeners();

      super.doDestroy();
    }

    //endregion

    //region Listeners

    /**
     * Adds an event listener. This method accepts parameters in the following format:
     *
     * ```javascript
     *  {
     *      thisObj    : this,          // The this reference for the handlers
     *      eventname2 : 'functionName' // Resolved at invocation time using the thisObj,
     *      otherevent : {
     *          fn      : 'handlerFnName',
     *          once    : true          // Just this handler is auto-removed on fire
     *      },
     *      yetanother  : {
     *          fn      : 'yetAnotherHandler',
     *          args    : [ currentState1, currentState2 ] // Capture info to be passed to handler
     *      }
     *      prio        : 100           // Higher prio listeners are called before lower
     *  }
     * ```
     *
     * When listeners have a `thisObj` option, they are linked to the lifecycle of that object.
     * When it is destroyed, those listeners are removed.
     *
     * @param {Object} config An object containing listener definitions.
     * @param {Object} [config.thisObj] The `this` reference for all listeners.
     * (May be overridden if a handler is specified in object form)
     * @param {Boolean} [config.once] Specify as `true` to remove the listener as soon as it is invoked.
     * @param {Object[]} [config.args] An array of arguments to be passed to the handler before the event object.
     * @param {Object} [thisObj] `this` reference for all listeners.
     * @param {Number} [prio] The priority for all listeners; higher priority listeners are caled before lower.
     * @returns {Function} Returns a detacher function unless configured with `detachable: false`. Call detacher to remove listeners
     */
    addListener(config, thisObj, arg2) {
      const me = this,
        events = me.eventListeners || (me.eventListeners = {});

      if (typeof config === 'string') {
        // arguments[2] is thisObj if (eventname, handler, thisObj) form called.
        // Note that the other side of the if compares to undefined, so this will work.
        return me.addListener({
          [config]: thisObj,
          detachable: thisObj.detachable !== false,
          thisObj: arg2
        });
      } else {
        // If the thisObj came from the parameter, ensure the config object has it
        // because this is how autoDetaching works.
        thisObj = config.thisObj !== undefined ? config.thisObj : (config.thisObj = thisObj);

        for (const key in config) {
          if (!specialProperties[key]) {
            const listenerSpec = config[key],
              listener = {
                fn: typeof listenerSpec === 'object' ? listenerSpec.fn : listenerSpec,
                thisObj: listenerSpec.thisObj !== undefined ? listenerSpec.thisObj : thisObj,
                args: listenerSpec.args || config.args,
                prio: listenerSpec.prio !== undefined ? listenerSpec.prio : config.prio !== undefined ? config.prio : 0,
                once:
                  listenerSpec.once !== undefined ? listenerSpec.once : config.once !== undefined ? config.once : false,
                catchAll: key === 'catchAll'
              },
              eventName = key.toLowerCase(),
              listeners = events[eventName] || (events[eventName] = []);

            // Insert listener directly in prio order
            listeners.splice(
              ArrayHelper.findInsertionIndex(listener, listeners, priorityComparator, listeners.length),
              0,
              listener
            );
          }
        }

        if (config.relayAll) {
          me.relayAll(config.relayAll);
        }

        // Hook into the thisObj's destruction sequence to remove these listeners.
        if (thisObj) {
          me.attachAutoDetacher(config);
        }
        if (config.detachable !== false) {
          return () => me.removeListener(config);
        }
      }
    }

    /**
     * Shorthand for addListener
     * @param config
     * @param [thisObj]
     */
    on() {
      return this.addListener(...arguments);
    }

    /**
     * Shorthand for removeListener
     * @param config
     * @param thisObj
     */
    un() {
      this.removeListener(...arguments);
    }

    /**
     * Removes an event listener. Same API signature as {@link #function-addListener}
     * @param {Object} config Listeners
     * @param {Object} thisObj `this` reference for all listeners
     */
    removeListener(config, thisObj = config.thisObj, ...params) {
      const me = this;

      if (typeof config === 'string') {
        me.removeListener({ [config]: thisObj }, params.length > 0 ? params[0] : true);
        return;
      }

      Object.entries(config).forEach(([key, configListener]) => {
        if (specialProperties[key]) {
          return;
        }

        const eventName = key.toLowerCase(),
          listeners = me.eventListeners && me.eventListeners[eventName];

        if (listeners) {
          const index = listeners.findIndex(
            (listener) =>
              (listener.fn === configListener || listener.fn === configListener.fn) &&
              (listener.thisObj === thisObj || listener.thisObj === configListener.thisObj || !thisObj)
          );
          if (index >= 0) {
            listeners.splice(index, 1);
            if (!listeners.length) {
              delete me.eventListeners[eventName];
            }
          }
        }
      });

      if (config.thisObj && !config.thisObj.isDestroyed) {
        me.detachAutoDetacher(config);
      }
    }

    /**
     * Check if any listener is registered for the specified eventName
     * @param {String} eventName
     * @returns {Boolean} `true` if listener is registered, otherwise `false`
     */
    hasListener(eventName) {
      return Boolean(this.eventListeners && this.eventListeners[eventName]);
    }

    /**
     * Relays all events through another object that also implements Events mixin. Adds a prefix to the event name
     * before relaying, for example add -> storeAdd
     * ```
     * // Relay all events from store through grid, will make it possible to listen for store events prefixed on grid:
     * 'storeLoad', 'storeChange', 'storeRemoveAll' etc.
     * store.relayAll(grid, 'store');
     *
     * grid.on('storeLoad', () => console.log('Store loaded');
     * ```
     * @param {Common.mixin.Events} through Object to relay the events through, needs to mix Events mixin in
     * @param {String} prefix Prefix to add to event name
     * @param {Boolean} [transformCase] Specify false to prevent making first letter of event name uppercase
     */
    relayAll(through, prefix, transformCase = true) {
      const me = this;

      if (!me.relayAllTargets) me.relayAllTargets = [];

      me.relayAllTargets.push({ through, prefix, transformCase });
    }

    /**
     * Removes all listeners registered to this object
     */
    removeAllListeners() {
      const me = this,
        listeners = me.eventListeners || (me.eventListeners = {});

      for (let event in listeners) {
        listeners[event].forEach((cfg) => me.removeListener(event, cfg));
      }
    }

    relayEvents(source, eventNames, prefix) {
      const me = this,
        listenerConfig = { detachable: true };

      function retrigger(eventName, ...params) {
        return me.trigger((prefix || '') + eventName, ...params);
      }

      eventNames.forEach((eventName) => {
        listenerConfig[eventName] = (...params) => {
          return retrigger(eventName, ...params);
        };
      });

      return source.on(listenerConfig);
    }

    /**
     * Internal function used to hook destroy() calls when using thisObj
     * @private
     */
    attachAutoDetacher(config) {
      const target = config.thisObj,
        // If it's a Bryntyum Base subclass, hook doDestroy, otherwise, destroy
        destructorName = 'doDestroy' in target ? 'doDestroy' : 'destroy';

      if (destructorName in target) {
        config._oldDestructor = target[destructorName];
        target[destructorName] = () => {
          // Remove listeners first, so that they do not fire during destruction.
          // The observable being listened to by the thisObj may already have
          // been destroyed in a clean up sequence
          if (!this.isDestroyed) {
            this.removeListener(config);
          }
          config._oldDestructor.call(target);
        };
      } else {
        target[destructorName] = () => {
          this.removeListener(config);
        };
      }
    }

    /**
     * Internal function used restore hooked destroy() calls when using thisObj
     * @private
     */
    detachAutoDetacher(config) {
      const target = config.thisObj,
        destructorName = 'doDestroy' in target ? 'doDestroy' : 'destroy';

      if (config._oldDestructor) {
        target[destructorName] = config._oldDestructor;
      }
    }

    //endregion

    //region Promise based workflow

    // experimental, used in tests to support async/await workflow
    await(eventName, options = { checkLog: true, resetLog: true }) {
      const me = this;

      return new Promise((resolve) => {
        // check if previously triggered?
        if (options.checkLog && me._triggered && me._triggered[eventName]) {
          // resolve immediately, no params though...
          resolve();
          // reset log to be able to await again
          if (options.resetLog) {
            me.clearLog(eventName);
          }
        }

        me.on({
          [eventName]: (...params) => {
            // resolve when event is caught
            resolve(...params);
            // reset log to be able to await again
            if (options.resetLog) {
              me.clearLog(eventName);
            }
          },
          prio: -10000, // Let others do their stuff first
          once: true // promises can only be resolved once anyway
        });
      });
    }

    clearLog(eventName) {
      if (this._triggered) {
        if (eventName) {
          delete this._triggered[eventName];
        } else {
          this._triggered = {};
        }
      }
    }

    //endregion

    //region Trigger

    /**
     * Wraps a function with event triggering. First triggers before[eventName] with the supplied eventObject. If it is
     * not prevented (by returning false) the supplied fn is called with the eventObject as first argument and any
     * optional arguments after that. It then triggers [eventName] with the eventObject (that might have been altered in
     * fn). Finally it returns the return value from the fn.
     * @param {String} eventName Event name, used to trigger 'beforeEventName' and 'eventName'
     * @param {Object} eventObject Passed when triggering events
     * @param {Function} fn Function to call if before is not prevented
     * @param {Array} args Arguments to pass to fn
     * @param {Boolean} quiet Specify true to not trigger events
     * @returns {*} Result returned from calling fn, or false if prevented
     * @internal
     */
    callPreventable(eventName, eventObject, fn, args = [], quiet = false) {
      const me = this;

      if (!quiet && me.trigger('before' + StringHelper.capitalizeFirstLetter(eventName), eventObject) === false) {
        return false;
      }

      const result = fn(eventObject, ...args);

      if (!quiet) {
        me.trigger(eventName, eventObject);
      }

      return result;
    }

    /**
     * Triggers an event, calling all registered listeners with the supplied arguments. Returning false from any listener
     * makes function return false.
     * @param {String} eventName Event name for which to trigger listeners
     * @param {Object} param Single parameter passed on to listeners, source property will be added to it (this)
     * @param {Boolean} [param.bubbles] Pass as `true` to indicate that the event will bubble up the widget
     * ownership hierarchy. For example up a Menu->parent Menu tree, or a Field->Container tree.
     * @returns {Boolean} Returns false if any listener returned false, otherwise true
     */
    // TODO: should returning false from a listener really prevent other listeners from executing?
    trigger(eventName, param) {
      const me = this,
        name = eventName.toLowerCase(),
        { eventsSuspended, relayAllTargets, callOnFunctions } = me;

      let listeners = me.eventListeners && me.eventListeners[name],
        doSlice = true;

      // log trigger, used by experimental promise support to resolve immediately when needed
      if (!me._triggered) {
        me._triggered = {};
      }
      me._triggered[eventName] = true;

      if (eventsSuspended) {
        if (eventsSuspended.shouldQueue) eventsSuspended.queue.push(arguments);
        return true;
      }

      // Include catchall listener for all events.
      // Do not push the catchAll listeners onto the events own listener array.
      if (me.eventListeners && me.eventListeners.catchall) {
        (listeners = listeners ? listeners.slice() : []).push(...me.eventListeners.catchall);

        // The catchAll listeners must honour their prio settings.
        listeners.sort(priorityComparator);
        doSlice = false;
      }

      if (!listeners && !relayAllTargets && !callOnFunctions) return true;

      // default to include source : this in param
      if (param) {
        if (!('source' in param)) {
          if (Object.isExtensible(param)) {
            param.source = me;
          } else {
            param = Object.setPrototypeOf(
              {
                source: me
              },
              param
            );
          }
        }
      } else {
        param = {
          source: me
        };
      }

      // Lowercased event name should be the "type" property in keeping with DOM events.
      if (param.type !== name) {
        // Create instance property because "type" is read only
        if (param.constructor !== Object) {
          Reflect.defineProperty(param, 'type', { get: () => name });
        } else {
          param.type = name;
        }
      }

      if (callOnFunctions) {
        const fnName = 'on' + StringHelper.capitalizeFirstLetter(eventName);
        if (fnName in me) {
          me.callback(me[fnName], me, [param]);

          // See if the called function was injected into the instance
          // masking an implementation in the prototype.
          // we must call the class's implementation after the injected one.
          // Note: The handler may have resulted in destruction.
          if (!me.isDestroyed && me.hasOwnProperty(fnName)) {
            const myProto = Object.getPrototypeOf(me);
            if (fnName in myProto) {
              myProto[fnName].call(me, param);

              // A handler may have resulted in destruction.
              if (me.isDestroyed) {
                return;
              }
            }
          }
        }
      }

      if (listeners) {
        let i = 0,
          listener,
          handler;

        // Make a flat copy of the listeners to protect against a situation where an event listener
        // adds another listener while triggering the event, which we do not want.
        // The array may already be a copy if there are catchAll listeners. See above.
        if (doSlice) {
          listeners = listeners.slice();
        }

        // If any listener resulted in our destruction, abort.
        for (i; i < listeners.length && !me.isDestroyed; i++) {
          listener = listeners[i];

          let thisObj = listener.thisObj;

          // Listeners that have thisObj are auto removed when thisObj is destroyed. If thisObj is destroyed from
          // a listener we might still end up here, since listeners are sliced and not affected by the removal
          if (!thisObj || !thisObj.isDestroyed) {
            if (listener.once) {
              me.removeListener(name, listener);
            }

            if (typeof listener.fn === 'string') {
              if (thisObj) {
                handler = thisObj[listener.fn];
              }

              // keep looking for the callback in the hierarchy
              if (!handler) {
                const result = me.resolveCallback(listener.fn);

                handler = result.handler;
                thisObj = result.thisObj;
              }
            } else {
              handler = listener.fn;
            }

            // If listener was declared with args, send our param after them
            if (listener.args) {
              if (handler.call(thisObj || me, ...listener.args, param) === false) {
                return false;
              }
            } else {
              if (handler.call(thisObj || me, param) === false) {
                return false;
              }
            }
          }
        }
      }

      // relay all?
      if (relayAllTargets) {
        relayAllTargets.forEach((config) => {
          let name = eventName;
          if (config.transformCase) name = StringHelper.capitalizeFirstLetter(name);
          if (config.prefix) name = config.prefix + name;
          if (config.through.trigger(name, param) === false) return false;
        });
      }

      // Use DOM standard event property name to indicate that the event
      // bubbles up the owner axis.
      // False from any handler cancels the bubble.
      if (param.bubbles) {
        const owner = me.owner;
        if (owner) {
          return owner.trigger(eventName, param);
        }
      }

      return true;
    }

    /**
     * Prevents events from being triggered until {@link #function-resumeEvents()} is called. Optionally queues events that are triggered while
     * suspended. Multiple calls stack to require matching calls to `resumeEvents()` before actually resuming.
     * @param {Boolean} queue Specify true to queue events triggered while suspended
     */
    suspendEvents(queue = false) {
      const eventsSuspended =
        this.eventsSuspended || (this.eventsSuspended = { shouldQueue: queue, queue: [], count: 0 });
      eventsSuspended.count++;
    }

    /**
     * Resume event triggering after a call to {@link #function-suspendEvents()}. If any triggered events were queued they will be triggered.
     * @returns `true` if events have been resumed (multiple calls to suspend require an equal number of resume calls to resume).
     */
    resumeEvents() {
      const suspended = this.eventsSuspended;
      if (suspended) {
        if (--suspended.count === 0) {
          this.eventsSuspended = null;
          if (suspended.shouldQueue) {
            for (let queued of suspended.queue) {
              this.trigger(...queued);
            }
          }
        }
      }

      return !Boolean(this.eventsSuspended);
    }

    //endregion
  };

/**
 * Singleton that handles switching locale. Locales can be included on page with `<script type="module">` tags or
 * loaded using ajax. When using script tags the first locale loaded is used per default, if another should be used as
 * default specify it on the script tag for the grid (see example below).
 *
 * ```
 * // Using Ecma 6 modules
 * &lt;script type="module" src="./Common/localization/SvSE.js"&gt;
 *
 * // Specify default when using scripts
 * &lt;script src="build/locales/grid-locale-SvSE.js"&gt;
 * &lt;script data-default-locale="En" src="build/grid-all.js"&gt;
 *
 * import LocaleManager from 'Common/localization/LocaleManager.js';
 * LocaleManager.applyLocale('SvSE');
 * ```
 *
 * @demo localization
 */
class LocaleManager extends Events(Base) {
  static get defaultConfig() {
    return {
      locales: {}
    };
  }

  construct(...args) {
    const me = this;

    super.construct(...args);

    // currentScript not working in IE11
    // if (document.currentScript && document.currentScript.dataset.defaultLocale) {
    //     me.defaultLocaleName = document.currentScript.dataset.defaultLocale;
    // }

    let scriptTag = document.querySelector('script[data-default-locale]');
    if (scriptTag) {
      me.defaultLocaleName = scriptTag.dataset.defaultLocale;
    }

    if (window.bryntum && window.bryntum.locales) {
      Object.keys(window.bryntum.locales).forEach((localeName) => {
        // keeping this check in case some client tries to use an old locale
        if (!localeName.startsWith('moment')) {
          let locale = window.bryntum.locales[localeName];
          if (locale.extends) {
            me.extendLocale(locale.extends, locale);
          } else {
            me.registerLocale(locale.localeName, { desc: locale.localeDesc, locale: locale });
          }
        }
      });

      if (!me.locale) {
        // English locale is built in, no need to apply it here since it will be applied anyway
        if (me.defaultLocaleName !== 'En') {
          // No locale applied, use default or first found
          me.applyLocale(me.defaultLocaleName || Object.keys(me.locales)[0]);
        }
      }
    }
  }

  set locales(localeConfigs) {
    this._locales = localeConfigs;
  }

  get locales() {
    return this._locales;
  }

  /**
   * Get/set currently used locale. Set a name of a locale to have it applied, or give a locale configuration to
   * have it registered and then applied
   * @property {String|Object}
   */
  set locale(locale) {
    if (typeof locale === 'string') {
      this.applyLocale(locale);
    } else {
      if (!locale.locale) {
        locale = {
          locale,
          localeName: locale.localeName || 'custom'
        };
      }

      this.registerLocale(locale.localeName, locale);
      this.applyLocale(locale.localeName);
    }
  }

  get locale() {
    return this._locale;
  }

  /**
   * Register a locale to make it available for applying
   * @param name
   * @param config
   */
  registerLocale(name, config) {
    const me = this,
      isDefault = me.defaultLocaleName === name,
      isCurrent = me.locale && me.locale.localeName === name,
      isFirst = Object.keys(me.locales).length === 0;

    me.locales[name] = config;

    // if no default locale specified, use the first one. otherwise apply the default when it is registered
    // also reapply if current locale is registered again (first grid, then scheduler etc).
    if (isDefault || (!me.defaultLocaleName && (isFirst || isCurrent))) {
      me.internalApplyLocale(config);
    }
  }

  /**
   * Extend an already loaded locale to add additional translations
   * @param name
   * @param config
   */
  extendLocale(name, config) {
    const locale = this.locales[name];
    if (!locale) return false;

    Object.keys(config).forEach((cls) => {
      if (!locale.locale[cls]) {
        locale.locale[cls] = config[cls];
      } else {
        Object.assign(locale.locale[cls], config[cls]);
      }
    });

    delete locale.locale.extends;

    return true;
  }

  internalApplyLocale(localeConfig) {
    const me = this;
    me._locale = localeConfig.locale;
    me.trigger('locale', localeConfig);
  }

  /**
   * Apply a locale. Locale must be defined in LocaleManager#locales. If it is not loaded it will be loaded using ajax
   * and then applied.
   * @param {String} name Name of locale to apply (for example En or SvsE)
   * @returns {boolean|Promise}
   */
  applyLocale(name, forceApply = false, ignoreError = false) {
    const me = this,
      localeConfig = me.locales[name];

    if (localeConfig && localeConfig.locale && me._locale === localeConfig.locale && !forceApply) {
      // no need to apply same locale again
      return true;
    }

    // ignoreError is used in examples where one example might have defined a locale not available in another

    if (!localeConfig) {
      if (ignoreError) return true;

      throw new Error(`Locale ${name} not registered`);
    }

    function internalApply() {
      me.internalApplyLocale(localeConfig);
    }

    if (!localeConfig.locale) {
      return new Promise((resolve, reject) => {
        me.loadLocale(localeConfig.path)
          .then((response) => {
            //const text      = response.substring(response.indexOf('{'), response.lastIndexOf('};') + 1),
            //      getLocale = new Function('return ' + text);
            response.text().then((text) => {
              // eslint-disable-next-line no-new-func
              const parseLocale = new Function(text);
              parseLocale();

              localeConfig.locale = window.bryntum.locales[name];
              internalApply();
              resolve(localeConfig);
            });
          })
          .catch((response) => reject(response));
      });
    }

    internalApply();
    return true;
  }

  /**
   * Loads a locale using ajax
   * @private
   * @param {String} path Path to locale file
   * @returns {Promise}
   */
  loadLocale(path) {
    return AjaxHelper.get(path);
  }
}

let LocaleManagerSingelton = new LocaleManager();

/**
 * @module Common/localization/Localizable
 */

/**
 * Mixin that simplifies localization of strings in a class.
 *
 * ```
 * // Get localized string
 * grid.L('sort')
 * ```
 *
 * @mixin
 */
var Localizable = (Target) =>
  class Localizable extends (Target || Base) {
    static get defaultConfig() {
      return {
        localeClass: null,
        localizableProperties: []
      };
    }

    static get inTextLocaleRegExp() {
      return /L\{([^}]+)\}/g;
    }

    // In case it's wrapped in 'L{text}'
    static parseText(text) {
      const match = this.inTextLocaleRegExp.exec(text);
      return match ? match[1] : text;
    }

    construct(config = {}, ...args) {
      const me = this;

      // Base class applies configs.
      super.construct(config, ...args);

      LocaleManagerSingelton.on('locale', me.updateLocalization, me);

      me.updateLocalization();
    }

    get localeClass() {
      // Trying to extract localeClass from a parent widget. null by default
      return this._localeClass || (this.parent && this.parent.localeClass) || null;
    }

    set localeClass(key) {
      this._localeClass = key;
    }

    updateLocalization() {
      const me = this;

      me.localizableProperties &&
        me.localizableProperties.forEach((name) => {
          // No need to translate properties which are not defined
          if (me[name] === undefined) return;

          me.originalLocales = me.originalLocales || {};

          // Need to save original values since they will be overridden by localizable equivalents
          me.originalLocales[name] = me.originalLocales[name] || me[name];

          // Doing localization from the original values
          if (me.originalLocales[name]) {
            me[name] = Localizable.L.call(me, me.originalLocales[name]);
          }
        });
    }

    /**
     * Get localized string, returns value of `text` if no localized string found
     * @param {String} text String key
     * @param {Object} [templateData] Data to supply to template if localized string is one
     * @returns {String}
     */
    static L(text, templateData, current = this.localeClass || this) {
      if (LocaleManagerSingelton.locale) {
        // traverse prototypes to find localization

        while (current) {
          const name = current.$name || current.name,
            localeClass = LocaleManagerSingelton.locale[name],
            localeText = localeClass && localeClass[Localizable.parseText(text)];

          if (localeText) {
            return typeof localeText === 'function' && templateData != null ? localeText(templateData) : localeText;
          }

          current = Object.getPrototypeOf(current);
        }
      }
      return text;
    }

    /**
     * Convenience function that can be called directly on the class that mixes Localizable in
     * @param {String} text String key
     * @param {Object} [templateData] Data to supply to template if localized string is one
     * @returns {String}
     * @category Misc
     * @example
     * button.text = grid.L('group');
     */
    L(text, templateData) {
      return Localizable.L(text, templateData, this.constructor);
    }

    /**
     * Get the global LocaleManager
     * @returns {Common.localization.LocaleManager}
     * @category Misc
     */
    get localeManager() {
      return LocaleManagerSingelton;
    }
  };

/*
Not ported:
-----------
Week of Year w 1 2 ... 52 53
wo 1st 2nd ... 52nd 53rd
ww 01 02 ... 52 53
Week Year gg 70 71 ... 29 30
gggg 1970 1971 ... 2029 2030
Week Year (ISO) GG 70 71 ... 29 30
GGGG 1970 1971 ... 2029 2030
Time Zone z or zz EST CST ... MST PST
Note: as of 1.6.0, the z/zz format tokens have been deprecated from plain moment objects. Read more about it here. However, they do work if you are using a specific time zone with the moment-timezone addon.
Z -07:00 -06:00 ... +06:00 +07:00
ZZ -0700 -0600 ... +0600 +0700
Unix Timestamp X 1360013296
Unix Millisecond Timestamp x 1360013296123
*/

const enOrdinalSuffix = (number) => number + ({ '1': 'st', '2': 'nd', '3': 'rd' }[number[number.length - 1]] || 'th');
// Left-to-right unicode mark
// https://www.codetable.net/decimal/8206
const LTRSymbolRegexp = new RegExp('\u200E');

// These vars are set when changing locale

let locale = 'en-US',
  ordinalSuffix = enOrdinalSuffix,
  // Used to cache used formats, to not have to parse format string each time
  formatCache = {},
  intlFormatterCache = {},
  parserCache = {};

function useIntlFormat(name, options, date) {
  const formatter = intlFormatterCache[name] || (intlFormatterCache[name] = new Intl.DateTimeFormat(locale, options));

  let result = formatter.format(date);

  // IE11 inserts direction control characters to the start of the string
  // This breaks substring(0, 2). Skipping first character in the row for I
  // https://stackoverflow.com/questions/25574963/ies-tolocalestring-has-strange-characters-in-results
  if (BrowserHelper.isIE11) {
    result = result.replace(LTRSymbolRegexp, '');
  }

  return result;
}

const MS_PER_DAY = 864e5,
  MS_PER_WEEK = MS_PER_DAY * 7,
  defaultFormat = 'YYYY-MM-DDTHH:mm:ss.SSSZ',
  formats = {
    // 1, 2, ... 11, 12
    M: (date) => date.getMonth() + 1, //date.toLocaleDateString(locale, { month : 'numeric' }),
    // 1st, 2nd, 3rd, 4th, ... 11th, 12th
    Mo: (date) => ordinalSuffix(formats['M'](date).toString()),
    // 01, 02, ...
    MM: (date) => (date.getMonth() + 1).toString().padStart(2, '0'), //date.toLocaleDateString(locale, { month : '2-digit' }),
    // Jan, Feb, ...
    MMM: (date) => useIntlFormat('MMM', { month: 'short' }, date),
    // January, February, ...
    MMMM: (date) => useIntlFormat('MMMM', { month: 'long' }, date),

    // 1, 2, ...
    Q: (date) => Math.ceil((date.getMonth() + 1) / 4),
    // 1st, 2nd, ...
    Qo: (date) => ordinalSuffix(formats['Q'](date).toString()),

    // 1, 2, ...
    D: (date) => date.getDate(), //date.toLocaleDateString(locale, { day : 'numeric' }),
    // 1st, 2nd, ...
    Do: (date) => ordinalSuffix(formats['D'](date).toString()),
    // 01, 02, ...
    DD: (date) =>
      date
        .getDate()
        .toString()
        .padStart(2, '0'), //date.toLocaleDateString(locale, { day : '2-digit' }),

    // 1, 2, ..., 365, 365
    DDD: (date) =>
      Math.ceil(
        (new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0) -
          new Date(date.getFullYear(), 0, 0, 12, 0, 0)) /
          MS_PER_DAY
      ),
    // 1st, 2nd, ...
    DDDo: (date) => ordinalSuffix(formats['DDD'](date).toString()),
    // 001, 002, ...
    DDDD: (date) =>
      formats['DDD'](date)
        .toString()
        .padStart(3, '0'),

    // 0, 1, ..., 6
    d: (date) => date.getDay(),
    // 0th, 1st, ...
    do: (date) => ordinalSuffix(date.getDay().toString()),
    // Su, Mo, ...
    dd: (date) => formats['ddd'](date).substring(0, 2),
    // Sun, Mon, ...
    ddd: (date) => useIntlFormat('ddd', { weekday: 'short' }, date),
    // Sunday, Monday, ...
    dddd: (date) => useIntlFormat('dddd', { weekday: 'long' }, date),

    e: (date) => date.getDay(),
    E: (date) => date.getDay() + 1,

    // ISO week, 1, 2, ...
    W: (date) => {
      // Adapted from https://www.epochconverter.com/weeknumbers
      const target = new Date(date.valueOf());
      target.setDate(target.getDate() - ((date.getDay() + 6) % 7) + 3);
      const firstThursday = target.valueOf();
      target.setMonth(0, 1);
      if (target.getDay() !== 4) {
        target.setMonth(0, 1 + ((4 - target.getDay() + 7) % 7));
      }
      return 1 + Math.ceil((firstThursday - target) / MS_PER_WEEK);
    },
    Wo: (date) => ordinalSuffix(formats['W'](date).toString()),
    WW: (date) =>
      formats['W'](date)
        .toString()
        .padStart(2, '0'),

    // 1979, 2018
    Y: (date) => date.getFullYear(), //date.toLocaleDateString(locale, { year : 'numeric' }),
    // 79, 18
    YY: (date) => date.getFullYear() % 100, //date.toLocaleDateString(locale, { year : '2-digit' }),
    // 1979, 2018
    YYYY: (date) => date.getFullYear(), //date.toLocaleDateString(locale, { year : 'numeric' }),

    // AM, PM
    A: (date) => (date.getHours() < 12 ? 'AM' : 'PM'),
    a: (date) => (date.getHours() < 12 ? 'am' : 'pm'),

    // 0, 1, ... 23
    H: (date) => date.getHours(),
    // 00, 01, ...
    HH: (date) =>
      date
        .getHours()
        .toString()
        .padStart(2, '0'),
    // 1, 2, ... 12
    h: (date) => date.getHours() % 12 || 12,
    // 01, 02, ...
    hh: (date) =>
      formats['h'](date)
        .toString()
        .padStart(2, '0'),
    // 1, 2, ... 24
    k: (date) => date.getHours() + 1,
    // 01, 02, ...
    kk: (date) =>
      formats['k'](date)
        .toString()
        .padStart(2, '0'),
    // Locale specific (0 -> 24 or 1 AM -> 12 PM)
    K: (date) => useIntlFormat('K', { hour: 'numeric' }, date),
    // Locale specific (00 -> 24 or 1 AM -> 12 PM)
    KK: (date) => useIntlFormat('KK', { hour: '2-digit' }, date),

    // 0, 1, ... 59
    m: (date) => date.getMinutes(), //date.toLocaleTimeString(locale, { minute : 'numeric' }),
    // 00, 01, ...
    mm: (date) =>
      formats['m'](date)
        .toString()
        .padStart(2, '0'),

    // 0, 1, ... 59
    s: (date) => date.getSeconds(), //date.toLocaleTimeString(locale, { second : 'numeric' }),
    // 00, 01, ...
    ss: (date) =>
      formats['s'](date)
        .toString()
        .padStart(2, '0'),

    // 0, 1, ... 9
    S: (date) =>
      date
        .getMilliseconds()
        .toString()
        .substr(0, 1),
    // 00, 01, ... 99
    SS: (date) =>
      date
        .getMilliseconds()
        .toString()
        .substr(0, 2)
        .padEnd(2, '0'),
    // 000, 001, ... 999
    SSS: (date) =>
      date
        .getMilliseconds()
        .toString()
        .substr(0, 3)
        .padEnd(3, '0'),

    z: (date) => useIntlFormat('z', { timeZoneName: 'short' }, date),
    zz: (date) => useIntlFormat('zz', { timeZoneName: 'long' }, date),

    LT: (date) => useIntlFormat('LT', { hour: '2-digit', minute: '2-digit' }, date),
    LTS: (date) => useIntlFormat('LTS', { hour: '2-digit', minute: '2-digit', second: '2-digit' }, date),
    L: (date) => useIntlFormat('L', { year: 'numeric', month: '2-digit', day: '2-digit' }, date),
    l: (date) => useIntlFormat('l', { year: 'numeric', month: 'numeric', day: 'numeric' }, date),
    LL: (date) => useIntlFormat('LL', { year: 'numeric', month: 'long', day: 'numeric' }, date),
    ll: (date) => useIntlFormat('ll', { year: 'numeric', month: 'short', day: 'numeric' }, date),
    LLL: (date) =>
      useIntlFormat(
        'LLL',
        {
          year: 'numeric',
          month: 'long',
          day: 'numeric',
          hour: 'numeric',
          minute: '2-digit'
        },
        date
      ),
    lll: (date) =>
      useIntlFormat(
        'lll',
        {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: 'numeric',
          minute: '2-digit'
        },
        date
      ),
    LLLL: (date) =>
      useIntlFormat(
        'LLLL',
        {
          year: 'numeric',
          month: 'long',
          day: 'numeric',
          hour: 'numeric',
          minute: '2-digit',
          weekday: 'long'
        },
        date
      ),
    llll: (date) =>
      useIntlFormat(
        'llll',
        {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: 'numeric',
          minute: '2-digit',
          weekday: 'short'
        },
        date
      )
  },
  // Want longest keys first, to not stop match at L of LTS etc.
  formatKeys = Object.keys(formats).sort((a, b) => b.length - a.length),
  formatRegexp = `^(?:${formatKeys.join('|')})`,
  // return empty object, meaning value cannot be processed to a valuable date part
  emptyFn = () => ({}),
  parsers = {
    YYYY: (str) => ({ year: parseInt(str) }),
    Y: (str) => ({ year: parseInt(str) }),
    YY: (str) => {
      const year = parseInt(str);
      return { year: year + (year > 1968 ? 1900 : 2000) };
    },
    MM: (str) => ({ month: parseInt(str) - 1 }),
    Mo: (str) => ({ month: parseInt(str) - 1 }),
    DD: (str) => ({ date: parseInt(str) }),
    M: (str) => ({ month: parseInt(str) - 1 }),
    D: (str) => ({ date: parseInt(str) }),
    Do: (str) => ({ date: parseInt(str) }),
    DDD: emptyFn,
    MMM: emptyFn,
    MMMM: emptyFn,
    DDDo: emptyFn,
    DDDD: emptyFn,
    d: emptyFn,
    do: emptyFn,
    dd: emptyFn,
    ddd: emptyFn,
    dddd: emptyFn,
    Q: emptyFn,
    Qo: emptyFn,
    W: emptyFn,
    Wo: emptyFn,
    WW: emptyFn,
    e: emptyFn,
    E: emptyFn,
    HH: (str) => ({ hours: parseInt(str) }),
    mm: (str) => ({ minutes: parseInt(str) }),
    H: (str) => ({ hours: parseInt(str) }),
    m: (str) => ({ minutes: parseInt(str) }),
    ss: (str) => ({ seconds: parseInt(str) }),
    s: (str) => ({ seconds: parseInt(str) }),
    S: (str) => ({ milliseconds: parseInt(str) }),
    SS: (str) => ({ milliseconds: parseInt(str) }),
    SSS: (str) => ({ milliseconds: parseInt(str) }),

    A: (str) => ({ amPm: str.toLowerCase() }),
    a: (str) => ({ amPm: str.toLowerCase() }),

    L: 'MM/DD/YYYY',
    LT: 'HH:mm A',

    // Can either be Z (=UTC, 0) or +-HH:MM
    Z: (str) => {
      if (!str) {
        return {};
      }

      let timeZone = 0;
      // If string being parsed is more "detailed" than the format specified we can have more chars left,
      // thus check the last (for example HH:mmZ with input HH:mm:ssZ -> ssZ)
      if (!str.endsWith('Z')) {
        const matches = timeZoneRegEx.exec(str);

        // If timezone regexp matches, sting has time zone offset like '+02:00'
        if (matches) {
          const sign = matches[1] === '+' ? 1 : -1,
            hours = parseInt(matches[2]) || 0,
            minutes = parseInt(matches[3]) || 0;

          timeZone = sign * (hours * 60 + minutes);
        }
        // otherwise we just return current time zone, because there's a Z key in the input
        else {
          timeZone = -1 * new Date().getTimezoneOffset();
        }
      }
      return { timeZone };
    }
  },
  parserKeys = Object.keys(parsers).sort((a, b) => b.length - a.length),
  parserRegexp = new RegExp(`(${parserKeys.join('|')})`),
  // Following regexp includes all formats that should be handled by Date class
  localeStrRegExp = new RegExp('(l|LL|ll|LLL|lll|LLLL|llll)'),
  //    ISODateRegExp             = new RegExp('YYYY-MM-DD[T ]HH:mm:ss(.s+)?Z'),

  // Some validConversions are negative to show that it's not an exact conversion, just an estimate.
  validConversions = {
    // The units below assume:
    // 30 days in a month, 91 days for a quarter and 365 for a year
    // 52 weeks per year, 4 per month, 13 per quarter
    year: {
      year: 1,
      quarter: 4,
      month: 12,
      week: 52,
      day: 365,
      hour: 24 * 365,
      minute: 1440 * 365,
      second: 86400 * 365,
      millisecond: 86400000 * 365
    },
    quarter: {
      year: 1 / 4,
      quarter: 1,
      month: 3,
      week: 4,
      day: 91,
      hour: 24 * 91,
      minute: 1440 * 91,
      second: 86400 * 91,
      millisecond: 86400000 * 91
    },
    month: {
      year: 1 / 12,
      quarter: 1 / 3,
      month: 1,
      week: 4,
      day: -30,
      hour: -24 * 30,
      minute: -1440 * 30,
      second: -86400 * 30,
      millisecond: -86400000 * 30
    },
    week: {
      year: -1 / 52,
      quarter: -1 / 13,
      month: -1 / 4,
      day: 7,
      hour: 168,
      minute: 10080,
      second: 604800,
      millisecond: 604800000
    },
    day: {
      year: -1 / 365,
      quarter: -1 / 91,
      month: -1 / 30,
      week: 1 / 7,
      hour: 24,
      minute: 1440,
      second: 86400,
      millisecond: 86400000
    },
    hour: {
      year: -1 / (365 * 24),
      quarter: -1 / (91 * 24),
      month: -1 / (30 * 24),
      week: 1 / 168,
      day: 1 / 24,
      minute: 60,
      second: 3600,
      millisecond: 3600000
    },
    minute: {
      year: -1 / (365 * 1440),
      quarter: -1 / (91 * 1440),
      month: -1 / (30 * 1440),
      week: 1 / 10080,
      day: 1 / 1440,
      hour: 1 / 60,
      second: 60,
      millisecond: 60000
    },
    second: {
      year: -1 / (365 * 86400),
      quarter: -1 / (91 * 86400),
      month: -1 / (30 * 86400),
      week: 1 / 604800,
      day: 1 / 86400,
      hour: 1 / 3600,
      minute: 1 / 60,
      millisecond: 1000
    },
    millisecond: {
      year: -1 / (365 * 86400000),
      quarter: -1 / (91 * 86400000),
      month: -1 / (30 * 86400000),
      week: 1 / 604800000,
      day: 1 / 86400000,
      hour: 1 / 3600000,
      minute: 1 / 60000,
      second: 1 / 1000
    }
  },
  normalizedUnits = {
    ms: 'millisecond',
    milliseconds: 'millisecond',
    s: 'second',
    seconds: 'second',
    m: 'minute',
    minutes: 'minute',
    h: 'hour',
    hours: 'hour',
    d: 'day',
    days: 'day',
    w: 'week',
    weeks: 'week',
    M: 'month',
    months: 'month',
    q: 'quarter',
    quarters: 'quarter',
    y: 'year',
    years: 'year'
  },
  withDecimalsDurationRegex = /^\s*([-+]?\d+(?:[.,]\d*)?|[-+]?(?:[.,]\d+))\s*([^\s]+)?/i,
  noDecimalsDurationRegex = /^\s*([-+]?\d+)(?![.,])\s*([^\s]+)?/i,
  canonicalUnitNames = ['millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'],
  deltaUnits = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'],
  // Used when creating a date from an object, to fill in any blanks
  dateProperties = ['milliseconds', 'seconds', 'minutes', 'hours', 'date', 'month', 'year'],
  // TODO: Should we provide special number parsing?
  parseNumber = (n) => {
    const result = parseFloat(n);
    return isNaN(result) ? null : result;
  },
  timeZoneRegEx = /([+-])(\d\d):*(\d\d)*$/,
  unitMagnitudes = {
    millisecond: 0,
    second: 1,
    minute: 2,
    hour: 3,
    day: 4,
    week: 5,
    month: 6,
    quarter: 7,
    year: 8
  };

/**
 * @module Common/helper/DateHelper
 */

/**
 * Helps with date manipulation, comparison, parsing, formatting etc.
 *
 * ## Parsing strings
 * Use DateHelper.parse() to parse strings into dates. It accepts a date string and a format specifier.
 * The format specifier is string built up using the following tokens:
 *
 * | Unit        | Token | Description                |
 * |-------------|-------|----------------------------|
 * | Year        | YYYY  | 2018                       |
 * |             | YY    | < 68 -> 2000, > 68 -> 1900 |
 * | Month       | MM    | 01 - 12                    |
 * | Date        | DD    | 01 - 31                    |
 * | Hour        | HH    | 00 - 23 or 1 - 12          |
 * | Minute      | mm    | 00 - 59                    |
 * | Second      | ss    | 00 - 59                    |
 * | Millisecond | S     | 0 - 9                      |
 * |             | SS    | 00 - 99                    |
 * |             | SSS   | 000 - 999                  |
 * | AM/PM       | A     | AM or PM                   |
 * |             | a     | am or pm                   |
 * | TimeZone    | Z     | Z for UTC or +-HH:mm       |
 * | Predefined  | L     | Long date, MM/DD/YYYY      |
 * |             | LT    | Long time, HH:mm A         |
 *
 * For example:
 * ```
 * DateHelper.parse('2018-11-06', 'YYYY-MM-DD');
 * DateHelper.parse('13:14', 'HH:mm');
 * DateHelper.parse('6/11/18', 'DD/MM/YY');
 * ```
 *
 * ## Formatting dates
 * Use DateHelper.format() to create a string from a date using a format specifier. The format specifier is similar to
 * that used when parsing strings. It can use the following tokens (input used for output below is
 * `new Date(2018,8,9,18,7,8,145)`):
 *
 * | Unit                  | Token | Description & output                  |
 * |-----------------------|-------|---------------------------------------|
 * | Year                  | YYYY  | 2018                                  |
 * |                       | YY    | 18                                    |
 * |                       | Y     | 2018                                  |
 * | Quarter               | Q     | 3                                     |
 * |                       | Qo    | 3rd                                   |
 * | Month                 | MMMM  | September                             |
 * |                       | MMM   | Sep                                   |
 * |                       | MM    | 09                                    |
 * |                       | Mo    | 9th                                   |
 * |                       | M     | 9                                     |
 * | Week (iso)            | WW    | 36 (2 digit)                          |
 * |                       | Wo    | 36th                                  |
 * |                       | W     | 36                                    |
 * | Date                  | DDDD  | Day of year, 3 digits                 |
 * |                       | DDDo  | Day of year, ordinal                  |
 * |                       | DDD   | Day of year                           |
 * |                       | DD    | 09                                    |
 * |                       | Do    | 9th                                   |
 * |                       | D     | 9                                     |
 * | Weekday               | dddd  | Sunday                                |
 * |                       | ddd   | Sun                                   |
 * |                       | dd    | Su                                    |
 * |                       | do    | 0th                                   |
 * |                       | d     | 0                                     |
 * | Hour                  | HH    | 18 (00 - 23)                          |
 * |                       | H     | 18 (0 - 23)                           |
 * |                       | hh    | 06 (00 - 12)                          |
 * |                       | h     | 6 (0 - 12)                            |
 * |                       | KK    | 19 (01 - 24)                          |
 * |                       | K     | 19 (1 - 24)                           |
 * |                       | kk    | 06 or 18, locale determines           |
 * |                       | k     | 6 or 18, locale determines            |
 * | Minute                | mm    | 07                                    |
 * |                       | m     | 7                                     |
 * | Second                | ss    | 08                                    |
 * |                       | s     | 8                                     |
 * | Millisecond           | S     | 1                                     |
 * |                       | SS    | 14                                    |
 * |                       | SSS   | 145                                   |
 * | AM/PM                 | A     | AM or PM                              |
 * |                       | a     | am or pm                              |
 * | Predefined            | LT    | H: 2-digit (2d), m: 2d                |
 * | (uses browser locale) | LTS   | H: 2d, m: 2d, s : 2d                  |
 * |                       | L     | Y: numeric (n), M : 2d, D : 2d        |
 * |                       | l     | Y: n, M : n, D : n                    |
 * |                       | LL    | Y: n, M : long (l), D : n             |
 * |                       | ll    | Y: n, M : short (s), D : n            |
 * |                       | LLL   | Y: n, M : l, D : n, H: n, m: 2d       |
 * |                       | lll   | Y: n, M : s, D : n, H: n, m: 2d       |
 * |                       | LLLL  | Y: n, M : l, D : n, H: n, m: 2d, d: l |
 * |                       | llll  | Y: n, M : s, D : n, H: n, m: 2d, d: s |
 *
 * For example:
 *
 * ```
 * DateHelper.format(new Date(2018,10,6), 'YYYY-MM-DD'); // 2018-11-06
 * DateHelper.format(new Date(2018,10,6), 'M/D/YY'); // 11/6/18
 * ```
 *
 * Arbitrary text can be embedded in the format string by wrapping it with {}:
 *
 * ```
 * DateHelper.format(new Date(2019, 7, 16), '{It is }dddd{, yay!}') -> It is Friday, yay!
 * ```
 *
 * ## Unit names
 * Many DateHelper functions (for example add, as, set) accepts a unit among their params. The following units are
 * available:
 *
 * | Unit        | Aliases                       |
 * |-------------|-------------------------------|
 * | millisecond | millisecond, milliseconds, ms |
 * | second      | second, seconds, s            |
 * | minute      | minute, minutes, m            |
 * | hour        | hour, hours, h                |
 * | day         | day, days, d                  |
 * | week        | week, weeks, w                |
 * | month       | month, months, M              |
 * | quarter     | quarter, quarters, q          |
 * | year        | year, years, y                |
 *
 * For example:
 * ```
 * DateHelper.add(date, 2, 'days');
 * DateHelper.as('hour', 7200, 'seconds');
 * ```
 */
class DateHelper extends Localizable() {
  //region Parse & format

  static buildParser(format) {
    // Split input format by regexp, which includes predefined patterns. Normally format would have some
    // splitters, like 'YYYY-MM-DD' or 'D/M YYYY' so output will contain matched patterns as well as splitters
    // which would serve as anchors. E.g. provided format is 'D/M!YYYY' and input is `11/6!2019` algorithm would work like:
    // 1. split format by regexp                // ['', 'D', '/', 'M', '!', 'YYYY', '']
    // 2. find splitters                        // ['/', '!']
    // 3. split input by seps, step by step     // ['11', ['6', ['2019']]]
    //
    // Inputs like 'YYYYY' (YYYY + Y) are kinda invalid, need to figure smth when
    // we encounter them.
    const parts = format.split(parserRegexp),
      parser = [];

    // if length of the parts array is 1 - there are no regexps in the input string. thus - no parsers
    // do same if there are patterns matching locale strings (l, ll, LLLL etc.)
    // returning empty array to use new Date() as parser
    if (parts.length === 1 || localeStrRegExp.test(format)) {
      return [];
    } else {
      parts.reduce((prev, curr, index, array) => {
        // ignore first and last empty string
        if (index !== 0 || curr !== '') {
          // if current element matches parser regexp store it as a parser
          if (parserRegexp.test(curr)) {
            const localeParsers = (this.L('parsers') !== 'parsers' && this.L('parsers')) || {},
              fn = localeParsers[curr] || parsers[curr];

            // Z should be last element in the string that matches regexp. Last array element is always either
            // an empty string (if format ends with Z) or splitter (everything that doesn't match regexp after Z)
            // If there is a pattern after Z, then Z index will be lower than length - 2
            if (curr === 'Z' && index < array.length - 2) {
              throw new Error(`Invalid format ${format} TimeZone (Z) must be last token`);
            }

            // If fn is a string, we found an alias (L, LLL, l etc.).
            // Need to build parsers from mapped format and merge with existing
            if (typeof fn === 'string') {
              // we are going to merge nested parsers with current, some cleanup required:
              // 1. last element is no longer last
              // 2. need to pass last parser to the next step
              const nestedParsers = DateHelper.buildParser(fn),
                lastItem = nestedParsers.pop();
              delete lastItem.last;

              // elevate nested parsers
              parser.push(...nestedParsers);

              prev = lastItem;
            } else {
              prev.pattern = curr;
              prev.fn = parsers[curr];
            }
          }
          // if it doesn't match - we've found a splitter
          else {
            prev.splitter = curr;
            parser.push(prev);
            prev = {};
          }
        } else if (prev.hasOwnProperty('pattern')) {
          parser.push(prev);
        }
        return prev;
      }, {});
    }

    parser[parser.length - 1].last = true;

    return parser;
  }

  /**
   * Returns a date created from the supplied string using the specified format. Will try to create even if format
   * is left out, by first using the default format (YYYY-MM-DDTHH:mm:ssZ) and then using `new Date(dateString)`.
   * Supported tokens:
   *
   * | Unit        | Token | Description                |
   * |-------------|-------|----------------------------|
   * | Year        | YYYY  | 2018                       |
   * |             | YY    | < 68 -> 2000, > 68 -> 1900 |
   * | Month       | MM    | 01 - 12                    |
   * | Date        | DD    | 01 - 31                    |
   * | Hour        | HH    | 00 - 23 or 1 - 12          |
   * | Minute      | mm    | 00 - 59                    |
   * | Second      | ss    | 00 - 59                    |
   * | Millisecond | S     | 0 - 9                      |
   * |             | SS    | 00 - 99                    |
   * |             | SSS   | 000 - 999                  |
   * | AM/PM       | A     | AM or PM                   |
   * |             | a     | am or pm                   |
   * | TimeZone    | Z     | Z for UTC or +-HH:mm       |
   * | Predefined  | L     | Long date, MM/DD/YYYY      |
   * |             | LT    | Long time, HH:mm A         |
   *
   * Predefined formats and functions used to parse tokens can be localized, see for example the swedish locale SvSE.js
   *
   * @param {String} dateString Date string
   * @param {String} format Date format
   * @returns {Date}
   * @category Parse & format
   */
  static parse(dateString, format = defaultFormat) {
    if (!dateString) {
      return null;
    }

    if (dateString instanceof Date) {
      return dateString;
    }

    // // For ISO 8601 native is faster, but not very forgiving
    // if (format === defaultFormat) {
    //     const dt = new Date(dateString);
    //     if (!isNaN(dt)) {
    //         return dt;
    //     }
    // }

    let config = { year: 0, month: 0, date: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 },
      parser = parserCache[format],
      result;

    if (!parser) {
      parser = parserCache[format] = DateHelper.buildParser(format);
    }

    // Each parser knows its pattern and splitter. It looks for splitter in the
    // input string, takes first substring and tries to process it. Remaining string
    // is passed to the next parser.
    parser.reduce((dateString, parser) => {
      if (parser.last) {
        Object.assign(config, parser.fn(dateString));
      } else {
        let splitAt;

        // ISO 8601 says that T symbol can be replaced with a space
        if (parser.splitter === 'T' && dateString.indexOf('T') === -1) {
          splitAt = dateString.indexOf(' ');
        } else {
          splitAt = dateString.indexOf(parser.splitter);
        }

        let part, rest;

        // If splitter is not found in the current string we may be dealing with
        // 1. partial input - in that case we just feed all string to current parser and move on
        // 2. time zone (ssZ - splitter is empty string), see comment below
        if (splitAt === -1 || parser.splitter === '') {
          // NOTE: parantheses are required here as + and - signs hold valuable information
          // with parantheses we get array like ['00','+','01:00'], omitting them we won't get
          // regexp match in result, loosing information
          let chunks = dateString.split(/([Z\-+])/);

          // If splitter is not found in the string, we may be dealing with string that contains info about TZ.
          // For instance, if format contains Z as last arg which is not separated (normally it is not indeed),
          // like `YYYY-MM-DD HH:mm:ssZ`, then second to last parser will have string that it cannot just parse, like
          // '2010-01-01 10:00:00'        -> '00'
          // '2010-01-01 10:00:00Z'       -> '00Z'
          // '2010-01-01 10:00:00-01'     -> '00-01'
          // '2010-01-01 10:00:00+01:30'  -> '00+01:30'
          // this cannot be processed by date parsers, so we need to process that additionally. So we
          // split string by symbols that can be found around timezone info: Z,-,+
          if (chunks.length === 1) {
            part = dateString;
            rest = '';
          } else {
            part = chunks[0];
            rest = `${chunks[1]}${chunks[2]}`;
          }
        } else {
          part = dateString.substring(0, splitAt) || dateString;
          rest = dateString.substring(splitAt + parser.splitter.length);
        }

        parser.fn && Object.assign(config, parser.fn(part));

        return rest;
      }
    }, dateString);

    const date = this.create(config);
    if (date) {
      result = date;
    } else {
      // Last resort, try if native passing can do it
      result = new Date(dateString);
    }

    return result;
  }

  /**
   * Creates a date from a date definition object. The object can have the following properties:
   * - year
   * - month
   * - date (day in month)
   * - hours
   * - minutes
   * - seconds
   * - milliseconds
   * - amPm : 'am' or 'pm', implies 12 hour clock
   * - timeZone : offset from UTC in minutes
   * @param {Object} definition
   * @returns {Date}
   * @category Parse & format
   */
  static create(definition) {
    // Shallow clone to not alter input
    const def = Object.assign({}, definition);

    // Not much validation yet, only considered invalid if all properties are 0
    let invalid = true,
      useUTC = false;

    // Fill in blanks and replace any NaN with 0
    dateProperties.forEach((property) => {
      if (!(property in def) || isNaN(def[property])) {
        def[property] = 0;
      }

      if (def[property] > 0) invalid = false;
    });

    if (def.amPm === 'pm') {
      def.hours = (def.hours % 12) + 12;
    }

    if ('timeZone' in def) {
      useUTC = true;

      def.minutes -= def.timeZone;
    }

    if (invalid) {
      return null;
    }

    const args = [def.year, def.month, def.date, def.hours, def.minutes, def.seconds, def.milliseconds];

    return useUTC ? new Date(Date.UTC(...args)) : new Date(...args);
  }

  /**
   * Converts a date to string with the specified format. Formats heavily inspired by https://momentjs.com.
   * Available formats (input used for output below is `new Date(2018,8,9,18,7,8,145)`):
   *
   * | Unit                  | Token | Description & output                  |
   * |-----------------------|-------|---------------------------------------|
   * | Year                  | YYYY  | 2018                                  |
   * |                       | YY    | 18                                    |
   * |                       | Y     | 2018                                  |
   * | Quarter               | Q     | 3                                     |
   * |                       | Qo    | 3rd                                   |
   * | Month                 | MMMM  | September                             |
   * |                       | MMM   | Sep                                   |
   * |                       | MM    | 09                                    |
   * |                       | Mo    | 9th                                   |
   * |                       | M     | 9                                     |
   * | Week (iso)            | WW    | 36 (2 digit)                          |
   * |                       | Wo    | 36th                                  |
   * |                       | W     | 36                                    |
   * | Date                  | DDDD  | Day of year, 3 digits                 |
   * |                       | DDDo  | Day of year, ordinal                  |
   * |                       | DDD   | Day of year                           |
   * |                       | DD    | 09                                    |
   * |                       | Do    | 9th                                   |
   * |                       | D     | 9                                     |
   * | Weekday               | dddd  | Sunday                                |
   * |                       | ddd   | Sun                                   |
   * |                       | dd    | Su                                    |
   * |                       | do    | 0th                                   |
   * |                       | d     | 0                                     |
   * | Hour                  | HH    | 18 (00 - 23)                          |
   * |                       | H     | 18 (0 - 23)                           |
   * |                       | hh    | 06 (00 - 12)                          |
   * |                       | h     | 6 (0 - 12)                            |
   * |                       | KK    | 19 (01 - 24)                          |
   * |                       | K     | 19 (1 - 24)                           |
   * |                       | kk    | 06 or 18, locale determines           |
   * |                       | k     | 6 or 18, locale determines            |
   * | Minute                | mm    | 07                                    |
   * |                       | m     | 7                                     |
   * | Second                | ss    | 08                                    |
   * |                       | s     | 8                                     |
   * | Millisecond           | S     | 1                                     |
   * |                       | SS    | 14                                    |
   * |                       | SSS   | 145                                   |
   * | AM/PM                 | A     | AM or PM                              |
   * |                       | a     | am or pm                              |
   * | Predefined            | LT    | H: 2-digit (2d), m: 2d                |
   * | (uses browser locale) | LTS   | H: 2d, m: 2d, s : 2d                  |
   * |                       | L     | Y: numeric (n), M : 2d, D : 2d        |
   * |                       | l     | Y: n, M : n, D : n                    |
   * |                       | LL    | Y: n, M : long (l), D : n             |
   * |                       | ll    | Y: n, M : short (s), D : n            |
   * |                       | LLL   | Y: n, M : l, D : n, H: n, m: 2d       |
   * |                       | lll   | Y: n, M : s, D : n, H: n, m: 2d       |
   * |                       | LLLL  | Y: n, M : l, D : n, H: n, m: 2d, d: l |
   * |                       | llll  | Y: n, M : s, D : n, H: n, m: 2d, d: s |
   *
   * Some examples:
   *
   * ```
   * DateHelper.format(new Date(2019, 7, 16), 'dddd') -> Friday
   * DateHelper.format(new Date(2019, 7, 16, 14, 27), 'HH:mm') --> 14:27
   * DateHelper.format(new Date(2019, 7, 16, 14, 27), 'L HH') --> 2019-07-16 14
   * ```
   *
   * Arbitrary text can be embedded in the format string by wrapping it with {}:
   *
   * ```
   * DateHelper.format(new Date(2019, 7, 16), '{It is }dddd{, yay!}') -> It is Friday, yay!
   * ```
   *
   * @param {Date} date Date
   * @param {String} format Desired format
   * @returns {String} Formatted string
   * @category Parse & format
   */
  static format(date, format = defaultFormat) {
    if (!date) {
      return null;
    }

    let formatter = formatCache[format],
      output = '';

    if (!formatter) {
      formatter = formatCache[format] = [];

      // Build formatter array with the steps needed to format the date
      for (let i = 0; i < format.length; i++) {
        // Matches a predefined format?
        const formatMatch = format.substr(i).match(formatRegexp),
          predefined = formatMatch && formatMatch[0];

        if (predefined) {
          const localeFormats = (this.L('formats') !== 'formats' && this.L('formats')) || {},
            fn = localeFormats[predefined] || formats[predefined];
          formatter.push(fn);
          i += predefined.length - 1;
        }
        // Start of text block? Append it
        else if (format[i] === '{') {
          // Find closing brace
          const index = format.indexOf('}', i + 1);

          // No closing brace, grab rest of string
          if (index === -1) {
            formatter.push(format.substr(i + 1));
            i = format.length;
          }
          // Closing brace found
          else {
            formatter.push(format.substring(i + 1, index));
            // Carry on after closing brace
            i = index;
          }
        }
        // Otherwise append to output (for example - / : etc)
        else {
          formatter.push(format[i]);
        }
      }
    }

    formatter.forEach((step) => {
      if (typeof step === 'string') {
        output += step;
      } else {
        output += step(date);
      }
    });

    // MS inserts a Left-to-right control char between localized date parts, remove it to have the expected string
    // output. Otherwise comparision with typed strings will fail
    if (BrowserHelper.isEdge || BrowserHelper.isIE11) {
      output = output.replace(/\u200E/g, '');
    }

    return output;
  }

  /**
   * Converts the specified amount of desired unit into milliseconds. Can be called by only specifying a unit as the
   * first argument, it then uses amount = 1. For example: asMilliseconds('hour') == asMilliseconds(1, 'hour')
   * @param {Number/String} amount Amount, what of is decided by specifying unit (also takes a unit which implies an amount of 1)
   * @param {String} unit Time unit (s, hour, months etc.)
   * @returns {Number}
   * @category Parse & format
   */
  static asMilliseconds(amount, unit = null) {
    if (typeof amount === 'string') {
      unit = amount;
      amount = 1;
    }

    return this.as('millisecond', amount, unit);
  }

  /**
   * Converts a millisecond time delta to a human readable form. For example `1000 * 60 * 60 * 50`
   * milliseconds would be rendered as "2 days, 2 hours"
   * @param {Number} delta The millisecond delta value.
   * @param {Boolean} [abbrev] Pass `true` to use abbreviated unit names, eg "2d, 2h" for the above example.
   */
  static formatDelta(delta, abbrev = false) {
    const result = [],
      getUnit = abbrev ? this.getShortNameOfUnit : this.getLocalizedNameOfUnit,
      sep = abbrev ? '' : ' ';

    // Loop downwards through the magnitude of units from year -> ms
    for (const unitName of deltaUnits) {
      const d = Math.floor(this.as(unitName, delta));

      // If there's a non-zero integer quantity of this unit, add it to result
      // and subtract from the delta, then go round to next unit down.
      if (d) {
        result.push(`${d}${sep}${getUnit.call(this, unitName, d > 1)}`);
        delta -= this.as('ms', d, unitName);
      }
      if (!delta) {
        break;
      }
    }

    return result.join(', ');
  }

  /**
   * Converts the specified amount of one unit (fromUnit) into an amount of another unit (toUnit)
   * @param toUnit
   * @param amount
   * @param fromUnit
   * @returns {Number}
   * @category Parse & format
   */
  static as(toUnit, amount, fromUnit = 'ms') {
    if (toUnit === fromUnit) return amount;

    toUnit = this.normalizeUnit(toUnit);
    fromUnit = this.normalizeUnit(fromUnit);

    // validConversions[][] can be negative to signal that conversion is not exact, ignore sign here
    if (unitMagnitudes[fromUnit] > unitMagnitudes[toUnit]) {
      return amount * Math.abs(validConversions[fromUnit][toUnit]);
    } else {
      return amount / Math.abs(validConversions[toUnit][fromUnit]);
    }
  }

  formatContainsHourInfo(format) {
    return format.match(/[Hhk]/);
  }

  /**
   * Returns true for 24 hour format.
   * @param {String} format Date format
   * @returns {Boolean}
   * @category Parse & format
   */
  static is24HourFormat(format) {
    return this.format(new Date(1970, 0, 0, 13, 0, 0), format).includes('13');
  }

  //endregion

  //region Manipulate

  /**
   * Add days, hours etc. to a date. Always clones the date, original will be left unaffected.
   * @param {Date} date Original date
   * @param {Number} amount Amount of days, hours etc
   * @param {String} unit Unit for amount
   * @returns {Date} New calculated date
   * @category Manipulate
   */
  static add(date, amount, unit = 'ms') {
    const me = this;

    let d;

    if (typeof date === 'string') {
      d = me.parse(date);
    } else {
      d = new Date(date.getTime());
    }

    if (!unit || amount === 0) return d;

    unit = DateHelper.normalizeUnit(unit);

    switch (unit) {
      case 'millisecond':
        d = new Date(d.getTime() + amount);
        break;
      case 'second':
        d = new Date(d.getTime() + amount * 1000);
        break;
      case 'minute':
        d = new Date(d.getTime() + amount * 60000);
        break;
      case 'hour':
        d = new Date(d.getTime() + amount * 3600000);
        break;
      case 'day':
        // Integer value added, do calendar calculation to correctly handle DST etc.
        if (amount % 1 === 0) {
          d.setDate(d.getDate() + amount);
        }
        // No browsers support fractional values for dates any longer, do time based calculation
        else {
          d = new Date(d.getTime() + amount * 86400000);
        }

        if (d.getHours() === 23 && d.getHours() === 0) {
          d = me.add(d, 1, 'hour');
        }
        break;
      case 'week':
        d.setDate(d.getDate() + amount * 7);
        break;
      case 'month':
        let day = d.getDate();
        if (day > 28) {
          day = Math.min(day, me.getLastDateOfMonth(me.add(me.getFirstDateOfMonth(d), amount, 'month')).getDate());
        }
        d.setDate(day);
        d.setMonth(d.getMonth() + amount);
        break;
      case 'quarter':
        d = me.add(d, amount * 3, 'month');
        break;
      case 'year':
        d.setFullYear(d.getFullYear() + amount);
        break;
    }
    return d;
  }

  /**
   * Calculates the difference between two dates, in the specified unit.
   * @param {Date} start First date
   * @param {Date} end Second date
   * @param {String} unit Unit to calculate difference in
   * @param {Boolean} fractional Specify false to round result
   * @returns {Number} Difference in the specified unit
   * @category Manipulate
   */
  static diff(start, end, unit = 'ms', fractional = true) {
    unit = DateHelper.normalizeUnit(unit);

    if (!start || !end) return 0;

    let amount;

    switch (unit) {
      case 'year':
        amount = this.diff(start, end, 'month') / 12;
        break;

      case 'quarter':
        amount = this.diff(start, end, 'month') / 3;
        break;

      case 'month':
        amount = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
        break;

      case 'week':
        amount = this.diff(start, end, 'day') / 7;
        break;

      case 'day':
        const dstDiff = start.getTimezoneOffset() - end.getTimezoneOffset();
        amount = (end - start + dstDiff * 60 * 1000) / 86400000;
        break;

      case 'hour':
        amount = (end - start) / 3600000;
        break;

      case 'minute':
        amount = (end - start) / 60000;
        break;

      case 'second':
        amount = (end - start) / 1000;
        break;

      case 'millisecond':
        amount = end - start;
        break;
    }

    return fractional ? amount : Math.round(amount);
  }

  /**
   * Sets the date to the start of the specified unit, by default returning a clone of the date instead of changing it
   * inplace.
   * @param {Date} date Original date
   * @param {String} unit Start of this unit, 'day', 'month' etc.
   * @param {Boolean} clone Manipulate a copy of the date
   * @returns {Date} Manipulated date
   * @category Manipulate
   */
  static startOf(date, unit = 'day', clone = true) {
    if (!date) {
      return null;
    }

    unit = this.normalizeUnit(unit);

    if (clone) date = this.clone(date);

    const toSet = {},
      index = canonicalUnitNames.indexOf(unit);

    for (let i = 0; i < index; i++) {
      const currentUnit = canonicalUnitNames[i];
      // Week and quarter are not part of the date
      if (currentUnit !== 'quarter' && currentUnit !== 'week') {
        toSet[currentUnit] = currentUnit === 'day' ? 1 : 0; // day is 1 based
      }
    }

    // Special handling of quarter and week
    if (unit === 'quarter') {
      toSet.month = (this.get(date, 'quarter') - 1) * 3;
    } else if (unit === 'week') {
      const delta = date.getDay() - this.weekStartDay;
      toSet.day = date.getDate() - delta;
    }

    return this.set(date, toSet);
  }

  /**
   * Creates a clone of the specified date
   * @param {Date} date Original date
   * @returns {Date} Cloned date
   * @category Manipulate
   */
  static clone(date) {
    return new Date(date.getTime());
  }

  /**
   * Removes time from a date (same as calling #startOf(date, 'day'))
   * @param {Date} date Date to remove time from
   * @param {Boolean} clone Manipulate a copy of the date
   * @returns {Date} Manipulated date
   * @category Manipulate
   */
  static clearTime(date, clone = true) {
    return DateHelper.startOf(date, 'day', clone);
  }

  /**
   * Sets a part of a date (in place)
   * @param {Date} date Date to manipulate
   * @param {String|Object} unit Part of date to set, for example 'minute'. Or an object like { second: 1, minute: 1 }
   * @param {Number} amount Value to set
   * @returns {Date} Modified date
   * @category Manipulate
   */
  static set(date, unit, amount) {
    if (!unit) {
      return date;
    }

    if (typeof unit === 'string') {
      switch (this.normalizeUnit(unit)) {
        case 'millisecond':
          // Setting value to 0 when it is 0 at DST crossing messes it up
          if (amount !== 0 || date.getMilliseconds() > 0) {
            date.setMilliseconds(amount);
          }
          break;
        case 'second':
          // Setting value to 0 when it is 0 at DST crossing messes it up
          if (amount !== 0 || date.getSeconds() > 0) {
            date.setSeconds(amount);
          }
          break;
        case 'minute':
          // Setting value to 0 when it is 0 at DST crossing messes it up
          if (amount !== 0 || date.getMinutes() > 0) {
            date.setMinutes(amount);
          }
          break;
        case 'hour':
          date.setHours(amount);
          break;
        case 'day':
        case 'date':
          date.setDate(amount);
          break;
        case 'week':
          throw new Error('week not implemented');
        case 'month':
          date.setMonth(amount);
          break;
        case 'quarter':
          // Setting quarter = first day of first month of that quarter
          date.setDate(1);
          date.setMonth((amount - 1) * 3);
          break;
        case 'year':
          date.setFullYear(amount);
          break;
      }
    } else {
      Object.entries(unit)
        // Make sure smallest unit goes first, to not change month before changing day
        .sort((a, b) => canonicalUnitNames.indexOf(a[0]) - canonicalUnitNames.indexOf(b[0]))
        .forEach(([unit, amount]) => {
          this.set(date, unit, amount);
        });
    }

    return date;
  }

  /**
   * Constrains the date within a min and a max date
   * @param {Date} date The date to constrain
   * @param {Date} min Min date
   * @param {Date} max Max date
   * @return {Date} The constrained date
   * @category Manipulate
   */
  static constrain(date, min, max) {
    return this.min(this.max(date, min), max);
  }

  /**
   * Returns time only (same as calling new Date(1970, 0, 1, hours, minutes, seconds))
   * @param {Number} hours Hours value
   * @param {Number} minutes Minutes value
   * @param {Number} seconds Seconds value
   * @returns {Date} Date value for input hours, minutes, seconds parameters
   * @category Manipulate
   */
  static getTime(hours, minutes = 0, seconds = 0) {
    return new Date(1970, 0, 1, hours, minutes, seconds);
  }

  //endregion

  //region Comparison

  static isDST(date) {
    // from https://stackoverflow.com/questions/11887934/how-to-check-if-the-dst-daylight-saving-time-is-in-effect-and-if-it-is-whats
    const jan = new Date(date.getFullYear(), 0, 1),
      jul = new Date(date.getFullYear(), 6, 1);
    return date.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
  }

  /**
   * Determines if a date precedes another.
   * @param first First date
   * @param second Second date
   * @returns {Boolean} true if first precedes second, otherwise false
   * @category Comparison
   */
  static isBefore(first, second) {
    return first < second;
  }

  /**
   * Determines if a date succeeds another.
   * @param first First date
   * @param second Second date
   * @returns {Boolean} true if first succeeds second, otherwise false
   * @category Comparison
   */
  static isAfter(first, second) {
    return first > second;
  }

  /**
   * Checks if two dates are equal.
   * @param first First date
   * @param second Second date
   * @param unit If not given, the comparison will be done up to a millisecond
   * @returns {Boolean} true if the dates are equal
   * @category Comparison
   */
  static isEqual(first, second, unit = null) {
    if (unit === null) return first - second === 0;
    return this.startOf(first, unit) - this.startOf(second, unit) === 0;
  }

  /**
   * Compares two dates using the specified precision
   * @param {Date} first
   * @param {Date} second
   * @param {String} unit
   * @returns {Number} 0 = equal, -1 first before second, 1 first after second
   * @category Comparison
   */
  static compare(first, second, unit = null) {
    const DH = this;

    // Unit specified, cut the rest out
    if (unit) {
      first = DH.startOf(first, unit);
      second = DH.startOf(second, unit);
    }

    // Comparision on ms level
    if (DH.isBefore(first, second)) return -1;
    if (DH.isAfter(first, second)) return 1;
    return 0;
  }

  /**
   * Checks if date is the start of specified unit
   * @param {Date} date
   * @param {String} unit
   * @returns {Boolean}
   * @category Comparison
   */
  static isStartOf(date, unit) {
    return this.isEqual(date, this.startOf(date, unit));
  }

  /**
   * Checks if this date is >= start and < end.
   * @param {Date} date The source date
   * @param {Date} start Start date
   * @param {Date} end End date
   * @return {Boolean} true if this date falls on or between the given start and end dates.
   * @category Comparison
   */
  static betweenLesser(date, start, end) {
    //return start <= date && date < end;
    return start.getTime() <= date.getTime() && date.getTime() < end.getTime();
  }

  /**
   * Checks if this date is >= start and <= end.
   * @param {Date} date The source date
   * @param {Date} start Start date
   * @param {Date} end End date
   * @return {Boolean} true if this date falls on or between the given start and end dates.
   * @category Comparison
   */
  static betweenLesserEqual(date, start, end) {
    return start.getTime() <= date.getTime() && date.getTime() <= end.getTime();
  }

  /**
   * Returns true if dates intersect
   * @param {Date} date1Start
   * @param {Date} date1End
   * @param {Date} date2Start
   * @param {Date} date2End
   * @return {Boolean} Returns true if dates intersect
   * @category Comparison
   */
  static intersectSpans(date1Start, date1End, date2Start, date2End) {
    return this.betweenLesser(date1Start, date2Start, date2End) || this.betweenLesser(date2Start, date1Start, date1End);
  }

  /**
   * Returns 1 if first param is a greater unit than second param, -1 if the opposite is true or 0 if they're equal
   * @param {String} unit1 The 1st unit
   * @param {String} unit2 The 2nd unit
   * @category Comparison
   */
  static compareUnits(unit1, unit2) {
    const index1 = canonicalUnitNames.indexOf(unit1),
      index2 = canonicalUnitNames.indexOf(unit2);

    return Math.sign(index1 - index2);
  }

  /**
   * Returns true if the first time span completely 'covers' the second time span.
   * @example
   * DateHelper.timeSpanContains(new Date(2010, 1, 2), new Date(2010, 1, 5), new Date(2010, 1, 3), new Date(2010, 1, 4)) ==> true
   * DateHelper.timeSpanContains(new Date(2010, 1, 2), new Date(2010, 1, 5), new Date(2010, 1, 3), new Date(2010, 1, 6)) ==> false
   * @param {Date} spanStart The start date for initial time span
   * @param {Date} spanEnd The end date for initial time span
   * @param {Date} otherSpanStart The start date for the 2nd time span
   * @param {Date} otherSpanEnd The end date for the 2nd time span
   * @return {Boolean}
   * @category Comparison
   */
  static timeSpanContains(spanStart, spanEnd, otherSpanStart, otherSpanEnd) {
    return otherSpanStart - spanStart >= 0 && spanEnd - otherSpanEnd >= 0;
  }

  //endregion

  //region Query

  /**
   * Get the first day of week, 0-6 (Sunday-Saturday). This is determined by the used locale.
   * @readonly
   */
  static get weekStartDay() {
    // Try locale first
    let weekStartDay = this.L('weekStartDay');
    if (weekStartDay !== 'weekStartDay') {
      return weekStartDay;
    }

    // Default to 0, should not need to happen in real world scenarios when a locale is always loaded
    return 0;
  }

  /**
   * Get the specified part of a date
   * @param {Date} date
   * @param {String} unit Part of date, hour, minute etc.
   * @category Query
   */
  static get(date, unit) {
    switch (this.normalizeUnit(unit)) {
      case 'millisecond':
        return date.getMilliseconds();
      case 'second':
        return date.getSeconds();
      case 'minute':
        return date.getMinutes();
      case 'hour':
        return date.getHours();
      case 'date':
      case 'day': // Scheduler has a lot of calculations expecting this to work
        return date.getDate();
      case 'week':
        return formats.W(date);
      case 'month':
        return date.getMonth();
      case 'quarter':
        return Math.floor(date.getMonth() / 3) + 1;
      case 'year':
        return date.getFullYear();
    }

    return null;
  }

  /**
   * Get number of days in the current month for the supplied date
   * @param {Date} date Date which month should be checked
   * @returns {Number} Days in month
   * @category Query
   */
  static daysInMonth(date) {
    const d = this.clone(date);
    d.setDate(1);
    d.setMonth(date.getMonth() + 1);
    d.setDate(0);
    return d.getDate();
  }

  /**
   * Get the first date of the month for the supplied date
   * @param {Date} date
   * @returns {Date}
   * @category Query
   */
  static getFirstDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth(), 1);
  }

  /**
   * Get the last date of the month for the supplied date
   * @param {Date} date
   * @returns {Date}
   * @category Query
   */
  static getLastDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth() + 1, 0);
  }

  /**
   * Get the earliest of two dates
   * @param {Date} first
   * @param {Date} second
   * @returns {Date} Earliest date
   * @category Query
   */
  static min(first, second) {
    return first.getTime() < second.getTime() ? first : second;
  }

  /**
   * Get the latest of two dates
   * @param {Date} first
   * @param {Date} second
   * @returns {Date} Latest date
   * @category Query
   */
  static max(first, second) {
    return first.getTime() > second.getTime() ? first : second;
  }

  /**
   * Get an incremented date. Incrementation based on specified unit and optional amount
   * @param {Date} date
   * @param {String} unit
   * @param {Number} [increment]
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date}
   * @category Query
   */
  static getNext(date, unit, increment = 1, weekStartDay = this.weekStartDay) {
    const me = this;

    if (unit === 'week') {
      let dt = me.clone(date),
        day = dt.getDay();
      dt = me.startOf(dt, 'day');
      dt = me.add(dt, weekStartDay - day + 7 * (increment - (weekStartDay <= day ? 0 : 1)), 'day');

      // For south american timezones, midnight does not exist on DST transitions, adjust...
      if (dt.getDay() !== weekStartDay) me.add(dt, 1, 'hour');

      return dt;
    }

    return me.startOf(me.add(date, increment, unit), unit);
  }

  /**
   * Get the start of the next day
   * @param {Date} date
   * @param {Boolean} clone
   * @param {Boolean} noNeedToClearTime
   * @returns {Date}
   * @category Query
   */
  static getStartOfNextDay(date, clone, noNeedToClearTime) {
    let nextDay = DateHelper.add(noNeedToClearTime ? date : DateHelper.clearTime(date, clone), 1, 'day');

    // DST case
    if (nextDay.getDate() == date.getDate()) {
      let offsetNextDay = DateHelper.add(DateHelper.clearTime(date, clone), 'day', 2).getTimezoneOffset(),
        offsetDate = date.getTimezoneOffset();

      nextDay = DateHelper.add(nextDay, offsetDate - offsetNextDay, 'minute');
    }

    return nextDay;
  }

  /**
   * Get the end of previous day
   * @param {Date} date
   * @param {Boolean} noNeedToClearTime
   * @returns {Date}
   * @category Query
   */
  static getEndOfPreviousDay(date, noNeedToClearTime) {
    let dateOnly = noNeedToClearTime ? date : DateHelper.clearTime(date, true);

    // dates are different
    if (dateOnly - date) {
      return dateOnly;
    } else {
      return this.add(dateOnly, -1, 'day');
    }
  }

  //endregion

  //region Unit helpers

  /**
   * Turns (10, 'day') into '10 days' etc.
   * @param {Number} count Amount of unit
   * @param {String} unit Unit, will be normalizes (days, d -> day etc.)
   * @returns {String}
   * @category Unit helpers
   */
  static formatCount(count, unit) {
    unit = DateHelper.normalizeUnit(unit);
    if (count !== 1) unit += 's';
    return count + ' ' + unit;
  }

  /**
   * Get the ratio between two units ( year, month -> 1/12 )
   * @param {String} baseUnit
   * @param {String} unit
   * @param {Boolean} acceptEstimate If true, process negative values of validConversions. Defaults to false.
   * @returns {Number} Ratio
   * @category Unit helpers
   */
  static getUnitToBaseUnitRatio(baseUnit, unit, acceptEstimate = false) {
    baseUnit = DateHelper.normalizeUnit(baseUnit);
    unit = DateHelper.normalizeUnit(unit);

    if (baseUnit === unit) return 1;

    // Some validConversions have negative sign to signal that it is not an exact conversion.
    // Ignore those here unless acceptEstimate is provided.
    if (
      validConversions[baseUnit] &&
      validConversions[baseUnit][unit] &&
      (acceptEstimate || validConversions[baseUnit][unit] > 0)
    ) {
      return 1 / DateHelper.as(unit, 1, baseUnit);
    }

    if (
      validConversions[unit] &&
      validConversions[unit][baseUnit] &&
      (acceptEstimate || validConversions[unit][baseUnit] > 0)
    ) {
      return DateHelper.as(baseUnit, 1, unit);
    }

    return -1;
  }

  /**
   * Get unit suitable to use in calculations (?)
   * @param unit
   * @returns {*}
   * @category Unit helpers
   */
  static getMeasuringUnit(unit) {
    if (unit === 'week') return 'day';
    return unit;
  }

  /**
   * Returns a localized abbreviated form of the name of the duration unit.
   * For example in the `EN` locale, for `"qrt"` it will return `"q"`.
   * @param {String} unit Duration unit
   * @return {String}
   * @category Unit helpers
   */
  static getShortNameOfUnit(unit) {
    const me = this;

    // Convert abbreviations to the canonical name.
    // See locale file and the applyLocale method below.
    unit = me.parseTimeUnit(unit);

    // unitLookup is keyed by eg 'DAY', 'day', 'MILLISECOND', 'millisecond' etc
    return me.unitLookup[unit].abbrev;
  }

  /**
   * Returns a localized full name of the duration unit.
   * For for example in the `EN` locale, for `"d"` it will return either
   * `"day"` or `"days"`, depending from the `plural` argument
   * @static
   * @param {String} unit Time unit
   * @param {Boolean} plural Whether to return a plural name or singular
   * @return {String}
   * @category Unit helpers
   */
  static getLocalizedNameOfUnit(unit, plural) {
    const me = this;

    // Normalize to not have to have translations for each variation used in code
    unit = me.normalizeUnit(unit);

    // Convert abbreviations to the canonical name.
    // See locale file and the applyLocale method below.
    unit = me.parseTimeUnit(unit);

    // unitLookup is keyed by eg 'DAY', 'day', 'MILLISECOND', 'millisecond' etc
    return me.unitLookup[unit][plural ? 'plural' : 'single'];
  }

  /**
   * Normalizes a unit for easier usage in conditionals. For example year, years, y -> year
   * @param {String} unit
   * @returns {String}
   * @category Unit helpers
   */
  static normalizeUnit(unit) {
    if (!unit) {
      return null;
    }

    if (unit.toLowerCase() === 'date') {
      return unit.toLowerCase();
    }

    return canonicalUnitNames.includes(unit.toLowerCase())
      ? // Already valid
        unit.toLowerCase()
      : // Trying specified case first, since we have both "M" for month and "m" for minute
        normalizedUnits[unit] || normalizedUnits[unit.toLowerCase()];
  }

  static getUnitByName(name) {
    // Allow either a canonical name to be passed, or, if that fails, parse it as a localized name or abbreviation.
    return DateHelper.normalizeUnit(name) || DateHelper.normalizeUnit(this.parseTimeUnit(name));
  }

  /**
   * Returns a duration of the timeframe in the given unit.
   * @param {Date} start The start date of the timeframe
   * @param {Date} end The end date of the timeframe
   * @param {String} unit Duration unit
   * @return {Number} The duration in the units
   * @category Unit helpers
   * @ignore
   */
  static getDurationInUnit(start, end, unit, doNotRound) {
    return this.diff(start, end, unit, doNotRound);
  }

  /**
   * Checks if two date units align
   * @private
   * @param {String} majorUnit
   * @param {String} minorUnit
   * @returns {Boolean}
   * @category Unit helpers
   */
  static doesUnitsAlign(majorUnit, minorUnit) {
    // TODO: probably needs some fleshing out to be generally useful, otherwise move to TimeAxisViewModel?
    // Maybe also use getUnitToBaseUnitRatio() for assertion?
    if (majorUnit !== minorUnit && minorUnit === 'week') return false;
    return true;
  }

  static getSmallerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[this.normalizeUnit(unit)] - 1] || null;
  }

  static getLargerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[this.normalizeUnit(unit)] + 1] || null;
  }

  //endregion

  //region Date picker format

  /**
   * Parses a typed duration value according to locale rules.
   *
   * The value is taken to be a string consisting of the numeric magnitude and the units.
   * The units may be a recognised unit abbreviation of this locale or the full local unit name.
   *
   * For example: "2d", "2 d", "2 day", "2 days" will be turned into `{ magnitude : 2, unit : "day" }`
   *
   * **NOTE:** Doesn't work with complex values like "2 days, 2 hours"
   *
   * @param {String} value The value to parse.
   * @param {Boolean} [allowDecimals=true] Decimals are allowed in the magnitude.
   * @param {String} [defaultUnit] Default unit to use if only magnitude passed.
   * @returns {Object} If successfully parsed, the result contains two properties,
   * `magnitude` being a number, and `unit` being the canonical unit name, *NOT*
   * a localized name. If parsing was unsuccessful, `null` is returned.
   * @category Parse & format
   */
  static parseDuration(value, allowDecimals = true, defaultUnit) {
    const me = this,
      durationRegEx = allowDecimals ? withDecimalsDurationRegex : noDecimalsDurationRegex,
      match = durationRegEx.exec(value);

    if (value == null || !match) {
      return null;
    }

    const magnitude = parseNumber(match[1]),
      unit = me.parseTimeUnit(match[2]) || defaultUnit;

    if (!unit) {
      return null;
    }

    return {
      magnitude,
      unit
    };
  }

  /**
   * Parses a typed unit name, for example `"ms"` or `"hr"` or `"yr"` into the
   * canonical form of the unit name which may be passed to {@link #function-add-static}
   * or {@link #function-diff-static}
   * @param {*} unitName
   * @category Parse & format
   */
  static parseTimeUnit(unitName) {
    // NOTE: In case you get a crash here when running tests, it is caused by missing locale. Build locales
    // using `scripts/build.js locales` to resolve.
    const unitMatch = unitName == null ? null : this.durationRegEx.exec(unitName.toLowerCase());

    if (!unitMatch) {
      return null;
    }

    // See which group in the unitAbbrRegEx matched match[2]
    for (let unitOrdinal = 0; unitOrdinal < canonicalUnitNames.length; unitOrdinal++) {
      if (unitMatch[unitOrdinal + 1]) {
        return canonicalUnitNames[unitOrdinal];
      }
    }
  }

  //endregion

  static set locale(name) {
    locale = name;
  }

  static get locale() {
    return locale;
  }

  static applyLocale() {
    const me = this,
      unitAbbreviations = me.L('unitAbbreviations'),
      unitNames = (me.unitNames = me.L('unitNames'));

    // This happens when applying an incomplete locale, as done in Localizable.t.js.
    // Invalid usecase, but return to prevent a crash in that test.
    if (unitNames === 'unitNames') {
      return;
    }

    locale = me.L('locale') || 'en-US';
    if (locale === 'en-US') {
      // TODO: Include in En locale instead?
      ordinalSuffix = enOrdinalSuffix;
    } else if (me.L('ordinalSuffix') !== 'ordinalSuffix') {
      ordinalSuffix = me.L('ordinalSuffix');
    }
    formatCache = {};
    parserCache = {};
    intlFormatterCache = {};

    let unitAbbrRegEx = '';

    me.unitLookup = {};

    for (let i = 0; i < unitAbbreviations.length; i++) {
      const a = unitAbbreviations[i],
        n = unitNames[i];

      n.canonicalUnitName = canonicalUnitNames[i];

      // Create a unitLookup object keyed by unit full names
      // both lower and upper case to be able to look up plurals or abbreviations
      // also always include english names, since those are used in sources
      me.unitLookup[n.single] = me.unitLookup[n.single.toUpperCase()] = me.unitLookup[
        n.canonicalUnitName
      ] = me.unitLookup[n.canonicalUnitName.toUpperCase()] = n;

      unitAbbrRegEx += `${i ? '|' : ''}(`;
      for (let j = 0; j < a.length; j++) {
        unitAbbrRegEx += `${a[j]}|`;
      }
      unitAbbrRegEx += `${n.single}|${n.plural}|${n.canonicalUnitName})`;
    }
    me.durationRegEx = new RegExp(`^(?:${unitAbbrRegEx})$`);
  }
}

/*  */
DateHelper._$name = 'DateHelper';

// Update when changing locale
LocaleManagerSingelton.on({
  locale: 'applyLocale',
  thisObj: DateHelper
});

// Apply default locale
if (LocaleManagerSingelton.locale) DateHelper.applyLocale();
DateHelper._$name = 'DateHelper';

/**
 * @module Common/helper/ObjectHelper
 */

const whiteSpaceRe = /\s+/,
  typeOf = (value) => {
    const baseType = typeof value;

    // If not atomic type, we handle date or null
    if (baseType === 'object') {
      if (value === null) {
        return 'null';
      }
      if (Object.prototype.toString.call(value) === '[object Date]') {
        return 'date';
      }
    }
    return baseType;
  };

// Detect if browser has bad implementation of toFixed()
const toFixedFix =
  (1.005).toFixed(2) === '1.01'
    ? null
    : function(number, fractionDigits) {
        const split = number.toString().split('.'),
          newNumber = +(!split[1] ? split[0] : split.join('.') + '1');

        return number.toFixed.call(newNumber, fractionDigits);
      };

/**
 * Helper for Object manipulation.
 */
class ObjectHelper {
  /**
   * Checks if two values are equal. Basically === but special handling of dates.
   * @param a First value
   * @param b Second value
   * @returns {*} true if values are equal, otherwise false
   */
  static isEqual(a, b, useIsDeeply = false) {
    // Eliminate null vs undefined mismatch
    if (
      (a === null && b !== null) ||
      (a === undefined && b !== undefined) ||
      (b === null && a !== null) ||
      (b === undefined && a !== undefined)
    ) {
      return false;
    }

    // Covers undefined === undefined and null === null, since mismatches are elminiated above
    if (a == null && b == null) {
      return true;
    }

    const typeA = typeof a,
      typeB = typeof b;

    if (typeA === typeB) {
      switch (typeA) {
        case 'number':
        case 'string':
        case 'boolean':
          return a === b;
      }

      switch (true) {
        case a instanceof Date && b instanceof Date:
          // faster than calling DateHelper.isEqual
          return a - b === 0;

        case Array.isArray(a) && Array.isArray(b):
          return a.length === b.length ? a.every((v, idx) => this.isEqual(v, b[idx], useIsDeeply)) : false;

        case typeA === 'object' && a.constructor.prototype === b.constructor.prototype:
          return useIsDeeply ? this.isDeeplyEqual(a, b, useIsDeeply) : JSON.stringify(a) === JSON.stringify(b);
      }
    }

    return String(a) === String(b);
  }

  /**
   * Checks if two objects are deeply equal
   * @param {Object} a
   * @param {Object} b
   * @param {Object} [options] Additional comparison options
   * @param {Object} [options.ignore] Map of property names to ignore when comparing
   * @param {Function} [options.shouldEvaluate] Function used to evaluate if a property should be compared or not.
   * Return false to prevent comparision
   * @param {Function} [options.evaluate] Function used to evaluate equality. Return `true`/`false` as evaluation
   * result or anything else to let `isEqual` handle the comparision
   * @returns {Boolean}
   */
  static isDeeplyEqual(a, b, options = {}) {
    // Same object, equal :)
    if (a === b) {
      return true;
    }

    // Nothing to compare, not equal
    if (!a || !b) {
      return false;
    }

    // Property names excluding ignored
    const aKeys = this.keys(a, options.ignore),
      bKeys = this.keys(b, options.ignore);

    // Property count differs, not equal
    if (aKeys.length !== bKeys.length) {
      return false;
    }

    for (let i = 0; i < aKeys.length; i++) {
      const aKey = aKeys[i];
      const bKey = bKeys[i];

      // Property name differs, not equal
      if (aKey !== bKey) {
        return false;
      }

      const aVal = a[aKey];
      const bVal = b[bKey];

      // Allow caller to determine if property values should be evaluated or not
      // TODO: Not currently used
      if (options.shouldEvaluate) {
        if (
          options.shouldEvaluate(
            aKey,
            {
              value: aVal,
              object: a
            },
            {
              value: bVal,
              object: b
            }
          ) === false
        ) {
          continue;
        }
      }

      // Allow caller to determine equality of properties
      if (options.evaluate) {
        const result = options.evaluate(
          aKey,
          {
            value: aVal,
            object: a
          },
          {
            value: bVal,
            object: b
          }
        );

        // Not equal
        if (result === false) {
          return false;
        }

        // Equal, skip isEqual call below
        if (result === true) {
          continue;
        }
      }

      // Values differ, not equal (also digs deeper)
      if (!this.isEqual(aVal, bVal, options)) {
        return false;
      }
    }

    // Found to be equal
    return true;
  }

  /**
   * Checks if value B is partially equal to value A.
   * @param a First value
   * @param b Second value
   * @returns {Boolean} true if values are partially equal, false otherwise
   */
  static isPartial(a, b) {
    a = String(a).toLowerCase();
    b = String(b).toLowerCase();

    return a.indexOf(b) != -1;
  }

  /**
   * Checks if value a is smaller than value b.
   * @param a First value
   * @param b Second value
   * @returns {Boolean} true if a < b
   */
  static isLessThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isBefore(a, b);
    }
    return a < b;
  }

  /**
   * Checks if value a is bigger than value b.
   * @param a First value
   * @param b Second value
   * @returns {Boolean} true if a > b
   */
  static isMoreThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isAfter(a, b);
    }
    return a > b;
  }

  /**
   * Used by the Base class to make deep copies of defaultConfig blocks
   * @private
   */
  static fork(obj) {
    var ret, key, value;

    if (obj && obj.constructor === Object) {
      ret = Object.setPrototypeOf({}, obj);

      for (key in obj) {
        value = obj[key];

        if (value) {
          if (value.constructor === Object) {
            ret[key] = this.fork(value);
          } else if (value instanceof Array) {
            ret[key] = value.slice();
          }
        }
      }
    } else {
      ret = obj;
    }

    return ret;
  }

  static assign(dest, ...sources) {
    var i = 0,
      ln = sources.length,
      source,
      key;

    for (; i < ln; i++) {
      source = sources[i];

      for (key in source) {
        dest[key] = source[key];
      }
    }
    return dest;
  }

  static clone(source) {
    if (source == null) {
      return source;
    }

    var type = source.constructor.name,
      result = source,
      i,
      key;

    // Date
    if (type === 'Date') {
      return new Date(source.getTime());
    }

    // Array
    if (type === 'Array') {
      i = source.length;

      result = [];

      while (i--) {
        result[i] = this.clone(source[i]);
      }
    }
    // Object
    else if (type === 'Object') {
      result = {};

      for (key in source) {
        result[key] = this.clone(source[key]);
      }
    }

    return result;
  }

  static merge(dest, ...sources) {
    var i = 0,
      ln = sources.length,
      source,
      key,
      value,
      sourceKey;

    for (; i < ln; i++) {
      source = sources[i];

      for (key in source) {
        value = source[key];
        if (value && value.constructor === Object) {
          sourceKey = dest[key];
          if (sourceKey && sourceKey.constructor.name === 'Object') {
            this.merge(sourceKey, value);
          } else {
            dest[key] = this.clone(value);
          }
        } else {
          dest[key] = value;
        }
      }
    }

    return dest;
  }

  /**
   * Copies the named properties from the `source` parameter into the `dest` parameter.
   * @param {Object} dest The destination into which properties are copied.
   * @param {Object} source The source from which properties are copied.
   * @param {String[]} props The list of property names.
   * @returns The `dest` object.
   */
  static copyProperties(dest, source, props) {
    let prop, i;
    for (i = 0; i < props.length; i++) {
      prop = props[i];
      if (prop in source) {
        dest[prop] = source[prop];
      }
    }
    return dest;
  }

  /**
   * Copies the named properties from the `source` parameter into the `dest` parameter
   * unless the property already exists in the `dest`.
   * @param {Object} dest The destination into which properties are copied.
   * @param {Object} source The source from which properties are copied.
   * @param {String[]} props The list of property names.
   * @returns The `dest` object.
   */
  static copyPropertiesIf(dest, source, props) {
    for (const prop of props) {
      if (!(prop in dest)) {
        dest[prop] = source[prop];
      }
    }
    return dest;
  }

  /**
   * Returns an array containing all enumerable property names from every prototype level for the object.
   * @param {Object} object Object to retrieve property names from
   * @param {Object} [ignore] Optional map of names to ignore
   * @returns {String[]} All keys from every prototype level.
   */
  static keys(object, ignore = null) {
    const result = [];

    for (const p in object) {
      if (!ignore || !ignore[p]) {
        result.push(p);
      }
    }
    return result;
  }

  /**
   * Tests whether a passed object has any enumerable properties.
   * @param {Object} object
   * @returns {Boolean} `true` if the passed object has no enumerable properties.
   */
  static isEmpty(object) {
    for (const p in object) {
      // eslint-disable-line no-unused-vars
      return false;
    }
    return true;
  }

  /**
   * Gathers the names of properties which have truthy values into an array.
   *
   * This is useful when gathering CSS class names for complex element production.
   * Instead of appending to an array or string which may already contain the
   * name, and instead of contending with space separation and concatenation
   * and conditional execution, just set the properties of an object:
   *
   *     cls = {
   *         [this.selectedCls] : this.isSelected(thing),
   *         [this.dirtyCls] : this.isDirty(thing)
   *     };
   *
   * @param {Object} source Source of keys to gather into an array.
   * @returns {String[]} The keys which had a truthy value.
   */
  static getTruthyKeys(source) {
    const keys = Object.keys(source);

    for (let i = 0; i < keys.length; ) {
      if (source[keys[i]]) {
        i++;
      } else {
        keys.splice(i, 1);
      }
    }

    return keys;
  }

  /**
   * Gathers the values of properties which are truthy into an array.
   * @param {Object} source Source of values to gather into an array.
   * @returns {String[]} The truthy values from the passed object.
   */
  static getTruthyValues(source) {
    const keys = Object.keys(source);

    for (let i = 0; i < keys.length; ) {
      if (source[keys[i]]) {
        keys[i] = source[keys[i++]];
      } else {
        keys.splice(i, 1);
      }
    }

    return keys;
  }

  /**
   * Converts a list of names, either an a space separated string, or
   * from an array, into a series of properties in an object with truthy
   * values. The Converse of {@link #function-getTruthyKeys-static}
   * @param {String|String[]} The list of names to convert to object form.
   */
  static createTruthyKeys(source) {
    if (typeof source === 'string') {
      source = source.split(whiteSpaceRe);
    }
    const result = {};

    for (const key of source) {
      if (key.length) {
        result[key] = 1;
      }
    }

    return result;
  }

  /**
   * Returns an array of a given object's properties names including properties in
   * all superclasses, in the same order as we get with a normal loop.
   * @param {Object} source An object which may have properties in a prototype
   * chain, such as a configuration (These are chained because of inheritance).
   * @returns {String[]} The property names.
   */
  static allKeys(object) {
    const result = [];

    for (object; object; object = Object.getPrototypeOf(object)) {
      result.push(...Object.keys(object));
    }

    return result;
  }

  /**
   * Checks if a given path exists in an object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {Boolean} Returns `true` if path exists or `false` if it does not
   */
  static pathExists(object, path) {
    const properties = path.split('.');

    return properties.every((property) => {
      if (!(property in object)) {
        return false;
      }
      object = object[property];
      return true;
    });
  }

  /**
   * Returns value for a given path in the object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {*} Value associated with passed key
   */
  static getPath(object, path) {
    return path.split('.').reduce((result, key) => {
      return (result || {})[key];
    }, object);
  }

  /**
   * Sets value for a given path in the object
   * @param {Object} object Target object
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @param {*} value Value for a given path
   */
  static setPath(object, path, value) {
    path.split('.').reduce((result, key, index, array) => {
      const isLast = index === array.length - 1;

      if (isLast) {
        return (result[key] = value);
      } else if (!(result[key] instanceof Object)) {
        result[key] = {};
      }

      return result[key];
    }, object);
  }

  static coerce(from, to) {
    var fromType = typeOf(from),
      toType = typeOf(to),
      isString = typeof from === 'string';

    if (fromType !== toType) {
      switch (toType) {
        case 'string':
          return String(from);
        case 'number':
          return Number(from);
        case 'boolean':
          // See http://ecma262-5.com/ELS5_HTML.htm#Section_11.9.3 as to why '0'.
          // TL;DR => ('0' == 0), so if given string '0', we must return boolean false.
          return isString && (!from || from === 'false' || from === '0') ? false : Boolean(from);
        case 'null':
          return isString && (!from || from === 'null') ? null : false;
        case 'undefined':
          return isString && (!from || from === 'undefined') ? undefined : false;
        case 'date':
          return isString && isNaN(from) ? DateHelper.parse(from) : Date(Number(from));
      }
    }
    return from;
  }

  static wrapProperty(object, propertyName, newGetter, newSetter, deep = true) {
    const newProperty = {};

    let proto = Object.getPrototypeOf(object),
      existingProperty = Object.getOwnPropertyDescriptor(proto, propertyName);

    while (!existingProperty && proto && deep) {
      proto = Object.getPrototypeOf(proto);
      if (proto) {
        existingProperty = Object.getOwnPropertyDescriptor(proto, propertyName);
      }
    }

    if (existingProperty) {
      if (existingProperty.set) {
        newProperty.set = (v) => {
          existingProperty.set.call(object, v);

          // Must invoke the getter in case "v" has been transformed.
          newSetter && newSetter.call(object, existingProperty.get.call(object));
        };
      } else {
        newProperty.set = newSetter;
      }
      if (existingProperty.get) {
        newProperty.get = () => {
          let result = existingProperty.get.call(object);
          if (newGetter) {
            result = newGetter.call(object, result);
          }
          return result;
        };
      } else {
        newProperty.get = newGetter;
      }
    } else {
      newProperty.set = (v) => {
        object[`_${propertyName}`] = v;
        newSetter && newSetter.call(object, v);
      };
      newProperty.get = () => {
        let result = object[`_${propertyName}`];
        if (newGetter) {
          result = newGetter.call(object, result);
        }
        return result;
      };
    }
    Object.defineProperty(object, propertyName, newProperty);
  }

  /**
   * Finds a property descriptor for the passed object from all inheritance levels.
   * @param {Object} object The Object whos property to find.
   * @param {String} propertyName The name of the property to find.
   * @returns {Object} An ECMA property descriptor is the property was found, otherwise `null`
   */
  static getPropertyDescriptor(object, propertyName) {
    let result = null;
    for (let obj = object; !result && obj !== Base; obj = Object.getPrototypeOf(obj)) {
      result = Object.getOwnPropertyDescriptor(obj, propertyName);
    }
    return result;
  }

  /**
   * Changes the passed object and removes all null and undefined properties from it
   * @param {Object} object Target object
   * @returns {Object} Passed object
   */
  static cleanupProperties(obj) {
    Object.entries(obj).forEach(([key, value]) => value == null && delete obj[key]);
    return obj;
  }

  /**
   * Checks that the supplied value is of the specified type. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} type Expected type
   * @param {String} name Name of the value, used in error message
   */
  static assertType(value, type, name) {
    // eslint-disable-next-line valid-typeof
    if (value != null && typeof value !== type) {
      throw new Error(`Incorrect type "${typeof value}" for ${name}, expected "${type}"`);
    }
  }

  /**
   * Checks that the supplied value is a number.  Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertNumber(value, name) {
    this.assertType(value, 'number', name);
  }

  /**
   * Checks that the supplied value is a boolean.  Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertBoolean(value, name) {
    this.assertType(value, 'boolean', name);
  }

  /**
   * Number.toFixed(), with polyfill for browsers that needs it
   * @param {Number } number
   * @param {Number} digits
   * @returns {*}
   */
  static toFixed(number, digits) {
    if (toFixedFix) {
      return toFixedFix(number, digits);
    }

    return number.toFixed(digits);
  }
}
ObjectHelper._$name = 'ObjectHelper';

/* eslint-disable standard/no-callback-literal */
// Gives circular dependencies which I could not solve, called from global scope instead
//import GlobalEvents from '../GlobalEvents.js';

// https://app.assembla.com/spaces/bryntum/tickets/7903-rendering-fails
// HACK: this value is required to calculate width if it was configured relative to font size (em) but no element is set
const DEFAULT_FONT_SIZE = 14,
  t0t0 = { align: 't0-t0' };

// We only do the measurement once, if the value is null
let scrollBarWidth = null,
  idCounter = 0,
  themeInfo = null;

const // Transform matrix parse Regex. CSS transform computed style looks like this:
  // matrix(scaleX(), skewY(), skewX(), scaleY(), translateX(), translateY())
  // or
  // matrix3d(scaleX(), skewY(), 0, 0, skewX(), scaleY(), 0, 0, 0, 0, 1, 0, translateX(), translateY())
  // This is more reliable than using the style literal which may include
  // relative styles such as "translateX(-20em)", or not include the translation at all if it's from a CSS rule.
  // Use a const so as to only compile RexExp once
  translateMatrixRe = /(?:matrix\((?:-?\d*\.?[0-9]*),\s?(?:-?\d*\.?[0-9]*),\s?(?:-?\d*\.?[0-9]*),\s?(?:-?\d*\.?[0-9]*),\s?(-?\d*\.?[0-9]*),\s?(-?\d*\.?[0-9]*))|(?:matrix3d\((?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(-?\d*),\s?(-?\d*))/,
  pxTtranslateXRe = /translate(3d|X)?\((-?\d*\.?[0-9]*)px(?:,\s?(-?\d*\.?[0-9]*)px)?/,
  pxTtranslateYRe = /translate(3d|Y)?\((-?\d*\.?[0-9]*)px(?:,\s?(-?\d*\.?[0-9]*)px)?/,
  domIdRe = /^[^a-z]+|[^\w:.-]+/gi,
  whiteSpaceRe$1 = /\s+/,
  // DomHelper#createElement properties which require special processing.
  // All other configs such as id and type are applied directly to the element.
  elementCreateProperties = {
    tag: 1,
    html: 1,
    children: 1,
    tooltip: 1,
    style: 1,
    dataset: 1,
    parent: 1,
    nextSibling: 1,
    ns: 1,
    reference: 1,
    unmatched: 1, // Used by syncId approach
    _element: 1, // Used by sync to assign used element back to the config, for usage by the caller
    onlyChildren: 1, // Used by sync to not touch the target element itself,
    elementData: 1,
    compareHtml: 1 // Sync
  },
  // Attributes to ignore on sync
  syncIgnoreAttributes = {
    tag: 1,
    html: 1,
    children: 1,
    tooltip: 1,
    parent: 1,
    nextSibling: 1,
    ns: 1,
    reference: 1,
    _element: 1,
    elementData: 1,
    retainElement: 1,
    compareHtml: 1
  },
  styleIgnoreProperties = {
    length: 1,
    parentRule: 1
  },
  styleDimensionProperties = {
    width: 1,
    height: 1,
    top: 1,
    left: 1,
    minWidth: 1,
    minHeight: 1,
    maxWidth: 1,
    maxHeight: 1,
    fontSize: 1
  },
  nativeFocusableTags = {
    BUTTON: 1,
    IFRAME: 1,
    EMBED: 1,
    INPUT: 1,
    OBJECT: 1,
    SELECT: 1,
    TEXTAREA: 1,
    HTML: BrowserHelper.isIE11 ? 1 : 0,
    BODY: BrowserHelper.isIE11 ? 0 : 1
  },
  win = window,
  doc = document,
  emptyObject = {},
  emptyArray = [],
  arraySlice = Array.prototype.slice,
  immediatePromise = new Promise((resolve) => resolve()),
  devicePixelRatio = window.devicePixelRatio || 1,
  roundPx = devicePixelRatio === 1 ? Math.round : (px) => Math.round(px * devicePixelRatio) / devicePixelRatio,
  fontProps = [
    'font-size',
    'font-size-adjust',
    'font-style',
    'font-weight',
    'font-family',
    'font-kerning',
    'font-stretch',
    'line-height',
    'text-transform',
    'text-decoration',
    'letter-spacing',
    'word-break'
  ],
  // Used in sync to give ObjectHelper.isDeeplyEqual() some domain knowledge
  syncEqualityEvaluator = {
    // Attributes used during creation that should not be compared
    ignore: {
      _element: 1,
      parent: 1,
      elementData: 1,
      ns: 1
    },
    // Function to evaluate 'compareHtml' property instead of 'html' for DocumentFragments
    evaluate(property, a, b) {
      if (property === 'html' && typeof a.value !== 'string') {
        // DocumentFragment, compare separately supplied html
        return a.object.compareHtml === b.object.compareHtml;
      }
    }
  };

let templateElement, htmlParser;

/**
 * @module Common/helper/DomHelper
 */

/**
 * Helps with dom querying and manipulation.
 * ```
 * DomHelper.createElement({
 *   tag: 'div',
 *   className: 'parent',
 *   style: 'background: red',
 *   children: [
 *      { tag: 'div', className: 'child' },
 *      { tag: 'div', className: 'child' }
 *   ]
 * });
 * ```
 */
class DomHelper {
  /**
   * Returns `true` if the passed element is focusable either programatically or through pointer gestures.
   * @param {HTMLElement} element The element to test.
   */
  static isFocusable(element, skipAccessibilityCheck = false) {
    if (!skipAccessibilityCheck) {
      // offsetParent indicates that the element has layout, ie it is deeply visible.
      // document.body does not have an offsetParent.
      if (element !== document.body && !element.offsetParent) {
        return false;
      }
    }

    const nodeName = element.nodeName;

    /*
     * An element is focusable if:
     *   - It is natively focusable, or
     *   - It is an anchor or link with href attribute, or
     *   - It has a tabIndex, or
     *   - It is an editing host (contenteditable="true")
     */
    return (
      nativeFocusableTags[nodeName] ||
      ((nodeName === 'A' || nodeName === 'LINK') && !!element.href) ||
      element.getAttribute('tabIndex') != null ||
      element.contentEditable === 'true'
    );
  }

  /**
   * Returns `true` if the passed element is currently visible in the browser viewport, i.e. user can find it on screen
   * @param {HTMLElement} element The element to test.
   * @param {Boolean} whole Whether to check that whole element is visible, not just part of it.
   */
  static isInView(el, whole = true) {
    let elRect = Rectangle.from(el),
      inView = true;

    const fullHeight = elRect.height,
      fullWidth = elRect.width;

    while (inView && el.parentElement) {
      el = el.parentElement;
      elRect = elRect.intersect(Rectangle.from(el));
      inView = elRect && (!whole || (elRect.height >= fullHeight && elRect.width >= fullWidth));
    }

    return inView;
  }

  /**
   * Returns true if element has opened shadow root
   * @param {HTMLElement} element Element to check
   * @returns {Boolean}
   */
  static isCustomElement(element) {
    return element && element.shadowRoot;
  }

  /**
   * Resolves element from point, checking shadow DOM if requried
   * @param {Number} x
   * @param {Number} y
   * @returns {HTMLElement}
   */
  static elementFromPoint(x, y) {
    let el = document.elementFromPoint(x, y);

    // Try to check shadow dom if it exists
    if (DomHelper.isCustomElement(el)) {
      el = el.shadowRoot.elementFromPoint(x, y) || el;
    }

    return el;
  }

  /**
   * Returns active element checking shadow dom too
   * @returns {HTMLElement}
   */
  static get activeElement() {
    let el = document.activeElement;

    while (el.shadowRoot) {
      el = el.shadowRoot.activeElement;
    }

    return el;
  }

  /**
   * Returns the `id` of the passed element. Generates a unique `id` if the element does not have one.
   * @param {HTMLElement} element The element to return the `id` of.
   */
  static getId(element) {
    return element.id || (element.id = 'b-element-' + ++idCounter);
  }

  //region Internal

  /**
   * Internal convenience fn to allow specifying either an element or a CSS selector to retrieve one
   * @private
   * @param {String|HTMLElement} elementOrSelector element or selector to lookup in DOM
   * @returns {HTMLElement}
   */
  static getElement(elementOrSelector) {
    // also used for SVG elements, so need to use more basic class, that is also returned by querySelector
    if (elementOrSelector instanceof Element) {
      return elementOrSelector;
    }

    return doc.querySelector(elementOrSelector);
  }

  /**
   * Sets attributes passed as object to given element
   * @private
   * @param {String|Element} elementOrSelector
   * @param {Object} attributes
   */
  static setAttributes(elementOrSelector, attributes) {
    const element = this.getElement(elementOrSelector);

    Object.entries(attributes).forEach(([key, value]) => element.setAttribute(key, value));
  }

  /**
   * Sets a CSS [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length) style value.
   * @param {String|HTMLElement} element The element to set the style in, or, if just the result is required,
   * the style magnitude to return with units added.
   * @param {String} [style] The name of a style property which specifies a [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length)
   * @param {Number|String} [value] The magnitude. If a number is used, the value will be set in `px` units.
   * @returns {String} The style value string.
   */
  static setLength(element, style, value) {
    if (arguments.length === 1) {
      return typeof element === 'number' ? `${element}px` : element;
    } else {
      element = this.getElement(element);
      return (element.style[style] = typeof value === 'number' ? `${value}px` : value);
    }
  }

  //endregion

  //region Children, going down...

  /**
   * Gets the first direct child of `element` that matches `selector.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @returns {HTMLElement}
   * @category Query children
   */
  static getChild(element, selector) {
    // TODO: Only IE11 doesn't support :scope
    if (BrowserHelper.supportsQueryScope) {
      selector = ':scope>' + selector;
    } else {
      const elId = element.id || (element.id = 'b-element-' + ++idCounter);
      selector = `#${elId} > ${selector}`;
    }
    return element.querySelector(selector);
  }

  /**
   * Checks if `element` has any child that matches `selector`.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @returns {Boolean} true if any child matches selector
   * @category Query children
   */
  static hasChild(element, selector) {
    return DomHelper.getChild(element, selector) != null;
  }

  /**
   * Returns all child elements (not necessarily direct children) that matches `selector.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @returns {HTMLElement[]} Matched elements, somewhere below `element
   * @category Query children
   */
  static children(element, selector) {
    return Array.from(element.querySelectorAll(selector));
  }

  /**
   * Looks at the specified `element` and all of its children for the one that first matches `selector.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @returns {HTMLElement} Matched element, either element or an element below it
   * @category Query children
   */
  static down(element, selector) {
    if (!element) {
      return null;
    }

    if (element.matches && element.matches(selector)) {
      return element;
    }
    if (BrowserHelper.supportsQueryScope) {
      selector = ':scope ' + selector;
    } else {
      const elId = element.id || (element.id = 'b-element-' + ++idCounter);
      selector = `#${elId} ${selector}`;
    }
    return element.querySelector(selector);
  }

  /**
   * Checks if childElement is a descendant of parentElement (contained in it or a sub element)
   * @param {HTMLElement} parentElement Parent element
   * @param {HTMLElement} childElement Child element, at any level below parent
   * @returns {Boolean}
   * @category Query children
   */
  static isDescendant(parentElement, childElement) {
    // In case of IE11 and parentElement is <html>, HTMLDocument#contains is not supported - fallback to body
    if (!parentElement.contains) {
      parentElement = parentElement.body;
    }

    return parentElement.contains(childElement);
  }

  /**
   * Iterates over each result returned from `element.querySelectorAll(selector)`. First turns it into an array to
   * work in IE. Can also be called with only two arguments, in which case the first argument is used as selector and
   * document is used as the element.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @param {Function} fn Function called for each found element
   * @category Query children
   */
  static forEachSelector(element, selector, fn) {
    if (typeof element === 'string') {
      fn = selector;
      selector = element;
      element = doc;
    }
    this.children(element, selector).forEach(fn);
  }

  /**
   * Iterates over the direct child elements of the specified element. First turns it into an array to
   * work in IE.
   * @param {HTMLElement} element Parent element
   * @param {Function} fn Function called for each child element
   * @category Query children
   */
  static forEachChild(element, fn) {
    Array.from(element.children).forEach(fn);
  }

  /**
   * Removes each element returned from `element.querySelectorAll(selector)`.
   * @param {HTMLElement} element
   * @param {String} selector
   * @category Query children
   */
  static removeEachSelector(element, selector) {
    this.forEachSelector(element, selector, (child) => child.remove());
  }

  static removeClsGlobally(element, ...classes) {
    classes.forEach((cls) => this.forEachSelector(element, '.' + cls, (child) => child.classList.remove(cls)));
  }

  //endregion

  //region Parents, going up...

  /**
   * Looks at the specified element and all of its parents for the one that first matches selector.
   * @param {HTMLElement} element Element
   * @param {String} selector CSS selector
   * @returns {HTMLElement} Matched element, either the passed in element or an element above it
   * @category Query parents
   */
  static up(element, selector) {
    /*let parent = element;
        while (parent && !parent.matches(selector)) parent = parent.parentElement;
        return parent;*/
    return element && element.closest(selector);
  }

  static getAncestor(element, possibleAncestorParents, outerElement = null) {
    let found = false,
      ancestor,
      parent = element;

    if (!Array.isArray(possibleAncestorParents)) possibleAncestorParents = [possibleAncestorParents];

    while ((parent = parent.parentElement)) {
      if (possibleAncestorParents.includes(parent)) {
        found = true;
        break;
      }
      if (outerElement && parent === outerElement) break;
      ancestor = parent;
    }

    if (!found) return null;
    return ancestor || element;
  }

  //endregion

  //region Creation

  /**
   * Converts the passed id to an id valid for usage as id on a DOM element.
   * @param {String} id
   * @returns {String}
   */
  static makeValidId(id) {
    if (id == null) return null;

    return String(id).replace(domIdRe, '');
  }

  /**
   * Creates an Element. Example usage:
   * @example
   * DomHelper.createElement({
   *   tag         : 'table', // defaults to 'div'
   *   cellSpacing : 0,
   *   className   : 'nacho',
   *   html        : 'I am a nacho',
   *   children    : [ { tag: 'tr', ... }, myDomElement ],
   *   parent      : myExistingElement // Or its id
   *   style       : 'font-weight: bold;color: red',
   *   dataset     : { index: 0, size: 10 },
   *   tooltip     : 'Yay!',
   *   ns          : 'http://www.w3.org/1999/xhtml'
   * });
   * @param {Object} config Element config, as in example
   * @param {Boolean} returnAll Specify true to return all elements & child elements created as an array
   * @returns {HTMLElement|HTMLElement[]|Object} Single element or array of elements `returnAll` was set to true.
   * If any elements had a `reference` property, this will be an object containing a reference to
   * all those elements, keyed by the reference name.
   * @category Creation
   */
  static createElement(config = {}, returnAll = false, refs = null, syncIdField = null) {
    if (typeof config.parent === 'string') {
      config.parent = document.getElementById(config.parent);
    }

    // nextSibling implies a parent
    const parent = config.parent || (config.nextSibling && config.nextSibling.parentNode);

    let element;

    if (config.ns) {
      element = doc.createElementNS(config.ns, config.tag || 'svg');
    } else {
      element = doc.createElement(config.tag || 'div');
    }

    if (config.html) {
      if (config.html instanceof DocumentFragment) {
        element.appendChild(config.html);
      } else {
        element.innerHTML = config.html;
      }
    }

    if (config.tooltip) {
      WidgetHelper.attachTooltip(element, config.tooltip);
    }

    if (config.style) {
      this.applyStyle(element, config.style);
    }

    if (config.dataset) {
      Object.assign(element.dataset, config.dataset);
    }

    if (parent) {
      parent.insertBefore(element, config.nextSibling);
    }

    if (config.reference) {
      (refs || (refs = {}))[config.reference] = element;
      element.setAttribute('reference', config.reference);
    }

    // Attach custom data to the element, not visible
    if (config.elementData) {
      element.elementData = config.elementData;
    }

    // Handle things like id, className, type, rel, cellSpacing, href etc which just get assigned.
    for (const prop of Object.keys(config)) {
      if (!elementCreateProperties[prop]) {
        if (config.ns) {
          element.setAttribute(prop, config[prop]);
          //element.setAttributeNS(config.ns, prop, config[prop]);
        } else {
          element[prop] = config[prop];
        }
      }
    }

    // if returnAll is true, use array
    if (returnAll === true) {
      returnAll = [element];
    }
    // if it already is an array, add to it (we are probably a child)
    else if (Array.isArray(returnAll)) {
      returnAll.push(element);
    }

    if (config.children) {
      if (syncIdField) {
        // Map syncId -> child element to avoid querying dom later on
        element.syncIdMap = {};
      }

      config.children.forEach((child) => {
        // Append string children as text nodes
        if (typeof child === 'string') {
          element.appendChild(document.createTextNode(child));
        }
        // Just append Elements directly.
        else if (isNaN(child.nodeType)) {
          child.parent = element;
          if (!child.ns) {
            child.ns = config.ns;
          }

          const childElement = DomHelper.createElement(child, returnAll, refs, syncIdField),
            syncId = child.dataset && child.dataset[syncIdField];

          // syncId is used with DomHelper.sync to match elements. Populate a map here to make finding them faster
          if (syncId != null) {
            element.syncIdMap[syncId] = childElement;
          }

          // Do not want to alter the initial config
          delete child.parent;
        } else {
          element.appendChild(child);
        }
      });
    }

    if (syncIdField) {
      // Store used config, to be able to compare on sync to determine if changed without hitting dom
      element.lastConfig = config;
    }

    // If references were used, return them in an object
    // If returnAll was specified, return the array
    // By default, return the root element
    return refs || returnAll || element;
  }

  /**
   * Create element(s) from a template (html string). Note that
   * `textNode`s are discarded unless the `raw` option is passed
   * as `true`.
   *
   * If the template has a single root element, then the single element will be returned
   * unless the `array` option is passed as `true`.
   *
   * If there are multiple elements, then an Array will be returned.
   *
   * @param {String} template The HTML string from which to create DOM content
   * @param {Object} [options] An object containing properties to modify how the DOM is created and returned.
   * @param {Boolean} [options.array] `true` to return an array even if there's only one resulting element.
   * @param {Boolean} [options.raw] Return all child nodes, including text nodes.
   * @param {Boolean} [options.fragment] Return a DocumentFragment.
   * @private
   */
  static createElementFromTemplate(template, options = emptyObject) {
    const { array, raw, fragment } = options;
    let result;

    // Use template by preference if it exists. It's faster on most supported platforms
    // https://jsperf.com/domparser-vs-template/
    if (DomHelper.supportsTemplate) {
      (templateElement || (templateElement = doc.createElement('template'))).innerHTML = template;

      result = templateElement.content;
      if (fragment) {
        // The template is reused, so therefore is its fragment.
        // If we release the fragment to a caller, it must be a clone.
        return result.cloneNode(true);
      }
    } else {
      (htmlParser || (htmlParser = new DOMParser())).parseFromString(template, 'text/html');

      result = htmlParser.parseFromString(template, 'text/html').body;

      // We must return a DocumentFragment.
      // myElement.append(fragment) inserts the contents of the fragment, not the fragment itself.
      if (fragment) {
        // Empty string results in *no document.body* on IE!
        const nodes = result ? result.childNodes : emptyArray;
        result = document.createDocumentFragment();
        while (nodes.length) {
          result.appendChild(nodes[0]);
        }
        return result;
      }
      // Happens with empty template in IE11
      else if (!result) {
        result = { children: [], childNodes: [] };
      }
    }

    // Raw means all child nodes are returned
    if (raw) {
      result = result.childNodes;
    }
    // Otherwise, only element nodes
    else {
      result = result.children;
    }

    return result.length === 1 && !array ? result[0] : arraySlice.call(result);
  }

  /**
   * Inserts an `element` at first position in `into`.
   * @param {HTMLElement} into Parent element
   * @param {HTMLElement} element Element to insert, or an element config passed on to createElement()
   * @returns {HTMLElement}
   * @category Creation
   */
  static insertFirst(into, element) {
    if (element && element.nodeType !== Node.ELEMENT_NODE && element.tag) {
      element = DomHelper.createElement(element);
    }
    return into.insertBefore(element, into.firstElementChild);
  }

  /**
   * Inserts a `element` before `beforeElement` in `into`.
   * @param {HTMLElement} into Parent element
   * @param {HTMLElement} element Element to insert, or an element config passed on to createElement()
   * @param {HTMLElement} beforeElement Element before which passed element should be inserted
   * @returns {HTMLElement}
   * @category Creation
   */
  static insertBefore(into, element, beforeElement) {
    if (element && element.nodeType !== Node.ELEMENT_NODE && element.tag) {
      element = DomHelper.createElement(element);
    }
    return beforeElement ? into.insertBefore(element, beforeElement) : DomHelper.insertFirst(into, element);
  }

  /**
   * Appends element to parentElement.
   * @param {HTMLElement} parentElement Parent element
   * @param {HTMLElement|Object|String} elementOrConfig Element to insert, or an element config passed on to createElement(), or an html string passed to createElementFromTemplate
   * @returns {HTMLElement}
   * @category Creation
   */
  static append(parentElement, elementOrConfig) {
    if (elementOrConfig) {
      if (typeof elementOrConfig === 'string') {
        elementOrConfig = DomHelper.createElementFromTemplate(elementOrConfig);
      } else if (elementOrConfig.nodeType !== Node.ELEMENT_NODE && elementOrConfig.tag) {
        elementOrConfig = DomHelper.createElement(elementOrConfig);
      }
    }
    if (Array.isArray(elementOrConfig)) {
      return elementOrConfig.map((element) => parentElement.appendChild(element));
    } else {
      return parentElement.appendChild(elementOrConfig);
    }
  }

  //endregion

  //region Get position

  /**
   * Returns the element's `transform translateX` value in pixels.
   * @param {HTMLElement} element
   * @returns {Number} X transform
   * @category Position, get
   */
  static getTranslateX(element) {
    let transformStyle = element.style.transform,
      matches = pxTtranslateXRe.exec(transformStyle);

    // Use inline transform style if it contains "translate(npx, npx" or "translate3d(npx, npx" or "translateX(npx"
    if (matches) {
      return parseInt(matches[2]);
    } else {
      // If the inline style is the matrix() form, then use that, otherwise, use computedStyle
      matches =
        translateMatrixRe.exec(transformStyle) ||
        translateMatrixRe.exec(this.getStyleValue(this.getElement(element), 'transform'));
      return matches ? parseInt(matches[1] || matches[3]) : 0;
    }
  }

  /**
   * Returns the element's `transform translateY` value in pixels.
   * @param {HTMLElement} element
   * @returns {Number} Y coordinate
   * @category Position, get
   */
  static getTranslateY(element) {
    let transformStyle = element.style.transform,
      matches = pxTtranslateYRe.exec(transformStyle);
    // Use inline transform style if it contains "translate(npx, npx" or "translate3d(npx, npx" or "translateY(npx"
    if (matches) {
      // If it was translateY(npx), use first item in the parens.
      const y = parseInt(matches[matches[1] === 'Y' ? 2 : 3]);
      // FF will strip `translate(x, 0)` -> `translate(x)`, so need to check for isNaN also
      return isNaN(y) ? 0 : y;
    } else {
      // If the inline style is the matrix() form, then use that, otherwise, use computedStyle
      matches =
        translateMatrixRe.exec(transformStyle) ||
        translateMatrixRe.exec(this.getStyleValue(this.getElement(element), 'transform'));
      return matches ? parseInt(matches[2] || matches[4]) : 0;
    }
  }

  /**
   * Gets both X and Y coordinates as an array [x, y]
   * @param {HTMLElement} element
   * @returns {Number[]} [x, y]
   * @category Position, get
   */
  static getTranslateXY(element) {
    return [this.getTranslateX(element), this.getTranslateY(element)];
  }

  /**
   * Get elements X offset within a containing element
   * @param {HTMLElement} element
   * @param {HTMLElement} container
   * @returns {Number} X offset
   * @category Position, get
   */
  static getOffsetX(element, container = null) {
    return container
      ? element.getBoundingClientRect().left - container.getBoundingClientRect().left
      : element.offsetLeft;
  }

  /**
   * Get elements Y offset within a containing element
   * @param {HTMLElement} element
   * @param {HTMLElement} container
   * @returns {Number} Y offset
   * @category Position, get
   */
  static getOffsetY(element, container = null) {
    return container ? element.getBoundingClientRect().top - container.getBoundingClientRect().top : element.offsetTop;
  }

  /**
   * Gets elemnts X and Y offset within containing element as an array [x, y]
   * @param {HTMLElement} element
   * @param {HTMLElement} container
   * @returns {Number[]} [x, y]
   * @category Position, get
   */
  static getOffsetXY(element, container = null) {
    return [this.getOffsetX(element, container), this.getOffsetY(element, container)];
  }

  /**
   * Focus element without scrolling the element into view.
   * @param {HTMLElement} element
   */
  static focusWithoutScrolling(element) {
    const x = win.pageXOffset, // no window.scrollX in IE11
      y = win.pageYOffset; // no window.scrollY in IE11

    // focusOptions supports by Chrome starting from version 64
    element.focus({ preventScroll: true });

    // Next code is for browsers which do not support focusOptions
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus
    if (BrowserHelper.isChrome && BrowserHelper.chromeVersion >= 64) return;

    win.scrollTo(x, y);
  }

  /**
   * Get elements X position on page
   * @param {HTMLElement} element
   * @returns {Number}
   * @category Position, get
   */
  static getPageX(element) {
    return element.getBoundingClientRect().left + win.pageXOffset; // no window.scrollX in IE11
  }

  /**
   * Get elements Y position on page
   * @param {HTMLElement} element
   * @returns {Number}
   * @category Position, get
   */
  static getPageY(element) {
    return element.getBoundingClientRect().top + win.pageYOffset; // no window.scrollY in IE11
  }

  /**
   * Returns extremal (min/max) size (height/width) of the element in pixels
   * @param {HTMLElement} element
   * @param {String} style minWidth/minHeight/maxWidth/maxHeight
   * @returns {number}
   * @internal
   */
  static getExtremalSizePX(element, style) {
    let prop = StringHelper.hyphenate(style),
      measure = prop.split('-')[1],
      value = this.getStyleValue(element, prop);

    if (/%/.test(value)) {
      // Element might be detached from DOM
      if (element.parentElement) {
        value = parseInt(this.getStyleValue(element.parentElement, measure), 10);
      } else {
        value = NaN;
      }
    } else {
      value = parseInt(value, 10);
    }

    return value;
  }

  //endregion

  //region Set position

  /**
   * Set element's `X` translation in pixels.
   * @param {HTMLElement} element
   * @param {Number} x The value by which the element should be translated from its default position.
   * @category Position, set
   */
  static setTranslateX(element, x) {
    const t = DomHelper.getStyleValue(element, 'transform').split(/,\s*/);

    // Avoid blurry text on non-retina displays
    x = roundPx(x);

    if (t.length > 1) {
      t[t[0].startsWith('matrix3d') ? 12 : 4] = x;
      element.style.transform = t.join(',');
    } else {
      element.style.transform = `translateX(${x}px)`;
    }
  }

  /**
   * Set element's `Y` translation in pixels.
   * @param {HTMLElement} element
   * @param {Number} y  The value by which the element should be translated from its default position.
   * @category Position, set
   */
  static setTranslateY(element, y) {
    const t = DomHelper.getStyleValue(element, 'transform').split(/,\s*/);

    // Avoid blurry text on non-retina displays
    y = roundPx(y);

    if (t.length > 1) {
      t[t[0].startsWith('matrix3d') ? 13 : 5] = y;
      element.style.transform = t.join(',') + ')';
    } else {
      element.style.transform = `translateY(${y}px)`;
    }
  }

  /**
   * Set element's style `top`.
   * @param {HTMLElement} element
   * @param {Number/String} y The top position. If numeric, `'px'` is used as the unit.
   * @category Position, set
   */
  static setTop(element, y) {
    this.setLength(element, 'top', y);
  }

  /**
   * Set element's style `left`.
   * @param {HTMLElement} element
   * @param {Number/String} x The top position. If numeric, `'px'` is used as the unit.
   * @category Position, set
   */
  static setLeft(element, x) {
    this.setLength(element, 'left', x);
  }

  /**
   * Set elements `X` and `Y` translation in pixels.
   * @param {HTMLElement} element
   * @param {Number} [x] The `X translation.
   * @param {Number} [y] The `Y translation.
   * @category Position, set
   */
  static setTranslateXY(element, x, y) {
    if (x == null) {
      return this.setTranslateY(element, y);
    }
    if (y == null) {
      return this.setTranslateX(element, x);
    }

    // Avoid blurry text on non-retina displays
    x = roundPx(x);
    y = roundPx(y);

    const t = DomHelper.getStyleValue(element, 'transform').split(/,\s*/),
      is3d = t[0].startsWith('matrix3d');

    if (t.length > 1) {
      t[is3d ? 12 : 4] = x;
      t[is3d ? 13 : 5] = y;
      element.style.transform = t.join(',') + ')';
    } else {
      element.style.transform = `translateX(${x}px) translateY(${y}px)`;
    }
  }

  /**
   * Increase `X` translation
   * @param {HTMLElement} element
   * @param {Number} x The number of pixels by which to increase the element's `X` translation.
   * @category Position, set
   */
  static addTranslateX(element, x) {
    DomHelper.setTranslateX(element, DomHelper.getTranslateX(element) + x);
  }

  /**
   * Increase `Y` position
   * @param {HTMLElement} element
   * @param {Number} y The number of pixels by which to increase the element's `Y` translation.
   * @category Position, set
   */
  static addTranslateY(element, y) {
    DomHelper.setTranslateY(element, DomHelper.getTranslateY(element) + y);
  }

  /**
   * Increase X position
   * @param {HTMLElement} element
   * @param x
   * @category Position, set
   */
  static addLeft(element, x) {
    DomHelper.setLeft(element, DomHelper.getOffsetX(element) + x);
  }

  /**
   * Increase Y position
   * @param {HTMLElement} element
   * @param y
   * @category Position, set
   */
  static addTop(element, y) {
    DomHelper.setTop(element, DomHelper.getOffsetY(element) + y);
  }

  /**
   * Align the passed element with the passed target according to the align spec.
   * @param {HTMLElement} element The element to align.
   * @param {HTMLElement|Common.helper.util.Rectangle} target The target element or rectangle to align to
   * @param {Object} alignSpec See {@link Common.helper.util.Rectangle#function-alignTo} Defaults to `{ align : 't0-t0' }`
   */
  static alignTo(element, target, alignSpec = t0t0) {
    target = target instanceof Rectangle ? target : Rectangle.from(target, null, true);

    const elXY = this.getTranslateXY(element),
      elRect = Rectangle.from(element, null, true),
      targetRect = elRect.alignTo(
        Object.assign(alignSpec, {
          target
        })
      );

    this.setTranslateXY(element, elXY[0] + targetRect.x - elRect.x, elXY[1] + targetRect.y - elRect.y);
  }

  //endregion

  //region Styles & CSS

  /**
   * Returns a style value or values for the passed element.
   * @param {HTMLElement} element The element to read styles from
   * @param {String|String[]} propName The property or properties to read
   * @param {Boolean} [inline=false] Pass as `true` to read the element's inline style.
   * Note that this could return inaccurate results if CSS rules apply to this element.
   * @return {String|Object} The value or an object containing the values keyed by the requested property name.
   * @category CSS
   */
  static getStyleValue(element, propName, inline, pseudo) {
    const styles = inline ? element.style : element.ownerDocument.defaultView.getComputedStyle(element, pseudo);

    if (Array.isArray(propName)) {
      let result = {};
      for (let prop of propName) {
        result[prop] = styles.getPropertyValue(StringHelper.hyphenate(prop));
      }
      return result;
    }

    // Use the elements owning view to get the computed style.
    // Ensure the property name asked for is hyphenated.
    // getPropertyValue doesn't work with camelCase
    return styles.getPropertyValue(StringHelper.hyphenate(propName));
  }

  /**
   * Applies specified style to the passed element. Style can be an object or a string.
   * @param {HTMLElement} element Target element
   * @param {String|Object} style Style to apply, 'border: 1px solid black' or { border: '1px solid black' }
   * @param {Boolean} [overwrite] Specify `true` to replace style instead of applying changes
   * @category CSS
   */
  static applyStyle(element, style, overwrite = false) {
    if (typeof style === 'string') {
      if (overwrite) {
        // Only assign if either end has any styles, do not want to add empty `style` tag on element
        if (style.length || element.style.cssText.length) {
          element.style.cssText = style;
        }
      } else {
        // Add style so as not to delete configs in style such as width, height, flex etc.
        // If a style is already there, the newest, appended one will take precedence.
        element.style.cssText += style;
      }
    } else {
      if (overwrite) {
        element.style.cssText = '';
        //element.removeAttribute('style');
      }

      // Prototype chained objects may be passed, so use direct loop.
      for (let key in style) {
        // Ignore readonly properties of the CSSStyleDeclaration object:
        // https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration
        if (!styleIgnoreProperties[key]) {
          // Append 'px' for numeric dimensions
          if (styleDimensionProperties[key] && typeof style[key] == 'number') {
            element.style[StringHelper.hyphenate(key)] = style[key] + 'px';
          } else {
            element.style[StringHelper.hyphenate(key)] = style[key];
          }
        }
      }
    }
  }

  static getCSSText(style) {
    if (typeof style === 'string') {
      return style;
    }

    let cssText = '';

    for (let key in style) {
      // Ignore readonly properties of the CSSStyleDeclaration object:
      // https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration
      if (!styleIgnoreProperties[key]) {
        cssText += `${StringHelper.hyphenate(key)}:${style[key]};`;
      }
    }

    return cssText;
  }

  // For IE11, it doesn't support adding/removing multiple classes at once

  /**
   * Add multiple classes to elements classList. Helper for IE11 which does not support it directly
   * @param {HTMLElement} element
   * @param {String[]} classes
   * @category CSS
   */
  static addClasses(element, classes) {
    classes.forEach((cls) => element.classList.add(cls));
  }

  /**
   * Remove multiple classes to elements classList. Helper for IE11 which does not support it directly
   * @param {HTMLElement} element
   * @param {String[]} classes
   * @category CSS
   */
  static removeClasses(element, classes) {
    classes.forEach((cls) => element.classList.remove(cls));
  }

  /**
   * Toggle multiple classes in elements classList. Helper for IE11 which does not support toggling with force or for
   * multiple classes at once.
   * @param {HTMLElement} element
   * @param {String[]} classes
   * @param {Boolean} [force] Specify true to add classes, false to remove. Leave blank to toggle
   * @category CSS
   */
  static toggleClasses(element, classes, force = null) {
    if (!Array.isArray(classes)) {
      classes = [classes];
    }

    if (force === true) {
      this.addClasses(element, classes);
    } else if (force === false) {
      this.removeClasses(element, classes);
    } else {
      classes.forEach((cls) => element.classList.toggle(cls));
    }
  }

  /**
   * Adds a CSS class to an element during the specified duration
   * @param {HTMLElement} element Target element
   * @param {String} cls CSS class to add temporarily
   * @param {Number} duration Duration in ms, 0 means cls will not be applied
   * @category CSS
   */
  static addTemporaryClass(element, cls, duration) {
    if (duration > 0) {
      element.classList.add(cls);
      setTimeout(() => {
        element && element.classList.remove(cls);
      }, duration);
    }
  }

  //endregion

  //region Effects

  /**
   * Highlights the passed element or Rectangle according to the theme's highlihghting rules.
   * Usually an animated framing effect.
   * @param {HTMLElement/Common.helper.util.Rectangle} element The element or Rectangle to highlight.
   */
  static highlight(element) {
    if (element instanceof Rectangle) {
      return element.highlight();
    }
    return new Promise((resolve) => {
      setTimeout(() => {
        element.classList.add('b-fx-highlight');
        setTimeout(() => {
          element.classList.remove('b-fx-highlight');
          resolve();
        }, 1000);
      }, 0);
    });
  }

  //endregion

  //region Measuring / Scrollbar

  /**
   * Measures the scrollbar width using a hidden div. Caches result
   * @returns {Number}
   * @readonly
   */
  static get scrollBarWidth() {
    // Ensure the measurement is only done once, when the value is null and body is available
    if (scrollBarWidth === null && doc.body) {
      const element = DomHelper.createElement({
        parent: doc.body,
        style: 'position:absolute;top:-999px;width:100px;height:100px;overflow:scroll'
      });
      scrollBarWidth = element.offsetWidth - element.clientWidth;
      element.remove();
    }

    return scrollBarWidth;
  }

  /**
   * Resets DomHelper.scrollBarWidth cache, triggering a new measurement next time it is read
   */
  static resetScrollBarWidth() {
    scrollBarWidth = null;
  }

  /**
   * Measures the text width using a hidden div
   * @param {String} text
   * @param {HTMLElement} sourceElement
   * @returns {Number} width
   * @category Measure
   */
  static measureText(text, sourceElement, useHTML, parentElement) {
    const offScreenDiv = this.getMeasureElement(sourceElement, parentElement);

    offScreenDiv[useHTML ? 'innerHTML' : 'innerText'] = text;

    const result = offScreenDiv.clientWidth;
    offScreenDiv.className = '';

    return result;
  }

  /**
   * Measures a relative size, such as a size specified in `em` units for the passed element.
   * @param {String} size The CSS size value to measure.
   * @param {HTMLElement} sourceElement
   * @returns {Number} size The size in pixels of the passed relative measurement.
   * @category Measure
   */
  static measureSize(size, sourceElement) {
    if (!size) {
      return 0;
    }

    if (typeof size === 'number') {
      return size;
    }

    if (!size.length) {
      return 0;
    }

    if (/^\d+(px)?$/.test(size)) {
      return parseInt(size);
    }

    if (sourceElement) {
      const offScreenDiv = this.getMeasureElement(sourceElement);
      offScreenDiv.innerHTML = '';
      offScreenDiv.style.width = DomHelper.setLength(size);
      //const result = BrowserHelper.isIE11 ?  offScreenDiv.offsetWidth : offScreenDiv.clientWidth;
      const result = offScreenDiv.offsetWidth;
      offScreenDiv.style.width = offScreenDiv.className = '';
      return result;
    }

    if (/^\d+em$/.test(size)) {
      return parseInt(size) * DEFAULT_FONT_SIZE;
    }

    return isNaN(size) ? 0 : parseInt(size);
  }

  // parentElement allows measurement to happen inside a specific element, allowing scoped css rules to match
  static getMeasureElement(sourceElement, parentElement = doc.body) {
    const sourceElementStyle = win.getComputedStyle(sourceElement),
      offScreenDiv = (parentElement.offScreenDiv =
        parentElement.offScreenDiv ||
        DomHelper.createElement(
          {
            parent: parentElement,
            style: 'position:fixed;top:-10000px;left:-10000px;visibility:hidden;contain:strict',
            className: 'b-measure-element',
            children: [
              {
                style: 'white-space:nowrap;display:inline-block;will-change:contents;width:auto;contain:none'
              }
            ]
          },
          true
        )[1]);

    fontProps.forEach((prop) => {
      if (offScreenDiv.style[prop] !== sourceElementStyle[prop]) {
        offScreenDiv.style[prop] = sourceElementStyle[prop];
      }
    });
    offScreenDiv.className = sourceElement.className;

    // In case the measure element was moved/removed, re-add it
    if (offScreenDiv.parentElement.parentElement !== parentElement) {
      parentElement.appendChild(offScreenDiv.parentElement);
    }

    return offScreenDiv;
  }

  //endregion

  //region Sync

  /**
   * Sync one source element attributes, children etc. to a target element. Source element can be specified as a html
   * string, as a `createElement` config or an actual HTMLElement
   * @param {String|HTMLElement|Object} config Source "element" to copy from or a config object with the following options:
   * @param {HTMLElement} [config.sourceElement] Source element to copy from. Mutually exclusive with `html` and `elementConfig`
   * @param {String} [config.html] HTML string to use instead of source element. Mutually exclusive with `sourceElement` and `elementConfig`
   * @param {Object} [config.elementConfig] A `createElement` config object defining a source element. Mutually exclusive with `sourceElement` and `html`
   * @param {Object} [config.targetElement] Target element to apply to
   * @param {Boolean|String} [config.useSyncId] Specify `true` to use `dataset.syncId` for element re-usage, or a string to match elements on another dataset field. Only valid in combination with `elementConfig`
   * @param {Function} [config.callback] A function that will be called on element reusage, creation and similar
   * @param {HTMLElement} targetElement Target element to apply to, can also be specified as part of the config object
   * @returns {HTMLElement} Returns the updated targetElement (which is also updated in place)
   */
  static sync(config, targetElement) {
    let element = config,
      useSyncId = false;

    if (!(config instanceof HTMLElement) && typeof config !== 'string') {
      if (config.sourceElement) {
        element = config.sourceElement;
      } else if (config.html) {
        element = config.html;
      } else if (config.elementConfig) {
        element = config.elementConfig;
      }

      if (config.targetElement) {
        targetElement = config.targetElement;
      }

      // true -> syncId, otherwise use specified value
      useSyncId = config.useSyncId === true ? 'syncId' : config.useSyncId;

      if (useSyncId && !config.elementConfig) {
        throw new Error('syncId can only be used in combination with elementConfig');
      }
    }

    if (typeof element === 'string') {
      element = this.createElementFromTemplate(element);
    }

    this.performSync(element, targetElement, useSyncId, config.callback);

    return targetElement;
  }

  // Internal helper used for recursive syncing
  static performSync(sourceElement, targetElement, useSyncId, callback) {
    const isElement = sourceElement instanceof HTMLElement,
      onlyChildren = !isElement ? sourceElement.onlyChildren : false;

    // Syncing identical elements is a no-op
    if (
      // When syncing elements, compare outerHTML
      (isElement && sourceElement.outerHTML !== targetElement.outerHTML) ||
      // When syncing a config, compare to config cached on target element
      (!isElement &&
        (!useSyncId || !ObjectHelper.isDeeplyEqual(sourceElement, targetElement.lastConfig, syncEqualityEvaluator)))
    ) {
      // TODO: Since targetElement holds its previously used config in lastConfig it would be possible to compare to
      //   that instead of to the actual element, to gain some speed
      // Sync without affecting then containing element?
      if (!onlyChildren) {
        this.syncAttributes(sourceElement, targetElement);
        this.syncContent(sourceElement, targetElement);
      }

      this.syncChildren(sourceElement, targetElement, useSyncId, callback);

      // When using config, cache the config on the target for future comparison
      if (!isElement) {
        targetElement.lastConfig = sourceElement;
      }

      return true;
    } else if (!isElement) {
      // Sync took no action, notify the world
      callback &&
        callback({
          action: 'none',
          config: sourceElement,
          element: targetElement
        });
    }

    return false;
  }

  // Attributes as map { attr : value, ... }, either from an html element or from a config
  static getSyncAttributes(elementOrConfig) {
    const attributes = {},
      // Attribute names, simplifies comparisons and calls to set/removeAttribute
      names = [];

    // Extract from element
    if (elementOrConfig instanceof HTMLElement) {
      for (let i = 0; i < elementOrConfig.attributes.length; i++) {
        const attr = elementOrConfig.attributes[i];
        if (attr.specified) {
          const name = attr.name.toLowerCase();
          attributes[name] = attr.value;
          names.push(name);
        }
      }
    }
    // Or from elementConfig
    else {
      Object.keys(elementOrConfig).forEach((attr) => {
        if (!syncIgnoreAttributes[attr]) {
          const originalAttr = attr;

          if (attr === 'className') {
            attr = 'class';
          }

          const name = attr.toLowerCase();
          attributes[name] = elementOrConfig[originalAttr];
          names.push(name);
        }
      });
    }

    return { attributes, names };
  }

  /**
   * Syncs attributes from sourceElement to targetElement.
   * @private
   * @param {HTMLElement|Object} sourceElement
   * @param {HTMLElement} targetElement
   */
  static syncAttributes(sourceElement, targetElement) {
    const // Extract attributes from elements (sourceElement might be a config)
      { attributes: sourceAttributes, names: sourceNames } = this.getSyncAttributes(sourceElement),
      { attributes: targetAttributes, names: targetNames } = this.getSyncAttributes(targetElement),
      // Used to ignore data-xx attributes when we will be setting entire dataset
      hasDataset = sourceNames.includes('dataset'),
      // Intersect arrays to determine what needs adding, removing and syncing
      toAdd = sourceNames.filter((attr) => !targetNames.includes(attr)),
      toRemove = targetNames.filter(
        (attr) => !sourceNames.includes(attr) && (!hasDataset || !attr.startsWith('data-'))
      ),
      toSync = sourceNames.filter((attr) => targetNames.includes(attr));

    if (toAdd.length > 0) {
      for (let i = 0; i < toAdd.length; i++) {
        const attr = toAdd[i];

        // Style requires special handling
        if (attr === 'style') {
          this.applyStyle(targetElement, sourceAttributes.style, true);
        }
        // So does dataset
        else if (attr === 'dataset') {
          Object.assign(targetElement.dataset, sourceAttributes.dataset);
        }
        // Other attributes are set using setAttribute (since it calls toString() DomClassList works fine)
        else {
          targetElement.setAttribute(attr, sourceAttributes[attr]);
        }
      }
    }

    if (toRemove.length > 0) {
      for (let i = 0; i < toRemove.length; i++) {
        targetElement.removeAttribute(toRemove[i]);
      }
    }

    if (toSync.length > 0) {
      for (let i = 0; i < toSync.length; i++) {
        const attr = toSync[i];
        // Set all attributes that has changed, with special handling for style
        if (attr === 'style') {
          // TODO: Check for changes?
          this.applyStyle(targetElement, sourceAttributes.style, true);
        }
        // And dataset
        else if (attr === 'dataset') {
          // TODO: Any cost to assigning same values?
          Object.assign(targetElement.dataset, sourceAttributes.dataset);
        }
        // And class, which might be a DomClassList
        else if (attr === 'class' && sourceAttributes[attr].isDomClassList) {
          if (!sourceAttributes.class.isEqual(targetAttributes.class)) {
            targetElement.setAttribute('class', sourceAttributes.class);
          }
        } else if (targetAttributes[attr] !== sourceAttributes[attr]) {
          targetElement.setAttribute(attr, sourceAttributes[attr]);
        }
      }
    }
  }

  /**
   * Sync content (innerText) from sourceElement to targetElement
   * @private
   * @param {HTMLElement|Object} sourceElement
   * @param {HTMLElement} targetElement
   */
  static syncContent(sourceElement, targetElement) {
    let sourceChildCount,
      html = null;

    if (sourceElement instanceof HTMLElement) {
      sourceChildCount = sourceElement.childElementCount;
    } else {
      sourceChildCount = sourceElement.children ? sourceElement.children.length : 0;
      html = sourceElement.html;

      // elementData holds custom data that we want to attach to the element (not visible in dom)
      if (sourceElement.elementData) {
        targetElement.elementData = sourceElement.elementData;
      }
    }

    // No child elements in source, remove any from target
    if (sourceChildCount === 0 && targetElement.childElementCount > 0 && !html) {
      targetElement.innerHTML = '';
    }
    // Apply html from config
    else if (html) {
      // If given a DocumentFragment, replace content with it
      if (html instanceof DocumentFragment) {
        // Syncing a textNode to a textNode? Use shortcut
        if (
          targetElement.childNodes.length === 1 &&
          targetElement.childElementCount === 0 &&
          html.childNodes.length === 1 &&
          html.childElementCount === 0
        ) {
          this.setInnerText(targetElement, html.firstChild.data);
        } else {
          // TODO: Is there a faster way?
          targetElement.innerHTML = '';
          targetElement.appendChild(html);
        }
      }
      // Something that might be html, set innerHTML
      else if (html.includes('<')) {
        targetElement.innerHTML = html;
      }
      // Plain text, prefer setting data on first text node
      else {
        this.setInnerText(targetElement, html);
      }
    }
  }

  static setInnerText(targetElement, text) {
    // setting firstChild.data is faster than innerText (and innerHTML),
    // but in some cases the inner node is lost and needs to be recreated
    const firstChild = targetElement.firstChild;
    if (firstChild) {
      firstChild.data = text;
    } else {
      // textContent is supposed to be faster than innerText, since it does not trigger layout
      targetElement.textContent = text;
    }
  }

  // Sync children of one element to another
  static syncChildrenElement(sourceElement, targetElement) {
    const me = this,
      sourceNodes = arraySlice.call(sourceElement.childNodes),
      targetNodes = arraySlice.call(targetElement.childNodes);

    while (sourceNodes.length) {
      const sourceNode = sourceNodes.shift(),
        targetNode = targetNodes.shift();

      // only textNodes and elements allowed (no comments)
      if (sourceNode && sourceNode.nodeType !== Node.TEXT_NODE && sourceNode.nodeType !== Node.ELEMENT_NODE) {
        throw new Error(`Source node type ${sourceNode.nodeType} not supported by DomHelper.sync()`);
      }
      if (targetNode && targetNode.nodeType !== Node.TEXT_NODE && targetNode.nodeType !== Node.ELEMENT_NODE) {
        throw new Error(`Target node type ${targetNode.nodeType} not supported by DomHelper.sync()`);
      }

      if (!targetNode) {
        // out of target nodes, add to target
        targetElement.appendChild(sourceNode);
      } else {
        // match node

        if (sourceNode.nodeType === targetNode.nodeType) {
          // same type of node, take action depending on which type
          if (sourceNode.nodeType === Node.TEXT_NODE) {
            // text
            targetNode.data = sourceNode.data;
          } else {
            if (sourceNode.tagName === targetNode.tagName) {
              me.performSync(sourceNode, targetNode);
            } else {
              // new tag, remove targetNode and insert new element
              targetElement.insertBefore(sourceNode, targetNode);
              targetNode.remove();
            }
          }
        }
        // Trying to set text node as element, use it as innerText
        // (we get this in FF with store mutations and List)
        else if (sourceNode.nodeType === Node.TEXT_NODE && targetNode.nodeType === Node.ELEMENT_NODE) {
          targetElement.innerText = sourceNode.data.trim();
        } else {
          throw new Error('Currently no support for transforming nodeType');
        }
      }
    }

    // Out of source nodes, remove remaining target nodes
    targetNodes.forEach((targetNode) => {
      targetNode.remove();
    });
  }

  // Sync children from a config object to an element, able to reuse elements
  static syncChildrenConfig(config, targetElement, syncIdField, callback) {
    // Having specified html replaces all inner content, no point in syncing
    if (config.html) {
      return;
    }

    const me = this,
      sourceConfigs = arraySlice.call(config.children || []),
      targetElements = arraySlice.call(targetElement.children),
      syncIdMap = targetElement.syncIdMap || {};

    let syncId;

    // Always repopulate the map, since elements might get used by other syncId below
    if (syncIdField) {
      targetElement.syncIdMap = {};
    }

    while (sourceConfigs.length) {
      const sourceConfig = sourceConfigs.shift();

      // If syncIdField was supplied, we should first try to reuse element with matching "id"
      if (syncIdField && sourceConfig.dataset) {
        syncId = sourceConfig.dataset[syncIdField];
        // We have an id to look for
        if (syncId != null && !sourceConfig.unmatched) {
          // Find any matching element
          const syncTargetElement = syncIdMap[syncId];
          if (syncTargetElement) {
            if (
              // Ignore if flagged with `retainElement` (for example during dragging)
              !sourceConfig.retainElement &&
              // Otherwise sync with the matched element
              me.performSync(sourceConfig, syncTargetElement, syncIdField, callback)
            ) {
              // Sync took some action, notify the world
              callback &&
                callback({
                  action: 'reuseOwnElement',
                  config: sourceConfig,
                  element: syncTargetElement,
                  syncId
                });
            }

            // Since it wont sync above when flagged to be retained, we need to apply the flag here
            if (sourceConfig.retainElement) {
              syncTargetElement.retainElement = true;
            }
            // And remove it when no longer needed
            else if (syncTargetElement.retainElement) {
              syncTargetElement.retainElement = false;
            }

            // Cache the element on the syncId for faster retrieval later
            targetElement.syncIdMap[syncId] = syncTargetElement;

            // Attach to config to be reachable by caller
            sourceConfig._element = syncTargetElement;

            // Remove our target from targetNodes, no other node is allowed to sync with it
            ArrayHelper.remove(targetElements, syncTargetElement);

            syncTargetElement.isReleased = false;
          } else {
            // No match, move to end of queue to not steal some one else's element
            sourceConfigs.push(sourceConfig);
            // Also flag as unmatched to know that when we reach this element again
            sourceConfig.unmatched = true;
          }
          // Node handled, carry on with next one
          continue;
        }
      }

      // Avoid polluting the config object when done
      if (sourceConfig.unmatched) {
        delete sourceConfig.unmatched;
      }

      // Skip over any retained elements
      let targetNode;

      for (let i = 0; i < targetElements.length && !targetNode; i++) {
        if (!targetElements[i].retainElement) {
          targetNode = targetElements[i];
          // shift is much faster than splice...
          if (i === 0) {
            targetElements.shift();
          } else {
            targetElements.splice(i, 1);
          }
        }
      }

      // Out of target nodes, add to target
      if (!targetNode) {
        // Create a new element, passing along the syncIdField if used, to allow populating the syncIdMap during creation
        const newElement = targetElement.appendChild(DomHelper.createElement(sourceConfig, false, null, syncIdField));

        // TODO: Move to createElement?
        if (syncId != null) {
          targetElement.syncIdMap[syncId] = newElement;
        }

        sourceConfig._element = newElement;

        callback &&
          callback({
            action: 'newElement',
            config: sourceConfig,
            element: newElement,
            syncId
          });
      }
      // We have targets left
      else {
        // Matching element tag, sync it
        if ((sourceConfig.tag || 'div').toLowerCase() === targetNode.tagName.toLowerCase()) {
          const oldConfig = targetNode.lastConfig;

          me.performSync(sourceConfig, targetNode, syncIdField, callback);

          if (syncId != null) {
            targetElement.syncIdMap[syncId] = targetNode;
            targetNode.isReleased = false;
          }

          sourceConfig._element = targetNode;

          callback &&
            callback({
              action: 'reuseElement',
              config: sourceConfig,
              oldConfig,
              element: targetNode,
              syncId
            });
        }
        // Not matching, replace it
        else {
          const newElement = targetElement.insertBefore(DomHelper.createElement(sourceConfig), targetNode);

          // TODO: Move to createElement?
          if (syncId != null) {
            targetElement.syncIdMap[syncId] = newElement;
          }

          sourceConfig._element = newElement;

          callback &&
            callback({
              action: 'newElement',
              config: sourceConfig,
              element: newElement,
              syncId
            });

          targetNode.remove();
        }
      }
    }

    // Out of source nodes, remove remaining target nodes
    targetElements.forEach((targetNode) => {
      // Element might be retained, hands off (for example while dragging)
      if (!targetNode.retainElement) {
        // When using syncId to reuse elements, "release" left over elements instead of removing them
        if (syncIdField) {
          // Prevent releasing already released element
          if (!targetNode.isReleased) {
            targetNode.className = 'b-released';
            targetNode.isReleased = true;

            callback &&
              callback({
                action: 'releaseElement',
                config: targetNode.lastConfig,
                oldConfig: targetNode.lastConfig,
                element: targetNode
              });

            targetNode.elementData = targetNode.lastConfig = null;
          }
        }
        // In normal sync mode, remove left overs
        else {
          targetNode.remove();
        }
      } else if (syncIdField) {
        // Keep retained element in map
        targetElement.syncIdMap[targetNode.dataset[syncIdField]] = targetNode;
      }
    });
  }

  /**
   * Sync traversing children
   * @private
   * @param {HTMLElement|Object} sourceElement Source element
   * @param {HTMLElement} targetElement Target element
   * @param {String} syncIdField Field in dataset to use for element re-usage
   */
  static syncChildren(sourceElement, targetElement, syncIdField, callback) {
    if (sourceElement instanceof HTMLElement) {
      this.syncChildrenElement(sourceElement, targetElement, syncIdField, callback);
    } else {
      this.syncChildrenConfig(sourceElement, targetElement, syncIdField, callback);
    }
  }

  /**
   * Synchronizes the passed element's `classList` with the class names
   * passed in either Array or String format or Object. Avoiding mutating an element's
   * `classList` or `className` can avoid browser style recalculations.
   * @param {HTMLElement} element The element whose class list to synchronize.
   * @param {String[]|String|Object} newClasses The incoming class names to set on the element.
   * @category CSS
   */
  static syncClassList(element, newClasses) {
    const classList = element.classList,
      isString = typeof newClasses === 'string',
      newClsArray = isString
        ? newClasses.trim().split(whiteSpaceRe$1)
        : Array.isArray(newClasses)
        ? newClasses
        : ObjectHelper.getTruthyKeys(newClasses),
      classCount = newClsArray.length;

    let changed = classList.length !== classCount,
      i;

    // If the incoming and existing class lists are the same length
    // then check that each contains the same names. As soon as
    // we find a non-matching name, we know we have to update the
    // className.
    for (i = 0; !changed && i < classCount; i++) {
      changed = !classList.contains(newClsArray[i]);
    }

    if (changed) {
      element.className = isString ? newClasses : newClsArray.join(' ');
    }
  }

  /**
   * Changes the theme to the passed theme name if possible.
   *
   * Theme names are case insensitive. The `href` used is all lower case.
   *
   * To use this method, the `<link rel="stylesheet">` _must_ use the default,
   * Bryntum-supplied CSS files where the `href` end with `<themeName>.css`, so that
   * it can be found in the document, and switched out for a new link with
   * the a modified `href`. The new `href` will use the same path, just
   * with the `themeName` portion subsituted for the new name.
   *
   * If no `<link>` with that name pattern can be found, an error will be thrown.
   *
   * If you use this method, you  must ensure that the theme files are
   * all accessible on your server.
   *
   * Because this is an asynchronous operation, a `Promise` is returned.
   * The theme change event is passed to the success function. If the
   * theme was not changed, because the theme name passed is the current theme,
   * nothing is passed to the success function.
   *
   * The theme change event contains two properties:
   *
   *  - `prev` The previous Theme name.
   *  - `theme` The new Theme name.
   *
   * @param {String} newThemeName
   * @returns {Promise} A promise who's success callback receives the theme change
   * event if the theme in fact changed. If the theme `href` could not be loaded,
   * the failure callback is called, passing the error event caught.
   */
  static setTheme(newThemeName) {
    newThemeName = newThemeName.toLowerCase();

    const oldThemeName = this.themeInfo.name.toLowerCase(),
      oldThemeLink =
        document.head.querySelector('#bryntum-theme') || document.head.querySelector(`[href$="${oldThemeName}.css"]`);

    // Theme link href ends with <themeName>.css also there could be a query - css?11111...
    if (!oldThemeLink || !oldThemeLink.href.includes(`${oldThemeName}.css`)) {
      throw new Error(`Theme link for ${oldThemeName} not found`);
    }

    // Do not reapply same theme
    if (oldThemeLink.href.includes(newThemeName)) {
      return immediatePromise;
    }

    return new Promise((resolve, reject) => {
      const newThemeLink = document.createElement('link'),
        nextSibling = oldThemeLink.nextSibling,
        oldThemeName = DomHelper.themeInfo.name.toLowerCase(),
        themeEvent = {
          theme: newThemeName,
          prev: oldThemeName
        },
        onThemeLoad = () => {
          themeInfo = null;
          oldThemeLink.remove();
          window.bryntum.GlobalEvents.trigger('theme', themeEvent);
          resolve(themeEvent);
        },
        onThemeLoadError = (e) => {
          reject(e);
        };

      newThemeLink.rel = 'stylesheet';
      newThemeLink.id = 'bryntum-theme';
      newThemeLink.addEventListener('load', onThemeLoad);
      newThemeLink.addEventListener('error', onThemeLoadError);
      newThemeLink.href = oldThemeLink.href.replace(oldThemeName, newThemeName);
      nextSibling.parentNode.insertBefore(newThemeLink, nextSibling);
    });
  }

  /**
   * A theme information object about the current theme.
   *
   * Currently this has only one property:
   *
   *   - `name` The current theme name.
   * @property {Object}
   * @readonly
   */
  static get themeInfo() {
    if (!themeInfo) {
      const testDiv = this.createElement({
          parent: document.body,
          className: 'b-theme-info'
        }),
        // Need to be a pseudo element for Edge to report content correctly
        themeData = this.getStyleValue(testDiv, 'content', false, ':before');

      if (themeData) {
        // themeData could be invalid JSON string in case there is no content rule
        try {
          themeInfo = JSON.parse(themeData.replace(/^["']|["']$|\\/g, ''));
        } catch (e) {
          themeInfo = null;
        }
      }

      testDiv.remove();
    }
    return themeInfo;
  }

  //endregion
}

let clearTouchTimer;
const clearTouchEvent = () => (DomHelper.isTouchEvent = false),
  setTouchEvent = () => {
    DomHelper.isTouchEvent = true;

    // Jump round the click delay
    clearTimeout(clearTouchTimer);
    clearTouchTimer = setTimeout(clearTouchEvent, 400);
  };

// Set event type flags so that mousedown and click handlers can know whether a touch gesture was used.
// This is used. This must stay until we have a unified DOM event system which handles both touch and mouse events.
doc.addEventListener('touchstart', setTouchEvent, true);
doc.addEventListener('touchend', setTouchEvent, true);

DomHelper.supportsTemplate = 'content' in doc.createElement('template');

//region Polyfills

// TODO: include babels polyfills instead of keeping own?

if (!('children' in Node.prototype)) {
  const elementFilter = (node) => node.nodeType === 1;
  Object.defineProperty(Node.prototype, 'children', {
    get: function() {
      return Array.prototype.filter.call(this.childNodes, elementFilter);
    }
  });
}

if (!Element.prototype.matches) {
  Element.prototype.matches =
    Element.prototype.matchesSelector ||
    Element.prototype.mozMatchesSelector ||
    Element.prototype.msMatchesSelector ||
    Element.prototype.oMatchesSelector ||
    Element.prototype.webkitMatchesSelector ||
    function(s) {
      let matches = (this.document || this.ownerDocument).querySelectorAll(s),
        i = matches.length;
      while (--i >= 0 && matches.item(i) !== this) {}
      return i > -1;
    };
}

if (win.Element && !Element.prototype.closest) {
  Node.prototype.closest = Element.prototype.closest = function(s) {
    var el = this;
    if (!doc.documentElement.contains(el)) return null;

    do {
      if (el.matches(s)) return el;
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);
    return null;
  };
} else {
  // It's crazy that closest is not already on the Node interface!
  Node.prototype.closest = function(selector) {
    return this.parentNode.closest(selector);
  };
}

// from:https://github.com/jserz/js_piece/blob/master/DOM/ChildNode/remove()/remove().md
(function(arr) {
  arr.forEach(function(item) {
    if (item.hasOwnProperty('remove')) {
      return;
    }
    Object.defineProperty(item, 'remove', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function remove() {
        this.parentNode && this.parentNode.removeChild(this);
      }
    });
  });
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);

// IE11 polyfill
if (!SVGElement.prototype.contains) {
  SVGElement.prototype.contains = function(node) {
    do {
      if (this === node) {
        return true;
      }
      node = node.parentNode;
    } while (node);

    return false;
  };
}

// IE11 polyfill for Event constructors
if (typeof win.CustomEvent !== 'function') {
  let evt, constructor;

  win.CustomEvent = constructor = function(
    event,
    params = {
      bubbles: false,
      cancelable: false,
      detail: undefined
    }
  ) {
    evt = doc.createEvent('CustomEvent');
    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    return evt;
  };
  constructor.prototype = win.Event.prototype;

  win.MouseEvent = constructor = function(
    event,
    params = {
      bubbles: false,
      cancelable: false,
      detail: undefined
    }
  ) {
    evt = doc.createEvent('MouseEvents');
    evt.initMouseEvent(
      event,
      params.bubbles,
      params.cancelable,
      doc.defaultView || win,
      params.detail,
      params.screenX,
      params.screenY,
      params.clientX,
      params.clientY,
      false,
      false,
      false,
      false,
      0,
      document
    );
    return evt;
  };
  constructor.prototype = win.Event.prototype;

  win.KeyboardEvent = constructor = function(
    event,
    params = {
      bubbles: false,
      cancelable: false,
      detail: undefined
    }
  ) {
    const modifiers = `${params.shiftKey ? 'Shift ' : ''}${params.ctrlKey ? 'Control' : ''}`;

    evt = doc.createEvent('KeyboardEvent');
    evt.initKeyboardEvent(
      event,
      params.bubbles,
      params.cancelable,
      doc.defaultView || win,
      params.key,
      params.location,
      modifiers,
      false,
      ''
    );
    return evt;
  };
  constructor.prototype = win.Event.prototype;
}

//endregion

// https://gist.github.com/brettz9/4093766
if (BrowserHelper.isEdge) {
  if (
    !Object.getOwnPropertyDescriptor(SVGElement.prototype, 'dataset') ||
    !Object.getOwnPropertyDescriptor(SVGElement.prototype, 'dataset').get
  ) {
    var propDescriptor = {
      enumerable: true,
      get: function() {
        var i,
          that = this,
          map = {},
          attrVal,
          attrName,
          propName,
          attribute,
          attributes = this.attributes,
          attsLength = attributes.length,
          toUpperCase = function(n0) {
            return n0.charAt(1).toUpperCase();
          },
          getter = function() {
            return this;
          },
          setter = function(attrName, value) {
            return typeof value !== 'undefined' ? this.setAttribute(attrName, value) : this.removeAttribute(attrName);
          };

        for (i = 0; i < attsLength; i++) {
          attribute = attributes[i];
          // Fix: This test really should allow any XML Name without
          //         colons (and non-uppercase for XHTML)
          if (attribute && attribute.name && /^data-\w[\w-]*$/.test(attribute.name)) {
            attrVal = attribute.value;
            attrName = attribute.name;
            // Change to CamelCase
            propName = attrName.substr(5).replace(/-./g, toUpperCase);
            Object.defineProperty(map, propName, {
              enumerable: this.enumerable,
              get: getter.bind(attrVal || ''),
              set: setter.bind(that, attrName)
            });
          }
        }
        return map;
      }
    };
    // FF enumerates over element's dataset, but not
    // SVGElement.prototype.dataset; IE9 iterates over both
    Object.defineProperty(SVGElement.prototype, 'dataset', propDescriptor);
  }
}

// Polyfill to allow an array to be passed to classList.add/remove
const nativeAdd = DOMTokenList.prototype.add,
  nativeRemove = DOMTokenList.prototype.remove;

DOMTokenList.prototype.add = function(cls) {
  if (Array.isArray(cls)) {
    nativeAdd.call(this, ...cls);
  } else {
    nativeAdd.call(this, ...arguments);
  }
};
DOMTokenList.prototype.remove = function(cls) {
  if (Array.isArray(cls)) {
    nativeRemove.call(this, ...cls);
  } else {
    nativeRemove.call(this, ...arguments);
  }
};
DomHelper._$name = 'DomHelper';

//TODO: add loader
/**
 * @module Common/widget/Mask
 */

/**
 * Masks an element (document.body if no element specified). Call static methods for ease of use or make instance for
 * reusability.
 *
 * @example
 * Mask.mask('hello');
 * Mask.unmask();
 *
 * @externalexample widget/Mask.js
 */
class Mask extends Delayable() {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Mode: bright, bright-blur, dark or dark-blur
       * @config {String}
       * @default
       */
      mode: 'dark',

      /**
       * The icon to show next to the text. Defaults to showing a spinner
       * @config {String}
       * @default
       */
      icon: 'b-icon b-icon-spinner',

      /**
       * The text (or HTML) to show in mask
       * @config {String}
       */
      text: null
    };
  }

  //endregion

  //region Init

  construct(config) {
    super.construct(config);

    if (!this.element) {
      this.element = document.body;
    }

    this.show();
  }

  doDestroy() {
    const me = this;

    if (me.maskElement) {
      me.maskElement.remove();
      me.maskElement = null;
      if (me.mode.endsWith('blur')) {
        DomHelper.forEachChild(me.element, (child) => {
          child.classList.remove(`b-masked-${me.mode}`);
        });
      }
      me.element.mask = null;
    }
    super.doDestroy();
  }

  /**
   * Creates mask element
   * @private
   */
  create() {
    const me = (this.element.mask = this);

    me.maskElement = DomHelper.createElement({
      parent: me.element,
      className: `b-mask b-widget b-mask-${me.mode}`
    });
    me.text = me._text;
  }

  //endregion

  //region Static

  /**
   * Shows a mask with the specified message
   * @param {String|Object} text Message
   * @param {HTMLElement} element Element to mask
   * @returns {Common.widget.Mask}
   */
  static mask(text, element = document.body) {
    return new Mask(
      typeof text !== 'string'
        ? Object.assign({ element }, text)
        : {
            element,
            text
          }
    );
  }

  /**
   * Unmask
   * @param {HTMLElement} element Element to unmask
   * @returns {Promise} A promise which is resolved when the mask is gone
   */
  static unmask(element = document.body) {
    return element.mask && element.mask.close();
  }

  //endregion

  //region Mask content

  /**
   * Gets or sets the text displayed in the mask
   * @property {String}
   */
  set text(txt) {
    let me = this;

    me._text = txt || '';

    if (me.maskElement) {
      me.maskElement.innerHTML = `<div class="b-mask-content"><i class="b-mask-icon ${me.icon}"></i>${me._text}</i>`;
    }
  }

  get text() {
    return this._text;
  }

  //endregion

  //region Show & hide

  /**
   * Show mask
   */
  show() {
    const me = this;

    if (me.hasTimeout('hide')) {
      // TODO: Consider this behaviour, should showing a mask which is not fully hidden resolve?
      me.resolve();
      me.clearTimeout('hide');
    }

    if (!me.element.mask) {
      me.create();
    }
    const { element, maskElement } = me;

    if (!maskElement) return; // already masked by other instance, only allowing one

    element.classList.add('b-masked');
    maskElement.classList.add('b-visible');
    maskElement.classList.remove('b-hidden');
    me.shown = true;

    // blur has to blur child elements
    if (me.mode.endsWith('blur')) {
      DomHelper.forEachChild(element, (child) => {
        if (child !== maskElement) {
          child.classList.add(`b-masked-${me.mode}`);
        }
      });
    }
  }

  /**
   * Hide mask
   * @returns {Promise} A promise which is resolved when the mask is hidden, or immediately if already hidden
   */
  hide() {
    const me = this,
      { element, maskElement } = me;

    return new Promise((resolve) => {
      if (me.shown) {
        me.shown = false;
        maskElement.classList.remove('b-visible');
        maskElement.classList.add('b-hidden');
        element.classList.remove('b-masked');

        if (me.mode.endsWith('blur')) {
          DomHelper.forEachChild(element, (child) => {
            if (child !== maskElement) {
              child.classList.remove(`b-masked-${me.mode}`);
            }
          });
        }

        // TODO: use AnimationHelper when available
        me.resolve = resolve;
        me.setTimeout(() => resolve(), 500, 'hide');
      } else {
        resolve();
      }
    });
  }

  /**
   * Close mask (removes it)
   * @returns {Promise} A promise which is resolved when the mask is closed
   */
  close() {
    return new Promise((resolve) => {
      this.hide().then(() => {
        this.destroy();
        resolve();
      });
    });
  }

  //endregion
}
Mask._$name = 'Mask';

/* globals ResizeObserver: true */

let resizeFireTimer = null;

const resizedQueue = [],
  isAbsolutelyPositioned = (n) =>
    n.nodeType === 1 && n.ownerDocument.defaultView.getComputedStyle(n).getPropertyValue('position') === 'absolute';

/**
 * @module Common/helper/ResizeMonitor
 */

/**
 * Allows size monitoring of elements.
 *
 * ```
 * ResizeMonitor.addResizeListener(
 *   myElement,
 *   element => {
 *      console.log(element, ' changed size');
 *   }
 * );
 * ```
 *
 * @internal
 */
class ResizeMonitor {
  /**
   * Adds a resize listener to the passed element which is called when the element
   * is resized by layout.
   * @param {HTMLElement} element The element to listen for resizing.
   * @param {Function} handler The handling function. Will be passed the element.
   */
  static addResizeListener(element, handler) {
    const me = this;

    if (element === document || element === window) {
      element = document.body;
    }

    if (!element.classList.contains('b-resize-monitored')) {
      element.classList.add('b-resize-monitored');
      element._bResizemonitor = {
        handlers: []
      };
    }

    // If we're looking at the document, or body, use a window resize listener.
    if (element === document.body) {
      if (!me.hasWindowResizeListener) {
        // Throttle the reaction to window resize to only fire once every 100ms
        window.addEventListener('resize', me.onWindowResize);
      }
    }
    // Regular element - use ResizeObserver by preference
    else if (window.ResizeObserver) {
      if (!me.resizeObserver) {
        me.resizeObserver = new ResizeObserver(me.onElementResize);
      }
      me.resizeObserver.observe(element);
    }
    // Polyfill ResizeObesrver
    else {
      const [monitors, expand, shrink] = DomHelper.createElement(
        {
          parent: element,
          className: 'b-resize-monitors',
          children: [
            {
              className: 'b-resize-monitor-expand'
            },
            {
              className: 'b-resize-monitor-shrink'
            }
          ]
        },
        true
      );
      expand.scrollLeft = expand.scrollTop = shrink.scrollLeft = shrink.scrollTop = 1000000;
      expand.addEventListener('scroll', me.onSizeMonitorScroll, true);
      shrink.addEventListener('scroll', me.onSizeMonitorScroll, true);

      // Also need to fake a resize-scroll on DOM mutation
      (handler.targetMutationMonitor = new MutationObserver((m) => {
        const changedNodes = [];

        for (let mr of m) {
          if (mr.type === 'childList') {
            changedNodes.push.apply(changedNodes, mr.removedNodes);
            changedNodes.push.apply(changedNodes, mr.addedNodes);
          }
        }
        // If the changed nodes were absolutely positioned, then they won't
        // cause a resize, so return
        if (changedNodes.length > 0 && changedNodes.every(isAbsolutelyPositioned)) {
          return;
        }
        expand.dispatchEvent(new CustomEvent('scroll', {}));
      })).observe(element, {
        childList: true,
        subtree: true
      });

      // store reference for easier cleanup later
      handler.monitorElement = monitors;
    }
    element._bResizemonitor.handlers.push(handler);
  }

  /**
   * Removes a resize listener from the passed element.
   * @param {HTMLElement} element The element to listen for resizing.
   * @param {Function} handler The handling function to remove.
   */
  static removeResizeListener(element, handler) {
    if (element) {
      if (element === document || element === window) {
        element = document.body;
      }
      const resizeMonitor = element._bResizemonitor;

      if (resizeMonitor && resizeMonitor.handlers) {
        ArrayHelper.remove(resizeMonitor.handlers, handler);

        // remove any added elements
        if (handler.monitorElement) {
          handler.monitorElement.remove();
          handler.monitorElement = null;
        }
        // remove the DOM mutation observer
        if (handler.targetMutationMonitor) {
          handler.targetMutationMonitor.disconnect();
        }

        // Down to no listeners.
        if (!resizeMonitor.handlers.length) {
          if (this.resizeObserver) {
            this.resizeObserver.unobserve(element);
          }
        }
      }
    }
  }

  static onElementResize(entries) {
    for (let resizeObserverEntry of entries) {
      let resizedElement = resizeObserverEntry.target,
        resizeMonitor = resizedElement._bResizemonitor,
        newRect = resizeObserverEntry.contentRect || resizedElement.getBoundingClientRect();

      if (resizedElement.offsetParent) {
        if (
          !resizeMonitor.rectangle ||
          newRect.width !== resizeMonitor.rectangle.width ||
          newRect.height !== resizeMonitor.rectangle.height
        ) {
          const oldRect = resizeMonitor.rectangle;
          resizeMonitor.rectangle = newRect;
          for (let resizeHandler of resizeMonitor.handlers) {
            resizeHandler(resizedElement, oldRect, newRect);
          }
        }
      }
    }
  }

  static onSizeMonitorScroll(e) {
    // If the element has gone, ignore the event; the listener will be removed automatically.
    if (document.body.contains(e.target)) {
      e.stopPropagation();

      const monitorNode = e.target.parentNode,
        resizedElement = monitorNode.parentNode,
        resizeMonitor = resizedElement._bResizemonitor,
        newRect = resizedElement.getBoundingClientRect();

      if (
        !resizeMonitor.rectangle ||
        newRect.width !== resizeMonitor.rectangle.width ||
        newRect.height !== resizeMonitor.rectangle.height
      ) {
        resizedQueue.push([resizedElement, resizeMonitor.rectangle, newRect]);
        resizeMonitor.rectangle = newRect;
        if (!resizeFireTimer) {
          resizeFireTimer = requestAnimationFrame(ResizeMonitor.fireResizeEvents);
        }
      }
      monitorNode.firstChild.scrollLeft = monitorNode.firstChild.scrollTop = monitorNode.childNodes[1].scrollTop = monitorNode.childNodes[1].scrollLeft = 1000000;
    }
  }

  static onWindowResize(e) {
    let resizedElement = document.body,
      resizeMonitor = resizedElement._bResizemonitor,
      oldRect = resizeMonitor.rectangle;

    resizeMonitor.rectangle = document.documentElement.getBoundingClientRect();

    for (let resizeHandler of resizedElement._bResizemonitor.handlers) {
      resizeHandler(resizedElement, oldRect, resizeMonitor.rectangle);
    }
  }

  static fireResizeEvents() {
    for (let resizedEntry of resizedQueue) {
      for (let resizeHandler of resizedEntry[0]._bResizemonitor.handlers) {
        // Checking offsetParent to avoid resizing of elements which are not visible or exist in DOM
        if (resizedEntry[0].offsetParent) {
          resizeHandler.apply(this, resizedEntry);
        }
      }
    }
    resizeFireTimer = null;
    resizedQueue.length = 0;
  }
}
ResizeMonitor._$name = 'ResizeMonitor';

/**
 * @module Common/helper/util/Point
 */

/**
 * Encapsulates an X,Y coordinate point.
 * @extends Common/helper/util/Rectangle
 */
class Point extends Rectangle {
  /**
   * Creates a new Point encapsulting the event's page position.
   * @param {Event} event
   * @typings ignore
   */
  static from(event) {
    const touchPoints = event.changedTouches;

    return new Point(
      touchPoints ? touchPoints[0].screenX : event.screenX,
      touchPoints ? touchPoints[0].screenY : event.pageY
    );
  }

  /**
   * Constructs a Point
   * @param x The X coordinate
   * @param y The Y coordinate
   */
  constructor(x, y) {
    super(x, y, 0, 0);
  }

  /**
   * Coerces this Point to be within the passed Rectangle. Translates it into the bounds.
   * @param {Common.helper.util.Rectangle} into The Rectangle into which to coerce this Point.
   */
  constrain(into) {
    this.x = Math.min(Math.max(this.x, into.x), into.right - 1);
    this.y = Math.min(Math.max(this.y, into.y), into.bottom - 1);
    return this;
  }

  toArray() {
    return [this.x, this.y];
  }
}

// The Rectangle class uses the Point class, but cannot import it.
// TODO: find a better way of getting a reference to the Point class in Rectangle.

// #8224 - Gantt angular demo doesn't work in production
// eslint-disable-next-line no-proto
Point.__proto__.Point = Point;
Point._$name = 'Point';

/**
 * @module Common/helper/FunctionHelper
 */

/**
 * Provides functionality for working with functions
 * @internal
 */
class FunctionHelper {
  static curry(func) {
    return function curried(...args) {
      if (args.length >= func.length) {
        return func.apply(this, args);
      } else {
        return function(...args2) {
          return curried.apply(this, args.concat(args2));
        };
      }
    };
  }

  static bindAll(obj) {
    for (let key in obj) {
      if (typeof obj[key] === 'function') {
        obj[key] = obj[key].bind(obj);
      }
    }
  }

  /**
   * Returns a function which calls the passed `interceptor` function first, and the passed `original` after
   * as long as the `interceptor` does not return `false`.
   * @param {Function} original The function to call second.
   * @param {Function} interceptor The function to call first.
   * @param {Object} [thisObj] The `this` reference when the functions are called.
   * @returns The return value from the `original` function **if it was called**, else `false`.
   */
  static createInterceptor(original, interceptor, thisObj) {
    return (...args) => {
      if (interceptor.call(thisObj, ...args) !== false) {
        return original.call(thisObj, ...args);
      }
      return false;
    };
  }

  /**
   * Returns a function which calls the passed `sequence` function after calling
   * the passed `original`.
   * @param {Function} original The function to call first.
   * @param {Function} sequence The function to call second.
   * @param {Object} [thisObj] The `this` reference when the functions are called.
   * @returns The value returned from the sequence if it returned a value, else the return
   * value from the original function.
   */
  static createSequence(original, sequence, thisObj) {
    return (...args) => {
      const origResult = original.call(thisObj, ...args),
        sequenceResult = sequence.call(thisObj, ...args);

      return sequenceResult === void 0 ? origResult : sequenceResult;
    };
  }

  /**
   * Create a "debounced" function which will call on the "leading edge" of a timer period.
   * When first invoked will call immediately, but invocations after that inside its buffer
   * period will be rejected, and *one* invocation will be made after the buffer period has expired.
   *
   * This is useful for responding immediately to a first mousemove, but from then on, only
   * calling the action function on a regular timer while the mouse continues to move.
   *
   * @param {Function} fn The function to call.
   * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Array} [extraArgs] The argument list to append to those passed to the function.
   * @param {Function} [alt] A function to call when the invocation is rejected due to buffer time not having expired.
   */
  static createThrottled(fn, buffer, thisObj, extraArgs, alt) {
    let lastCallTime = 0,
      callArgs,
      timerId,
      result;

    const invoke = () => {
      timerId = 0;
      lastCallTime = performance.now();
      callArgs.push.apply(callArgs, extraArgs);
      fn.apply(thisObj, callArgs);
    };

    result = function(...args) {
      let elapsed = performance.now() - lastCallTime;

      callArgs = args;

      // If it's been more then the buffer period since we invoked, we can call it now
      if (elapsed >= buffer) {
        clearTimeout(timerId);
        invoke();
      }
      // Otherwise, kick off a timer for the requested period.
      else {
        if (!timerId) {
          timerId = setTimeout(invoke, buffer - elapsed);
        }
        if (alt) {
          callArgs.push.apply(callArgs, extraArgs);
          alt.apply(thisObj, callArgs);
        }
      }
    };

    result.cancel = () => clearTimeout(timerId);

    return result;
  }

  /**
   * Create a "debounced" function which will call on the "trailing edge" of a timer period.
   * When first invoked will wait until the buffer period has expired to call the function, and
   * more calls within that time will restart the timer.
   *
   * This is useful for responding to keystrokes, but deferring action until the user pauses typing.
   *
   * @param {Function} fn The function to call.
   * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Array} [args] The argument list to append to those passed to the function.
   */
  static createBuffered(fn, buffer, thisObj, args) {
    let callArgs, timerId, result;

    const invoke = () => {
      timerId = 0;
      callArgs.push.apply(callArgs, args);
      fn.apply(thisObj, callArgs);
    };

    result = function(...args) {
      callArgs = args;

      // Cancel any impending invocation. It's pushed out for <buffer> ms from each call
      if (timerId) {
        clearTimeout(timerId);
      }

      timerId = setTimeout(invoke, buffer);
    };

    result.cancel = () => clearTimeout(timerId);

    return result;
  }

  static returnTrue() {
    return true;
  }

  static animate(duration, fn, scope, easing = 'linear') {
    let cancel = false;

    const result = new Promise((resolve) => {
      const start = performance.now(),
        iterate = () => {
          const progress = Math.min((performance.now() - start) / duration, 1);
          if (!cancel) {
            if (fn.call(scope, this.easingFunctions[easing](progress)) === false) {
              resolve();
            }
          }
          if (cancel || progress === 1) {
            // Push resolution into the next animation frame so that
            // this frame completes before the resolution handler runs.
            requestAnimationFrame(() => resolve());
          } else {
            requestAnimationFrame(iterate);
          }
        };

      iterate();
    });

    result.cancel = () => {
      cancel = true;
      return false;
    };

    return result;
  }
}

/* eslint-disable */
const half = 0.5,
  e1 = 1.70158,
  e2 = 7.5625,
  e3 = 1.525,
  e4 = 2 / 2.75,
  e5 = 2.25 / 2.75,
  e6 = 1 / 2.75,
  e7 = 1.5 / 2.75,
  e8 = 2.5 / 2.75,
  e9 = 2.625 / 2.75,
  e10 = 0.75,
  e11 = 0.9375,
  e12 = 0.984375;
FunctionHelper.easingFunctions = {
  linear: (t) => t,
  easeInQuad: (t) => Math.pow(t, 2),
  easeOutQuad: (t) => -(Math.pow(t - 1, 2) - 1),
  easeInOutQuad: (t) => ((t /= half) < 1 ? half * Math.pow(t, 2) : -half * ((t -= 2) * t - 2)),
  easeInCubic: (t) => Math.pow(t, 3),
  easeOutCubic: (t) => Math.pow(t - 1, 3) + 1,
  easeInOutCubic: (t) => ((t /= half) < 1 ? half * Math.pow(t, 3) : half * (Math.pow(t - 2, 3) + 2)),
  easeInQuart: (t) => Math.pow(t, 4),
  easeOutQuart: (t) => -(Math.pow(t - 1, 4) - 1),
  easeInOutQuart: (t) => ((t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2)),
  easeInQuint: (t) => Math.pow(t, 5),
  easeOutQuint: (t) => Math.pow(t - 1, 5) + 1,
  easeInOutQuint: (t) => ((t /= half) < 1 ? half * Math.pow(t, 5) : half * (Math.pow(t - 2, 5) + 2)),
  easeInSine: (t) => -Math.cos(t * (Math.PI / 2)) + 1,
  easeOutSine: (t) => Math.sin(t * (Math.PI / 2)),
  easeInOutSine: (t) => -half * (Math.cos(Math.PI * t) - 1),
  easeInExpo: (t) => (t === 0 ? 0 : Math.pow(2, 10 * (t - 1))),
  easeOutExpo: (t) => (t === 1 ? 1 : -Math.pow(2, -10 * t) + 1),
  easeInOutExpo: (t) =>
    t === 0
      ? 0
      : t === 1
      ? 1
      : (t /= half) < 1
      ? half * Math.pow(2, 10 * (t - 1))
      : half * (-Math.pow(2, -10 * --t) + 2),
  easeInCirc: (t) => -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) =>
    (t /= half) < 1 ? -half * (Math.sqrt(1 - t * t) - 1) : half * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeOutBounce: (t) =>
    t < e6
      ? e2 * t * t
      : t < e4
      ? e2 * (t -= e7) * t + e10
      : t < e8
      ? e2 * (t -= e5) * t + e11
      : e2 * (t -= e9) * t + e12,
  easeInBack: (t) => t * t * ((e1 + 1) * t - e1),
  easeOutBack: (t) => (t = t - 1) * t * ((e1 + 1) * t + e1) + 1,
  easeInOutBack: (t) => {
    let s = 1.70158;
    return (t /= half) < 1
      ? half * (t * t * (((s *= e3) + 1) * t - s))
      : half * ((t -= 2) * t * (((s *= e3) + 1) * t + s) + 2);
  },
  elastic: (t) => -1 * Math.pow(4, -8 * t) * Math.sin(((t * 6 - 1) * (2 * Math.PI)) / 2) + 1,
  swingFromTo: (t) => {
    let s = 1.70158;
    return (t /= half) < 1
      ? half * (t * t * (((s *= e3) + 1) * t - s))
      : half * ((t -= 2) * t * (((s *= e3) + 1) * t + s) + 2);
  },
  swingFrom: (t) => t * t * ((e1 + 1) * t - e1),
  swingTo: (t) => (t -= 1) * t * ((e1 + 1) * t + e1) + 1,
  bounce: (t) =>
    t < e6
      ? e2 * t * t
      : t < e4
      ? e2 * (t -= e7) * t + e10
      : t < e8
      ? e2 * (t -= e5) * t + e11
      : e2 * (t -= e9) * t + e12,
  bouncePast: (t) =>
    t < e6
      ? e2 * t * t
      : t < e4
      ? 2 - (e2 * (t -= e7) * t + e10)
      : t < e8
      ? 2 - (e2 * (t -= e5) * t + e11)
      : 2 - (e2 * (t -= e9) * t + e12),
  easeFromTo: (t) => ((t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2)),
  easeFrom: (t) => Math.pow(t, 4),
  easeTo: (t) => Math.pow(t, 0.25)
};

FunctionHelper._$name = 'FunctionHelper';

/**
 * @module Common/helper/EventHelper
 */

const touchProperties = ['clientX', 'clientY', 'pageX', 'pageY', 'screenX', 'screenY'],
  isOption = {
    element: 1,
    thisObj: 1,
    once: 1,
    delegate: 1,
    delay: 1,
    capture: 1,
    passive: 1,
    throttled: 1,
    autoDetach: 1
  },
  ctrlKeyProp = {
    get: () => true
  },
  normalizedKeyNames = {
    Spacebar: 'Space',
    Del: 'Delete',
    Esc: 'Escape',
    Left: 'ArrowLeft',
    Up: 'ArrowUp',
    Right: 'ArrowRight',
    Down: 'ArrowDown'
  },
  fixEvent = (event) => {
    const { type } = event;

    // Normalize key names
    if (type.startsWith('key')) {
      const normalizedKeyName = normalizedKeyNames[event.key];
      if (normalizedKeyName) {
        Object.defineProperty(event, 'key', {
          get: () => normalizedKeyName
        });
      }

      // Polyfill the code property for SPACE because it is not set for synthetic events.
      if (event.key === ' ' && !event.code) {
        Object.defineProperty(event, 'code', {
          get: () => 'Space'
        });
      }
    }

    // Sync OSX's meta key with the ctrl key. This will only happen on Mac platform.
    // It's read-only, so define a local property to return true for ctrlKey.
    if (event.metaKey && !event.ctrlKey) {
      Object.defineProperty(event, 'ctrlKey', ctrlKeyProp);
    }

    // When we listen to event on document and get event which bubbled from shadow dom, reading its target would
    // return shadow root element. We need actual element which started the event
    if (
      event.target &&
      event.target.shadowRoot &&
      event.composedPath &&
      !BrowserHelper.isIE11 &&
      !BrowserHelper.isEdge
    ) {
      const targetElement = event.composedPath()[0],
        originalTarget = event.target;

      // Can there be an event which actually originated from custom element, not its shadow dom?
      if (event.target !== targetElement) {
        Object.defineProperty(event, 'target', {
          get: () => targetElement
        });

        // Save original target just in case
        Object.defineProperty(event, 'originalTarget', {
          get: () => originalTarget
        });
      }
    }

    // Firefox has a bug where it can report that the target is the #document when mouse is over a pseudo element
    if (event.target && event.target.nodeType === 9 && 'clientX' in event) {
      const targetElement = DomHelper.elementFromPoint(event.clientX, event.clientY);
      Object.defineProperty(event, 'target', {
        get: () => targetElement
      });
    }

    // Firefox has a bug where it can report a textNode as an event target/relatedTarget.
    // We standardize this to report the parentElement.
    if (event.target && event.target.nodeType === 3) {
      const targetElement = event.target.parentElement;
      Object.defineProperty(event, 'target', {
        get: () => targetElement
      });
    }
    if (event.relatedTarget && event.relatedTarget.nodeType === 3) {
      const relatedTargetElement = event.target.parentElement;
      Object.defineProperty(event, 'relatedTarget', {
        get: () => relatedTargetElement
      });
    }

    // If it's a touch event, move the positional details
    // of touches[0] up to the event.
    if (type.startsWith('touch') && event.touches.length) {
      EventHelper.normalizeEvent(event);
    }

    return event;
  };

/**
 * Utility methods for dealing with Events, normalizing Touch/Pointer/Mouse events.
 */
class EventHelper {
  static normalizeEvent(event) {
    return ObjectHelper.copyPropertiesIf(event, event.touches[0] || event.changedTouches[0], touchProperties);
  }

  /**
   * Returns the `[x, y]` coordinates of the event in the viewport coordinate system.
   * @param {Event} event The event
   * @return {Number[]} The coordinate.
   */
  static getXY(event) {
    if (event.touches) {
      event = event.touches[0];
    }
    return [event.clientX, event.clientY];
  }

  /**
   * Returns the pixel distance between two mouse/touch/pointer events.
   * @param {Event} event1 The first event.
   * @param {Event} event2 The second event.
   * @return {Number} The distance in pixels between the two events.
   */
  static getDistanceBetween(event1, event2) {
    const xy1 = this.getXY(event1),
      xy2 = this.getXY(event2);

    // No point in moving this to Point. We are dealing only with number values here.
    return Math.sqrt(Math.pow(xy1[0] - xy2[0], 2) + Math.pow(xy1[1] - xy2[1], 2));
  }

  /**
   * Returns a {@link Common.helper.util.Point} which encapsulates the `pageX/Y` position of the event.
   * May be used in {@link Common.helper.util.Rectangle} events.
   * @param {Event} event A browser mouse/touch/pointer event.
   * @return {Common.helper.util.Point} The page point.
   */
  static getPagePoint(event) {
    return new Point(event.pageX, event.pageY);
  }

  /**
   * Returns a {@link Common.helper.util.Point} which encapsulates the `clientX/Y` position of the event.
   * May be used in {@link Common.helper.util.Rectangle} events.
   * @param {Event} event A browser mouse/touch/pointer event.
   * @return {Common.helper.util.Point} The page point.
   */
  static getClientPoint(event) {
    return new Point(event.clientX, event.clientY);
  }

  /**
   * Add a listener or listeners to an element
   * @param {HTMLElement} element The element to add a listener/listeners to.
   * @param {String|Object} eventName Either a string, being the name of the event to listen for,
   * or an options object containing event names and options as keys. See the options parameter
   * for details, or the {@link #function-on-static} method for details.
   * @param {Function} [handler] If the second parameter is a string event name, this is the handler function.
   * @param {Object} [options] If the second parameter is a string event name, this is the options.
   * @param {HTMLElement} options.element The element to add the listener to.
   * @param {Object} options.thisObj The default `this` reference for all handlers added in this call.
   * @param {Boolean} [options.autoDetach=true] The listeners are automatically removed when the `thisObj` is destroyed.
   * @param {String} [options.delegate] A CSS selector string which only fires the handler when the event takes place in a matching element.
   * @param {Boolean} [options.once] Specify as `true` to have the listener(s) removed upon first invocation.
   * @param {Number} [options.delay] The number of millieconds to delay the handler call after the event fires:
   *
   *     {
   *         once       : true,           // Removed upon first firing
   *         delegate   : this.iconCls,   // Only when clicking the icon
   *         thisObj    : this            // The this reference when the handler is called
   *                                      // Listener is removed when thisObj is destroyed
   *     }
   * @returns {Function} A detacher function which removes all the listeners when called.
   */
  static addListener(element, eventName, handler, options) {
    if (element.nodeType) {
      // All separate params, element, eventname and handler
      if (typeof eventName === 'string') {
        options = Object.assign(
          {
            element,
            [eventName]: handler
          },
          options
        );
      }
      // element, options
      else {
        options = Object.assign(
          {
            element
          },
          eventName
        );
      }
    }
    // Just an options object passed
    else {
      options = element;
    }
    return this.on(options);
  }

  /**
   * Adds a listener or listeners to an element.
   * all property names other than the options listed below are taken to be event names,
   * and the values as handler specs.
   *
   * A handler spec is usually a function reference or the name of a function in the `thisObj`
   * option.
   *
   * But a handler spec may also be an options object containing a `handler` property which is
   * the function or function name, and local options, including `element` and `thisObj`
   * which override the top level options.
   *
   *  Usage example
   *
   * ```javascript
   * construct(config) {
   *     super.construct(config);
   *
   *     // Add auto detaching event handlers to this Widget's reference elements
   *     EventHelper.on({
   *         element : this.iconElement,
   *         click   : '_handleIconClick',
   *         thisObj : this,
   *         contextmenu : {
   *             element : document,
   *             handler : '_handleDocumentContextMenu'
   *         }
   *     });
   * }
   *```
   *
   * The `click` handler on the `iconElement` calls `this._handleIconClick`.
   *
   * The `contextmenu` handler is added to the `document` element, but the `thisObj`
   * is defaulted in from the top `options` and calls `this._handleDocumentContextMenu`.
   *
   * Note that on touch devices, `dblclick` and `contextmenu` events are synthesized.
   * Synthesized events contain a `browserEvent` property containing the final triggering
   * event of the gesture. For example a synthesized `dblclick` event would contain a
   * `browserEvent` property which is the last `touchend` event. A synthetic `contextmenu`
   * event will contain a `browserEvent` property which the longstanding `touchstart` event.
   *
   * @param {Object} options The full listener specification.
   * @param {HTMLElement} options.element The element to add the listener to.
   * @param {Object} options.thisObj The default `this` reference for all handlers added in this call.
   * @param {Boolean} [options.autoDetach=true] The listeners are automatically removed when the `thisObj` is destroyed.
   * @param {String} [options.delegate] A CSS selector string which only fires the handler when the event takes place in a matching element.
   * @param {Boolean} [options.once] Specify as `true` to have the listener(s) removed upon first invocation.
   * @param {Number} [options.delay] The number of millieconds to delay the handler call after the event fires.
   * @param {Number} [options.throttled] For rapidly repeating events (Such as `wheel` or `scroll` or `mousemove`)
   * this is the number of millieconds to delay subsequent handler calls after first invocation which happens immediately.
   * @returns {Function} A detacher function which removes all the listeners when called.
   *
   */
  static on(options) {
    const EventHelper = this,
      element = options.element,
      thisObj = options.thisObj,
      handlerDetails = [],
      keys = ObjectHelper.allKeys(options);

    let len = keys.length,
      i,
      eventName;

    for (i = 0; i < len; i++) {
      eventName = keys[i];

      // Only treat it as an event name if it's not a supported option
      if (!isOption[eventName]) {
        let handlerSpec = options[eventName];
        if (typeof handlerSpec !== 'object') {
          handlerSpec = {
            handler: handlerSpec
          };
        }
        const targetElement = handlerSpec.element || element;

        // If we need to convert taphold to an emulated contextmenu, add a wrapping function
        // in addition to the contextmenu listener. Platforms may support mouse *and* touch.
        if (BrowserHelper.isTouchDevice) {
          if (eventName === 'contextmenu') {
            handlerDetails.push(
              EventHelper.addElementListener(
                targetElement,
                'touchstart',
                {
                  handler: EventHelper.createContextMenuWrapper(handlerSpec.handler, handlerSpec.thisObj || thisObj)
                },
                options
              )
            );
          } else if (eventName === 'dblclick') {
            handlerDetails.push(
              EventHelper.addElementListener(
                targetElement,
                'touchend',
                {
                  handler: EventHelper.createDblClickWrapper(
                    targetElement,
                    handlerSpec.handler,
                    handlerSpec.thisObj || thisObj
                  ),
                  delay: 10,
                  capture: true
                },
                options
              )
            );
          }
        }

        // Keep track of the real handlers added.
        // addElementLister returns [ element, eventName, addedfunction, capture ]
        handlerDetails.push(EventHelper.addElementListener(targetElement, eventName, handlerSpec, options));
      }
    }

    const detacher = () => {
      len = handlerDetails.length;
      for (i = 0; i < len; i++) {
        const handlerSpec = handlerDetails[i];
        handlerSpec[0].removeEventListener(handlerSpec[1], handlerSpec[2], handlerSpec[3]);
      }
      handlerDetails.length = 0;
    };

    // { autoDetach : true, thisObj : scheduler } means remove all listeners when the scheduler dies.
    if (thisObj && options.autoDetach !== false) {
      thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, detacher, thisObj);
    }

    return detacher;
  }

  /**
   * Used internally to add a single event handler to an element.
   * @param {HTMLElement} element The element to add the handler to.
   * @param {String} eventName The name of the event to add a handler for.
   * @param {Function|String|Object} handlerSpec Either a function to call, or
   * the name of a function to call in the `thisObj`, or an object containing
   * the handler local options.
   * @param {Function|String} [handlerSpec.handler] Either a function to call, or
   * the name of a function to call in the `thisObj`.
   * @param {HTMLElement} [handlerSpec.element] Optionally a local element for the listener.
   * @param {Object} [handlerSpec.thisObj] A local `this` specification for the handler.
   * @param {Object} defaults The `options` parameter from the {@link #function-addListener-static} call.
   * @private
   */
  static addElementListener(element, eventName, handlerSpec, defaults) {
    const handler = this.createHandler(element, eventName, handlerSpec, defaults),
      handlerHasPassive = 'passive' in handlerSpec;
    let options = handlerSpec.capture || defaults.capture;

    // If we are passed the passive option and the browser supports it, then convert
    // The capture option into the object options form.
    if ((handlerHasPassive || 'passive' in defaults) && BrowserHelper.supportsPassive) {
      options = {
        capture: !!options,
        passive: handlerHasPassive ? handlerSpec.passive : defaults.passive
      };
    }
    element.addEventListener(eventName, handler, options);

    return [element, eventName, handler, options];
  }

  static createHandler(element, eventName, handlerSpec, defaults) {
    const delay = handlerSpec.delay || defaults.delay,
      throttled = handlerSpec.throttled || defaults.throttled,
      once = handlerSpec.once || defaults.once,
      thisObj = handlerSpec.thisObj || defaults.thisObj,
      capture = handlerSpec.capture || defaults.capture,
      delegate = handlerSpec.delegate || defaults.delegate;

    //Capture initial conditions in case of destruction of thisObj.
    // Destruction completely wipes the object.

    let wrappedFn = handlerSpec.handler,
      // Innermost level of wrapping which calls the user's handler.
      // Normalize the event cross-browser, and attempt to normalize touch events.
      // Resolve named functions in the thisObj.
      handler = (event, ...args) => {
        // When playing a demo using DemoBot, only handle synthetic events
        if (this.playingDemo && event.isTrusted) {
          return;
        }

        // If the thisObj is already destroyed, we cannot call the function.
        // If in dev mode, warn the developer with a JS error.
        if (thisObj && thisObj.isDestroyed) {
          // eslint-disable-next-line
          return;
        }

        // Fix up events to handle various browser inconsistencies
        fixEvent(event);

        // delegate: '.b-field-trigger' only fires when click is in a matching el.
        // currentTarget becomes the delegate.
        if (delegate) {
          // Maintainer: In Edge event.target can be an empty object for transitionend events
          const delegatedTarget = event.target instanceof HTMLElement && event.target.closest(delegate);
          if (!delegatedTarget) {
            return;
          }
          // Allow this to be redefined as it bubbles through listeners up the parentNode axis
          // which might have their own delegate settings.
          Object.defineProperty(event, 'currentTarget', {
            get: () => delegatedTarget,
            configurable: true
          });
        }

        if (typeof wrappedFn === 'string') {
          wrappedFn = thisObj[wrappedFn];
        }
        wrappedFn.call(thisObj, event, ...args);
      };

    // Go through options, each creates a new handler by wrapping the previous handler to implement the options.
    // Right now, we have delay. Note that it may be zero, so test != null
    if (delay != null) {
      const wrappedFn = handler;
      handler = (...args) => {
        setTimeout(() => {
          wrappedFn(...args);
        }, delay);
      };
    }

    // If they specified the throttled option, wrap the hander in a createdThrottled
    // version. Allow the called to specify an alt function to call when the event
    // fires before the buffer time has expired.
    if (throttled != null) {
      let alt,
        buffer = throttled;

      if (throttled.buffer) {
        alt = (e) => throttled.alt.call(this, fixEvent(e));
        buffer = throttled.buffer;
      }
      handler = FunctionHelper.createThrottled(handler, buffer, thisObj, null, alt);
    }

    // This must always be the last option processed so that it is the outermost handler
    // which is the one added to the element and is called immediately so that the
    // handler is removed immediately.
    // TODO: Use the native once option when all browsers support it. Only IE11 doesn't.
    if (once) {
      const wrappedFn = handler;
      handler = (...args) => {
        element.removeEventListener(eventName, handler, capture);
        wrappedFn(...args);
      };
    }

    // Only autoDetach here if there's a local thisObj is in the handlerSpec for this one listener.
    // If it's in the defaults, then the "on" method will handle it.
    if (handlerSpec.thisObj && handlerSpec.autoDetach !== false) {
      thisObj.doDestroy = FunctionHelper.createInterceptor(
        thisObj.doDestroy,
        () => element.removeEventListener(eventName, handler),
        thisObj
      );
    }

    return handler;
  }

  /**
   * Private function to wrap the passed function. The returned wrapper function to be used as
   * a `touchstart` handler which will call the passed function passing a fabricated `contextmenu`
   * event if there's no `touchend` or `touchmove` after a default of 400ms.
   * @param {String|Function} handler The handler to call.
   * @param {Object} thisObj The owner of the function.
   * @private
   */
  static createContextMenuWrapper(handler, me) {
    const EventHelper = this;

    return (event) => {
      // Only attempt conversion to contextmenu if it's a single touch start.
      if (event.touches.length === 1) {
        const tapholdStartTouch = event.touches[0],
          // Dispatch a synthetic "contextmenu" event from the touchpoint in <longPressTime> milliseconds.
          tapholdTimer = setTimeout(() => {
            // Remove the gesture cancelling listeners
            touchMoveRemover();

            const contextmenuEvent = new MouseEvent('contextmenu', tapholdStartTouch);
            Object.defineProperty(contextmenuEvent, 'target', {
              get() {
                return tapholdStartTouch.target;
              }
            });
            if (typeof handler === 'string') {
              handler = me[handler];
            }

            contextmenuEvent.browserEvent = event;

            // Call the wrapped handler passing the fabricated contextmenu event
            handler.call(me, contextmenuEvent);
            EventHelper.contextMenuTouchId = tapholdStartTouch.identifier;
          }, EventHelper.longPressTime),
          // This is what gets called if the user moves their touchpoint,
          // or releases the touch before <longPressTime>ms is up
          cancelTapholdTimer = () => {
            EventHelper.contextMenuTouchId = null;
            touchMoveRemover();
            clearTimeout(tapholdTimer);
          },
          // Touchmove or touchend before that timer fires cancels the timer and removes these listeners.
          touchMoveRemover = EventHelper.on({
            element: document,
            touchmove: cancelTapholdTimer,
            touchend: cancelTapholdTimer,
            pointermove: cancelTapholdTimer,
            pointerup: cancelTapholdTimer,
            capture: true
          });
      }
    };
  }

  /**
   * Private function to wrap the passed function. The returned wrapper function to be used as
   * a `touchend` handler which will call the passed function passing a fabricated `dblclick`
   * event if there is a `click` within 300ms.
   * @param {String|Function} handler The handler to call.
   * @param {Object} thisObj The owner of the function.
   * @private
   */
  static createDblClickWrapper(element, handler, me) {
    const EventHelper = this;

    let startId, secondListenerDetacher, tapholdTimer;

    return () => {
      if (!secondListenerDetacher) {
        secondListenerDetacher = EventHelper.on({
          element,

          // We only get here if a touchstart arrives within 300ms of a click
          touchstart: (secondStart) => {
            startId = secondStart.changedTouches[0].identifier;
            // Prevent zoom
            secondStart.preventDefault();
          },
          touchend: (secondClick) => {
            if (secondClick.changedTouches[0].identifier === startId) {
              secondClick.preventDefault();

              clearTimeout(tapholdTimer);
              startId = secondListenerDetacher = null;

              const targetRect = Rectangle.from(secondClick.changedTouches[0].target, null, true),
                offsetX = secondClick.changedTouches[0].pageX - targetRect.x,
                offsetY = secondClick.changedTouches[0].pageY - targetRect.y,
                dblclickEventConfig = Object.assign(
                  {
                    browserEvent: secondClick
                  },
                  secondClick
                ),
                dblclickEvent = new MouseEvent('dblclick', dblclickEventConfig);

              Object.defineProperty(dblclickEvent, 'target', {
                get() {
                  return secondClick.target;
                }
              });

              Object.defineProperty(dblclickEvent, 'offsetX', {
                get() {
                  return offsetX;
                }
              });

              Object.defineProperty(dblclickEvent, 'offsetY', {
                get() {
                  return offsetY;
                }
              });

              if (typeof handler === 'string') {
                handler = me[handler];
              }

              // Call the wrapped handler passing the fabricated dblclick event
              handler.call(me, dblclickEvent);
            }
          },
          once: true
        });

        // Cancel the second listener is there's no second click within <dblClickTime> milliseconds.
        tapholdTimer = setTimeout(() => {
          secondListenerDetacher();
          startId = secondListenerDetacher = null;
        }, EventHelper.dblClickTime);
      }
    };
  }

  static lockComposedPath(event) {
    if (event.composedPath) {
      event.composedPath = ((path) => () => path)(event.composedPath());
    }
  }
}

/**
 * The time in milliseconds for a `taphold` gesture to trigger a `contextmenu` event.
 * @member {Number} [longPressTime=500]
 * @readonly
 * @static
 */
EventHelper.longPressTime = 500;

/**
 * The time in milliseconds within which a second touch tap event triggers a `dblclick` event.
 * @member {Number} [dblClickTime=300]
 * @readonly
 * @static
 */
EventHelper.dblClickTime = 300;

// Flag body if last user action used keyboard, used for focus styling etc.
EventHelper.on({
  element: document,
  mousedown() {
    if (!DomHelper.isTouchEvent) {
      DomHelper.usingKeyboard = false;
      document.body.classList.remove('b-using-keyboard');
    }
  },
  touchmove() {
    DomHelper.usingKeyboard = false;
    document.body.classList.remove('b-using-keyboard');
  },
  keydown() {
    DomHelper.usingKeyboard = true;
    document.body.classList.add('b-using-keyboard');
  }
});

// When dragging on a touch device, we need to prevent scrolling from happening.
// Dragging only starts on a touchmove event, by which time it's too late to preventDefault
// on the touchstart event which started it.
// To do this we need a capturing, non-passive touchmove listener at the document level so we can preventDefault.
// This is in lieu of a functioning touch-action style on iOS Safari. When that's fixed, this will not be needed.
if (BrowserHelper.isTouchDevice) {
  EventHelper.on({
    element: document,
    touchmove: (event) => {
      // If we're touching a b-dragging event, then stop any panning by preventing default.
      if (event.target.closest('.b-dragging')) {
        event.preventDefault();
      }
    },
    passive: false,
    capture: true
  });
}
EventHelper._$name = 'EventHelper';

/**
 * @module Common/util/CollectionFilter
 */

/**
 * A class which encapsulates a single filter operation which may be applied to any object to decide whether to
 * include or exclude it from a set.
 *
 * A CollectionFilter generally has at least three main properties:
 *
 * * `property` - The name of a property in candidate objects from which to extract the value to test
 * * `value` - The value which  this filter uses to test against.
 * * `operator` - The comparison operator, eg: `'='` or `'>'` etc.
 *
 * Given these three essential values, further configurations may affect how the filter is applied:
 *
 * * `caseSensitive` - If configured as `false`, string comparisons are case insensitive.
 * * `convert` - A function which, when passed the extracted value from the candidate object, returns the value to test.
 *
 * A filter may also be configured with a single `filterBy` property. This function is just passed the raw
 * candidate object and must return `true` or `false`.
 *
 * A CollectionFilter may be configured to encapsulate a single filtering function by passing that function as the sole
 * parameter to the constructor:
 *
 *     new CollectionFilter(candidate => candidate.title.contains('search string'));
 *
 */
class CollectionFilter extends Base {
  static get defaultConfig() {
    return {
      /**
       * The name of a property of candidate objects which yields the value to compare against this CollectionFilter's {@link #config-value}.
       * @config {String}
       */
      property: null,

      /**
       * The value against which to compare the {@link #config-property} of candidate objects.
       * @config {*}
       */
      value: null,

      /**
       * The operator to use when comparing a candidate object's {@link #config-property} with this CollectionFilter's {@link #config-value}.
       * May be: `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`, `'startsWith'`, `'endsWith'`
       * @config {String}
       */
      operator: null,

      /**
       * May be used in place of the {@link #config-property}, {@link #config-value} and {@link #config-property} configs. A function which
       * accepts a candidate object and returns `true` or `false`
       * @config {Function}
       */
      filterBy: null,

      /**
       * A function which accepts a value extracted from a candidate object using the {@link #config-property} name, and
       * returns the value which the filter should use to compare against its {@link #config-value}.
       * @config {Function}
       */
      convert: null,

      /**
       * Configure as `false` to have string comparisons case insensitive.
       * @config {Boolean}
       */
      caseSensitive: true,

      /**
       * The `id` of this Filter for when used by a {@link Common.util.Collection} Collection.
       * By default the `id` is the {@link #config-property} value.
       * @config {String}
       */
      id: null
    };
  }

  construct(config) {
    if (typeof config === 'function') {
      config = {
        filterBy: config
      };
    }

    super.construct(config);
  }

  /**
   * When in a Collection (A Collection holds its Filters in a Collection), we need an id.
   * @property {String}
   * @private
   */
  get id() {
    return this._id || (this._id = this.property || IdHelper.generateId('b-filter'));
  }

  set id(id) {
    this._id = id;
  }

  onChange(propertyChanged) {
    const me = this;

    // Inform any owner (eg a Store), that it has to reassess its CollectionFilters
    if (!me.isConfiguring && me.owner && !me.owner.isConfiguring && me.owner.onFilterChanged) {
      me.owner.onFilterChanged(me, propertyChanged);
    }
  }

  get filterBy() {
    return this._filterBy || this.defaultFilterBy;
  }

  /**
   * May be used in place of the {@link #config-property}, {@link #config-value} and {@link #config-property} configs. A function which
   * accepts a candidate object and returns `true` or `false`
   * @type {Function}
   */
  set filterBy(filterBy) {
    this._filterBy = filterBy;
  }

  defaultFilterBy(candidate) {
    return this[this.operator](this.convert(candidate[this.property]));
  }

  /**
   * The name of a property of candidate objects which yields the value to compare against this CollectionFilter's {@link #config-value}.
   * @type {String}
   */
  set property(property) {
    this._property = property;

    // Signal to owner about filter change
    this.onChange('property');
  }

  get property() {
    return this._property;
  }

  /**
   * The value against which to compare the {@link #config-property} of candidate objects.
   * @type {*}
   */
  set value(value) {
    this._value = !this.caseSensitive && typeof value === 'string' ? value.toLowerCase() : value;

    // Signal to owner about filter change
    this.onChange('value');
  }

  get value() {
    return this._value;
  }

  /**
   * The operator to use when comparing a candidate object's {@link #config-property} with this CollectionFilter's {@link #config-value}.
   * May be: `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`, `'startsWith'`, `'endsWith'`
   * @type {String}
   */
  set operator(operator) {
    this._operator = operator;

    // Signal to owner about filter change
    this.onChange('operator');
  }

  get operator() {
    return this._operator || (typeof this.value === 'string' ? '*' : '=');
  }

  convert(value) {
    return !this.caseSensitive && typeof value === 'string' ? value.toLowerCase() : value;
  }

  filter(candidate) {
    return this.filterBy(candidate);
  }

  startsWith(v) {
    return String(v).startsWith(this.value);
  }

  endsWith(v) {
    return String(v).endsWith(this.value);
  }

  '='(v) {
    return ObjectHelper.isEqual(v, this.value);
  }

  '!='(v) {
    return !ObjectHelper.isEqual(v, this.value);
  }

  '>'(v) {
    return ObjectHelper.isMoreThan(v, this.value);
  }

  '>='(v) {
    return ObjectHelper.isMoreThan(v, this.value) || ObjectHelper.isEqual(v, this.value);
  }

  '<'(v) {
    return ObjectHelper.isLessThan(v, this.value);
  }

  '<='(v) {
    return ObjectHelper.isLessThan(v, this.value) || ObjectHelper.isEqual(v, this.value);
  }

  '*'(v) {
    return ObjectHelper.isPartial(v, this.value);
  }

  // Accepts an array or a Collection
  static generateFiltersFunction(filters) {
    if (!filters || (!filters.length && !filters.count)) {
      return FunctionHelper.returnTrue;
    }

    return function(candidate) {
      let match = true;

      for (const filter of filters) {
        // Skip disabled filters
        if (!filter.disabled) {
          match = filter.filter(candidate);
        }
        if (!match) {
          break;
        }
      }

      return match;
    };
  }
}
CollectionFilter._$name = 'CollectionFilter';

/**
 * @module Common/util/CollectionSorter
 */

/**
 * A class which encapsulates a single sorter operation which may be applied to any object to decide whether to
 * include or exclude it from a set.
 *
 * A CollectionSorter generally has two properties:
 *
 * * `property` - The name of a property in collection objects by which to sort
 * * `direction` - The sort direction, `'ASC'` or `'DESC'`.
 *
 * It may also be configured with just a {@link #config-sortFn} function which returns the desired comparison
 * result when passed two objects to compare. Note that this does *not* require or use the
 * {@link #config-property} config. Two collection items are passed for comparison.
 *
 * Further configurations may affect how the sorter is applied:
 *
 * * `convert` - A function which, when passed the {@link #config-property} value from
 * a collection object, returns the value to sort by.
 *
 * A CollectionSorter may be configured to encapsulate a {@link #config-sortFn} by passing that function as the sole
 * parameter to the constructor:
 *
 *     new CollectionSorter((lhs, rhs) => {
 *         lhs = lhs.customerDetails.companyName.toLowerCase();
 *         rhs = rhs.customerDetails.companyName.toLowerCase();
 *
 *         if (lhs < rhs) {
 *             return -1;
 *         }
 *         else if (lhs > rhs) {
 *             return 1;
 *         }
 *         else {
 *             return 0;
 *         }
 *     });
 *
 */
class CollectionSorter extends Base {
  static get defaultConfig() {
    return {
      /**
       * The name of a property of collection objects which yields the value to sort by.
       * @config {String}
       */
      property: null,

      /**
       * The direction to sort in, `'ASC'` or `'DESC'`
       * @config {String}
       * @default
       */
      direction: 'ASC',

      /**
       * A function which takes the place of using {@link #config-property} and {@link #config-direction}.
       * The function is passed two objects from the collection to compare andmiust return the comparison result.
       * @config {Function}
       */
      sortFn: null,

      /**
       * When using {@link #config-property}, this may be specified as a function which takes the raw
       * property value and returns the value to actually sort by.
       * @config {Function}
       */
      convert: null,

      /**
       * The `id` of this Sorter for when used by a {@link Common.util.Collection} Collection.
       * By default the `id` is the {@link #config-property} value.
       * @config {String}
       */
      id: null,

      /**
       * Use `localeCompare()` when sorting, which lets the browser sort in a locale specific order. Set to `true`,
       * a locale string or a locale config to enable.
       *
       * Enabling this has big negative impact on sorting
       * performance. For more info on `localeCompare()`, see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
       *
       * ```javascript
       * collection.addSorter({ field: 'name', useLocaleSort : 'sv-SE' });
       * ```
       *
       * @config {Boolean|String|Object}
       * @default false
       */
      useLocaleSort: null
    };
  }

  construct(config) {
    if (typeof config === 'function') {
      config = {
        sortFn: config
      };
    }

    super.construct(config);
  }

  /**
   * When in a Collection (A Collection holds its Sorters in a Collection), we need an id.
   * @property {String}
   * @private
   */
  get id() {
    return this._id || (this._id = this.property || IdHelper.generateId('b-sorter'));
  }

  set id(id) {
    this._id = id;
  }

  set sortFn(sortFn) {
    this._sortFn = sortFn;
  }

  get sortFn() {
    if (this._sortFn) {
      return this._sortFn;
    }
    return this.defaultSortFn;
  }

  /**
   * Default sortFn used when no sortFn specified. Uses the {@link #config-property},
   * {@link #config-direction}, and {@link #config-convert}.
   * @private
   */
  defaultSortFn(lhs, rhs) {
    const me = this,
      { convert, property, useLocaleSort } = me,
      multiplier = me.direction.toLowerCase() === 'desc' ? -1 : 1;

    lhs = lhs[property];
    rhs = rhs[property];

    if (convert) {
      lhs = convert(lhs);
      rhs = convert(rhs);
    }

    if (useLocaleSort && lhs != null && rhs != null) {
      // Use systems locale
      if (useLocaleSort === true) {
        return String(lhs).localeCompare(rhs);
      }

      // Use specified locale
      if (typeof useLocaleSort === 'string') {
        return String(lhs).localeCompare(rhs, useLocaleSort);
      }

      // Use locale config
      if (typeof useLocaleSort === 'object') {
        return String(lhs).localeCompare(rhs, useLocaleSort.locale, useLocaleSort);
      }
    }

    return (lhs > rhs ? 1 : lhs < rhs ? -1 : 0) * multiplier;
  }

  static generateSortFunction(sorters, tieBreaker) {
    const items = sorters.isCollection ? sorters.values : sorters,
      n = items.length;

    return (lhs, rhs) => {
      let comp, i;

      for (i = 0; i < n; ++i) {
        comp = items[i].sortFn(lhs, rhs);
        if (comp) {
          return comp;
        }
      }

      return tieBreaker ? tieBreaker(lhs, rhs) : 0;
    };
  }
}
CollectionSorter._$name = 'CollectionSorter';

/**
 * @module Common/util/Collection
 */

const return0 = () => 0,
  reverseNumericSortFn = (a, b) => b - a,
  filteredIndicesProperty = Symbol('filteredIndicesProperty'),
  emptyArray$1 = Object.freeze([]),
  sortEvent = Object.freeze({
    action: 'sort',
    added: emptyArray$1,
    removed: emptyArray$1,
    replaced: emptyArray$1
  }),
  filterEvent = Object.freeze({
    action: 'filter',
    added: emptyArray$1,
    removed: emptyArray$1,
    replaced: emptyArray$1
  }),
  keyTypes = {
    string: 1,
    number: 1
  },
  nonPrimitives = new WeakMap(),
  safeIndexKey = (value) => {
    if (value && typeof value === 'object') {
      let substitute = nonPrimitives.get(value);
      if (substitute === undefined) {
        substitute = Symbol('bscik'); // Bryntum safe collection index key
        nonPrimitives.set(value, substitute);
      }
      value = substitute;
    }

    return value;
  };

/**
 * A class which encapsulates a {@link #function-get keyed},
 * {@link #function-addFilter filterable}, {@link #function-addSorter sortable}
 * collection of objects. Entries may not be atomic data types such as `string` or `number`.
 *
 * The entries are keyed by their `id` which is determined by interrogating the {@link #config-idProperty}.
 *
 * To filter a Collection, add a {@link Common.util.CollectionFilter CollectionFilter}
 * using the {@link #function-addFilter} method. A Filter config object may be specified here
 * which will be promoted to a CollectionFilter instance.
 *
 * To sort a Collection, add a {@link Common.util.CollectionSorter CollectionSorter}
 * using the {@link #function-addSorter} method. A Sorter config object may be specified here
 * which will be promoted to a CollectionSorter instance.
 */
class Collection extends Events(Base) {
  static get defaultConfig() {
    return {
      /**
       * Specify the name of the property of added objects which provides the lookup key
       * @config {String}
       * @default
       */
      idProperty: 'id',

      /**
       * Specify the names of properties which are to be indexed for fast lookup.
       * @config {String[]}
       */
      extraKeys: null,

      /**
       * Automatically apply filters on item add.
       * @config {String[]}
       * @default
       */
      autoFilter: true
    };
  }

  construct(config) {
    /**
     * A counter which is incremented whenever the Collection is mutated in a meaningful way.
     *
     * If a {@link #function-splice} call results in no net replacement, removal or addition,
     * then the `generation` will not be incremented.
     * @property {Number}
     * @readonly
     */
    this.generation = 0;
    this._values = [];

    super.construct(config);
  }

  doDestroy() {
    super.doDestroy();

    this._values.length = 0;

    if (this.isFiltered) {
      this._filteredValues.length = 0;
      this.filters.destroy();
    }

    this._sorters && this._sorters.destroy();
  }

  get isCollection() {
    return true;
  }

  /**
   * Clears this collection.
   */
  clear() {
    const me = this,
      removed = this._values.slice();

    if (me.totalCount) {
      me._values.length = 0;
      if (me._filteredValues) {
        me._filteredValues.length = 0;
      }
      me._indicesInvalid = true;

      // Indicate to obervers that data has changed.
      me.generation++;
      me.trigger('change', {
        action: 'clear',
        removed
      });
    }
  }

  /**
   * Replaces the internal values array with the passed array. Note that this takes ownership of the array, and the array
   * must not be mutated by outside code.
   *
   * This is an internal utility method, not designed for use by application code.
   * @internal
   * @param {Object[]} values The new values array
   */
  replaceValues(values, silent, ignoreFilters) {
    const me = this;

    let removed;

    if (me.isFiltered && !ignoreFilters) {
      removed = me._filteredValues;
      me._filteredValues = values;
    } else {
      removed = me._values;
      me._values = values;
      if (me._filteredValues) {
        me._filteredValues.length = 0;
      }
    }
    me._indicesInvalid = true;

    // Indicate to obervers that data has changed.
    me.generation++;

    if (!silent) {
      me.trigger('change', {
        action: 'replaceValues',
        removed,
        values,
        replaced: []
      });
    }
  }

  set values(values) {
    this.splice(0, this._values.length, values);
  }

  /**
   * The set of values of this Collection. If this Collection {@link #property-isFiltered},
   * this yields the filtered data set.
   *
   * Setting this property replaces the data set.
   * @property {Object[]}
   */
  get values() {
    return this.isFiltered ? this._filteredValues : this._values;
  }

  /**
   * Iterator that allows you to do for (let item of collection)
   */
  [Symbol.iterator]() {
    return this.values[Symbol.iterator]();
  }

  /**
   * Executes the passed function for each item in this Collection, passing in the item,
   * ths index, and the full item array.
   * @param {Function} fn The function to execute.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to include all items, bypassing filters.
   */
  forEach(fn, ignoreFilters = false) {
    (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).forEach(fn);
  }

  /**
   * Extracts ths content of this Collection into an array based upon the passed
   * value extraction function.
   * @param {Function} fn A function, which, when passed an item, returns a value to place into the resulting array.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to process an item even if it is filtered out.
   * @returns {Object[]} An array of values extracted from this Collection.
   */
  map(fn, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).map(fn);
  }

  /**
   * Returns the first item in this Collection which elicits a *truthy* return value from the passed funtion.
   * @param {Function} fn A function, which, when passed an item, returns `true` to select it as the item to return.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to include filtered out items.
   * @returns {Object} The matched item, or `undefined`.
   */
  find(fn, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).find(fn);
  }

  get first() {
    return this.values[0];
  }

  get last() {
    return this.values[this.count - 1];
  }

  /**
   * The set of all values of this Collection regardless of filters applied.
   * @readonly
   * @property {Object[]}
   */
  get allValues() {
    return this._values;
  }

  /**
   * Adds items to this Collection. Multiple new items may be passed.
   *
   * By default, new items are appended to the existing values.
   *
   * Any {@link #property-sorters} {@link #property-sorters} present are re-run.
   *
   * Any {@link #property-filters} {@link #property-filters} present are re-run.
   *
   * *Note that if application functionality requires add and remove, the
   * {@link #function-splice} operation is preferred as it performs both
   * operations in an atomic manner*
   * @param  {...Object} items The item(s) to add.
   */
  add(...items) {
    if (items.length === 1) {
      this.splice(this._values.length, null, ...items);
    } else {
      this.splice(this._values.length, null, items);
    }
  }

  /**
   * Removes items from this Collection. Multiple items may be passed.
   *
   * Any {@link #property-sorters} {@link #property-sorters} present are re-run.
   *
   * Any {@link #property-filters} {@link #property-filters} present are re-run.
   *
   * *Note that if application functionality requires add and remove, the
   * {@link #function-splice} operation is preferred as it performs both
   * operations in an atomic manner*
   * @param  {...Object} items The item(s) to remove.
   */
  remove(...items) {
    if (items.length === 1) {
      this.splice(0, ...items);
    } else {
      this.splice(0, items);
    }
  }

  /**
   * Moves an individual item to another location.
   * @param {Object} item The item to move.
   * @param {Object} [beforeItem] the item to insert the first item before. If omitted, the `item`
   * is moved to the end of the Collection.
   * @returns {Number} The new index of the `item`.
   */
  move(item, beforeItem) {
    const me = this,
      { _values } = me,
      itemIndex = me.indexOf(item, true);

    let beforeIndex = beforeItem ? me.indexOf(beforeItem, true) : _values.length;

    if (itemIndex === -1 || beforeIndex === -1) {
      throw new Error('Collection move parameters must be present in Collection');
    }

    if (itemIndex !== beforeIndex && itemIndex !== beforeIndex - 1) {
      if (itemIndex < beforeIndex) {
        beforeIndex--;
      }
      _values.splice(itemIndex, 1);
      _values.splice(beforeIndex, 0, item);
      me._indicesInvalid = true;

      me.trigger('change', {
        action: 'move',
        item,
        from: itemIndex,
        to: beforeIndex
      });
    }
    return beforeIndex;
  }

  /**
   * The core data set mutation method. Removes and adds at the same time. Analogous
   * to the `Array` `splice` method.
   *
   * Note that if items that are specified for removal are also in the `toAdd` array,
   * then those items are *not* removed then appended. They remain in the same position
   * relative to all remaning items.
   *
   * @param {Number} index Index at which to remove a block of items. Only valid if the
   * second, `toRemove` argument is a number.
   * @param {Object[]|Number} [toRemove] Either the number of items to remove starting
   * at the passed `index`, or an array of items to remove (If an array is passed, the `index` is ignored).
   * @param  {Object[]|Object} [toAdd] An item, or an array of items to add.
   */
  splice(index = 0, toRemove, ...toAdd) {
    const me = this,
      idProperty = me.idProperty,
      values = me._values,
      newIds = {},
      removed = [],
      replaced = [],
      oldCount = me.totalCount;

    let added, mutated;

    // Create an "newIds" map of the new items so remove ops know if it's really a replace
    // {
    //     1234 : true
    // }
    // And an "added" array of the items that need adding (there was not already an entry for the id)
    //
    if (toAdd) {
      if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
        toAdd = toAdd[0];
      }

      // Check for replacements if we contain any data
      if (oldCount && toAdd.length) {
        // Only risk rebuilding the indices if we are adding
        const idIndex = me.indices[idProperty];

        added = [];

        for (let i = 0; i < toAdd.length; i++) {
          const newItem = toAdd[i],
            id = safeIndexKey(newItem[idProperty]),
            existingIndex = idIndex[id];

          // Register incoming id so that removal leaves it be
          newIds[id] = true;

          // Incoming id is already present.
          // Replace it in place.
          if (existingIndex != null) {
            // If incoming is the same object, it's a no-op
            if (values[existingIndex] !== newItem) {
              replaced.push([values[existingIndex], newItem]);
              values[existingIndex] = newItem;
            }
          } else {
            added.push(newItem);
          }
        }
      }
      // Empty Collection, we simply add what we're passed
      else {
        added = toAdd;
      }
    }

    if (toRemove) {
      // We're removing a chunk starting at index
      if (typeof toRemove === 'number') {
        for (let removeIndex = index; toRemove; --toRemove) {
          const id = safeIndexKey(values[removeIndex][idProperty]);

          // If the entry here is being replaced, skip the insertion index past it
          if (newIds[id]) {
            index++;
            removeIndex++;
          }
          // If the id is not among incoming items, remove it
          else {
            removed.push(values[removeIndex]);
            values.splice(removeIndex, 1);
            me._indicesInvalid = mutated = true;
          }
        }
      }
      // We are removing an item/items
      else {
        let contiguous = added.length === 0,
          lastIdx;

        if (!Array.isArray(toRemove)) {
          toRemove = [toRemove];
        }
        // Create array of index points to remove.
        // They must be in reverse order so that removal leaves following remove indices stable
        const removeIndices = toRemove
          .reduce((result, item) => {
            const isNumeric = typeof item === 'number',
              idx = isNumeric ? item : me.indexOf(item, true);

            // Drop out of contiguous mode if we find a non-contiguous record, or a remove *index*
            if (contiguous && ((lastIdx != null && idx !== lastIdx + 1) || isNumeric)) {
              contiguous = false;
            }

            // Do not include indices out of range in our removeIndices
            if (idx >= 0 && idx < oldCount) {
              result.push(idx);
            }
            lastIdx = idx;
            return result;
          }, [])
          .sort(reverseNumericSortFn);

        // If it's a pure remove of contiguous items with no adds, fast track it.
        if (contiguous) {
          // If reduced to zero by being asked to remove items we do not contain
          // then this is a no-op
          if (removeIndices.length) {
            removed.push.apply(removed, toRemove);
            values.splice(removeIndices[removeIndices.length - 1], removeIndices.length);
            me._indicesInvalid = mutated = true;
          }
        } else {
          // Loop through removeIndices splicing each index out of the values
          // unless there's an incoming identical id.
          for (let i = 0; i < removeIndices.length; i++) {
            const removeIndex = removeIndices[i];

            if (removeIndex !== -1) {
              const id = safeIndexKey(values[removeIndex][idProperty]);

              // If the id is not among incoming items, remove it
              if (!newIds[id]) {
                removed.unshift(values[removeIndex]);
                values.splice(removeIndex, 1);
                me._indicesInvalid = mutated = true;
              }
            }
          }
        }
      }
    }

    // If we collected genuinely new entries, insert them at the splice index
    if (added.length) {
      values.splice(Math.min(index, values.length), 0, ...added);
      me._indicesInvalid = mutated = true;
    }

    // Ensure order of values matches the sorters
    if (me.isSorted) {
      me.onSortersChanged();
    }
    // The sort will also recreate the filteredValues so that it can be in correct sort order
    else if (me.isFiltered) {
      if (me.autoFilter) {
        me.onFiltersChanged();
      } else {
        me._filteredValues.push(...added);
      }
    }

    // If we either added or removed items, or we did an in-place replace operation
    // then inform all interested parties.
    if (mutated || replaced.length) {
      // Indicate to obervers that data has changed.
      me.generation++;

      /**
       * Fired when items are added, replace or removed
       * @event change
       * @param {String} action The underlying operation which caused data change.
       * May be `'splice'` (meaning an atomic add/remove operation, `'sort'` or `'filter'`)
       * @param {Common.util.Collection} source This Collection.
       * @param {Object[]} removed An array of removed items.
       * @param {Object[]} added An array of added items.
       * @param {Object[]} replaced An array of replacements, each entry of which contains `[oldValue, newValue]`.
       * @param {Number} oldCount The number of items in the full, untiltered collection prior to the splice operation.
       */
      me.trigger('change', {
        action: 'splice',
        removed,
        added,
        replaced,
        oldCount
      });
    } else {
      /**
       * Fired when a {@link #function-splice} operation is requested but the operation
       * is a no-op and has caused no change to this Collection's dataset. The splice
       * method's parameters are passed for reference.
       * @event noChange
       * @param {Number} index Index at which to remove a block of items.
       * @param {Object[]|Number} [toRemove] Either the number of items to remove starting
       * at the passed `index`, or an array of items to remove (If an array is passed, the `index` is ignored).
       * @param  {Object[]|Object} [toAdd] An item, or an array of items to add.
       */
      me.trigger('noChange', {
        index,
        toRemove,
        toAdd
      });
    }
  }

  /**
   * Change the id of an existing member by mutating its {@link #config-idProperty}.
   * @param {String|Number|Object} item The item or id of the item to change.
   * @param {String|Number} newId The id to set in the existing member.
   */
  changeId(item, newId) {
    const me = this,
      { idProperty } = me,
      oldId = keyTypes[typeof item] ? item : item[idProperty],
      member = me.get(oldId);

    if (member) {
      const existingMember = me.get(newId);

      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }

      member[idProperty] = newId;

      // If indices are valid, keep the id index correct
      if (!me._indicesInvalid) {
        const idIndex = me.indices.id,
          memberIndex = idIndex[oldId];

        delete idIndex[oldId];
        idIndex[newId] = memberIndex;
      }
    }
  }

  /**
   * Returns the item with the passed `id`. By default, filtered are honoured, and
   * if the item with the requested `id` is filtered out, nothing will be returned.
   *
   * To return the item even if it has been filtered out, pass the second parameter as `true`.
   * @param {*} id The `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return an item even if it is filtered out.
   * @returns {Object} The found item, or `undefined`.
   */
  get(id, ignoreFilters = false) {
    return this.getBy(this.idProperty, id, ignoreFilters);
  }

  getAt(index, ignoreFilters = false) {
    if (this.isFiltered && !ignoreFilters) {
      return this._filteredValues[index];
    } else {
      return this._values[index];
    }
  }

  /**
   * Returns the item with passed property name equal to the passed value. By default,
   * filtered are honoured, and if the item with the requested `id` is filtered out,
   * nothing will be returned.
   *
   * To return the item even if it has been filtered out, pass the third parameter as `true`.
   * @param {String} propertyName The property to test.
   * @param {*} value The value to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return an item even if it is filtered out.
   * @returns {Object} The found item, or `undefined`.
   */
  getBy(propertyName, value, ignoreFilters = false) {
    const me = this;

    if (me.isFiltered && ignoreFilters) {
      const index = me.findIndex(propertyName, value, true);
      if (index !== -1) {
        return me._values[index];
      }
    } else {
      const index = me.findIndex(propertyName, value);
      if (index !== -1) {
        return me.values[index];
      }
    }
  }

  /**
   * The number of items in this collection. Note that this honours filtering.
   * See {@link #property-totalCount};
   * @property {Number}
   * @readonly
   */
  get count() {
    return this.values.length;
  }

  /**
   * The number of items in this collection regardless of filtering.
   * @property {Number}
   * @readonly
   */
  get totalCount() {
    return this._values.length;
  }

  set idProperty(idProperty) {
    this._idProperty = idProperty;
    this.addIndex(idProperty);
  }

  /**
   * The property name used to extract item `id`s from added objects.
   * @property {String}
   */
  get idProperty() {
    return this._idProperty;
  }

  set extraKeys(extraKeys) {
    if (!Array.isArray(extraKeys)) {
      extraKeys = [extraKeys];
    }
    for (let i = 0; i < extraKeys.length; i++) {
      this.addIndex(extraKeys[i]);
    }
  }

  /**
   * The Collection of {@link Common.util.CollectionSorter Sorters} for this Collection.
   * @property {Common.util.Collection}
   * @readonly
   */
  get sorters() {
    if (!this._sorters) {
      this._sorters = new Collection({
        listeners: {
          change: 'onSortersChanged',
          thisObj: this
        }
      });
    }
    return this._sorters;
  }

  /**
   * Adds a Sorter to the Collection of Sorters which are operating on this Collection.
   *
   * A Sorter may be an specified as an instantiated {@link Common.util.CollectionSorter
   * CollectionSorter}, or a config object for a CollectionSorter of the form
   *
   *     {
   *         property  : 'age',
   *         direction : 'desc'
   *     }
   *
   * Note that by default, a Sorter *replaces* a Sorter with the same `property` to make
   * it easy to change existing Sorters. A Sorter's `id` is its `property` by default. You
   * can avoid this and add multiple Sorters for one property by configuring Sorters with `id`s.
   *
   * A Sorter may also be specified as a function which compares two objects eg:
   *
   *     (lhs, rhs) => lhs.customerDetails.age - rhs.customerDetails.age
   *
   * @param {Object} sorter A Sorter of Sorter configuration object to add to the Collection
   * of Sorters operating on this Collection.
   * @returns {Common.util.CollectionSorter} The resulting Sorter to make it easy to remove Sorters.
   */
  addSorter(sorter) {
    const result = sorter instanceof CollectionSorter ? sorter : new CollectionSorter(sorter);

    this.sorters.add(result);

    return result;
  }

  /**
   * A flag which is `true` if this Collection has active {@link #property-sorters}.
   * @property {Boolean}
   * @readonly
   */
  get isSorted() {
    return Boolean(this._sorters && this._sorters.count);
  }

  onSortersChanged() {
    const me = this;

    delete me._sortFunction;

    me._values.sort(me.sortFunction);
    me._indicesInvalid = true;

    me.trigger('change', sortEvent);
  }

  /**
   * A sorter function which encapsulates the {@link Common.util.CollectionSorter Sorters}
   * for this Collection.
   * @property {Function}
   * @readonly
   */
  get sortFunction() {
    if (!this._sortFunction) {
      if (this.isSorted) {
        this._sortFunction = CollectionSorter.generateSortFunction(this.sorters.values);
      } else {
        this._sortFunction = return0;
      }
    }

    return this._sortFunction;
  }

  /**
   * The Collection of {@link Common.util.CollectionFilter Filters} for this Collection.
   * @property {Common.util.Collection}
   * @readonly
   */
  get filters() {
    if (!this._filters) {
      this._filters = new Collection({
        listeners: {
          change: 'onFiltersChanged',
          thisObj: this
        }
      });
    }
    return this._filters;
  }

  /**
   * Adds a Filter to the Collection of Filters which are operating on this Collection.
   *
   * A Filter may be an specified as an instantiated {@link Common.util.CollectionFilter
   * CollectionFilter}, or a config object for a CollectionFilter of the form
   *
   *     {
   *         property : 'age',
   *         operator : '>=',
   *         value    : 21
   *     }
   *
   * Note that by default, a Filter *replaces* a Filter with the same `property` to make
   * it easy to change existing Filters. A Filter's `id` is its `property` by default. You
   * can avoid this and add multiple Filters for one property by configuring Filters with `id`s.
   *
   * A Filter may also be specified as a function which filters candidate objects eg:
   *
   *     candidate => candidate.customerDetails.age >= 21
   *
   * @param {Object} filter A Filter or Filter configuration object to add to the Collection
   * of Filters operating on this Collection.
   * @returns {Common.util.CollectionFilter} The resulting Filter to make it easy to remove Filters.
   */
  addFilter(filter) {
    const result = filter instanceof CollectionFilter ? filter : new CollectionFilter(filter);

    this.filters.add(result);

    return result;
  }

  /**
   * A flag which is `true` if this Collection has active {@link #property-filters}.
   * @property {Boolean}
   * @readonly
   */
  get isFiltered() {
    return Boolean(this._filters && this._filters.count);
  }

  onFiltersChanged() {
    const me = this;

    me._filterFunction = null;
    me._filteredValues = me._values.filter(me.filterFunction);
    me._indicesInvalid = true;

    me.trigger('change', filterEvent);
  }

  /**
   * A filter function which encapsulates the {@link Common.util.CollectionFilter Filters}
   * for this Collection.
   * @property {Function}
   * @readonly
   */
  get filterFunction() {
    if (!this._filterFunction) {
      if (this.isFiltered) {
        this._filterFunction = CollectionFilter.generateFiltersFunction(this.filters.values);
      } else {
        this._filterFunction = FunctionHelper.returnTrue;
      }
    }

    return this._filterFunction;
  }

  /**
   * Adds a lookup index for the passed property name. The index is built lazily when
   * an index is serched,
   * @internal
   * @param {String} indexProperty The property name to add an index for.
   */
  addIndex(indexProperty) {
    (this._indices || (this._indices = {}))[indexProperty] = {};

    // Indices need a rebuild now.
    this._indicesInvalid = true;

    /**
     * this.indices is keyed by the property name, and contains the keys linked to the index in the _values array.
     * So collection.add({id : foo, name : 'Nige'}, {id : 'bar', name : 'Faye'}) where collection has had an index
     * added for the "name" property would result in:
     *
     * {
     *     id : {
     *         foo : 0,
     *         bar : 1
     *     },
     *     name : {
     *         Nige : 0,
     *         Faye : 1
     *     }
     * }
     */
  }

  /**
   * Return the index of the item with the specified key having the specified value.
   * By default, filtering is taken into account and this returns the index in the filtered
   * dataset if present. To bypass this, pass the third parameter as `true`.
   * @param {String} propertyName The name of the property to test.
   * @param {*} value The value to test for.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return the index in
   * the original data set if the item is filtered out.
   * @returns {Number} The index of the item, or `-1` if not found.
   */
  findIndex(propertyName, value, ignoreFilters = false) {
    const me = this,
      isFiltered = me.isFiltered,
      index =
        isFiltered && !ignoreFilters ? me.indices[filteredIndicesProperty][propertyName] : me.indices[propertyName];

    if (index) {
      const itemIndex = index[safeIndexKey(value)];

      if (itemIndex != null) {
        return itemIndex;
      }
    } else {
      // Search the filtered values if we are filtered and not ignoreing filters
      const values = isFiltered && !ignoreFilters ? me._filteredValues : me._values,
        count = values.length;

      for (let i = 0; i < count; i++) {
        if (values[i][propertyName] == value) {
          return i;
        }
      }
    }

    // Not found
    return -1;
  }

  /**
   * Returns the index of the item with the same `id` as the passed item.
   *
   * By default, filtering is honoured, so if the item in question has been added,
   * but is currently filtered out of visibility, `-1` will be returned.
   *
   * To find the index in the master, unfiltered dataset, pass the second parameter as `true`;
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to find the index in the master, unfiltered data set.
   * @returns {Number} The index of the item, or `-1` if not found.
   */
  indexOf(item, ignoreFilters = false) {
    return this.findIndex(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters);
  }

  /**
   * Returns `true` if this Collection includes an item with the same `id` as the passed item.
   *
   * By default, filtering is honoured, so if the item in question has been added,
   * but is currently filtered out of visibility, `false` will be returned.
   *
   * To query inclusion in the master, unfiltered dataset, pass the second parameter as `true`;
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to find the index in the master, unfiltered data set.
   * @returns {Boolean} True if the passed item is found.
   */
  includes(item, ignoreFilters = false) {
    return this.indexOf(item, ignoreFilters) !== -1;
  }

  get indices() {
    if (this._indicesInvalid) {
      this.rebuildIndices();
    }
    return this._indices;
  }

  /**
   * Called when the Collection is mutated and the indices have been flagged as invalid.
   *
   * Rebuilds the indices object to allow lookup by keys.
   * @internal
   */
  rebuildIndices() {
    const me = this,
      isFiltered = me.isFiltered,
      indices = me._indices || (me._indices = {}),
      keyProps = Object.keys(indices),
      indexCount = keyProps.length,
      values = me._values,
      count = values.length;

    let i, j;

    // First, clear indices.
    if (isFiltered) {
      indices[filteredIndicesProperty] = {};
    }
    for (i = 0; i < indexCount; i++) {
      indices[keyProps[i]] = {};
      if (isFiltered) {
        indices[filteredIndicesProperty][keyProps[i]] = {};
      }
    }

    /*
     * Rebuild the indices object.
     * Loop through all items adding an entry for each one to each index.
     * So collection.add({id : foo, name : 'Nige'}, {id : 'bar', name : 'Faye'}) where collection has had an index
     * added for the "name" property would result in:
     *
     * {
     *     id : {
     *         foo : 0,
     *         bar : 1
     *     },
     *     name : {
     *         Nige : 0,
     *         Faye : 1
     *     }
     * }
     */
    for (i = 0; i < count; i++) {
      const item = values[i];

      for (j = 0; j < indexCount; j++) {
        const keyProp = keyProps[j];
        // This does indices.name['Nige'] = 0
        indices[keyProp][safeIndexKey(item[keyProp])] = i;
      }
    }

    // Create a parallel lookup structure into the _filteredValues
    if (isFiltered) {
      const values = me._filteredValues,
        count = values.length,
        indices = me._indices[filteredIndicesProperty];

      for (i = 0; i < count; i++) {
        const item = values[i];

        for (j = 0; j < indexCount; j++) {
          const keyProp = keyProps[j];
          // This does indices[filteredIndicesProperty].name['Nige'] = 0
          indices[keyProp][safeIndexKey(item[keyProp])] = i;
        }
      }
    }

    me._indicesInvalid = false;
  }
}
Collection._$name = 'Collection';

/**
 * @module Common/helper/util/Scroller
 */

const scrollLiterals = {
    true: 'auto',
    false: 'hidden',
    'hidden-scroll': 'auto'
  },
  scrollerCls = 'b-widget-scroller',
  defaultScrollOptions = {
    block: 'nearest'
  },
  immediatePromise$1 = new Promise((resolve) => resolve()),
  xAxis = {
    x: 1
  };

/**
 * Encapsulates scroll functionality for a Widget. All requests for scrolling and scrolling information
 * must go through a Widget's {@link Common.widget.Widget#config-scrollable} property.
 * @extends Common/Base
 */
class Scroller extends Delayable(Events(Base)) {
  get defaultConfig() {
    return {
      /**
       * The element which is to scroll.
       * @config {HTMLElement}
       */
      element: null,

      /**
       * How to handle overflowing in the `X` axis.
       * May be:
       * * `'auto'`
       * * `'visible'`
       * * `'hidden'`
       * * `'scroll'`
       * * `'hidden-scroll'` Meaning scrollable from the UI but with no scrollbar,
       * for example a grid header. Only on platforms which support this feature.
       * * `true` - meaning `'auto'`
       * * `false` - meaning `'hidden'`
       * @config {String/Boolean}
       */
      overflowX: null,

      /**
       * How to handle overflowing in the `Y` axis.
       * May be:
       * * `'auto'`
       * * `'visible'`
       * * `'hidden'`
       * * `'scroll'`
       * * `'hidden-scroll'` Meaning scrollable from the UI but with no scrollbar.
       * Only on platforms which support this feature.
       * * `true` - meaning `'auto'`
       * * `false` - meaning `'hidden'`
       * @config {String/Boolean}
       */
      overflowY: null,

      /**
       * If configured as `true`, the {@link #config-element} is not scrolled
       * but is translated using CSS transform when controlled by this class's API.
       * Scroll events are fired when the element is translated.
       * @default
       * @config {Boolean}
       */
      translate: null
    };
  }

  /**
   * Fired when scrolling happens on this Scroller's element. The event object is a native `scroll` event
   * with the described extra properties injected.
   * @event scroll
   * @param {Common.widget.Widget} widget The owning Widget which has been scrolled.
   * @param {Common.helper.util.Scroller} source This Scroller
   */

  /**
   * Fired when scrolling finished on this Scroller's element. The event object is the last native `scroll` event
   * fires by the element with the described extra properties injected.
   * @event scrollend
   * @param {Common.widget.Widget} widget The owning Widget which has been scrolled.
   * @param {Common.helper.util.Scroller} source This Scroller
   */

  /**
   * Partners this Scroller with the passed scroller in order to sync the scrolling position in the passed axes
   * @param {Common.helper.util.Scroller} otherScroller
   * @param {String|Object} [axes='x'] `'x'` or `'y'` or `{x: true/false, y: true/false}` axes to sync
   */
  addPartner(otherScroller, axes = xAxis) {
    if (typeof axes === 'string') {
      axes = {
        [axes]: 1
      };
    }

    (this.partners || (this.partners = new Collection())).add({
      id: otherScroller.id,
      scroller: otherScroller,
      axes
    });

    // It's a mutual relationship - the other scroller partners with us.
    if (!otherScroller.partners || !otherScroller.partners.includes(this.id)) {
      otherScroller.addPartner(this, axes);
    }
  }

  /**
   * Breaks the link between this Scroller and the passed Scroller set up by the
   * {@link #function-addPartner} method.
   * @param {Common.helper.util.Scroller} otherScroller The Scroller to unlink from.
   */
  removePartner(otherScroller) {
    if (this.partners && this.partners.includes(otherScroller)) {
      this.partners.remove(otherScroller);
      otherScroller.removePartner(this);
    }
  }

  /**
   * Scrolls the passed element or {@link Common.helper.util.Rectangle} into view according to the passed options.
   * @param {HTMLElement|Common.helper.util.Rectangle} element The element or a Rectangle in document space to scroll into view.
   * @param {Object} [options] How to scroll.
   * @param {String} [options.block] How far to scroll the element: `start/end/center/nearest`.
   * @param {Number} [options.edgeOffset] edgeOffset A margin around the element or rectangle to bring into view.
   * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
   * or the number of milliseconds to animate over, or an animation config object.
   * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
   * @param {String} [options.animate.easing] The name of an easing function.
   * @param {Boolean} [options.highlight] Set to `true` to highlight the element when it is in view.
   * @param {Boolean} [options.focus] Set to `true` to focus the element when it is in view.
   * @param {Boolean} [options.x] Pass as `false` to disable scrolling in the `X` axis.
   * @param {Boolean} [options.y] Pass as `false` to disable scrolling in the `Y` axis.
   * @returns {Promise} A promise which is resolved when the element has been scrolled into view.
   */
  scrollIntoView(element, options = defaultScrollOptions) {
    const isRectangle = element instanceof Rectangle,
      originalRect = isRectangle ? element : Rectangle.from(element),
      { xDelta, yDelta } = this.getDeltaTo(element, options),
      result = this.scrollBy(xDelta, yDelta, options);

    if (options.highlight || options.focus) {
      result.then(() => {
        if (isRectangle) {
          element = originalRect.translate(-xDelta, -yDelta);
        }
        if (options.highlight) {
          DomHelper.highlight(element);
        }
        if (options.focus) {
          element.focus();
        }
      });
    }
    return result;
  }

  /**
   * Scrolls by the passed deltas according to the passed options.
   * @param {Number} [xDelta=0] How far to scroll in the X axis.
   * @param {Number} [yDelta=0] How far to scroll in the Y axis.
   * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
   * @param {Boolean} [options.silent] Set to `true` to suspend `scroll` events during scrolling.
   * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
   * or the number of milliseconds to animate over, or an animation config object.
   * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
   * @param {String} [options.animate.easing] The name of an easing function.
   * @returns {Promise} A promise which is resolved when the scrolling has fnished.
   */
  scrollBy(xDelta = 0, yDelta = 0, options = defaultScrollOptions) {
    const me = this,
      animate = typeof options === 'object' ? options.animate : options,
      absX = Math.abs(xDelta),
      absY = Math.abs(yDelta);

    if (me.scrollAnimation) {
      me.scrollAnimation.cancel();
      me.scrollAnimation = null;
    }

    // Only set the flag if there is going to be scrolling done.
    // It is cleared by the scrollEnd handler, so there must be scrolling.
    if (xDelta || yDelta) {
      me.silent = options.silent;
    }

    let duration =
      animate &&
      (typeof animate === 'number' ? animate : typeof animate.duration === 'number' ? animate.duration : 300);

    // Only go through animation if there is significant scrolling to do.
    if (duration && (absX > 10 || absY > 10)) {
      const { x, y } = me;
      let lastX = x,
        lastY = y;

      // For small distances, constrain duration
      if (Math.max(absX, absY) < 50) {
        duration = Math.min(duration, 500);
      }

      me.scrollAnimation = FunctionHelper.animate(
        duration,
        (progress) => {
          const isEnd = progress === 1;
          if (xDelta) {
            // If the user, or another process has changed the position since last time, abort.
            // Unless called with the force option to proceed regardless.
            if (me.x !== lastX && !options.force) {
              return me.scrollAnimation && me.scrollAnimation.cancel();
            }
            lastX = me.x = Math.max(x + (isEnd ? xDelta : Math.round(xDelta * progress)), 0);
          }
          if (yDelta) {
            // If the user, or another process has changed the position since last time, abort.
            // Unless called with the force option to proceed regardless.
            if (me.y !== lastY && !options.force) {
              return me.scrollAnimation && me.scrollAnimation.cancel();
            }
            lastY = me.y = Math.max(y + (isEnd ? yDelta : Math.round(yDelta * progress)), 0);
          }
        },
        null,
        animate.easing
      );
      me.scrollAnimation.then(() => {
        me.scrollAnimation = null;
      });
      return me.scrollAnimation;
    } else {
      me.x += xDelta;
      me.y += yDelta;
      return immediatePromise$1;
    }
  }

  /**
   * Scrolls to the passed position according to the passed options.
   * @param {Number} [toX=0] Where to scroll to in the X axis.
   * @param {Number} [toY=0] Where to scroll to in the Y axis.
   * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
   * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
   * or the number of milliseconds to animate over, or an animation config object.
   * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
   * @param {String} [options.animate.easing] The name of an easing function.
   * @returns {Promise} A promise which is resolved when the scrolling has finished.
   */
  scrollTo(toX, toY, options) {
    const { x, y } = this,
      xDelta = toX == null ? 0 : toX - x,
      yDelta = toY == null ? 0 : toY - y;

    return this.scrollBy(xDelta, yDelta, options);
  }

  doDestroy() {
    const me = this;

    if (me._element) {
      me._element.removeEventListener('scroll', me.scrollHandler);
      me.wheelListenerRemover && me.wheelListenerRemover();
    }
    if (me.scrollAnimation) {
      me.scrollAnimation.cancel();
    }

    me.partners && me.partners.forEach((partner) => partner.scroller.removePartner(me));

    super.doDestroy();
  }

  /**
   * Respond to style changes to monitor scroll *when this Scroller is in `translate: true` mode.*
   * @param {Object[]} mutations The ElementMutation records.
   * @private
   */
  onElMutation(mutations) {
    const me = this,
      [x, y] = DomHelper.getTranslateXY(me.element);

    // If the mutation was due to a change in the translateX/Y styles, this is
    // a scroll event, so inform observers and partners
    if (me._x !== -x || me.y !== -y) {
      const scrollEvent = new CustomEvent('scroll', { bubbles: true });

      Object.defineProperty(scrollEvent, 'target', {
        get: () => me.element
      });

      me.onScroll(scrollEvent);
    }
  }

  onScroll(e) {
    const me = this;

    if (!me.widget || !me.widget.isDestroyed) {
      // Don't read the value until we have to. The x & y getters will check this flag
      me.positionDirty = true;
      e.widget = me.widget;

      // If we have the scroll silent flag, do not fire the event.
      if (!me.silent) {
        me.trigger('scroll', e);
      }

      // Keep partners in sync
      if (me.partners) {
        me.partners.forEach(({ axes, scroller }) => {
          // Don't feed back to the one who's just told us to scroll here.
          if (scroller !== me.controllingPartner) {
            scroller.sync(me, axes);
          }
        });
      }

      // If this scroll impulse was from a controlling partner, clear that now
      me.controllingPartner = null;

      // Will fire in 100ms, unless another scroll event comes round.
      // In which case execution will be pushed out by another 100ms.
      me.scrollEndHandler(e);
    }
  }

  onScrollEnd(e) {
    if (this.silent) {
      this.silent = false;
    }
    this.trigger('scrollEnd', e);
  }

  /**
   * Returns the xDelta and yDelta values in an object from the current scroll position to the
   * passed element or Rectangle.
   * @param {HTMLElement|Common.helper.util.Rectangle} element The element or a Rectangle to calculate deltas for.
   * @param {Object} [options] How to scroll.
   * @param {String} [options.block] How far to scroll the element: `start/end/center/nearest`.
   * @param {Number} [options.edgeOffset] A margin around the element or rectangle to bring into view.
   * @param {Boolean} [options.x] Pass as `false` to disable scrolling in the `X` axis.
   * @param {Boolean} [options.y] Pass as `false` to disable scrolling in the `Y` axis.
   * @returns {Object} `{ xDelta, yDelta }`
   * @internal
   */
  getDeltaTo(element, options) {
    if (!(element instanceof Rectangle)) {
      element = Rectangle.from(element);
    }
    const me = this,
      block = options.block || 'nearest',
      scrollerRect = me.viewport,
      edgeOffset = options.edgeOffset || 0,
      // Only include the offset round the target is the viewport is big enough to accommodate it.
      xOffset = scrollerRect.width >= element.width + edgeOffset * 2 ? edgeOffset : 0,
      yOffset = scrollerRect.height >= element.height + edgeOffset * 2 ? edgeOffset : 0,
      elRect = element
        .clone()
        .adjust(-xOffset, -yOffset, xOffset, yOffset)
        .constrainTo(new Rectangle(scrollerRect.x - me.x, scrollerRect.y - me.y, me.scrollWidth, me.scrollHeight)),
      targetRect = elRect.clone();

    let xDelta = 0,
      yDelta = 0;

    if (block === 'start') {
      targetRect.moveTo(scrollerRect.x, scrollerRect.y);
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    } else if (block === 'end') {
      targetRect.translate(scrollerRect.right - targetRect.right, scrollerRect.bottom - targetRect.bottom);
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    } else if (block === 'center') {
      const center = scrollerRect.center;

      targetRect.moveTo(center.x - targetRect.width / 2, center.y - targetRect.height / 2);
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    }
    // Use "nearest"
    else {
      // If it's *possible* to scroll to nearest x, calculate the delta
      if (targetRect.width <= scrollerRect.width) {
        if (targetRect.right > scrollerRect.right) {
          xDelta = targetRect.right - scrollerRect.right;
        } else if (targetRect.x < scrollerRect.x) {
          xDelta = targetRect.x - scrollerRect.x;
        }
      }
      // If it's *possible* to scroll to nearest y, calculate the delta
      if (targetRect.height <= scrollerRect.height) {
        if (targetRect.bottom > scrollerRect.bottom) {
          yDelta = targetRect.bottom - scrollerRect.bottom;
        } else if (targetRect.y < scrollerRect.y) {
          yDelta = targetRect.y - scrollerRect.y;
        }
      }
    }

    // Do not allow deltas which would produce -ve scrolling or scrolling past the maxX/Y
    return {
      // When calculating how much delta is necessary to scroll the targetRect to the center
      // constrain that to what is *possible*. If what you are trying to scroll into the
      // center is hard against the right edge of the scroll range, then it cannot scroll
      // to the center, and the result must reflect that even though scroll is self limiting.
      // This is because highlighting the requested "element", if that element is in fact
      // a Rectangle, uses a temporary element placed at the requested region which
      // MUST match where the actual scroll has moved the requested region.
      xDelta: options.x === false ? 0 : Math.max(Math.min(xDelta, me.maxX - me.x), -me.x),
      yDelta: options.y === false ? 0 : Math.max(Math.min(yDelta, me.maxY - me.y), -me.y)
    };
  }

  /**
   * A {@link Common.helper.util.Rectangle Rectangle} describing the bounds of the scrolling viewport.
   * @property {Common.helper.util.Rectangle}
   */
  get viewport() {
    return Rectangle.from(this.element);
  }

  get element() {
    return this._element;
  }
  set element(element) {
    const me = this,
      scrollHandler = me.scrollHandler || (me.scrollHandler = me.onScroll.bind(me));

    if (!me.scrollEndHandler) {
      me.scrollEndHandler = me.buffer(me.onScrollEnd, 100);
    }

    if (me._element) {
      if (me.translate) {
        me.mutationObserver && me.mutationObserver.disconnect(me._element);
      } else {
        me._element.removeEventListener('scroll', scrollHandler);
        me._element.classList.remove(scrollerCls);
      }
    }
    me._element = element;

    if (me.translate) {
      if (!me.mutationObserver) {
        me.mutationObserver = new MutationObserver((mutations) => me.onElMutation(mutations));
      }
      me.mutationObserver.observe(element, { attributes: true });

      me._x = me._y = 0;
      if (document.contains(element)) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      }
    } else {
      element.addEventListener('scroll', scrollHandler);
      element.classList.add(scrollerCls);
    }

    // Ensure the overflow configs, which are unable to process themselves
    // in the absence of the element get applied to the newly arrived element.
    me.updateOverflowX(me.overflowX);
    me.updateOverflowY(me.overflowY);
  }

  /**
   * The horizontal scroll position of the widget.
   * @property {Number}
   */
  get x() {
    const me = this,
      { element } = me;

    if (element && me.positionDirty) {
      if (me.translate) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      } else {
        me._x = element.scrollLeft;
        me._y = element.scrollTop;
      }
      me.positionDirty = false;
    }
    return me._x;
  }
  set x(x) {
    const { element } = this;

    this._x = x;

    if (element) {
      if (this.translate) {
        DomHelper.setTranslateX(element, -x);
      } else {
        element.scrollLeft = x;
      }

      // The scroll position will need to be read before we can return it.
      // Do not read it back now, that would cause a forced synchronous layout.
      this.positionDirty = true;
    }
  }

  sync(controllingPartner, axes) {
    const { x, y } = axes;

    this.controllingPartner = controllingPartner;

    if (x != null) {
      this.x = controllingPartner.x;
    }
    if (y != null) {
      this.y = controllingPartner.y;
    }
  }

  /**
   * The vertical scroll position of the widget.
   * @property {Number}
   */
  get y() {
    const me = this,
      { element } = me;

    if (element && me.positionDirty) {
      if (me.translate) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      } else {
        me._x = element.scrollLeft;
        me._y = element.scrollTop;
      }
      me.positionDirty = false;
    }
    return me._y;
  }
  set y(y) {
    const { element } = this;

    this._y = y;

    if (element) {
      if (this.translate) {
        DomHelper.setTranslateY(element, -y);
      } else {
        element.scrollTop = y;
      }

      // The scroll position will need to be read before we can return it.
      // Do not read it back now, that would cause a forced synchronous layout.
      this.positionDirty = true;
    }
  }

  /**
   * The maximum `X` scrollable position of the widget.
   * @property {Number}
   * @readonly
   */
  get maxX() {
    return this.scrollWidth - this.clientWidth;
  }

  /**
   * The maximum `Y` scrollable position of the widget.
   * @property {Number}
   * @readonly
   */
  get maxY() {
    return this.scrollHeight - this.clientHeight;
  }

  /**
   * The `overflow-x` setting for the widget. `true` means `'auto'`.
   * @property {Boolean/String}
   */
  get overflowX() {
    return this._overflowX;
  }
  set overflowX(overflowX) {
    this._overflowX = overflowX;

    if (this.element) {
      this.updateOverflowX(overflowX);
    }
  }

  updateOverflowX(overflowX) {
    const { element, translate } = this;

    // Scroll, but without showing scrollbars.
    // For example a grid header. Only works on platforms which
    // support suppression of scrollbars through CSS.
    if (overflowX === 'hidden-scroll' && !translate) {
      element.classList.add('b-hide-scroll');

      // Adds a wheel listener if needed - there is scrollbar width
      // and we don't already have one.
      this.enableWheel();
    }
    if (!translate) {
      element.style.overflowX = scrollLiterals[overflowX] || overflowX;
    }
    this.positionDirty = true;
  }

  /**
   * The `overflow-y` setting for the widget. `true` means `'auto'`.
   * @property {Boolean/String}
   */
  get overflowY() {
    return this._overflowY;
  }
  set overflowY(overflowY) {
    this._overflowY = overflowY;

    if (this.element) {
      this.updateOverflowY(overflowY);
    }
  }

  updateOverflowY(overflowY) {
    const { element, translate } = this;

    // Scroll, but without showing scrollbars.
    // For example a grid header. Only works on platforms which
    // support suppression of scrollbars through CSS.
    if (overflowY === 'hidden-scroll' && !translate) {
      element.classList.add('b-hide-scroll');

      // Adds a wheel listener if needed - there is scrollbar width
      // and we don't already have one.
      this.enableWheel();
    }
    if (!translate) {
      element.style.overflowY = scrollLiterals[overflowY] || overflowY;
    }
    this.positionDirty = true;
  }

  enableWheel() {
    if (!BrowserHelper.isChrome && !BrowserHelper.isSafari && !this.wheelListenerRemover) {
      this.wheelListenerRemover = EventHelper.on({
        element: this.element,
        wheel: 'onWheel',
        thisObj: this
      });
    }
  }

  onWheel(e) {
    if (e.deltaX > e.deltaY && this.overflowX !== false) {
      this.x += e.deltaX;
    } else if (this.overflowY !== false) {
      this.y += e.deltaY;
    }
  }

  /**
   * The horizontal scroll range of the widget.
   * @property {Number}
   * @readonly
   */
  get scrollWidth() {
    return this.element ? this.element.scrollWidth : 0;
  }

  set scrollWidth(scrollWidth) {
    const me = this;
    let stretcher = me.widthStretcher;

    // "Unsetting" scrollWidth removes the stretcher
    if (stretcher && scrollWidth == null) {
      stretcher.remove();
      me.widthStretcher = null;
    } else if (scrollWidth) {
      if (!stretcher) {
        stretcher = me.widthStretcher = DomHelper.createElement({
          className: 'b-scroller-stretcher'
        });
      }

      stretcher.style.transform = `translateX(${scrollWidth - 1}px)`;

      if (me.element && me.element.lastChild !== stretcher) {
        me.element.appendChild(stretcher);
      }
    }
  }

  get scrollHeight() {
    return this.element ? this.element.scrollHeight : 0;
  }

  /**
   * The vertical scroll range of the widget. May be set to larger than the actual data
   * height to enable virtual scrolling. This is how the grid extends its scroll range
   * while only rendering a small subset of the dataset.
   * @property {Number}
   */
  set scrollHeight(scrollHeight) {
    const me = this,
      stretcher =
        me.stretcher ||
        (me.stretcher = DomHelper.createElement({
          className: 'b-scroller-stretcher'
        }));

    stretcher.style.transform = `translateY(${scrollHeight - 1}px)`;
    if (me.element && me.element.lastChild !== stretcher) {
      me.element.appendChild(stretcher);
    }
  }

  /**
   * The client width of the widget.
   * @property {Number}
   * @readonly
   */
  get clientWidth() {
    return this.element ? this.element.clientWidth : 0;
  }

  /**
   * The client height of the widget.
   * @property {Number}
   * @readonly
   */
  get clientHeight() {
    return this.element ? this.element.clientHeight : 0;
  }

  /**
   * The unique ID of this Scroller
   * @property {String}
   * @readonly
   */
  get id() {
    if (!this._id) {
      if (this.widget) {
        this._id = `${this.widget.id}-scroller`;
      } else {
        this._id = IdHelper.generateId('scroller-');
      }
    }
    return this._id;
  }
}
Scroller._$name = 'Scroller';

const locale$1 = {
  localeName: 'En',
  localeDesc: 'English',

  //region Columns

  TemplateColumn: {
    noTemplate: 'TemplateColumn needs a template',
    noFunction: 'TemplateColumn.template must be a function'
  },

  ColumnStore: {
    columnTypeNotFound: (data) => `Column type '${data.type}' not registered`
  },

  //endregion

  //region Mixins

  InstancePlugin: {
    fnMissing: (data) =>
      `Trying to chain fn ${data.plugIntoName}#${data.fnName}, but plugin fn ${data.pluginName}#${data.fnName} does not exist`,
    overrideFnMissing: (data) =>
      `Trying to override fn ${data.plugIntoName}#${data.fnName}, but plugin fn ${data.pluginName}#${data.fnName} does not exist`
  },

  //endregion

  //region Features

  ColumnPicker: {
    columnsMenu: 'Columns',
    hideColumn: 'Hide column',
    hideColumnShort: 'Hide'
  },

  Filter: {
    applyFilter: 'Apply filter',
    filter: 'Filter',
    editFilter: 'Edit filter',
    on: 'On',
    before: 'Before',
    after: 'After',
    equals: 'Equals',
    lessThan: 'Less than',
    moreThan: 'More than',
    removeFilter: 'Remove filter'
  },

  FilterBar: {
    enableFilterBar: 'Show filter bar',
    disableFilterBar: 'Hide filter bar'
  },

  Group: {
    groupAscending: 'Group ascending',
    groupDescending: 'Group descending',
    groupAscendingShort: 'Ascending',
    groupDescendingShort: 'Descending',
    stopGrouping: 'Stop grouping',
    stopGroupingShort: 'Stop'
  },

  Search: {
    searchForValue: 'Search for value'
  },

  Sort: {
    sortAscending: 'Sort ascending',
    sortDescending: 'Sort descending',
    multiSort: 'Multi sort',
    removeSorter: 'Remove sorter',
    addSortAscending: 'Add ascending sorter',
    addSortDescending: 'Add descending sorter',
    toggleSortAscending: 'Change to ascending',
    toggleSortDescending: 'Change to descending',
    sortAscendingShort: 'Ascending',
    sortDescendingShort: 'Descending',
    removeSorterShort: 'Remove',
    addSortAscendingShort: '+ Ascending',
    addSortDescendingShort: '+ Descending'
  },

  Tree: {
    noTreeColumn: 'To use the tree feature one column must be configured with tree: true'
  },

  //endregion

  //region Grid

  Grid: {
    featureNotFound: (data) => `Feature '${data}' not available, make sure you have imported it`,
    invalidFeatureNameFormat: (data) => `Invalid feature name '${data}', must start with a lowercase letter`,
    removeRow: 'Delete row',
    removeRows: 'Delete rows',
    loadMask: 'Loading...',
    loadFailedMessage: 'Data loading failed.',
    moveColumnLeft: 'Move to left section',
    moveColumnRight: 'Move to right section',
    noRows: 'No rows to display'
  },

  //endregion

  //region Widgets

  Field: {
    invalidValue: 'Invalid field value',
    minimumValueViolation: 'Minimum value violation',
    maximumValueViolation: 'Maximum value violation',
    fieldRequired: 'This field is required',
    validateFilter: 'Value must be selected from the list'
  },

  DateField: {
    invalidDate: 'Invalid date input'
  },

  TimeField: {
    invalidTime: 'Invalid time input'
  },

  //endregion

  //region Others

  DateHelper: {
    locale: 'en-US',
    shortWeek: 'W',
    shortQuarter: 'q',
    week: 'Week',
    weekStartDay: 0,
    unitNames: [
      { single: 'millisecond', plural: 'ms', abbrev: 'ms' },
      { single: 'second', plural: 'seconds', abbrev: 's' },
      { single: 'minute', plural: 'minutes', abbrev: 'min' },
      { single: 'hour', plural: 'hours', abbrev: 'h' },
      { single: 'day', plural: 'days', abbrev: 'd' },
      { single: 'week', plural: 'weeks', abbrev: 'w' },
      { single: 'month', plural: 'months', abbrev: 'mon' },
      { single: 'quarter', plural: 'quarters', abbrev: 'q' },
      { single: 'year', plural: 'years', abbrev: 'yr' }
    ],
    // Used to build a RegExp for parsing time units.
    // The full names from above are added into the generated Regexp.
    // So you may type "2 w" or "2 wk" or "2 week" or "2 weeks" into a DurationField.
    // When generating its display value though, it uses the full localized names above.
    unitAbbreviations: [
      ['mil'],
      ['s', 'sec'],
      ['m', 'min'],
      ['h', 'hr'],
      ['d'],
      ['w', 'wk'],
      ['mo', 'mon', 'mnt'],
      ['q', 'quar', 'qrt'],
      ['y', 'yr']
    ],
    parsers: {
      L: 'MM/DD/YYYY',
      LT: 'HH:mm A'
    },
    ordinalSuffix: (number) => number + ({ '1': 'st', '2': 'nd', '3': 'rd' }[number[number.length - 1]] || 'th')
  },

  BooleanCombo: {
    Yes: 'Yes',
    No: 'No'
  }

  //endregion
};

LocaleManagerSingelton.registerLocale('En', { desc: 'English', locale: locale$1 });

let globaltouchStart,
  focusEventsSuspended = false,
  GlobalEvents = ((window.bryntum || (window.bryntum = {})).GlobalEvents = new (class extends Events(Base) {
    suspendFocusEvents() {
      focusEventsSuspended = true;
    }
    resumeFocusEvents() {
      focusEventsSuspended = false;
    }
    get lastInteractionType() {
      return lastInteractionType;
    }
  })()),
  lastInteractionType;

function createWidgetEvent(eventName, target, relatedTarget, fromWidget, toWidget, backwards, options) {
  const result = new CustomEvent(eventName, options);

  Object.defineProperty(result, 'target', {
    get() {
      return target;
    }
  });
  Object.defineProperty(result, 'relatedTarget', {
    get() {
      return relatedTarget;
    }
  });
  result.fromWidget = fromWidget;
  result.toWidget = toWidget;
  result.backwards = backwards;

  return result;
}

function getCommonAncestor(from, to) {
  if (from === to) {
    return from;
  }
  const isWidget = from instanceof Widget;

  while (from && !(from[isWidget ? 'owns' : 'contains'](to) || from === to)) {
    from = from[isWidget ? 'owner' : 'parentNode'];
  }
  return from;
}

const listeners = {
  element: document,
  touchstart(touchstart) {
    if (!globaltouchStart && touchstart.changedTouches.length === 1) {
      globaltouchStart = touchstart.changedTouches[0];
    } else {
      globaltouchStart = null;
    }
  },
  // Just this one has to be passive: false so that we are allowed to preventDefault
  // if we are part of a contextmenu longpres emulation. Otherwise the gesture will
  // proceed to cause a mousedown event.
  touchend: {
    handler: (event) => {
      if (globaltouchStart) {
        // If the touchstart was used to synthesize a contextmenu event
        // stop the touch gesture processing right now.
        // Also prevent the conversion of the touch into  click.
        if (globaltouchStart.identifier === EventHelper.contextMenuTouchId) {
          event.stopImmediatePropagation();
          event.preventDefault();
        } else if (
          event.changedTouches.length === 1 &&
          event.changedTouches[0].identifier === globaltouchStart.identifier
        ) {
          GlobalEvents.trigger('globaltap', { event });
        }
        globaltouchStart = null;
      }
    },
    passive: false
  },
  mousedown: {
    handler: (event) => {
      lastInteractionType = 'mouse';
      if (!globaltouchStart) {
        GlobalEvents.trigger('globaltap', { event });
      }
    },
    passive: false
  },
  keydown() {
    lastInteractionType = 'key';
  },
  keypress() {
    lastInteractionType = 'key';
  },
  focusin(focusin) {
    // https://app.assembla.com/spaces/bryntum/tickets/5503
    // Caused by the browser scrolling a focused element into view. The browser will do *whatever it takes*
    // to scroll a focused element so that as much of it is in view as possible. Its first point of scrolling will
    // be the float containing element. That must never scroll.
    Widget.floatRoot.scrollTop = Widget.floatRoot.scrollLeft = 0;

    if (focusEventsSuspended) {
      return;
    }

    const fromElement = focusin.relatedTarget,
      toElement = focusin.target || document.body,
      fromWidget = IdHelper.fromElement(fromElement),
      toWidget = IdHelper.fromElement(toElement),
      commonAncestor = getCommonAncestor(fromWidget, toWidget),
      // Flag if the fromElement is DOCUMENT_POSITION_FOLLOWING toElement
      backwards = !!(fromElement && toElement.compareDocumentPosition(fromElement) & 4);

    let event = createWidgetEvent('focusout', fromElement, toElement, fromWidget, toWidget, backwards);

    // Bubble focusout event up the "from" side of the tree
    for (let target = fromWidget; target && target !== commonAncestor; target = target.owner) {
      if (!(target.isDestroyed || target.isDestroying)) {
        target.onFocusOut && target.onFocusOut(event);
      }
    }

    // Focus is moving upwards to the ancestor widget.
    // Its focus method might delegate focus to a focusable descendant.
    if (commonAncestor && focusin.target === commonAncestor.element) {
      // If one of the handlers above has not moved focus onwards
      // and the common ancestor is a container which delegates
      // focus inwards to a descendant, then give it the opportunity to do that.
      if (
        document.activeElement === toElement &&
        commonAncestor.focusElement &&
        commonAncestor.focusElement !== commonAncestor.element
      ) {
        // Wait until out of the focusin handler to move focus on.
        setTimeout(() => commonAncestor.focus && commonAncestor.focus(), 0);
      }
    }
    // Focus is moving between two branches of a subtree.
    // Bubble focusin event up the "to" side of the tree
    else {
      event = createWidgetEvent('focusin', toElement, fromElement, fromWidget, toWidget, backwards);
      for (let target = toWidget; target && target !== commonAncestor; target = target.owner) {
        if (!(target.isDestroyed || target.isDestroying)) {
          target.onFocusIn && target.onFocusIn(event);
        }
      }
    }
    // Fire element focusmove event. Grid navigation will use  this when cells are focusable.
    const commonAncestorEl =
      getCommonAncestor(fromElement && fromElement.nodeType === 1 ? fromElement : null, toElement) ||
      toElement.parentNode;
    event = createWidgetEvent('focusmove', toElement, fromElement, fromWidget, toWidget, backwards, { bubbles: true });
    commonAncestorEl.dispatchEvent(event);
  },
  focusout(focusout) {
    if (focusEventsSuspended) {
      return;
    }

    if (!focusout.relatedTarget || !IdHelper.fromElement(focusout.relatedTarget)) {
      listeners.focusin({
        target: focusout.relatedTarget,
        relatedTarget: focusout.target
      });
    }
  },
  capture: true,
  passive: true
};

function setupFocusListeners(element = document) {
  const config = ObjectHelper.assign({}, listeners, { element });
  EventHelper.on(config);
}

setupFocusListeners();

// TODO: Needs more docs

/**
 * @module Common/widget/Widget
 */

const isTransparent = /transparent|rgba\(0,\s*0,\s*0,\s*0\)/,
  textInputTypes = {
    INPUT: 1,
    TEXTAREA: 1
  },
  widgetTriggerPaint = (w) => w.isVisible && w.trigger('paint'),
  negationPseudo = /^:not\((.+)\)$/,
  isRealigningFloater = (w) => w.floating && w.scrollAction === 'realign',
  dragGhost = DomHelper.createElement({
    // Safari won't allow dragging an empty node
    html: '\xa0',
    style: 'position:absolute;top:-10000em;left:-10000em'
  });

/**
 * Base class for other widgets. The Widget base class simply encapsulates an element, and may optionally contain some
 * specified {@link #config-html}.
 *
 * Subclasses should at override the {@link #function-template} member function to return an HTML string to create their own encapsulating element
 * and internal structure.
 *
 * @mixes Common/mixin/Events
 * @mixes Common/localization/Localizable
 * @extends Common/Base
 * @classType widget
 */
class Widget extends Delayable(Events(Localizable(Base))) {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * A {@link Common.helper.DomHelper#function-createElement-static} config object or HTML string from which to
       * create the Widget's element.
       * @private
       * @config {Object|String}
       * @category DOM
       */
      element: true,

      callOnFunctions: true,

      /**
       * Widget id, if not specified one will be generated. Also used for lookups through WidgetHelper
       * @config {String}
       * @category DOM
       */
      id: '',

      /**
       * Html to display initially
       * @config {String}
       * @category DOM
       */
      html: null,

      /**
       * true if no id was set, will use generated id instead (widget1, ...). Toggle automatically on creation
       * @default false
       * @type {Boolean}
       * @private
       * @category Misc
       */
      hasGeneratedId: null,

      /**
       * Custom CSS class to add to element
       * @config {String}
       * @category CSS
       */
      cls: null,

      /**
       * Custom style spec to add to element
       * @config {String}
       * @category CSS
       */
      style: null,

      /**
       * Disabled or enabled
       * @default false
       * @config {Boolean}
       * @category Misc
       */
      disabled: null,

      /**
       * Element (or element id) to append this widgets element to
       * @config {HTMLElement|String}
       * @default
       * @category DOM
       */
      appendTo: null,

      /**
       * Element (or element id) to insert this widget before. If provided, {@link #config-appendTo} config is ignored.
       * @config {HTMLElement|String}
       * @category DOM
       */
      insertBefore: null,

      /**
       * Element (or element id) to append this widget element to, as a first child. If provided, {@link #config-appendTo} config is ignored.
       * @config {HTMLElement|String}
       * @category DOM
       */
      insertFirst: null,

      /**
       * Object to apply to elements dataset (each key will be used as a data-attribute on the element)
       * @config {Object}
       * @category DOM
       */
      dataset: null,

      /**
       * Tooltip for the widget, either as a string or as a Tooltip config object
       * @config {String|Object}
       * @category Misc
       */
      tooltip: null,

      /**
       * Prevent tooltip from being displayed on touch devices. Useful for example for buttons that display a
       * menu on click etc, since the tooltip would be displayed at the same time.
       * @config {Boolean}
       * @default false
       * @category Misc
       */
      preventTooltipOnTouch: null,

      /**
       * Specify true to have widget monitoring window resize.
       * @config {Boolean}
       * @default false
       * @category Misc
       */
      monitorResize: null,

      cache: {},

      /**
       * Set to `true` to move the widget out of the document flow and position it
       * absolutely in browser viewport space.
       * @config {Boolean}
       * @default
       * @category Float & align
       */
      floating: null,

      /**
       * Set to `true` when a widget is rendered into another widget's  {@link #property-contentElement}, but must not
       * participate in the standard layout of that widget, and must be positioned relatively to that
       * widget's {@link #property-contentElement}.
       *
       * {@link Common.widget.Editor Editor}s are positioned widgets.
       * @config {Boolean}
       * @default
       * @category Float & align
       */
      positioned: null,

      /**
       * Only valid if this Widget is {@link #config-floating}
       * Set to `true` to be able to drag a widget freely on the page. Or set to an object with a ´handleSelector´ property which controls when a drag
       * should start.
       *
       * ```javascript
       *
       * draggable : {
       *     handleSelector : ':not(button)'
       * }
       *
       * ```
       *
       * @config {Boolean/Object}
       * @default false
       * @category Float & align
       */
      draggable: null,

      /**
       * Only valid if this Widget is {@link #config-floating}
       * The edge alignment spec to use by default when {@link #function-showBy} or {@link #function-alignTo} is used.
       * Format is `'[trbl]n-[trbl]n'` and it specifies our edge and the target edge plus optional
       * offsets from 0 to 100 along the edges to align to. See the {@link #function-showBy} function for more details.
       * @default
       * @config {String}
       * @category Float & align
       */
      align: 't-b',

      /**
       * Only valid if this Widget is {@link #config-floating}
       * Set to `true` to centre the Widget in browser viewport space.
       * @config {Boolean}
       * @default
       * @category Float & align
       */
      centered: null,

      /**
       * Only valid if this Widget is {@link #config-floating} and being shown through {@link #function-showBy}.
       * Element, Widget or Rectangle to which this Widget is constrained.
       * @config {HTMLElement|Common.widget.Widget|Common.helper.util.Rectangle}
       * @default document.body
       * @category Float & align
       */
      constrainTo: null,

      /**
       * Only valid if this Widget is {@link #config-floating} and being shown through {@link #function-showBy}.
       * `true` to show a connector arrow pointing to the align target.
       * @config {Boolean}
       * @default false
       * @category Float & align
       */
      anchor: null,

      /**
       * Defines what to do if document is scrolled while Widget is visible (only relevant when floating is set to true).
       * Valid values: ´null´: do nothing, ´hide´: hide the widget or ´realign´: realign to the target if possible.
       * @config {String}
       * @default
       * @category Float & align
       */
      scrollAction: null,

      /**
       * Only valid if this Widget is {@link #config-floating}. An object which defined which CSS style
       * property should be animated upon hide, and how it should be animated eg:
       *
       * ```javascript
       * {
       *    opacity: {
       *        to : 0,
       *        duration: '10s',
       *        delay: '0s'
       *    }
       * }
       * ```
       *
       * Set to `'false'` to disable animation.
       *
       * @config {Boolean|Object}
       * @default
       * @category Float & align
       */
      hideAnimation: null,

      /**
       * Only valid if this Widget is {@link #config-floating}. An object which defined which CSS style
       * property should be animated upon show, and how it should be animated eg:
       *
       * ```javascript
       * {
       *    opacity: {
       *        to : 1,
       *        duration: '10s',
       *        delay: '0s'
       *    }
       * }
       * ```
       *
       * Set to `'false'` to disable animation.
       *
       * @config {Boolean|Object}
       * @category Float & align
       */
      showAnimation: null,

      /**
       * Only valid if this Widget is {@link #config-floating}. The x position for the widget.
       *
       * @config {Number}
       * @default
       * @category Float & align
       */
      x: null,

      /**
       * Only valid if this Widget is {@link #config-floating}. The y position for the widget.
       *
       * @config {Number}
       * @default
       * @category Float & align
       */
      y: null,

      /**
       * Specifies whether (and optionally in which axes) a Widget may scroll. `true` means this widget
       * may scroll in both axes. May be an object containing boolean `overflowX` and `overflowY` properties which are applied
       * to CSS style properties `overflowX` and `overflowY`. If they are boolean, they are translated
       * to CSS overflow properties thus:
       *
       * *`true` -> `'auto'`
       * *`false` -> `'hidden'`
       *
       * After initialization, this property yields a {@link Common.helper.util.Scroller} which may be used
       * to both set and read scroll information.
       *
       * A Widget uses its `get overflowElement` property to select which element is to be scrollable.
       * By default, in the base `Widget` class, this is the Widget's encapsulating element. Subclasses
       * may implement `get overflowElement` to scroll inner elements.
       * @config {Boolean/Object}
       * @default false
       * @category Scrolling
       */
      scrollable: null,

      /**
       * The class to instantiate to use as the {@link #config-scrollable}. Defaults to {@link Common.helper.util.Scroller}.
       * @internal
       * @config {Common.helper.util.Scroller}
       * @category Scrolling
       */
      scrollerClass: Scroller,

      /**
       * The name of the property to set when a single value is to be applied to this Widget. Such as when used
       * in a grid WidgetColumn, this is the property to which the column's `field` is applied.
       * @config {String}
       * @default 'html'
       * @category Misc
       */
      defaultBindProperty: 'html',

      /**
       * Event that should be considered the default action of the widget. When that event is triggered the
       * widget is also expected to trigger an `action` event. Purpose is to allow reacting to most widgets in
       * a coherent way.
       * @private
       * @config {String}
       * @category Misc
       */
      defaultAction: null,

      /**
       * Widget's width, used to set element style.width. Either specify a valid width string or a number, which
       * will get 'px' appended. We recommend using CSS as the primary way to control width, but in some cases
       * this config is convenient.
       * @config {String|Number}
       * @category Layout
       */
      width: null,

      /**
       * Widget's height, used to set element style.height. Either specify a valid height string or a number, which
       * will get 'px' appended. We recommend using CSS as the primary way to control height, but in some cases
       * this config is convenient.
       * @config {String|Number}
       * @category Layout
       */
      height: null,

      // not public, only used by us in docs
      scaleToFitWidth: null,
      allowGrowWidth: true, // only used if scaleToFitWidth is true

      /**
       * Widget's margin. This may be configured as a single number or a `TRBL` format string.
       * numeric-only values are interpreted as pixels.
       * @config {Number|String}
       * @category Layout
       */
      margin: null,

      /**
       * When this widget is a child of a {@link Common.widget.Container},
       * it will by default be participating in a flexbox layout. This config
       * allows you to set this widget's <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex">flex</a> style.
       * This may be configured as a single number or a `<flex-grow> <flex-shrink> <flex-basis>` format string.
       * numeric-only values are interpreted as the `flex-grow` value.
       * @config {Number|String}
       * @category Layout
       */
      flex: null,

      /**
       * When this widget is a child of a {@link Common.widget.Container},
       * it will by default be participating in a flexbox layout. This config
       * allows you to set this widget's <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-self">align-self</a> style.
       * @config {String}
       * @category Layout
       */
      alignSelf: null,

      /**
       * Configure as `true` to have the component display a translucent ripple when its
       * {@link #property-focusElement}, or {@link #property-element} is tapped *if the
       * current theme supports ripples*. Out of the box, only the Material theme supports ripples.
       *
       * This may also be a config object containing the following properties:
       *
       *  - `delegate  ` Optional. A CSS selector to filter which child elements trigger ripples. By default
       * the ripple is clipped to the triggering element.
       *  - `color     ` Optional, default = `#000`. A CSS color name or specification.
       *  - `radius    ` Optional, default is 100. The ending radius of the ripple.
       * Note that it will be clipped by the target element by default.
       *  - `clip      ` A string which describes how to clip the ripple if it is not to be clipped to the default
       * element. Either the property of the widget to use as the clipping element, or a selector to
       * allow clipping to the closest matching ancestor to the target element.
       *
       * eg:
       *```
       *    columns  : [{}...],
       *    ripple   : {
       *        color : 'red',
       *        clip  : '.b-grid-row'
       *    },
       *    ...
       *```
       * @config {Boolean|Object}
       * @category Misc
       */
      ripple: null,

      /**
       * A title to display for the widget. Only in effect when inside a container that uses it (such as TabPanel)
       * @default
       * @config {String}
       */
      title: null,

      localizableProperties: ['title'],

      // Set this flag to require element to have a size to be considered visible
      requireSize: false,

      /**
       * An identifier by which this widget will be registered in the {@link Common.widget.Container#property-widgetMap}
       * of all ancestor containers.
       *
       * If omitted, this widget will be registered using its {@link #config-id}. In most cases `ref` is
       * preferable over `id` since `id` is required to be globally unique while `ref` is not.
       *
       * The `ref` value is also added to the elements dataset, to allow targeting it using CSS etc.
       * @default
       * @config {String}
       */
      ref: null,

      /**
       * Configure with true to make widget initially hidden
       * @default false
       * @config {Boolean}
       */
      hidden: null
    };
  }

  //endregion

  //region Init & destroy

  construct(config = {}, ...args) {
    const me = this;

    // Flag so we know when our dimensions have been constrained during alignment
    me.alignConstrained = 0;

    me.afterHideShowAnimate = me.afterHideShowAnimate.bind(me);
    me.callRealign = me.realign.bind(me);
    me.doHideOrRealign = me.doHideOrRealign.bind(me);

    me.initialRender = true;
    me._isUserAction = false;

    // Base class applies configs.
    super.construct(config, args);

    me.finalizeInit();
  }

  isType(type, deep) {
    return IdHelper.isType(this, type, deep);
  }

  startConfigure(config) {
    super.startConfigure(config);

    // Force construction of the widget's element before all other configs are evaluated.
    this._thisIsAUsedExpression(this.element);
  }

  set title(title) {
    this._title = title;
    if (this.titleElement) {
      this.titleElement.innerHTML = title;
    }
  }

  get title() {
    return this._title;
  }

  /**
   * Get this widget's encapsulating HTMLElement, which is created along with the widget but added to DOM at render time
   * @property {HTMLElement}
   * @readonly
   * @category DOM
   */
  get element() {
    return this._element;
  }

  set element(element) {
    const me = this;

    if (typeof element === 'string') {
      element = DomHelper.createElementFromTemplate(element);
    } else if (element.constructor.name === 'Object') {
      element = DomHelper.createElement(element);
    } else if (element.nodeType !== 1) {
      element = DomHelper.createElementFromTemplate(me.template(me));
    }
    me._element = element;
    const classList = element.classList;

    element.id = me.id;

    // Add the hierarchy, eg ['b-combo b-pickerfield b-textfield b-widget']
    // TODO: apply not needed when IE11 not supported, classList.add takes multiple classes
    //classList.add(...me.widgetClassList);
    element.className += ' ' + me.widgetClassList.join(' ');

    if (me._hidden) {
      classList.add('b-hidden');
    }

    // The environmental classes only need to be added to a naked Widget.
    // If we have a parent container, that will have them.
    if (!me.parent) {
      classList.add('b-outer');
      if (BrowserHelper.isTouchDevice) {
        classList.add('b-touch-events');
      }
      if (!DomHelper.scrollBarWidth) {
        classList.add('b-overlay-scrollbar');
      }
      if (BrowserHelper.isChrome) {
        classList.add('b-chrome');
      } else if (BrowserHelper.isSafari) {
        classList.add('b-safari');
      } else if (BrowserHelper.isFirefox) {
        classList.add('b-firefox');
      } else if (BrowserHelper.isIE11) {
        classList.add('b-ie');
      } else if (BrowserHelper.isEdge) {
        classList.add('b-edge');
      }
    }

    const namedElements = element.querySelectorAll('[reference]');

    for (const el of namedElements) {
      const name = el.getAttribute('reference');
      el.removeAttribute('reference');

      // Set a reference directly to significant elements.
      // For example the 'input' element of a field.
      me[name] = el;

      // Key elements contain owner pointer if data is supported (Not on IE SVG).
      el.dataset && (el.dataset.ownerCmp = me.id);
    }

    // Create Range which encapsulates content set by the content property.
    // It will be set to encapsulate initial content upon render.
    me.contentRange = BrowserHelper.isIE11 ? document.createRange() : new Range();
  }

  set constrainTo(constrainTo) {
    this._constrainTo = constrainTo;
  }

  get constrainTo() {
    return '_constrainTo' in this ? this._constrainTo : window;
  }

  set centered(value) {
    this._centered = value;

    if (value && !this.floating) {
      throw new Error('`centered` is only relevant when a Widget is `floating`');
    }

    if (value) {
      this.element.classList.add('b-centered');
    } else {
      this.element.classList.remove('b-centered');
    }
  }

  get centered() {
    return this._centered;
  }

  /**
   * The child element into which content should be placed. This means where {@link #config-html} should be put,
   * or, for {@link Common.widget.Container Container}s, where child items should be rendered.
   * @property {HTMLElement}
   * @category DOM
   */
  get contentElement() {
    return this.element;
  }

  /**
   * Get/set widgets id
   * @property {String}
   * @category DOM
   */
  get id() {
    return this._id;
  }

  set id(id) {
    const me = this,
      oldId = me._id;

    if (oldId) {
      IdHelper.unregister(me);
    }
    if (!id) {
      id = IdHelper.generateId(`b-${me.$name.toLowerCase()}-`);
      me.hasGeneratedId = true;
    }
    me._id = id;
    IdHelper.register(me);
  }

  /**
   * Get/set widgets elements style. The setter accepts a cssText string or a style config object, the getter always
   * returns a CSSStyleDeclaration
   * @property {String|Object|CSSStyleDeclaration}
   * @category DOM
   */
  get style() {
    return this.element ? this.element.ownerDocument.defaultView.getComputedStyle(this.element) : this._style;
  }

  set style(style) {
    this._style = style;
    this.element && DomHelper.applyStyle(this.element, this._style);
  }

  /**
   * Get widgets elements dataset or assign to it
   * @property {Object}
   * @category DOM
   */
  get dataset() {
    return this.element.dataset;
  }

  set dataset(dataset) {
    Object.assign(this.dataset, dataset);
  }

  /**
   * Called by the Base constructor after all configs have been applied.
   * @internal
   * @category Lifecycle
   */
  finalizeInit() {
    if (this.insertBefore || this.appendTo || this.insertFirst) {
      this.render();
    }
  }

  doDestroy() {
    const me = this,
      element = me._element;

    me.scrollable && me.scrollable.destroy();

    me._tooltip && me._tooltip.destroy();
    me.unmask();

    if (element) {
      // Remove listeners which are only added during the visible phase.
      // In its own method because it's called on hide and destroy.
      me.removeTransientListeners();

      me.revertFocus();

      ResizeMonitor.removeResizeListener(element.parentElement, me.onParentElementResize);
      ResizeMonitor.removeResizeListener(element, me.onElementResize);
      element.remove();

      me.dragEventDetacher && me.dragEventDetacher();
      me.dragOverEventDetacher && me.dragOverEventDetacher();
      dragGhost.remove();
    }

    IdHelper.unregister(me);

    super.doDestroy();
  }

  //endregion

  //region Render

  render(appendToElement, triggerPaint = true) {
    const me = this,
      { element, contentRange, contentElement } = me;

    ResizeMonitor.removeResizeListener(element.parentElement, me.onParentElementResize);
    ResizeMonitor.removeResizeListener(element, me.onElementResize);

    me.emptyCache();

    if (me.syncElement && me.currentElement) {
      DomHelper.sync(element, me.currentElement);
    } else {
      // Use passed element to insert this widget directly
      if (appendToElement) {
        me.appendTo = typeof appendToElement === 'string' ? document.getElementById(appendToElement) : appendToElement;
        me.appendTo.appendChild(element);
      }
      // If nothing was passed directly, try to use configs preferring `insertBefore` first
      else if (me.insertBefore) {
        me.insertBefore =
          typeof me.insertBefore === 'string' ? document.getElementById(me.insertBefore) : me.insertBefore;
        me.insertBefore.parentElement.insertBefore(element, me.insertBefore);
      } else if (me.insertFirst) {
        me.insertFirst = typeof me.insertFirst === 'string' ? document.getElementById(me.insertFirst) : me.insertFirst;

        // Try to insert as a first child
        if (me.insertFirst.firstChild) {
          me.insertFirst.insertBefore(element, me.insertFirst.firstChild);
        }
        // insertBefore will throw exceptions if firstChild element not exists. Add as only child then.
        else {
          me.insertFirst.appendChild(element);
        }
      } else if (me.appendTo) {
        me.appendTo = typeof me.appendTo === 'string' ? document.getElementById(me.appendTo) : me.appendTo;
        me.appendTo.appendChild(element);
      }

      me.currentElement = element;
    }

    // If it's a rerender from being removed, restore from cached pointers
    if ('contentRangeStart' in me) {
      contentRange.setStart(contentElement, me.contentRangeStart);
      contentRange.setEnd(contentElement, me.contentRangeEnd);
    } else {
      contentRange.setStart(me.contentElement, 0);
      contentRange.setEnd(me.contentElement, me.contentElement.childNodes.length);
    }

    // Not for public use, only used in docs
    if (me.scaleToFitWidth) {
      me.onParentElementResize = me.onParentElementResize.bind(me);
      ResizeMonitor.addResizeListener(element.parentElement, me.onParentElementResize);

      if (me.isVisible) {
        me.updateScale();
      }
    }
    // Mutually exclusive with scaleToFitWidth
    else if (me.monitorResize) {
      me.onElementResize = me.onElementResize.bind(me);
      ResizeMonitor.addResizeListener(element, me.onElementResize);

      // On render, we should announce our size immediately.
      // When the real event comes along, onElementResize will reject it because the size will be the same.
      ResizeMonitor.onElementResize([{ target: element }]);
    }

    if (triggerPaint) {
      me.triggerPaint();
    }
  }

  /**
   * A function which, when passed an instance of this Widget, produces a valid HTML string which is compiled
   * to create the encapsulating element for this Widget, and its own internal DOM structure.
   *
   * Note that this just creates the DOM structure that *this* Widget owns. If it contains child widgets
   * (Such as for example a grid), this is not included. The template creates own structure.
   *
   * Certain elements within the generated element can be identified as special elements with a `reference="name"`
   * property. These will be extracted from the element upon creation and injected as the named property into
   * the Widget. For example, a {@link Common.widget.TextField} will have an `input` property which is its
   * `<input>` element.
   * @param {Common.widget.Widget} me The widget for which to produce the initial HTML structure.
   * @internal
   */
  template(me) {
    return `<div class="${me.html ? 'b-html' : ''}" ${me.name ? `data-name="${me.name}"` : ''}>${me.html || ''}</div>`;
  }

  //endregion

  //region floating

  /**
   * If this Widget is {@link #config-floating} or {@link #config-positioned}, and visible,
   * aligns the widget according to the passed specification.
   * For details, see the {@link #function-showBy} method.
   * @param {Object} spec Alignment options. May be an object as processed by the {@link #function-showBy} method,
   * or an `HTMLElement` to align to using this Widget's {@link #config-align} configuration.
   * @category Float & align
   */
  alignTo(spec) {
    // You can "alignTo" an element or a Widget or a Point, and allow our align config.
    // property to specify how.
    if (spec.nodeType === 1 || spec instanceof Widget || spec instanceof Point) {
      spec = {
        target: spec
      };
    }

    // Release size constraints so we can align from scratch each time.
    this.releaseSizeConstraints();

    const me = this,
      { scrollable, element } = me,
      passedTarget = spec.target,
      target =
        passedTarget && (passedTarget instanceof Rectangle ? passedTarget : passedTarget.element || passedTarget),
      myPosition = Rectangle.from(element, me.positioned ? element.offsetParent : null, true),
      aligningToElement = target && target.nodeType === 1;

    spec = Object.assign(
      {
        // Constraining is a viewport coordinate based thing. not relevant to positioned
        // Widgets which are within their owning Widget and thereby constrained anyway.
        constrainTo: me.positioned ? null : me.constrainTo,
        axisLock: me.axisLock,
        anchor: me.anchor
      },
      typeof me.align === 'object' ? me.align : { align: me.align },
      spec
    );

    // As part of fallback process when fitting within constraints, this may shrink to minima specified
    // either on the align spec or the widget itself.
    myPosition.minWidth = spec.minWidth || me.minWidth;
    myPosition.minHeight = spec.minHeight || me.minHeight;

    // This is used by the realign call which may be called either when a global scroll is detected
    // or the constraining element is resized.
    me.lastAlignSpec = spec;

    if (aligningToElement && target.offsetParent) {
      // Translate the element into a browser viewport based Rectangle. Rectangle
      // Doesn't have the knowledge that we do to make this decision. Floating
      // alignment all takes place within browser viewport space, not document space.
      // Don't destroy the spec which was cached above with the element in it.
      spec = Object.setPrototypeOf({}, spec);
      spec.target = Rectangle.from(target, me.positioned ? element.offsetParent : null, !me.positioned);

      // Force the target to have an area so that intersect works.
      spec.target.height = Math.max(spec.target.height, 1);
      spec.target.width = Math.max(spec.target.width, 1);

      // Handle the target being clipped by the bounds of various elements.
      // For example in a grid, the SubGrid element will clip the left and right
      // but the main grid bodyContainer will clip the top and bottom.
      const clippedBy = me.clippedBy;
      if (clippedBy) {
        const clippedTarget = spec.target.intersect(clippedBy);

        // If there is an intersecting Rectangle with the forElement, align
        if (clippedTarget) {
          spec.target = clippedTarget;
        }
        // This is the case where the target is scrolled or positioned out of view.
        else {
          const result = me.hide();

          // The hide method clears this flag.
          // Only this hide invocation must complete with the
          // targetHidden flag as true
          me.lastAlignSpec.targetHidden = true;
          return result;
        }
      }

      // This is the element which determines our position.
      // This is used in doHideOrRealign to see if a scroll event
      // will have affected our position.
      me.anchoredTo = target;
    } else {
      me.anchoredTo = null;
    }

    if (spec.anchor) {
      spec.anchorSize = me.anchorSize;
      element.appendChild(me.anchorElement);
    }

    // Flag to prevent infinite loop when setting html from a beforeAlign listener
    me.isAligning = true;

    // Allow outside world to modify the suggested position
    me.trigger('beforeAlign', spec);

    me.isAligning = false;

    // Calculate the best position WRT target rectangle, our rectangle, a constrainTo rectangle
    // and the rectangle of an anchor pointer.
    const { constrainTo } = spec,
      constrainToWindow = constrainTo === window || constrainTo === document,
      result = myPosition.alignTo(spec);

    // May change if constraint changes our shape, and we have to go round again
    let { align, anchor, x, y, width, height, bottom, right } = result;

    // Which zone, T=0, R=1, B=2, L=3 the result is in
    me.lastAlignSpec.zone = result.zone;

    // If the alignment specified that we must constrain a dimension in order to
    // fit within our constrainTo, then obey that. If we own a Scroller, then
    // inform it that we do now need to scroll that dimension.
    // These conditions are released upon each alignment call because conditions may change.
    if (height !== myPosition.height) {
      if (!('configuredHeight' in me)) {
        me.configuredHeight = element.style.height;
      }
      me.height = height;
      me.alignConstrained = me.alignConstrained | 1;
      if (scrollable) {
        scrollable.overflowY = true;
      }
    }
    if (width !== myPosition.width) {
      if (!('configuredWidth' in me)) {
        me.configuredWidth = element.style.width;
      }
      me.width = width;
      me.alignConstrained = me.alignConstrained | 2;
      if (scrollable) {
        scrollable.overflowX = true;
      }
    }

    // If either dimension has been constrained, we may have changed shape
    // due to text wrapping/overflowing, so we have to realign at the
    // successful align setting.
    if (align && me.alignConstrained) {
      spec.align = align;
      const newResult = Rectangle.from(element, me.positioned ? element.offsetParent : null, true).alignTo(spec);

      anchor = newResult.anchor;
      x = newResult.x;
      y = newResult.y;
      width = newResult.width;
      height = newResult.height;
      bottom = newResult.bottom;
      right = newResult.right;
    }

    me.setXY(x, y);

    // If we asked it to also calculate our anchor position, position our anchor
    if (anchor) {
      const { edge } = anchor,
        { anchorElement } = me,
        colorMatchPoint = [],
        stylePointerEvents = element.style.pointerEvents;

      // Enable pointerEvents to make discoverable by elementFromPoint()
      element.style.pointerEvents = 'all';

      // Make the anchor color match the color of the closest adjacent element
      if (edge === 'top' || edge === 'bottom') {
        colorMatchPoint[0] = x + anchor.x;
        colorMatchPoint[1] = edge === 'top' ? y + 1 : bottom - 1;
      } else {
        colorMatchPoint[0] = edge === 'left' ? x + 1 : right - 1;
        colorMatchPoint[1] = y + anchor.y;
      }
      const colourSource = document.elementFromPoint(...colorMatchPoint);

      element.style.pointerEvents = stylePointerEvents || null;

      // If  it's off the edge of the screen, we won't be able to read it.
      // But that's fine, the anchor will be off the edge in that case.
      if (colourSource) {
        const fillColour = DomHelper.getStyleValue(colourSource, 'background-color');

        if (fillColour.match(isTransparent)) {
          me.anchorPathElement.setAttribute('fill', me.defaultAnchorBackgroundColor);
        } else {
          me.anchorPathElement.setAttribute('fill', fillColour);
        }
      }

      anchorElement.classList.remove('b-hide-display');
      anchorElement.style.transform = '';
      anchorElement.className = `b-anchor b-anchor-${edge}`;
      DomHelper.setTranslateXY(anchorElement, anchor.x, anchor.y);
    } else if (me._anchorElement) {
      me.anchorElement.classList.add('b-hide-display');
    }

    // If we are to hide on scroll, we still need to know if the element we are
    // aligned to moves. If we have not been *explicitly* aligned to an element,
    // Use the element at our display position. For example, when a context menu
    // is shown on a grid header, then is the grid header is moved by a scroll
    // event, then we must hide.
    if (me.scrollAction === 'hide' && !aligningToElement) {
      // Our element is over the X, Y point now,
      // elementFromPoint must "see through" it.
      element.style.pointerEvents = 'none';
      me.anchoredTo = document.elementFromPoint(x, y);
      element.style.pointerEvents = '';
    }

    // If we're aligning to an element, then listen for scrolls so that we can remain aligned.
    // Scrolls can be instigated with no mousedown, so transient floating Widgets can be put
    // out of alignment by scrolls.
    if (
      ((me.scrollAction === 'realign' && aligningToElement) || me.scrollAction === 'hide') &&
      !me.documentScrollListener
    ) {
      // Push binding to the scroll position out until the next animation frame.
      // This is in case the calling code is going to cause a scroll.
      // for example contextmenu is a focusing gesture which may cause a scroll
      // to fire as the target element moves into view.
      me.setTimeout(() => {
        document.addEventListener('scroll', me.doHideOrRealign, true);
        me.documentScrollListener = true;
      }, 0);
    }
    if (constrainTo && (constrainTo.nodeType === 1 || constrainToWindow) && !me.constrainListeners) {
      ResizeMonitor.addResizeListener(constrainTo, me.callRealign);

      // Do not listen for constrainTo mutations if it's the viewport.
      // Mutating it won't change its size.
      if (!constrainToWindow) {
        me.constrainMutationMonitor ||
          (me.constrainMutationMonitor = new MutationObserver(me.callRealign)).observe(constrainTo, {
            // eslint-disable-line no-undef
            attributes: true,
            childList: true
          });
      }
      me.constrainListeners = true;
    }
  }

  realign(el) {
    const me = this;

    if (me.isVisible && (me.floating || me.positioned) && me.lastAlignSpec) {
      const target = me.lastAlignSpec.target;

      // If there was a DOM mutation which caused our target to become not layed out, or the target
      // is outside of the passed element's rectangle (passed from scroll handler), we must hide
      if (target && target.nodeType === 1) {
        const targetRect = Rectangle.from(target);

        // We can align to an element which has a zero dimension, but the
        // intersection check requires that both dimensions are non-zero.
        targetRect.minHeight = targetRect.minWidth = 1;
        if (
          (target !== document.body && !target.offsetParent) ||
          (el && el.nodeType === 1 && el.contains(target) && !Rectangle.from(el).intersect(targetRect))
        ) {
          return me.hide();
        }
      }
      me.alignTo(me.lastAlignSpec);
    }
  }

  releaseSizeConstraints() {
    const me = this,
      scroller = me.scrollable;

    // Release constraints so we can align from scratch each time.
    if (me.alignConstrained & 1) {
      me.height = me.configuredHeight;
      if (scroller) {
        scroller.overflowY = scroller.config.overflowY;
      }
    }
    if (me.alignConstrained & 2) {
      me.width = me.configuredWidth;
      if (scroller) {
        scroller.overflowX = scroller.config.overflowX;
      }
    }
    me.alignConstrained = 0;
  }

  /**
   * Only valid for {@link #config-floating} Widgets. Moves to the front of the visual stacking order.
   * @category Float & align
   */
  toFront() {
    if (this.element && this.element.nextSibling) {
      this.element.parentNode.appendChild(this.element);
    }
  }

  //endregion

  //region Getters/setters

  set ref(ref) {
    this._ref = ref;

    this.element.dataset.ref = ref;
  }

  get ref() {
    return this._ref;
  }

  set clippedBy(clippedBy) {
    this._clippedBy = Array.isArray(clippedBy) ? clippedBy : clippedBy ? [clippedBy] : null;
  }

  get clippedBy() {
    const clippedBy = this._clippedBy;

    if (clippedBy) {
      let result = Rectangle.from(clippedBy[0], null, true),
        i;

      for (i = 1; i < clippedBy.length; i++) {
        result = result.intersect(Rectangle.from(clippedBy[i], null, true));
      }
      return result;
    }
  }

  get overflowElement() {
    return this.contentElement;
  }

  get maxHeightElement() {
    return this.element;
  }

  set scrollable(scrollable) {
    const overflowElement = this.overflowElement;

    if (typeof scrollable === 'boolean') {
      scrollable = {
        overflowX: scrollable,
        overflowY: scrollable
      };
    }

    if (overflowElement) {
      scrollable.element = overflowElement;
    }
    scrollable.widget = this;
    this._scrollable = new this.scrollerClass(scrollable);
  }

  /**
   * Accessor to the {@link Common.helper.util.Scroller} which can be used
   * to both set and read scroll information.
   * @property {Common.helper.util.Scroller} scrollable
   */
  get scrollable() {
    return this._scrollable;
  }

  /**
   * Get/set HTML to display. When specifying HTML, this widget's element will also have `b-html` added to its
   * classList, to allow targeted styling.
   * @property {String}
   * @category DOM
   */
  get html() {
    // Maintainer, we cannot use a ternary here, we need the this.initializingElement test to shortcut
    // to the true case to return the _html property to avoid infinite loops.
    if (this.initializingElement || !this.element) {
      return this.content || this._html;
    }
    return this.contentElement.innerHTML;
  }

  set html(html) {
    const me = this,
      isClearing = html == null,
      { element, contentElement } = me;

    if (me._html !== html) {
      me._html = html;
      if (element) {
        const anchorEl = contentElement === element && me._anchorElement;

        // Flag class that we are an HTML carrying element
        element.classList[isClearing ? 'remove' : 'add']('b-html');

        // Setting innerHTML destroys the anchorElement in some browsers
        // so we must temporarily remove it to preserve it.
        // Only if the contentElement is the main element.
        if (anchorEl) {
          me.element.removeChild(anchorEl);
        }
        me.contentElement.innerHTML = isClearing ? '' : html;

        if (anchorEl) {
          element.appendChild(anchorEl);
        }
        if (me.floating || me.positioned) {
          // Must realign because content change might change dimensions
          if (!me.isAligning) {
            me.realign();
          }
        }
      }
    }
  }

  /**
   * Set HTML content safely, without disturbing sibling elements which may have been
   * added to the {@link #property-contentElement} by plugins and features.
   * When specifying html, this widget's element will also have `b-html` added to its
   * classList, to allow targeted styling.
   * @property {String}
   * @category DOM
   */
  set content(html) {
    const me = this,
      isClearing = html == null,
      { element } = me;

    if (me._html !== html) {
      me._html = html;
      if (element) {
        let { contentRange } = me;

        // Flag class that we are an HTML carrying element
        element.classList[isClearing ? 'remove' : 'add']('b-html');

        // Replace the contents of our content range with the new content
        contentRange.deleteContents();
        if (!isClearing) {
          contentRange.insertNode(
            DomHelper.createElementFromTemplate(html, {
              fragment: true
            })
          );
        }

        // Must realign because content change might change dimensions
        if (!me.isAligning || me.positioned) {
          me.realign();
        }
      }
    }
  }

  onThemeChange() {
    // If we have a *visible* anchor element, then a theme change may
    // invalidate it's size or this.defaultAnchorBackgroundColor, so a
    // run through realign (and get anchorSize) will fix that.
    if (this.anchorElement && this.anchorElement.offsetParent) {
      this._anchorSize = null;
      this.realign();
    }
  }

  /**
   * Returns an `[x, y]` array containing the width and height of the anchor arrow used when
   * aligning this Widget to another Widget or element.
   *
   * The height is the height of the arrow when pointing upwards, the width is the width
   * of the baseline.
   * @property {Number[]}
   * @category Float & align
   */
  get anchorSize() {
    const me = this;

    let result = this._anchorSize;

    if (!result) {
      // TODO: Move the anchoring scheme to the Panel class when we have it.
      // These values will be in the SASS and styled into the SVG through the Panel's theme.
      const borderWidth = parseFloat(DomHelper.getStyleValue(me.element, 'border-top-width')),
        borderColour = DomHelper.getStyleValue(me.element, 'border-top-color'),
        anchorElement = me.anchorElement,
        svgEl = anchorElement.firstElementChild,
        pathElement = (me.anchorPathElement = svgEl.lastElementChild),
        hidden = me._hidden;

      let backgroundColour = DomHelper.getStyleValue(me.contentElement, 'background-color');

      // If the background colour comes through from the outer element, use that.
      if (backgroundColour.match(isTransparent)) {
        backgroundColour = DomHelper.getStyleValue(me.element, 'background-color');
      }
      me.defaultAnchorBackgroundColor = backgroundColour;

      result = anchorElement.getBoundingClientRect();
      const [width, height] = (result = me._anchorSize = [result.width, result.height]);

      svgEl.setAttribute('height', height + borderWidth);
      svgEl.setAttribute('width', width);
      pathElement.setAttribute('d', `M0,${height}L${width / 2},0.5L${width},${height}`);
      if (borderWidth) {
        pathElement.setAttribute('stroke-width', borderWidth);
        pathElement.setAttribute('stroke', borderColour);
      }
      result[1] -= borderWidth;

      if (hidden) {
        me.element.classList.add('b-hidden');
      }

      if (!me.themeChangeListener) {
        me.themeChangeListener = GlobalEvents.on({
          theme: 'onThemeChange',
          thisObj: me
        });
      }
    }

    // Reset to default in case it has been positioned by a coloured header
    me.anchorPathElement.setAttribute('fill', me.defaultAnchorBackgroundColor);

    return result;
  }

  get anchorElement() {
    let result = this._anchorElement;

    if (!result) {
      result = this._anchorElement = DomHelper.createElement({
        parent: this.element,
        className: 'b-anchor b-anchor-top',
        children: [
          {
            tag: 'svg',
            ns: 'http://www.w3.org/2000/svg',
            version: '1.1',
            class: 'b-pointer-el',
            children: [
              {
                tag: 'defs',
                children: [
                  {
                    tag: 'filter',
                    id: 'shadow-filter',
                    children: [
                      {
                        tag: 'feDropShadow',
                        dx: 0,
                        dy: -1,
                        stdDeviation: 2,
                        'flood-opacity': 0.05
                      }
                    ]
                  }
                ]
              },
              {
                tag: 'path',
                filter: BrowserHelper.isIE11 || BrowserHelper.isEdge ? null : 'url(#shadow-filter)'
              }
            ]
          }
        ]
      });
    }

    return result;
  }

  set anchor(anchor) {
    this._anchor = anchor;

    if (this._anchorElement) {
      this._anchorElement.classList[anchor ? 'remove' : 'add']('b-hide-display');
    }
  }

  get draggable() {
    return this._draggable;
  }

  set draggable(draggable) {
    const me = this,
      { element } = me;

    me._draggable = draggable;

    element.setAttribute('draggable', Boolean(draggable));

    if (draggable) {
      me.dragEventDetacher = EventHelper.addListener({
        element: me.element,
        dragstart: me.onWidgetDragStart,
        dragend: me.onWidgetDragEnd,
        thisObj: me
      });
    } else {
      me.dragEventDetacher && me.dragEventDetacher();
      me.dragOverEventDetacher && me.dragOverEventDetacher();
    }
  }

  onWidgetDragStart(e) {
    const me = this,
      actualTarget = document.elementFromPoint(e.clientX, e.clientY), // Can't be resolved from the event :/
      { handleSelector } = me.draggable;

    if (handleSelector) {
      const blacklist = negationPseudo.exec(handleSelector)[1]; // Extract the content of :not()

      // If the selector was :not(), then if we are a descendant of a matching element, it's a no-drag
      if (blacklist) {
        if (actualTarget.closest(`#${me.element.id} ${blacklist}`)) {
          e.preventDefault();
          return;
        }
      }
      // If we are not the descendant of a matching element, it's a no-drag
      else if (!actualTarget.closest(`#${me.element.id} ${handleSelector}`)) {
        e.preventDefault();
        return;
      }
    }

    // Opt out of auto-alignment on scroll or DOM mutation.
    me.removeTransientListeners();

    const dragStartX = e.clientX,
      dragStartY = e.clientY,
      scrollingPageElement = document.scrollingElement || document.body,
      widgetX = me.getXY()[0],
      widgetY = me.getXY()[1];

    document.body.appendChild(dragGhost);

    if (e.dataTransfer.setDragImage) {
      // Firefox requires this to be called before setDragImage
      e.dataTransfer.setData('application/node type', '');

      // Override the default HTML5 drag ghost and just drag an empty node
      e.dataTransfer.setDragImage(dragGhost, 0, 0);
    }

    // Prevent special cursor from being shown
    e.dataTransfer.effectAllowed = 'none';

    me.dragOverEventDetacher = EventHelper.addListener({
      element: document.body,
      dragover: (event) =>
        me.setXY(
          widgetX + event.clientX - dragStartX - scrollingPageElement.scrollLeft,
          widgetY + event.clientY - dragStartY - scrollingPageElement.scrollTop
        )
    });

    // Opt out of anchoring
    me.anchor = null;
  }

  onWidgetDragEnd(e) {
    dragGhost.remove();
    this.dragOverEventDetacher();
  }

  get anchor() {
    return this._anchor;
  }

  get floating() {
    return this._floating;
  }

  set floating(floating) {
    // Coerce all to boolean so that we have a true/false value
    floating = Boolean(floating);

    if (Boolean(this.floating) !== floating) {
      this._floating = floating;
    }
  }

  get positioned() {
    return this._positioned;
  }

  set positioned(positioned) {
    // Coerce all to boolean so that we have a true/false value
    positioned = Boolean(positioned);
    if (Boolean(this.positioned) !== positioned) {
      this.element.classList[positioned ? 'add' : 'remove']('b-positioned');
      this._positioned = positioned;
    }
  }

  getXY() {
    return [DomHelper.getPageX(this.element), DomHelper.getPageY(this.element)];
  }

  /**
   * Moves this Widget to the x,y position. Both arguments can be omitted to just set one value.
   *
   * *For {@link #config-floating} Widgets, this is a position in the browser viewport.*
   * *For {@link #config-positioned} Widgets, this is a position in the element it was rendered into.*
   *
   * @param {Number} [x]
   * @param {Number} [y]
   * @category Float & align
   */
  setXY(x, y) {
    const me = this;

    if (me.floating || me.positioned) {
      if (x != null) {
        me._x = x;
        me.centered = false;
      }
      if (y != null) {
        me._y = y;
        me.centered = false;
      }
      DomHelper.setTranslateXY(me.element, me._x || 0, me._y || 0);
    }
  }

  /**
   * Moves this Widget to the desired x position. *Only valid for {@link #config-floating} Widgets.
   * @param {Number} x
   * @category Float & align
   */
  set x(x) {
    this.setXY(x);
  }

  get x() {
    return this.getXY()[0];
  }

  /**
   * Moves this Widget to the desired y position. *Only valid for {@link #config-floating} Widgets.
   * @param {Number} y
   * @category Float & align
   */
  set y(y) {
    this.setXY(null, y);
  }

  get y() {
    return this.getXY()[1];
  }

  /**
   * Get elements offsetWidth or sets its style.width, or specified width if element not created yet.
   * @property {Number|String}
   * @category Layout
   */
  get width() {
    const me = this,
      element = me.element;

    if (me.monitorResize) {
      // If the width is invalid, read it now.
      if (me._width == null) {
        me._width = element.offsetWidth;
      }

      // Usually this will be set in onInternalResize
      return me._width;
    }
    // No monitoring, we have to measure;
    return element.offsetWidth;
  }

  set width(width) {
    DomHelper.setLength(this.element, 'width', width);

    // Invalidate the width, so it will be read from the DOM if a read is requested before the resize event
    this._width = null;
    this.element.style.flex = BrowserHelper.isIE11 ? '' : null;
  }

  /**
   * Get/set elements maxWidth. Getter returns max-width from elements style, which is always a string. Setter accepts
   * either a String or a Number (which will have 'px' appended). Note that like {@link #config-width},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String|Number}
   * @category Layout
   */
  get maxWidth() {
    return DomHelper.measureSize(this.element.style.maxWidth, this.element);
  }

  set maxWidth(maxWidth) {
    DomHelper.setLength(this.element, 'maxWidth', maxWidth);
  }

  /**
   * Get/set elements minWidth. Getter returns min-width from elements style, which is always a string. Setter accepts
   * either a String or a Number (which will have 'px' appended). Note that like {@link #config-width},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String|Number}
   * @category Layout
   */
  get minWidth() {
    return DomHelper.measureSize(this.element.style.minWidth, this.element);
  }

  set minWidth(minWidth) {
    DomHelper.setLength(this.element, 'minWidth', minWidth);
  }

  get flex() {
    return this._flex;
  }

  /**
   * Get element's flex property. This may be configured as a single number or a `<flex-grow> <flex-shrink> <flex-basis>` format string.
   * numeric-only values are interpreted as the `flex-grow` value.
   * @property {Number|String}
   * @category Layout
   */
  set flex(flex) {
    this._flex = flex;

    // Default grow to the same as flex and basis to 0.
    if (typeof flex === 'number' || (typeof flex === 'string' && flex.split(/\s/).length === 1)) {
      flex = `${flex} ${flex}`;
    }
    this.element.style.flex = flex;
    this.element.style.width = BrowserHelper.isIE11 ? '' : null;
  }

  /**
   * Get/set this widget's `align-self` flexbox setting. This may be set to modify
   * how this widget is aligned within the cross axis of a flexbox layout container.
   * @property {String}
   * @category Layout
   */
  get alignSelf() {
    return this._alignSelf;
  }

  set alignSelf(alignSelf) {
    this.element.style.alignSelf = alignSelf;
  }

  /**
   * Get element's margin property. This may be configured as a single number or a `TRBL` format string.
   * numeric-only values are interpreted as pixels.
   * @property {Number|String}
   * @category Layout
   */
  get margin() {
    return this._margin;
  }

  set margin(margin) {
    // Convert eg 1 to "1px 1px 1px 1px" or "0 8px" to "0px 8px 0px 8px"
    this.element.style.margin = this._margin = this.parseTRBL(margin).join(' ');
  }

  /**
   * Get element's offsetHeight or sets its style.height, or specified height if element no created yet.
   * @property {Number|String}
   * @category Layout
   */
  get height() {
    const me = this,
      element = me.element;

    if (me.monitorResize) {
      // If the height is invalid, read it now.
      if (me._height == null) {
        me._height = element.offsetHeight;
      }

      // Usually this will be set in onInternalResize
      return me._height;
    }
    // No monitoring, we have to measure;
    return element.offsetHeight;
  }

  set height(height) {
    DomHelper.setLength(this.element, 'height', height);

    // Invalidate the height, so it will be read from the DOM if a read is requested before the resize event
    this._height = null;
  }

  /**
   * Get/set element's maxHeight. Getter returns max-height from elements style, which is always a string. Setter
   * accepts either a String or a Number (which will have 'px' appended). Note that like {@link #config-height},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String|Number}
   * @category Layout
   */
  get maxHeight() {
    return DomHelper.measureSize(this.maxHeightElement.style.maxHeight, this.element);
  }

  set maxHeight(maxHeight) {
    const me = this,
      { element } = me;

    DomHelper.setLength(me.maxHeightElement, 'maxHeight', maxHeight);

    // Flexbox does not handle overflow correctly when a vertically
    // flexed item is constrained by the maxHeight of its containing el.
    // So we have to propagate the maxHeight from the encapsulating element
    // onto the contentElement.
    if (BrowserHelper.isIE11 && me.contentElement !== element) {
      if (maxHeight == null) {
        ResizeMonitor.removeResizeListener(element, me.boundMaxHeightBugHandler);
      } else {
        ResizeMonitor.addResizeListener(
          element,
          me.boundMaxHeightBugHandler || (me.boundMaxHeightBugHandler = me.fixIEMaxHeightBug.bind(me))
        );
        if (document.body.contains(element)) {
          me.fixIEMaxHeightBug();
        }
      }
    }
  }

  fixIEMaxHeightBug() {
    const { element, contentElement } = this;

    // If this widget is flexed vertically, the maxHeight of the encapsulating element must be
    // propapagated onto the contentElement.
    if (DomHelper.getStyleValue(element, 'flex-direction') === 'column') {
      // Release previous height constraint
      contentElement.style.maxHeight = '';

      let availableHeight = Rectangle.client(element).height;

      const siblings = element.childNodes,
        len = siblings.length;

      // In case there are height-consuming siblings of the contentElement.
      // For example a header/footer. The heights of these must be subtracted.
      for (let i = 0; i < len; i++) {
        const sibling = siblings[i];
        if (sibling !== contentElement && !sibling.classList.contains('b-resize-monitors')) {
          availableHeight -= sibling.offsetHeight;
        }
      }

      // Apply the adjusted height constraint to the contentElement
      this.contentElement.style.maxHeight = `${availableHeight}px`;
    }
  }

  /**
   * Get/set element's minHeight. Getter returns min-height from elements style, which is always a string. Setter
   * accepts either a String or a Number (which will have 'px' appended). Note that like {@link #config-height},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String|Number}
   * @category Layout
   */
  get minHeight() {
    return DomHelper.measureSize(this.element.style.minHeight, this.element);
  }

  set minHeight(minHeight) {
    DomHelper.setLength(this.element, 'minHeight', minHeight);
  }

  /**
   * Get/set element's disabled state
   * @property {Boolean}
   * @category Misc
   */
  get disabled() {
    return this._disabled;
  }

  set disabled(disabled) {
    const el = this.element,
      focusEl = this.focusElement;

    disabled && this.revertFocus();

    if (el) {
      el.classList[disabled ? 'add' : 'remove']('b-disabled');
      if (focusEl) {
        focusEl.disabled = disabled;
      }
    }
    this._disabled = disabled;
  }

  /**
   * Disable the widget
   */
  disable() {
    this.disabled = true;
  }

  /**
   * Enable the widget
   */
  enable() {
    this.disabled = false;
  }

  get tooltip() {
    return this._tooltip;
  }

  //noinspection JSAnnotator
  /**
   * Get/set a tooltip on the widget. Accepts a string or tooltip config (specify true (or 'true') to use placeholder
   * as tooltip). When using a string it will configure the tooltip with `textContent: true` which enforces a default
   * max width.
   *
   * @property {String|Object}
   * @category Misc
   */
  set tooltip(config) {
    const me = this;

    if (me._tooltip) {
      me._tooltip.destroy();
      me._tooltip = null;
    }

    if (config && !(me.preventTooltipOnTouch && BrowserHelper.isTouchDevice)) {
      if (config.constructor.name !== 'Object') {
        config = {
          html: typeof config === 'string' ? config : me.placeholder,
          textContent: true
        };
      }
      config.type = 'tooltip';

      if (!config.forElement) config.forElement = me.element;
      if (!('showOnHover' in config)) config.showOnHover = true;
      if (!('autoClose' in config)) config.autoClose = true;

      me._tooltip = WidgetHelper.createWidget(config);
    }
  }

  /**
   * Determines visibility by checking if the Widgets is hidden, if not it checks if its element is available in DOM
   * @property {Boolean}
   * @readonly
   */
  get isVisible() {
    const element = this.element;

    let result = element && !this._hidden;

    // TODO: When we have a containment hierarchy, this needs to take the hierarchy into account.
    // A descendant of a hidden, or non rendered (in the sense of being inserted into the document)
    // ancestor is not visible even if it is not hidden.
    if (result) {
      if (
        !document.body.contains(element) ||
        (this.requireSize && element.offsetWidth === 0 && element.offsetHeight === 0)
      ) {
        // element wasn't found in document, set visibility flag to false
        result = false;

        // No shadowroot support in IE11/Edge
        if (window.ShadowRoot) {
          // if element cannot be found in document, it may be in the shadow dom
          // walk through parentNodes, checking instances
          let current = element;
          while ((current = current.parentNode)) {
            if (current instanceof window.ShadowRoot) {
              result = true;
            }
          }
        }
      }
    }

    return result;
  }

  /**
   * Focuses this widget if it has a focusable element.
   */
  focus() {
    if (this.isFocusable) {
      DomHelper.focusWithoutScrolling(this.focusElement);
    }
  }

  /**
   * Get this widget's primary focus holding element if this widget is itself focusable, or contains focusable widgets.
   * @property {HTMLElement}
   * @readonly
   * @category DOM
   */
  get focusElement() {
    // Override in widgets which are focusable.
  }

  get isFocusable() {
    const focusElement = this.focusElement;

    // We are only focusable if the focusEl is deeply visible, that means
    // it must have layout - an offsetParent. Body does not have offsetParent.
    return (
      focusElement && this.isVisible && !this.disabled && (focusElement === document.body || focusElement.offsetParent)
    );
  }

  /**
   * Show widget
   * @category Visibility
   * @returns {Promise} A promise which is resolved when the widget is shown
   */
  show() {
    return new Promise((resolve) => {
      const me = this,
        { showAnimation, element } = me,
        floatRoot = Widget.floatRoot,
        style = element.style;

      let styleProp, animProps;

      /**
       * Triggered before a widget is shown. Return `false` to prevent the action.
       * @event beforeShow
       * @param {Common.widget.Widget} source The widget being shown.
       */
      if (!me.isVisible && me.trigger('beforeShow') !== false) {
        // Cancel any current hide/show animation
        me.cancelHideShowAnimation();

        if (showAnimation) {
          // setting transitions initial value before showing, to ensure transition will animate
          styleProp = Object.keys(showAnimation)[0];
          animProps = showAnimation[styleProp];

          me.currentAnimation = {
            styleProp
          };

          element.addEventListener('transitionend', me.afterHideShowAnimate);

          // setting transitions initial value before showing, to ensure transition will animate
          style[styleProp] = animProps.from;
        }

        if (me.floating) {
          if (!floatRoot.contains(element)) {
            me.render(floatRoot);
          }
          if (!document.body.contains(floatRoot)) {
            document.body.appendChild(floatRoot);
          }
        }

        me._hidden = false;

        element.classList.remove('b-hidden');

        if (showAnimation) {
          style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
          style[styleProp] = animProps.to;
        }

        me.afterShow(resolve);

        // If we're not being called from showBy, do default aligning
        if (!me.inShowBy && me.floating && me.forElement) {
          me.alignTo(me.forElement);
        }
      }
    });
  }

  /**
   * Show aligned to another target element or {@link Common.widget.Widget} or {@link Common.helper.util.Rectangle}
   * @param {Object/HTMLElement} spec Alignment specification, or the element to align to using the configured
   * {@link #config-align}.
   * @param {HTMLElement|Common.widget.Widget|Common.helper.util.Rectangle} spec.target The Widget or Element or Rectangle to align to.
   * @param {Boolean} [spec.anchor] True to show a pointer arrow connecting to the target. Defaults to false.
   * @param {Boolean} [spec.overlap] True to allow this to overlap the target.
   * @param {String} spec.align The alignment specification string, `[trbl]n-[trbl]n`. Defaults to this instance's
   * {@link #config-align} setting.
   * @param {HTMLElement|Common.widget.Widget|Common.helper.util.Rectangle} [spec.constrainTo] The Widget or Element or Rectangle to constrain to.
   * If the requested alignment cannot be constrained (it will first shrink the resulting Rectangle according
   * to the `minWidth` and `minHeight` properties of this spec, or the Widget), then it will try aligning at other edges
   * (honouring the `axisLock` option), and pick the fallback alignment which results in the shortest translation.
   * @param {Number} [spec.minHeight] The minimum height this widget may be compressed to when constraining within the `constrainTo` option.
   * @param {Number} [spec.minWidth] The minimum width this widget may be compressed to when constraining within the `constrainTo` option.
   * @param {Boolean} [spec.axisLock] Specify as `true` to fall back to aligning against the opposite
   * edge if the requested alignment cannot be constrained into the `constrainTo` option. Specify as
   * `'flexible'` to allow continuation to try the other edges if a solution cannot be found on the origially requested axis.
   * @param {Boolean} [spec.matchSize] *Only honoured when `axisLock` is enabled and alignment succeeds on the requested axis.
   * Specify as `true` to have this widget's size along the aligned edge match the size of the target's edge.
   * For example, a combobox's dropdown should match the width of the combobox.
   * @param {Number|Number[]} [spec.offset] The offset to create an extra margin round the target
   * to offset the aligned widget further from the target. May be configured as -ve to move the aligned widget
   * towards the target - for example producing the effect of the anchor pointer piercing the target.
   * @category Float & align
   */
  showBy(spec) {
    const me = this;

    // Prevent show from rerouting here.
    me.inShowBy = true;
    me.show();
    me.inShowBy = false;

    if (me.isVisible) {
      me.alignTo(spec);
    }
  }

  /**
   * Show this widget anchored to a coordinate
   * @param {Number|Number[]} x The x position (or an array with [x,y] values) to show by
   * @param {Number} [y] The y position to show by
   * @param {Object} [options] See {@link #function-showBy} for reference
   * @category Float & align
   */
  showByPoint(x, y, options) {
    const xy = arguments.length === 1 ? x : [x, y];

    this.showBy(
      Object.assign(
        {
          target: new Rectangle(xy[0], xy[1], 1, 1),
          align: 't-b'
        },
        options
      )
    );
  }

  afterShow(resolveFn) {
    // This method is injected when maxHeight is set on IE11.
    // Flexbox does not handle overflow correctly when a vertically
    // flexed item is constrained by the maxHeight of its containing el.
    // So we have to propagate the maxHeight from the encapsulating element
    // onto the contentElement.
    if (this.boundMaxHeightBugHandler) {
      this.boundMaxHeightBugHandler();
    }
    this.trigger('show');
    this.triggerPaint();
    resolveFn();
  }

  triggerPaint() {
    const me = this;

    if (me.isVisible) {
      /**
       * Triggered when a widget which had been in a non-visible state for any reason
       * achieves visibility.
       *
       * A non-visible state *might* mean the widget is hidden and has just been shown.
       *
       * But this event will also fire on widgets when a non-visible (unrendered, or hidden)
       * ancestor achieves visibility, for example a {@link Common.widget.Popup Popup} being shown.
       * @event paint
       * @param {Common.widget.Widget} source The widget being painted.
       */
      me.trigger('paint');
      if (me.eachWidget) {
        me.eachWidget(widgetTriggerPaint, true);
      }
    }
  }

  cancelHideShowAnimation() {
    const me = this,
      element = me.element,
      style = element.style;

    if (me.currentAnimation) {
      element.classList.remove('b-hiding');
      element.removeEventListener('transitionend', me.afterHideShowAnimate);
      style.transition = style[me.currentAnimation.styleProp] = '';
      me.currentAnimation = null;
    }
  }

  afterHideShowAnimate(event) {
    // If menu is destroyed too soon in Edge, this method will be invoked for destroyed element
    if (this.isDestroyed) {
      return;
    }

    const me = this,
      element = me.element,
      style = element.style,
      { styleProp, resolve } = me.currentAnimation;

    if (event.target === element && event.propertyName === styleProp) {
      element.classList.remove('b-hiding');
      me.currentAnimation = null;
      element.removeEventListener('transitionend', me.afterHideShowAnimate);

      style.transition = style[styleProp] = '';

      // Element must be fully hidden after the animation effect finishes
      if (me._hidden) {
        me.afterHideAnimation();
        // We want to fire 'hide' event immediately so since it's already fired we do not want to have 'hide' event fired twice
        me.afterHide(resolve, false);
      }
    }
  }

  /**
   * Hide widget
   * @param {Boolean} animate Pass `true` (default) to animate the hide action
   * @category Visibility
   * @returns {Promise} A promise which is resolved when the widget has been hidden
   */
  hide(animate = true) {
    return new Promise((resolve) => {
      const me = this,
        element = me.element,
        style = element.style,
        hideAnimation = animate && me.hideAnimation;

      // replaced check for isVisible with _hidden, need to hide a component not yet in view in EventEditor
      if (!me._hidden && me.trigger('beforeHide') !== false) {
        me._hidden = true;

        if (!element) return;

        me.revertFocus();

        // Focus exit causes close if autoClose: true, and if closeAction: 'hide'
        // that might destroy us, so exit now if that happens.
        if (me.isDestroyed) {
          resolve();
          return;
        }

        // Cancel any current hide/show animation
        if (me.currentAnimation) {
          me.cancelHideShowAnimation();
        }

        if (hideAnimation) {
          const styleProp = Object.keys(hideAnimation)[0],
            animProps = hideAnimation[styleProp];

          me.currentAnimation = {
            styleProp,
            resolve
          };

          // Element must behave as though it were not there during
          // the animated hide. This means pointer-events:none
          element.classList.add('b-hiding');
          element.addEventListener('transitionend', me.afterHideShowAnimate);

          style[styleProp] = animProps.from;
          style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
          me.requestAnimationFrame(() => {
            style[styleProp] = animProps.to;
          });
        } else {
          element.classList.add('b-hidden');
        }

        // only supply resolve function if not using animation
        me.afterHide(!hideAnimation && resolve);
      }
    });
  }

  doHideOrRealign(event) {
    const me = this,
      anchoredTo = me.anchoredTo,
      activeEl = document.activeElement;

    // If we're scrolling because a focused textual input field which we contain is being shifted into view,
    // we must not reposition - we'll just move with the document content.
    if (
      event.target.nodeType === 9 &&
      me.element.contains(activeEl) &&
      textInputTypes[activeEl] &&
      window.innerHeight < document.body.offsetHeight
    ) {
      return;
    }

    // If we either don't know what element we're anchored to (or not anchored to one at all),
    // or the element we're anchored to has been affected by the scroll, we must hide.
    if (me.scrollAction === 'hide' && (!anchoredTo || DomHelper.isDescendant(event.target, anchoredTo))) {
      me.hide();
    }
    // If the scrolling element contains the element we're anchored to, or we are anchored to something which is itself
    // inside a realigning floated widget, then we must realign
    else if (
      me.scrollAction === 'realign' &&
      (DomHelper.isDescendant(event.target, anchoredTo) || IdHelper.fromElement(anchoredTo, isRealigningFloater)) &&
      event.target !== (document.scrollingElement || document.body)
    ) {
      me.realign(event.target);
    }
  }

  afterHide(resolveFn = null, fireEvent = true) {
    const me = this,
      { lastAlignSpec } = me;

    // The flag must be cleared on a normal hide.
    // It's set after the hide() call in alignTo
    // if the target is outside our clippedTo region.
    if (lastAlignSpec) {
      lastAlignSpec.targetHidden = null;
    }

    // Remove listeners which are only added during the visible phase.
    // In its own method because it's called on hide and destroy.
    me.removeTransientListeners();

    // Postprocessing to be done after the hideAnimation finishes.
    // If there's no animation, we call it immediately.
    // We set the element to be hidden here, after any animation completes.
    // We also remove floating Widgets from the DOM when they are hidden.
    if (!me.hideAnimation) {
      me.afterHideAnimation();
    }

    fireEvent && me.trigger('hide');
    resolveFn && resolveFn();
  }

  removeTransientListeners() {
    const me = this;

    if (me.documentScrollListener) {
      document.removeEventListener('scroll', me.doHideOrRealign, true);
      me.documentScrollListener = false;
    }

    if (me.constrainListeners) {
      ResizeMonitor.removeResizeListener(me.lastAlignSpec.constrainTo, me.callRealign);
      me.constrainMutationMonitor && me.constrainMutationMonitor.disconnect();
      me.constrainListeners = false;
    }
  }

  afterHideAnimation() {
    const me = this,
      { element, contentRange } = me;

    if (me.floating && Widget.floatRoot.contains(element)) {
      if (contentRange) {
        me.contentRangeStart = contentRange.start;
        me.contentRangeEnd = contentRange.end;
      }
      element.remove();
    } else {
      element.classList.add('b-hidden');
    }
  }

  /**
   * Show or hide widget. Deprecated in 2.2.3, please use {@link #property-hidden} instead
   * @type {Boolean}
   * @category Visibility
   * @deprecated 2.2.3
   */
  set visible(show) {
    this.hidden = !show;
  }

  /**
   * Hide or show widget
   * @type {Boolean}
   * @category Visibility
   */
  set hidden(hide) {
    if (this.isConfiguring) {
      this._hidden = hide;
      this.element.classList[hide ? 'add' : 'remove']('b-hidden');
    } else {
      if (hide) {
        this.hide();
      } else {
        this.show();
      }
    }
  }

  /**
   * Get id assigned by user (not generated id)
   * @returns {String}
   * @readonly
   * @private
   * @category Misc
   */
  get assignedId() {
    return this.hasGeneratedId ? null : this.id;
  }

  /**
   * Get the owning Widget of this Widget. If this Widget is directly contained, then the containing
   * Widget is returned. If this Widget is floating, the configured `owner` property is returned.
   * If there is a `forElement`, that element's encapsulating Widget is returned.
   * @category Misc
   */
  get owner() {
    return this.parent || this._owner || IdHelper.fromElement(this.forElement || this.element.parentNode);
  }

  set owner(owner) {
    this._owner = owner;
  }

  /**
   * Looks up the {@link #property-owner} axis to find an ancestor which matches the passed selector.
   * The selector may be a widget type identifier, such as `'grid'`, or a function which will return
   * `true` when passed the desired ancestore.
   * @param {String|Function} selector A Type identifier or selection function.
   * @param {Boolean} [deep] When using a string identifier, pass `true` if all superclasses should be included, ie if a `Grid` should match `'widget'`.
   * @param {Number|String|Common.widget.Widget} [limit] how many steps to step up before aborting the search, or a selector to stop at or the topmost ancestor to consider.
   */
  up(selector, deep, limit) {
    const limitType = typeof limit,
      numericLimit = limitType === 'number',
      selectorLimit = limitType === 'string';

    for (let result = this.owner, steps = 1; result; result = result.owner, steps++) {
      if (widgetMatches(result, selector, deep)) {
        return result;
      }
      if (numericLimit && steps >= limit) {
        return;
      } else if (selectorLimit && widgetMatches(result, limit, deep)) {
        return;
      } else if (result === limit) {
        return;
      }
    }
  }

  /**
   * Returns `true` if this Widget owns the passed Element or Widget. This is based on the
   * widget hierarchy, not DOM containment. So an element in a `Combo`'s dropdown list
   * will be owned by the `Combo`.
   * @param {HTMLElement|Common.widget.Widget} target The element or Widget to test for being
   * within the ownership tree of this Widget.
   */
  owns(target) {
    // We were passed an HtmlElement
    if (target && target.nodeType === 1) {
      if (this.element.contains(target)) {
        return true;
      }
      target = IdHelper.fromElement(target);
    }

    while (target) {
      if (target === this) {
        return true;
      }
      target = target.owner;
    }
    return false;
  }

  onFocusIn(e) {
    const me = this,
      { element } = me;

    me.containsFocus = true;
    me.focusInEvent = e;
    element.classList.add('b-contains-focus');

    if (element.contains(e.target) && me.onInternalKeyDown && !me.keyDownListenerRemover) {
      me.keyDownListenerRemover = EventHelper.on({
        element,
        keydown: 'onInternalKeyDown',
        thisObj: me
      });
    }

    /**
     * Fired when focus enters this Widget.
     * @event focusin
     * @param {Common.widget.Widget} source - This Widget
     * @param {HTMLElement} fromElement The element which lost focus.
     * @param {HTMLElement} toElement The element which gained focus.
     * @param {Common.widget.Widget} fromWidget The widget which lost focus.
     * @param {Common.widget.Widget} toWidget The widget which gained focus.
     * @param {Boolean} backwards `true` if the `toElement` is before the `fromElement` in document order.
     */
    me.trigger('focusin', e);
  }

  onFocusOut(e) {
    const me = this;

    if (me.keyDownListenerRemover) {
      me.keyDownListenerRemover();
      me.keyDownListenerRemover = null;
    }

    if (!me.isDestroyed) {
      me.containsFocus = false;
      me.focusInEvent = null;
      me.element.classList.remove('b-contains-focus');

      /**
       * Fired when focus exits this Widget's ownership tree. This is different from a `blur` event.
       * focus moving from within this Widget's ownership tree, even if there are floating widgets
       * will not trigger this event. This is when focus exits this widget completely.
       * @event focusout
       * @param {Common.widget.Widget} source - This Widget
       * @param {HTMLElement} fromElement The element which lost focus.
       * @param {HTMLElement} toElement The element which gained focus.
       * @param {Common.widget.Widget} fromWidget The widget which lost focus.
       * @param {Common.widget.Widget} toWidget The widget which gained focus.
       * @param {Boolean} backwards `true` if the `toElement` is before the `fromElement` in document order.
       */
      me.trigger('focusout', e);
    }
  }

  /**
   * If this Widget contains focus, focus is reverted to the source from which it entered if possible.
   */
  revertFocus() {
    // TODO: look for fallback focus targets if the target is no longer focusable (disabled/hidden etc)
    if (
      this.focusInEvent &&
      this.focusInEvent.relatedTarget &&
      this.focusInEvent.relatedTarget.nodeType === 1 &&
      this.element.contains(document.activeElement)
    ) {
      DomHelper.focusWithoutScrolling(this.focusInEvent.relatedTarget);
    }
  }

  /**
   * Returns `true` if this Widget contains focus.
   */
  isFocused() {
    return this.element.classList.contains('b-contains-focus');
  }

  /**
   * Used by the Widget class internally to create CSS classes based on this Widget's
   * inheritance chain to allow styling from each level to apply.
   *
   * For example Combo would yield `"["b-widget", "b-field", "b-textfield", "b-pickerfield", "b-combo"]"`
   *
   * May be implemented in subclasses to add or remove classes from the super.widgetClassList
   * @returns {String[]} The css class list named using the class name.
   * @internal
   * @category DOM
   */
  get widgetClassList() {
    const me = this;

    let myCls = me.cls,
      result = me.classHierarchy(Widget).reduce(
        (target, cls) => {
          let widgetClassProperty = Reflect.getOwnPropertyDescriptor(cls.prototype, 'widgetClass'),
            widgetClass;

          // If the Class has its own get widgetClass, call it upon this instance.
          if (widgetClassProperty && widgetClassProperty.get) {
            widgetClass = widgetClassProperty.get.call(me);
          } else {
            widgetClass = `b-${cls.$name.toLowerCase()}`;
          }

          if (widgetClass) {
            // The result is used as a DOM classList. Must not contain spaces.
            target.push(...widgetClass.split(' '));
          }
          return target;
        },
        myCls ? myCls.split(' ') : []
      );

    if (me.floating) {
      result.push('b-floating');
    }
    if (BrowserHelper.isTouchDevice) {
      result.push('b-touch');
    }

    return result;
  }

  //endregion

  //region Cache

  /**
   * Gets dom elements in the view. Caches the results for faster future calls.
   * @param {String} query CSS selector
   * @param {Boolean} children true to fetch multiple elements
   * @param {HTMLElement} element Element to use as root for the query, defaults to the views outermost element
   * @returns {HTMLElement|HTMLElement[]|null} A single element or an array of elements (if parameter children is set to true)
   * @internal
   * @category DOM
   */
  fromCache(query, children = false, element = this.element) {
    if (!element) return null;

    const me = this;

    if (!me.cache[query]) {
      me.cache[query] = children ? DomHelper.children(element, query) : DomHelper.down(element, query);
    }
    return me.cache[query];
  }

  /**
   * Clear caches, forces all calls to fromCache to requery dom. Called on render/rerender.
   * @internal
   * @category DOM
   */
  emptyCache() {
    this.cache = {};
  }

  //endregion

  //region Mask

  /**
   * Mask the widget, showing the specified message
   * @param {String|Object} msg Mask message (or a {@link Common.widget.Mask} config object
   * @returns {Common.widget.Mask}
   */
  mask(msg) {
    const me = this;

    if (me.maskInstance) {
      me.maskInstance.destroy();
    }

    if (typeof msg === 'string') {
      return (me.maskInstance = WidgetHelper.mask(me.element, msg));
    }

    msg.element = me.element;

    return (me.maskInstance = WidgetHelper.mask(msg));
  }

  /**
   * Unmask the widget
   */
  unmask() {
    if (this.maskInstance) {
      WidgetHelper.unmask(this.element);
      this.maskInstance = null;
    }
  }

  //endregion

  //region Monitor resize

  onInternalResize(element, width, height, oldWidth, oldHeight) {
    this._width = element.offsetWidth;
    this._height = element.offsetHeight;
  }

  onElementResize(resizedElement) {
    const me = this,
      element = me.element,
      oldWidth = me._width,
      oldHeight = me._height,
      newWidth = element.offsetWidth,
      newHeight = element.offsetHeight;

    if (!me.suspendResizeMonitor && (oldWidth !== newWidth || oldHeight !== newHeight)) {
      me.onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight);
      /**
       * Fired when the encapsulating element of a Widget resizes *only when {@link #config-monitorResize} is `true`*.
       * @event resize
       * @param {Common.widget.Widget} source - This Widget
       * @param {Number} width The new width
       * @param {Number} height The new height
       * @param {Number} oldWidth The old width
       * @param {Number} oldHeight The old height
       */
      me.trigger('resize', { width: newWidth, height: newHeight, oldWidth, oldHeight });
    }
  }

  updateScale() {
    const me = this,
      element = me.element,
      parentElement = element.parentElement;

    // this could be placed elsewhere but want to keep it contained to not spam other code,
    // since this is a very specific usecase in our docs
    if (!me.configuredWidth) {
      me.configuredWidth = me.width;
    }

    // TODO: handle autoHeight, but seems it assigns height to late with current setup

    if (!me.parentHeight) {
      me.parentHeight = parentElement.offsetHeight;
    }

    // We are scaling to fit inside the width, so ensure that we are not the cause of a scrollbar
    // in our current, unscaled state by hiding while we measure the parent's offsetWidth which
    // we are going to scale to.
    element.style.display = 'none';

    const scale = parentElement.offsetWidth / me.configuredWidth,
      adjustedScale = me.allowGrowWidth ? Math.min(scale, 1) : scale;

    element.style.transform = `scale(${adjustedScale})`;
    element.style.transformOrigin = 'top left';
    element.style.display = '';

    parentElement.style.height = me.parentHeight * adjustedScale + 'px';

    if (me.allowGrowWidth && scale > 1) {
      // increase width
      me.width = me.configuredWidth * scale;
    }
  }

  onParentElementResize(event) {
    this.updateScale();
  }

  //endregion

  /**
   * Returns a `TRBL` array of values parse from the passed specification. This can be used to parse`
   * a value list for `margin` or `padding` or `border-width` etc - any CSS value which takes a `TRBL` value.
   * @param {Number|String|String[]} values The `TRBL` value
   * @param {String} [units=px] The units to add to values which are specified as numeric.
   */
  parseTRBL(values, units = 'px') {
    values = values || 0;

    if (typeof values === 'number') {
      return [`${values}${units}`, `${values}${units}`, `${values}${units}`, `${values}${units}`];
    }

    const parts = values.split(' '),
      len = parts.length;

    if (len === 1) {
      parts[1] = parts[2] = parts[3] = parts[0];
    } else if (len === 2) {
      parts[2] = parts[0];
      parts[3] = parts[1];
    } else if (len === 3) {
      parts[3] = parts[1];
    }

    return [
      isFinite(parts[0]) ? `${parts[0]}${units}` : parts[0],
      isFinite(parts[1]) ? `${parts[1]}${units}` : parts[2],
      isFinite(parts[2]) ? `${parts[2]}${units}` : parts[3],
      isFinite(parts[3]) ? `${parts[3]}${units}` : parts[4]
    ];
  }

  static get floatRoot() {
    const me = this;

    if (!me._floatRoot) {
      // Reuse any existing floatRoot. There might be one if using multiple product bundles
      me._floatRoot = document.querySelector('.b-float-root');

      if (!me._floatRoot) {
        me._floatRoot = DomHelper.createElement({
          className: 'b-float-root',
          parent: document.body
        });
      }
    }

    return me._floatRoot;
  }

  static fromElement(element, selector, limit) {}
}

Widget._$name = 'Widget';
BryntumWidgetAdapterRegister.register('widget', Widget);

/**
 * @module Common/widget/Tool
 */

/**
 * Base class for tools.
 *
 * May be configured with a `cls` and a `handler` which is a function (or name of a function)
 * in the owning Panel.
 * @extends Common/widget/Widget
 *
 * @classType tool
 */
class Tool extends Widget {
  template() {
    return `<div class="b-icon"></div>`;
  }

  construct(config) {
    super.construct(config);

    EventHelper.on({
      element: this.element,
      click: 'onClick',
      mousedown: 'onMousedown',
      thisObj: this
    });
  }

  onClick(e) {
    const me = this,
      panel = me.panel,
      handler = typeof me.handler === 'function' ? me.handler : panel[me.handler];

    if (
      panel.trigger('toolclick', {
        tool: me
      }) !== false
    ) {
      handler && me.callback(handler, panel, [e]);
    }
  }

  onMousedown(e) {
    const panel = this.panel,
      focusEl = panel.focusElement;

    e.preventDefault();
    if (focusEl && document.activeElement !== focusEl) {
      panel.focus();
    }
  }

  get panel() {
    return this.parent;
  }
}

Tool._$name = 'Tool';
BryntumWidgetAdapterRegister.register('tool', Tool);

/**
 * @module Common/widget/layout/Layout
 */

/**
 * A helper class used by {@link Common.widget.Container Container}s which renders child widgets to their
 * {@link Common.widget.Widget#property-contentElement}. It also adds the Container's
 * {@link Common.widget.Container#config-itemCls} class to child items.
 *
 * Subclasses may modify the way child widgets are rendered, or may offer APIs for manipulating the child widgets.
 *
 * The {@link Common.widget.layout.Card Card} layout class offers slide-in, slide-out animation of multiple
 * child widgets. {@link Common.widget.TabPanel} uses Card layout.
 */
class Layout extends Events(Base) {
  static get defaultConfig() {
    return {
      /**
       * The CSS class which should be added to the owning {@link Common.widget.Container Container}'s
       * {@link Common.widget.Widget#property-contentElement}.
       */
      containerCls: null,

      /**
       * The CSS class which should be added to the encapsulating element of child items.
       */
      itemCls: null
    };
  }

  static getLayout(layout, owner) {
    if (layout instanceof Layout) {
      return layout;
    }

    const isString = typeof layout === 'string',
      config = {
        owner
      };

    return new (isString ? layoutClasses[layout] : layout)(isString ? config : Object.assign(config, layout));
  }

  static registerLayout(cls, name = cls.$name.toLowerCase()) {
    layoutClasses[name] = cls;
  }

  renderChildren() {
    const { owner, containerCls, itemCls } = this,
      { contentElement, items } = owner,
      ownerItemCls = owner.itemCls,
      itemCount = items && items.length;

    contentElement.classList.add('b-content-element');
    if (containerCls) {
      contentElement.classList.add(containerCls);
    }

    // Need to check that container has widgets, for example TabPanel can have no tabs
    if (itemCount) {
      for (let i = 0; i < itemCount; i++) {
        const item = items[i],
          { element } = item;

        element.dataset.index = i;
        if (itemCls) {
          element.classList.add(itemCls);
        }
        if (ownerItemCls) {
          element.classList.add(ownerItemCls);
        }

        // If instantiated by the app developer, external to Container#createWidget
        // a widget will have the b-outer class. Remove that if it' contained.
        element.classList.remove('b-outer');
        item.render(contentElement);
      }
    }
  }

  /**
   * The owning Widget
   * @property {String} owner
   * @readonly
   */
}

const layoutClasses = {
  default: Layout
};
Layout._$name = 'Layout';

let lastTouchTime = 0;

const hasRipple = (w) => w.ripple,
  Ripple = (window.Ripple = new (class Ripple extends Widget {
    static get defaultConfig() {
      return {
        old_element: {
          children: [
            {
              className: 'b-ripple-inner',
              reference: 'rippleElement'
            }
          ]
        },

        element: {
          children: [
            {
              tag: 'svg',
              class: 'b-ripple-inner',
              reference: 'rippleElement',
              ns: 'http://www.w3.org/2000/svg',
              version: '1.1',
              viewBox: '0 0 100 100',
              children: [
                {
                  reference: 'circleElement',
                  tag: 'circle',
                  cx: '0',
                  cy: '0',
                  r: 10
                }
              ]
            }
          ]
        },

        floating: true,

        hideAnimation: false,

        showAnimation: false,

        scrollAction: 'realign',

        color: 'rgba(0,0,0,.3)',

        startRadius: 10,

        radius: 100
      };
    }

    static get $name() {
      return 'Ripple';
    }

    afterConstruct() {
      super.afterConstruct();

      EventHelper.on({
        element: document,
        DOMContentLoaded: 'doEnableDisable',
        thisObj: this
      });
      GlobalEvents.on({
        theme: 'doEnableDisable',
        thisObj: this
      });
    }

    doEnableDisable() {
      const me = this;

      me.show();

      const rippleAnimation = DomHelper.getStyleValue(me.circleElement, 'animationName');

      me.hide();

      // If our theme supports ripples, add our listeners
      if (rippleAnimation && rippleAnimation !== 'none') {
        me.listenerDetacher = EventHelper.on({
          // Trap all mousedowns and see if the encapsulating Component is configured to ripple
          mousedown: {
            element: document,
            capture: true,
            handler: 'onDocumentMousedown'
          },
          touchstart: {
            element: document,
            capture: true,
            handler: 'onDocumentTouchStart'
          },
          // Hide at the end of the ripple
          animationend: {
            element: me.circleElement,
            handler: 'onAnimationEnd'
          },
          thisObj: me
        });
      }
      // If not, remove them.
      else {
        me.listenerDetacher && me.listenerDetacher();
      }
    }

    onDocumentTouchStart(event) {
      lastTouchTime = performance.now();
      this.handleTriggerEvent(event);
    }

    onDocumentMousedown(event) {
      // We need to prevent a touchend->mousedown simulated mousedown from triggering a ripple.
      // https://developer.mozilla.org/en-US/docs/Web/API/Touch_events/Supporting_both_TouchEvent_and_MouseEvent
      if (performance.now() - lastTouchTime > 200) {
        this.handleTriggerEvent(event);
      }
    }

    handleTriggerEvent(event) {
      const targetWidget = IdHelper.fromElement(event.target, hasRipple);

      if (targetWidget) {
        const rippleCfg = targetWidget.ripple,
          target = rippleCfg.delegate
            ? event.target.closest(rippleCfg.delegate)
            : targetWidget.focusElement || targetWidget.element;

        if (target) {
          const ripple = ObjectHelper.assign(
            {
              event,
              target,
              radius: this.radius
            },
            rippleCfg
          );

          // The clip option is specified as a string property name or delegate
          if (typeof ripple.clip === 'string') {
            ripple.clip = targetWidget[ripple.clip] || event.target.closest(ripple.clip);

            // Not inside an instance of the clip delegate, then no ripple
            if (!ripple.clip) {
              return;
            }
          }
          this.ripple(ripple);
        }
      }
    }

    ripple({
      event,
      point = EventHelper.getClientPoint(event),
      target = event.target,
      clip = target,
      radius = this.radius,
      color = this.color
    }) {
      this.clip = clip;

      clip = Rectangle.from(clip, null, true);

      const me = this,
        centreDelta = clip.getDelta(point),
        rippleStyle = me.rippleElement.style,
        circleElement = me.circleElement;

      me.hide();
      me.alignTo(clip);
      rippleStyle.transform = `translateX(${centreDelta[0]}px) translateY(${centreDelta[1]}px)`;
      rippleStyle.height = rippleStyle.width = `${radius}px`;
      circleElement.setAttribute('r', radius);
      circleElement.setAttribute('fill', color);
      me.show();

      // Push binding to the scroll position out until the next animation frame.
      // This is in case the calling code is going to cause a scroll.
      // Mousedown is a focusing gesture which may cause a scroll
      // to fire as the target element moves into view.
      me.requestAnimationFrame(() => {
        document.addEventListener('scroll', me.callRealign, true);
        me.documentScrollListener = true;
      }, 0);
    }

    alignTo(clip) {
      if (clip.nodeType === 1) {
        clip = Rectangle.from(clip, null, true);
      }
      const me = this,
        { x, y, width, height } = clip;

      me.x = x;
      me.y = y;
      me.height = height;
      me.width = width;
    }

    // When fully expanded, it's all over.
    onAnimationEnd(event) {
      if (event.animationName === 'b-ripple-expand') {
        this.hide();
      }
    }

    realign() {
      if (this.isVisible) {
        this.alignTo(this.clip);
      }
    }
  })());

/**
 * @module Common/widget/Container
 */

const emptyObject$1 = Object.freeze({});

/**
 * Widget that can contain other widgets. Layout is flexbox by default, see the {@link #config-layout} config.
 *
 * @extends Common/widget/Widget
 *
 * @example
 * // create a container with two widgets
 * let container = new Container({
 *   widgets : [
 *     { type : 'text', label : 'Name' },
 *     { type : 'number', label : 'Score' }
 *   ]
 * });
 *
 * @classType container
 * @externalexample widget/Container.js
 */
class Container extends Widget {
  static get defaultConfig() {
    return {
      /**
       * An array of Widgets or typed Widget config objects.
       *
       * If configured as an Object, the property names are used as the child component's
       * {@link Common.widget.Widget#config-ref ref} name, and the value is the child component's config object.
       *
       * '''javascript
       *  new Panel({
       *      title    : 'Test Panel',
       *      floating : true,
       *      centered : true,
       *      width    : 600,
       *      height   : 400,
       *      layout   : 'fit',
       *      items    : {
       *          tabs : {
       *              type : 'tabpanel',
       *              items : {
       *                  general : {
       *                      title : 'General',
       *                      html  : 'General content'
       *                  },
       *                  details : {
       *                      title : 'Details',
       *                      html  : 'Details content'
       *                  }
       *              }
       *          }
       *      }
       *  }).show();```
       *
       * @config {Object[]|Common.widget.Widget[]|Object}
       */
      items: null,

      /**
       * Synonym for the {@link #config-items} config option.
       * @config {Object[]|Common.widget.Widget[]|Object}
       * @deprecated 2.1
       */
      widgets: null,

      /**
       * A config object containing default settings to apply to all child widgets.
       * @config {Object}
       */
      defaults: null,

      defaultType: 'widget',

      /**
       * The CSS style properties to apply to the {@link Common.widget.Widget#property-contentElement}.
       *
       * By default, a Container's {@link Common.widget.Widget#property-contentElement} uses flexbox layout, so this config
       * may contain the following properties:
       *
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction">flexDirection</a> default '`row`'
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap">flexWrap</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-flow">flexFlow</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content">justifyContent</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-items">alignItems</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-content">alignContent</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/place-content">placeContent</a>
       * @config {Object}
       */
      layoutStyle: null,

      /**
       * An optional CSS class to add to child items of this container.
       * @config {String}
       */
      itemCls: null,

      /**
       * The short name of a helper class which manages rendering and styling of child items.
       *
       * By default, the only special processing that is applied is that the Container class's
       * {@link #config-itemCls} is added to child items.
       *
       * Containers use CSS flexbox in its default configuration to arrange child items. You may either
       * use the {@link #config-layoutStyle} configuration to tune how child items are layed out,
       * or use one of the built in helper classes which include:
       *
       *  - `card` Child items are displayed one at a time, size to fit the {@link Common.widget.Widget#property-contentElement}
       * and are slid in from the side when activated.
       * @config {String}
       */
      layout: 'default',

      /**
       * An object containing named config objects which may be referenced by name in any {@link #config-items}
       * object. For example, a specialized {@link Common.widget.Menu Menu} subclass may have a `namedItems`
       * default value defined like this:
       *
       * ```javascript
       *  namedItems : {
       *      removeRow : {
       *          text : 'Remove row',
       *          onItem() {
       *              this.ownerGrid.remove(this.ownerGrid.selectedRecord);
       *          }
       *      }
       *  }
       * ```
       *
       * Then whenever that subclass is instantiated and configured with an {@link #config-items}
       * object, the items may be configured like this:
       *
       * ```javascript
       *  items : {
       *      removeRow : true,   // The referenced namedItem will be applied to this
       *      otherItemRef : {
       *          text : 'Option 2',
       *          onItem() {
       *          }
       *      }
       * }
       * ```
       * @config {Object}
       */
      namedItems: null
    };
  }

  // TODO: Remove when `widgets` is removed.
  setConfig(config, isConstructing) {
    // Assign deprecated widgets to items as early as possible to not have to have special handling in getters/setters
    if (config.widgets) {
      config.items = config.widgets;
    }

    super.setConfig(config, isConstructing);
  }

  startConfigure(config) {
    // Set a flag so that code can test for presence of items without tickling
    // any initial getter.
    const { items } = this;
    this.hasItems = Boolean(items && items.length);
    super.startConfigure(config);
  }

  set widgets(widgets) {
    console.warn('`widgets` was deprecated in 2.1, please change your code to use `items`');
    // Does nothing on purpose
  }

  get widgets() {
    console.warn('`widgets` was deprecated in 2.1, please change your code to use `items`');
    return this.items;
  }

  set items(items) {
    this._items = items;
    this._itemsInvalid = this.itemsInitialized = true;
  }

  /**
   * The array of instantiated child Widgets.
   * @property {Common.widget.Widget[]}
   * @readonly
   */
  get items() {
    const me = this,
      items = me._items;

    // _widgetMap must exist even if there are no items because of other widget containment
    // situations such as docked toolbars.
    if (!me._widgetMap) {
      me._widgetMap = {};
    }

    // Only convert the widget config objects into widgets
    // when we first access the widgets. This is more efficient
    // if this Container is never rendered.
    if (me._itemsInvalid) {
      const instancedItems = (me._items = []);

      if (Array.isArray(items)) {
        me.processItemsArray(items, instancedItems);
      } else if (items) {
        me.processItemsObject(items, me.namedItems, instancedItems);
      }

      // Allow child items to have a weight to establish their order
      if (instancedItems.some((i) => i.weight)) {
        instancedItems.sort((a, b) => (a.weight || 0) - (b.weight || 0));
      }

      me._itemsInvalid = false;
    }

    return me._items;
  }

  processItemsArray(items, result) {
    const len = items.length;

    let i, item;

    for (i = 0; i < len; i++) {
      item = items[i];

      if (!(item instanceof Widget)) {
        item = this.createWidget(item);
      } else {
        item.parent = this;
      }

      // If the widget creation function returns null, nothing to add
      if (item) {
        result.push(item);

        // Add current item to this and every parent widget map
        // cannot use prototype chain here for two reasons:
        // 1. performance
        // 2. prototypes would require new prototype chain for every branch - not optimal
        this.registerReference(item, item.ref || item.id);
      }
    }
  }

  processItemsObject(items, namedItems = emptyObject$1, result) {
    let item, ref;

    for (ref in items) {
      item = items[ref];

      // It might come in as itemRef : false
      if (item) {
        // If this class or instance has a "namedItems" object
        // named by this ref, then use it as the basis for the item
        if (ref in namedItems) {
          item =
            typeof item === 'object' ? ObjectHelper.merge(ObjectHelper.clone(namedItems[ref]), item) : namedItems[ref];
        }

        // Allow namedItems to be overridden with itemKey : false to indicate unavailability of an item
        if (item) {
          if (!(item instanceof Widget)) {
            item = this.createWidget(item);
          } else {
            item.parent = this;
          }

          // If the widget creation function returns null, nothing to add
          if (item) {
            result.push(item);

            // Add current item to this and every parent widget map
            // cannot use prototype chain here for two reasons:
            // 1. performance
            // 2. prototypes would require new prototype chain for every branch - not optimal
            this.registerReference(item, ref);
          }
        }
      }
    }
  }

  registerReference(item, ref) {
    for (let current = this; current; current = current.parent) {
      if (!current.widgetMap[ref]) {
        current.widgetMap[ref] = item;
      }
    }
  }

  /**
   * An object which contains a map of descendant widgets keyed by their {@link Common.widget.Widget#config-ref ref}.
   * All descendant widgets will be available in the `widgetMap`.
   * @property {Object}
   * @readonly
   * @typings any
   */
  get widgetMap() {
    // Force evaluation of the widgets array by the getter
    // so that configs are promoted to widgets and the widgetMap
    // is created, and if there are widgets, populated.
    if (!this._widgetMap) {
      this._thisIsAUsedExpression(this.items);
    }

    return this._widgetMap;
  }

  set record(record) {
    const me = this,
      widgets = me.queryAll((w) => w.name),
      len = widgets.length,
      cl = me.element.classList;

    // Though we set highlightExternalChange on the widgets we change
    // the value of, onChange listeners may update others, so inhibit
    // field update highlighting at the CSS level.
    cl.add('b-form-updating');

    for (let i = 0; i < len; i++) {
      const widget = widgets[i],
        name = widget.name,
        hec = widget.highlightExternalChange;

      // Don't want a field highlight on mass change
      widget.highlightExternalChange = false;

      // Setting record to null clears values
      if (!record && name) {
        widget.value = null;
      } else if (record && name in record) {
        widget.value = record[name];
      }

      widget.highlightExternalChange = hec;
    }
    me.setTimeout(() => cl.remove('b-form-updating'), 1500);

    me._record = record;
  }

  /**
   * The {@link Common.data.Model record} to be applied to the fields contained in this Container.
   * Any descendant widgets of this Container with a `name` property will have its value set to the
   * value of that named property of the record. If no record is passed, the widget has its value
   * set to `null`.
   * @property {Common.data.Model}
   */
  get record() {
    return this._record;
  }

  /**
   * Sets multiple flexbox settings which affect how child widgets are arranged.
   *
   * By default, Containers use flexbox layout, so this property
   * may contain the following properties:
   *
   * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction">flexDirection</a> default '`row`'
   * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap">flexWrap</a>
   * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-flow">flexFlow</a>
   * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content">justifyContent</a>
   * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-items">alignItems</a>
   * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-content">alignContent</a>
   * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/place-content">placeContent</a>
   * @property {Object}
   * @category Layout
   */
  set layoutStyle(layoutStyle) {
    DomHelper.applyStyle(this.contentElement, layoutStyle);
    this._layoutStyle = layoutStyle;
  }

  get layoutStyle() {
    return this._layoutStyle;
  }

  set layout(layout) {
    this._layout = Layout.getLayout(layout, this);
  }

  get layout() {
    return this._layout || (this._layout = new Layout());
  }

  /**
   * Iterate over all widgets in this container and below.
   *
   * *Note*: Due to this method aborting when the function returns
   * `false`, beware of using short form arrow functions. If the expression
   * executed evaluates to `false`, iteration will terminate.
   * @param {Function} fn A function to execute upon all descendant widgets.
   * Iteration terminates if this function returns `false`.
   * @param {Boolean} [deep=true] Pass as `false` to only consider immediate child widgets.
   */
  eachWidget(fn, deep = true) {
    const widgets = this.items,
      length = widgets ? widgets.length : 0;

    for (let i = 0; i < length; i++) {
      const widget = widgets[i];

      if (fn(widget) === false) {
        return;
      }
      if (deep && widget.eachWidget) {
        widget.eachWidget(fn, deep);
      }
    }
  }

  /**
   * Returns an array of all descendant widgets which the passed
   * filter function returns `true` for.
   * @param {Function} filter A function which, when passed a widget,
   * returns `true` to include the widget in the results.
   * @returns {Common.widget.Widget[]} All matching descendant widgets.
   */
  queryAll(filter) {
    const result = [];

    this.eachWidget((w) => {
      if (filter(w)) {
        result.push(w);
      }
    });

    return result;
  }

  /**
   * Returns the first descendant widgets which the passed
   * filter function returns `true` for.
   * @param {Function} filter A function which, when passed a widget,
   * returns `true` to return the widget as the sole result.
   * @returns {Common.widget.Widget} The first matching descendant widget.
   */
  query(filter) {
    let result = null;

    this.eachWidget((w) => {
      if (filter(w)) {
        result = w;
        return false;
      }
    });

    return result;
  }

  /**
   * Returns a directly contained widget by id
   * @param {String} id The widget id
   * @returns {Common.widget.Widget}
   */
  getWidgetById(id) {
    return this.widgetMap[id];
  }

  /**
   * This function is called prior to creating widgets, override it in subclasses to allow containers to modify the
   * configuration of each widget. When adding a widget to a container hierarchy each parent containers
   * `processWidgetConfig` will be called. Returning false from the function prevents the widget from being added at
   * all.
   */
  processWidgetConfig(widget) {}

  /**
   * This function converts a Widget config object into a Widget.
   * @param {Object} widget A Widget config object.
   * @internal
   */
  createWidget(widget) {
    const me = this;

    if (!widget.type) {
      widget.type = me.defaultType;
    }

    // A contained Widget must know its parent, and knowing it during construction
    // is important, but me must not mutate incoming config objects.
    widget = Object.setPrototypeOf(
      {
        parent: me
      },
      widget
    );

    let ancestor = widget;
    while ((ancestor = ancestor.parent)) {
      if (ancestor.processWidgetConfig(widget) === false) {
        return null;
      }
    }

    if (me.trigger('beforeWidgetCreate', { widget }) === false) {
      return null;
    }

    return WidgetHelper.createWidget(ObjectHelper.assign({}, me.defaults, widget), me.defaultType || 'widget');
  }

  render(appendToElement) {
    // Outer container has to be in place first.
    // Pass triggerPaint as false, as when contained, the outermost
    // container calls that at the end of its render
    const result = super.render(appendToElement, false);

    this.layout.renderChildren();

    // The outermost container must trigger paint after all children have
    // been rendered, and this cascades down through all descendants.
    if (!this.parent) {
      this.triggerPaint();
    }

    return result;
  }

  get focusElement() {
    const firstFocusable = this.query(this.defaultFocus || ((w) => w.focusElement));

    if (firstFocusable) {
      return firstFocusable.focusElement;
    }
    return super.focusElement;
  }

  doDestroy() {
    // Only destroy the widgets if they have been instanced.
    if (!this._itemsInvalid && this.items) {
      this.items.forEach((widget) => widget.destroy && widget.destroy());
    }

    super.doDestroy();
  }
}

Container._$name = 'Container';
BryntumWidgetAdapterRegister.register('container', Container);

/**
 * @module Common/widget/Toolbar
 */

/**
 * Widget that is themed to contain Buttons which is docked to the bottom or top of
 * a {@link Common.widget.Panel Panel}.
 *
 * ```javascript
 * // create a toolbar with two buttons
 * let container = new Toolbar({
 *   items : [
 *     { text : 'Add' },
 *     { text : 'Delete' }
 *   ]
 * });
 * ```
 *
 * @extends Common/widget/Container
 * @classType toolbar
 */
class Toolbar extends Container {
  static get defaultConfig() {
    return {
      defaultType: 'button',

      layout: 'default'
    };
  }

  createWidget(widget) {
    if (widget === '->') {
      widget = {
        cls: 'b-toolbar-fill'
      };
    }

    return super.createWidget(widget);
  }
}

Toolbar._$name = 'Toolbar';
BryntumWidgetAdapterRegister.register('toolbar', Toolbar);

/**
 * @module Common/widget/Panel
 */

const acceptNode = (e) =>
    !e.classList.contains('b-focus-trap') && DomHelper.isFocusable(e)
      ? NodeFilter.FILTER_ACCEPT
      : NodeFilter.FILTER_SKIP,
  byWeight = (l, r) => (l.weight || 0) - (r.weight || 0),
  byWeightReverse = (l, r) => (r.weight || 0) - (l.weight || 0);

// https://github.com/webcomponents/webcomponentsjs/issues/556
// Work around Internet Explorer wanting a function instead of an object.
// IE also *requires* this argument where other browsers don't.
acceptNode.acceptNode = acceptNode;

/**
 * Panel widget. A general pupose container which may be used to contain child {@link Common.widget.Container#config-items}
 * or {@link Common.widget.Widget#config-html}.
 *
 * Also may dock a {@link #config-header} and {@link #config-footer} either at top/bottom or left/right
 *
 * @extends Common/widget/Container
 *
 * @example
 * let panel = new Panel({
 *   title   : 'A Test Panel',
 *   widgets : [
 *     { type : 'text', placeholder: 'Text' },
 *   ],
 *   bbar : [{
 *     text : 'Proceed',
 *     onClick : () => {
 *       alert('Proceeding!');
 *     }
 *   }]
 * });
 *
 * @classType panel
 */
class Panel extends Container {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * By default, tabbing within a Panel is not contained, ie you can TAB out of the Panel
       * forwards or backwards.
       * Configure this as `true` to disallow tabbing out of the Panel, and make tabbing circular within this Panel.
       * @config {Boolean}
       * @default false
       */
      trapFocus: null,

      /**
       * A title to display in the header. Causes creation and docking of a header
       * to the top if no header is configured.
       *
       * If specified, overrides any title configured within the {@link #config-header} configuration.
       * @default
       * @config {String}
       */
      title: null,

      /**
       * Config object of a header. May contain a `title`, `titleAlign`, `dock`
       * and a `cls` property. If passed as a string, the value is used
       * as the title, dock is defaulted to `'top', and titleAlign` is defaulted to `start`.
       *
       * The `dock` property may be `top`, `right`, `bottom` or `left`.
       * The `titleAlign` property may be `start`, `center` or `end`.
       * @default
       * @config {Object|String}
       */
      header: null,

      /**
       * Config object of a footer. May contain a `dock`
       * and a `cls` property.
       *
       * The `dock` property may be `top`, `right`, `bottom` or `left`.
       * @default
       * @config {Object|String}
       */
      footer: null,

      /**
       * The tools to add either before or after the title in the Panel header.
       * Each property name is the reference by which an instantiated Tool Widget
       * may be retrieved from the live `{@link #property-tools}` property.
       * Each tool may have the following properties:
       * * `cls` The CSS class to apply.
       * * `handler` A method in the field to call upon click
       * * `align` `'start'` or `'end'` which end of the header the tool should go.
       * * `weight` (Optional) Heigher weighted tools gravitate towards the centre.
       * @config {Object}
       */
      tools: null,

      /**
       * A Config object representing the configuration of a {@link Common.widget.Toolbar},
       * or array of config objects representing the child items of a Toolbar.
       *
       * This creates a toolbar docked to the top of the panel immediately below the header.
       * @config {Object[]|Object}
       */
      tbar: null,

      /**
       * A Config object representing the configuration of a {@link Common.widget.Toolbar},
       * or array of config objects representing the child items of a Toolbar.
       *
       * This creates a toolbar docked to the bottom of the panel immediately above the footer.
       * @config {Object[]|Object}
       */
      bbar: null
    };
  }

  //endregion

  /**
   * A header {@link #config-tools tool} has been clicked.
   * @event toolclick
   * @param {Common.widget.Tool} source - This Panel.
   * @param {Common.widget.Tool} tool - The tool which is being clicked.
   */

  //region Init & destroy

  set element(element) {
    const me = this,
      headerFromTitle = me.title && (!me.parent || !me.parent.suppressChildHeaders),
      // If tools exist, we need to create the header infrastructure
      header = me.header || (me.tools || headerFromTitle ? {} : null),
      footer = me.footer,
      title = header && (typeof header === 'string' ? header : me.title || header.title),
      titleAlign = header && (header.titleAlign || 'start'),
      headerClass = me
        .classHierarchy(Panel)
        .map((cls) => `b-${cls.$name.toLowerCase()}-header`)
        .join(' '),
      tbar = me.tbar,
      bbar = me.bbar || me.buttons,
      children = [
        {
          reference: 'topFocusTrap',
          className: 'b-focus-trap',
          tabIndex: 0
        }
      ],
      startTools = [],
      endTools = [],
      result = {
        children
      };

    if (me.hasItems || me.focusable) {
      result.tabIndex = 0;
    }

    if (header) {
      const headerChildren = [
        {
          reference: 'titleElement',
          className: 'b-header-title',
          style: `text-align:${titleAlign}`,
          html: title
        }
      ];

      for (const toolRef in me.tools) {
        const tool = me.tools[toolRef];
        if (tool.align === 'start') {
          startTools.unshift(tool);
        } else {
          endTools.push(tool);
        }
      }

      // The tools at each end are sorted "gravitationally".
      // Higher weight sorts towards the center which is the title element.
      startTools.sort(byWeight);
      endTools.sort(byWeightReverse);
      headerChildren.unshift(...startTools.map((t) => t.element));
      headerChildren.push(...endTools.map((t) => t.element));

      children.push({
        tag: 'header',
        reference: 'headerElement',
        className: `${headerClass} b-dock-${header.dock || 'top'} ${header.cls || ''}`,
        children: headerChildren
      });
    }

    if (tbar) {
      tbar.layout.renderChildren();
      children.push(tbar.element);
    }

    children.push(me.bodyConfig);

    if (bbar) {
      bbar.layout.renderChildren();
      children.push(bbar.element);
    }

    if (footer) {
      children.push({
        tag: 'footer',
        reference: 'footerElement',
        className: `${headerClass} b-dock-${footer.dock || 'bottom'} ${footer.cls || ''}`
      });
    }

    children.push({
      reference: 'bottomFocusTrap',
      className: 'b-focus-trap',
      tabIndex: 0
    });

    super.element = result;
  }

  set bodyConfig(bodyConfig) {
    this._bodyConfig = bodyConfig;
  }

  get bodyConfig() {
    return (
      this._bodyConfig || {
        reference: 'bodyElement',
        className: this.classHierarchy(Panel)
          .map((cls) => `b-${cls.$name.toLowerCase()}-content`)
          .join(' '),
        html: this.html
      }
    );
  }

  get element() {
    return super.element;
  }

  set tbar(tbar) {
    if (tbar instanceof Toolbar) {
      tbar.parent = this;
    } else {
      if (Array.isArray(tbar)) {
        tbar = {
          items: tbar
        };
      }
      tbar = new Toolbar(
        Object.assign(
          {
            parent: this
          },
          tbar
        )
      );
    }
    tbar.element.classList.add('b-top-toolbar', `b-dock-${tbar.dock || 'top'}`);
    this._tbar = tbar;
  }

  get tbar() {
    return this._tbar;
  }

  set bbar(bbar) {
    if (bbar instanceof Toolbar) {
      bbar.parent = this;
    } else {
      if (Array.isArray(bbar)) {
        bbar = {
          items: bbar
        };
      }
      bbar = new Toolbar(
        Object.assign(
          {
            parent: this
          },
          bbar
        )
      );
    }
    bbar.element.classList.add('b-bottom-toolbar', `b-dock-${bbar.dock || 'bottom'}`);
    this._bbar = bbar;
  }

  get bbar() {
    return this._bbar;
  }

  // Override to iterate docked Toolbars in the correct order around
  // contained widgets.
  eachWidget(fn, deep = true) {
    const me = this,
      widgets = me.items ? me.items.slice() : [];

    if (me.tools) {
      widgets.unshift(...Object.values(me.tools));
    }
    if (me.tbar) {
      widgets.unshift(me.tbar);
    }
    if (me.bbar) {
      widgets.push(me.bbar);
    }

    for (let i = 0; i < widgets.length; i++) {
      const widget = widgets[i];

      if (fn(widget) === false) {
        return;
      }

      if (deep && widget.eachWidget) {
        widget.eachWidget(fn, deep);
      }
    }
  }

  /**
   * The tool Widgets as specified by the {@link #config-tools} configuration
   * (and the {@link Common.widget.Popup#config-closable} configuration in the Popup subclass).
   * Each is a {@link Common.widget.Widget Widget} instance which may be hidden, shown and observed and styled just like any other widget.
   * @property {Object}
   */
  set tools(tools) {
    const me = this,
      myTools = (me._tools = {});

    for (const toolRef in tools) {
      const tool = (myTools[toolRef] = WidgetHelper.createWidget(
        ObjectHelper.assign(
          {
            type: 'tool',
            ref: toolRef,
            //@nige: Widget defines ref but not reference, typo?
            reference: toolRef,
            parent: me
          },
          tools[toolRef]
        ),
        me.defaultToolType || 'tool'
      ));

      me.registerReference(tool, tool.ref);
    }
  }

  get tools() {
    return this._tools;
  }

  set trapFocus(trapFocus) {
    const me = this;

    me.element.classList[trapFocus ? 'add' : 'remove']('b-focus-trapped');
    if (trapFocus) {
      me.focusTrapListener = EventHelper.on({
        element: me.element,
        focusin: 'onFocusTrapped',
        delegate: '.b-focus-trap',
        thisObj: me
      });

      // Create a TreeWalker which visits focusable elements.
      if (!me.treeWalker) {
        me.treeWalker = document.createTreeWalker(me.element, NodeFilter.SHOW_ELEMENT, acceptNode, false);
      }
    } else {
      if (me.focusTrapListener) {
        me.focusTrapListener();
        me.focusTrapListener = null;
      }
    }
    me._trapFocus = trapFocus;
  }

  get trapFocus() {
    return this._trapFocus;
  }

  onFocusTrapped(e) {
    const me = this,
      treeWalker = me.treeWalker;

    // The only way of focusing these invisible elements is by TABbing to them.
    // If we hit the bottom one, wrap to the top.
    if (e.target === me.bottomFocusTrap) {
      treeWalker.currentNode = me.topFocusTrap;
      treeWalker.nextNode();
    }
    // If we hit the top one, wrap to the bottom.
    else {
      treeWalker.currentNode = me.bottomFocusTrap;
      treeWalker.previousNode();
    }

    me.requestAnimationFrame(() => treeWalker.currentNode.focus());
  }

  get focusElement() {
    // Either use our Containerness to yield the focus element of
    // a descendant or fall back to the encapsulating element.
    return this.hasItems && (super.focusElement || this.element);
  }

  get contentElement() {
    return this.element && this.bodyElement;
  }

  get widgetClassList() {
    const me = this,
      result = super.widgetClassList,
      header = me.header;

    if (header || me.title || me.tools) {
      result.push(`b-panel-has-header b-header-dock-${(header && header.dock) || 'top'}`);
    }

    if (me.tbar) {
      result.push(`b-panel-has-top-toolbar`);
    }

    if (me.bbar) {
      result.push(`b-panel-has-bottom-toolbar`);
    }

    return result;
  }

  //endregion

  doDestroy() {
    // Only destroy the widgets if they have been instanced.
    if (this.tbar) {
      this.tbar.destroy();
    }

    if (this.bbar) {
      this.bbar.destroy();
    }

    super.doDestroy();
  }
}

Panel._$name = 'Panel';
BryntumWidgetAdapterRegister.register('panel', Panel);

/**
 * @module Common/widget/Popup
 */

/**
 * Popup widget, used as base class for Menu but can also be used as is to contain widgets or html
 *
 * @extends Common/widget/Panel
 *
 * @example
 * let popup = new Popup({
 *   forElement : document.querySelector('button'),
 *   widgets    : [
 *     { type : 'text', placeholder: 'Text' },
 *     { type: 'button', text: 'Okey', style: 'width: 100%', color: 'orange'}
 *   ]
 * });
 *
 * @classType popup
 * @externalexample widget/Popup.js
 */
class Popup extends Panel {
  //region Config

  static get defaultConfig() {
    return {
      autoShow: true,

      /**
       * By default a Popup is transient, and will {@link #function-close} when the user clicks or
       * taps outside its owned widgets and when focus moves outside its owned widgets.
       *
       * Configure as `false` to make a Popup non-transient.
       * @config {Boolean}
       * @default
       */
      autoClose: true,

      /**
       * Show popup when user clicks the element that it is anchored to. Cannot be combined with showOnHover
       * @config {Boolean}
       * @default
       */
      showOnClick: false,

      forElement: null,

      monitorResize: true,

      floating: true,
      hidden: true,

      axisLock: true, // Flip edges if align violates constrainTo

      hideAnimation: BrowserHelper.isIE11
        ? null
        : {
            opacity: {
              from: 1,
              to: 0,
              duration: '.3s',
              delay: '0s'
            }
          },

      showAnimation: BrowserHelper.isIE11
        ? null
        : {
            opacity: {
              from: 0,
              to: 1,
              duration: '.4s',
              delay: '0s'
            }
          },

      /**
       * The action to take when calling the {@link #function-close} method.
       * By default, the popup is hidden.
       *
       * This may be set to `'destroy'` to destroy the popup upon close.
       * @config {String}
       * @default
       */
      closeAction: 'hide',

      /**
       * By default, tabbing within a Popup is circular - that is it does not exit.
       * Configure this as `false` to allow tabbing out of the Popup.
       * @config {Boolean}
       * @default
       */
      trapFocus: true,

      /**
       * By default a Popup is focused when it is shown.
       * Configure this as `false` to prevent automatic focus on show.
       * @config {Boolean}
       * @default
       */
      focusOnToFront: true,

      /**
       * Show a tool in the header to close this Popup, and allow `ESC` close it.
       * The tool is available in the {@link #property-tools} object
       * under the name `close`. It uses the CSS class `b-popup-close` to apply a
       * default close icon. This may be customized with your own CSS rules.
       * @config {Boolean}
       * @default
       */
      closable: null,

      /**
       * Optionally show an opaque mask below this Popup when shown.
       * Configure this as `true` to show the mask.
       *
       * When a Popup is modal, it defaults to being {@link Common.widget.Widget#config-centered centered}
       *
       * May also be an object containing the following properties:
       * * `closeOnMaskTap` Specify as `true` to {@link #function-close} when mask is tapped.
       * The default action is to focus the popup.
       *
       * Usage:
       * ```javascript
       * new Popup({
       *     title  : 'I am modal',
       *     modal  : {
       *         closeOnMaskTap : true
       *     },
       *     height : 100,
       *     width  : 200
       * });
       * ```
       *
       * @config {Boolean}
       * @default
       */
      modal: null
    };
  }

  //endregion

  startConfigure(config) {
    // Read the closable config which will force evaluation of tools
    // to include close tool.
    this._thisIsAUsedExpression(this.closable);

    super.startConfigure(config);
  }

  //region Init & destroy

  finalizeInit() {
    const me = this;

    me.anchoredTo = me.forElement;
    me.initialAnchor = me.anchor;

    if (me.forElement && me.showOnClick) {
      // disable autoShow if not enabled by config
      if (!me.initialConfig.autoShow) {
        me.autoShow = false;
      }
      EventHelper.on({
        element: me.forElement,
        click: 'onElementUserAction',
        thisObj: me
      });
    }

    super.finalizeInit();

    if (me.autoShow) {
      if (me.autoShow === true) {
        me.show();
      } else {
        me.setTimeout(() => me.show(), me.autoShow);
      }
    }
  }

  //endregion

  //region Show/hide

  /**
   * Performs the configured {@link #config-closeAction} upon this popup.
   * By default, the popup hides. The {@link #config-closeAction} may be
   * configured as `'destroy'`.
   * @fires beforeclose If popup is not hidden
   */
  close() {
    /**
     * Fired when the {@link #function-close} method is called and the popup is not hidden.
     * May be vetoed by returning `false` from a handler.
     * @event beforeClose
     * @param {Common.widget.Popup} source - This Popup
     */
    if (
      (!this._hidden && this.trigger('beforeClose') !== false) ||
      // we should destroy it even if it's hidden just omit beforeclose event
      (this._hidden && this.closeAction == 'destroy')
    ) {
      return this[this.closeAction]();
    }
  }

  //endregion

  //region Events

  onElementResize(resizedElement, lastRect, myRect) {
    const me = this,
      { lastAlignSpec } = me;

    // If this Popup changes size while we are aligned and we are aligned to
    // a target (not a position), then we might need to realign.
    if (me.isVisible && lastAlignSpec && lastAlignSpec.target) {
      const heightChange = !lastRect || myRect.height !== lastRect.height,
        widthChange = !lastRect || myRect.width !== lastRect.width;

      // Only realign if:
      // the height has changed and we are not aligned below, or
      // the width has changed and we are not aligned to the right.
      if ((heightChange && lastAlignSpec.zone !== 2) || (widthChange && lastAlignSpec.zone !== 1)) {
        // Must move to next AF because in Chrome, the resize monitor might fire
        // before the element is painted and the anchor color matching
        // scheme cannot work in that case.
        me.requestAnimationFrame(() => me.realign());
      }
    }

    super.onElementResize(resizedElement);
  }

  onInternalKeyDown(event) {
    // close on escape key
    if (event.key === 'Escape') {
      event.stopImmediatePropagation();
      this.close(true);
    }
  }

  onDocumentMouseDown({ event }) {
    const me = this;

    if (me.modal && event.target === Popup.modalMask) {
      event.preventDefault();
      if (me.modal.closeOnMaskTap) {
        me.close();
      } else if (!me.containsFocus) {
        me.focus();
      }
    }
    // in case of outside click and if popup is focused, focusout will trigger closing
    else if (!me.owns(event.target) && me.autoClose && !me.containsFocus) {
      me.close();
    }
  }

  onFocusIn(e) {
    const activeEl = document.activeElement;

    super.onFocusIn(e);

    // No event handler has moved focus, and target is outermost el
    // then delegate to the focusElement which for a Container
    // is found by finding the first visible, focusable descendant widget.
    if (document.activeElement === activeEl && e.target === this.element) {
      this.focus();
    }
  }

  onFocusOut(e) {
    if (this.autoClose) {
      this.close();
    }
    super.onFocusOut(e);
  }

  onShow() {
    const me = this;

    if (me.autoClose && !me.mouseDownRemover) {
      me.mouseDownRemover = GlobalEvents.on({
        globaltap: 'onDocumentMouseDown',
        thisObj: me
      });
    }

    // TODO: It's the floating "toFront" operation that should handle
    // focusing based on config focusOnToFront.
    if (me.focusOnToFront) {
      me.focus();
    }

    super.onShow && super.onShow();

    // Insert the modal mask below this Popup
    if (me.modal) {
      // If we have not been explicitly positioned, a modal is centered.
      if (!me._x && !me._y) {
        me.centered = true;
      }
      const { modalMask } = Popup;
      modalMask.classList.remove('b-hide-display');
      modalMask.parentNode.insertBefore(modalMask, me.element);
    }
  }

  onHide() {
    const me = this;

    if (me.mouseDownRemover) {
      me.mouseDownRemover();
      me.mouseDownRemover = null;
    }

    super.onHide && super.onHide();

    // Hide the modal mask.
    if (me.modal) {
      Popup.modalMask.classList.add('b-hide-display');
    }
  }

  onElementUserAction() {
    this.show();
  }

  //endregion

  set closable(closable) {
    this._closable = closable;
    if (!this.tools) {
      this.tools = {};
    }
  }

  get closable() {
    return this._closable;
  }

  set tools(tools) {
    const me = this;

    if (me.closable) {
      (tools || (tools = {})).close = {
        cls: 'b-popup-close',
        handler: 'close',
        weight: -1000
      };
    }
    super.tools = tools;
  }

  get tools() {
    return super.tools;
  }

  static get modalMask() {
    if (!this._modalMask) {
      this._modalMask = DomHelper.createElement({
        className: 'b-modal-mask b-hide-display',
        parent: this.floatRoot
      });
    }
    return this._modalMask;
  }
}

Popup._$name = 'Popup';
BryntumWidgetAdapterRegister.register('popup', Popup);

/**
 * @module Common/helper/TemplateHelper
 */

const tagSpaceRe = />[ \t\r\n]+</g,
  multiSpaceRe = /\s\s+/g;

/**
 * Helper for template strings, use as tag function
 * @example
 * TemplateHelper.tpl`...`
 * @internal
 */
class TemplateHelper {
  /**
   * Tag function for template literals that does some basic cleanup
   * @private
   */
  static tpl(strings, ...values) {
    let count = 0,
      output = values
        .map((val, i) => {
          // TODO: pad output nicely instead of just trimming away
          let ret = strings[i];

          if (Array.isArray(val)) {
            ret += val.reduce((ack, item) => (ack += (typeof item === 'string' ? item.trim() : item) + '\n'), '');
          } else {
            if (val === undefined) {
              val = '';
            }
            ret += typeof val === 'string' ? val.trim() : val;
          }

          count++;

          return ret;
        })
        .join('');

    if (count <= strings.length) {
      output += strings[strings.length - 1];
    }

    // Excise unnecessary *soft* whitespace textNodes. We cannot use \s because that
    // matches non-breaking spaces which need to be preserved.
    // Also reduce any usage of multiple spaces to single, since they have no value in html
    return output
      .replace(tagSpaceRe, '><')
      .replace(multiSpaceRe, ' ')
      .trim();
  }

  /**
   * Tag function for template literals that does some basic cleanup. Version for docs that do not remove blank space,
   * to keep code snippets formatting intact.
   * @private
   */
  static docsTpl(strings, ...values) {
    let count = 0,
      output = values
        .map((val, i) => {
          // TODO: pad output nicely instead of just trimming away

          let str = strings[i],
            ret = str;

          if (Array.isArray(val)) {
            ret += val.reduce((ack, item) => (ack += (typeof item === 'string' ? item.trim() : item) + '\n'), '');
          } else {
            if (val === undefined) {
              val = '';
            }
            ret += typeof val === 'string' ? val.trim() : val;
          }

          count++;

          return ret;
        })
        .join('');

    if (count <= strings.length) {
      output += strings[strings.length - 1];
    }

    // Excise unnecessary *soft* whitespace textNodes. We cannot use \s because that
    // matches non-breaking spaces which need to be preserved.
    return output.replace(tagSpaceRe, '><').trim();
  }

  static repeat(times) {
    return function(...args) {
      return TemplateHelper.tpl(...args).repeat(times);
    };
  }

  static loop(times) {}
}
TemplateHelper._$name = 'TemplateHelper';

/**
 * @module Common/widget/MenuItem
 */

const bIcon = /^b-icon-/,
  bFa = /^b-fa-/;

/**
 * Menu item widget, encapsulates a menu item within a Menu.
 *
 * May be configured with a {@link #config-checked} state which creates
 * a checkbox which may bwe toggled.
 *
 * Fires events when activated which bubble up through the parent hierachy
 * and may be listened for on an ancestor. See {@link Common.widget.Menu Menu}
 * for more details on usage.
 *
 * @extends Common/widget/Widget
 *
 * @classType menuitem
 */
class MenuItem extends Widget {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * A submenu configuration object, or an array of MenuItem configuration
       * objects from which to create a submenu.
       *
       * Note that this does not have to be a Menu. The `type` config can be used
       * to specify any widget as the submenu.
       * @config {Object|Object[]}
       */
      menu: null,

      /**
       * Item icon class.
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * Otherwise this is a developer-defined CSS class string which results in the desired icon.
       * @config {String}
       */
      icon: null,

      /**
       * The text to be displayed in the item
       * @config {String}
       */
      text: null,

      /**
       * If configured with a `Boolean` value, a checkbox is displayed
       * as the start icon, and the {@link #event-toggle} event is fired
       * when the checked state changes.
       * @config {Boolean}
       */
      checked: null,

      /**
       * By default, upon activate, non-checkbox menu items will collapse
       * the owning menu hierarchy.
       *
       * Configure this as `false` to cause the menu to persist after
       * activating an item
       * @config {Boolean}
       */
      closeParent: null,

      localizableProperties: ['text']
    };
  }

  /**
   * Actions this item. Fires the {@link #event-item} event, and if this
   * if a {@link #config-checked} item, toggles the checked state, firing
   * the {@link #event-toggle} event.
   */
  doAction(event) {
    const item = this,
      menu = this.parent,
      itemEvent = { menu, item, element: item.element, bubbles: true };

    if (typeof item.checked === 'boolean') {
      item.checked = !item.checked;
    }

    // Give internal handlers a chance to inject extra information before
    // user-supplied "item" handlers see the event.
    // Scheduler's ContextMenu feature does this
    item.trigger('beforeItem', itemEvent);

    /**
     * This menu item has been activated.
     *
     * Note that this event bubbles up through parents and can be
     * listened for on a top level {@link Common.widget.Menu Menu} for convenience.
     * @event item
     * @param {Common.widget.MenuItem} item - The menu item which is being actioned.
     * @param {Common.widget.Menu} menu - Menu containing the menu item
     */
    item.trigger('item', itemEvent);

    // Collapse the owning menu hierarchy if configured to do so
    if (item.closeParent && menu) {
      menu.rootMenu.close();

      // Don't prevent links doing their thing
      if (event && !item.href) {
        event.preventDefault();
      }
    }
  }

  doDestroy() {
    const menu = this._menu;

    if (menu instanceof Widget) {
      menu.destroy();
    }
    super.doDestroy();
  }

  template(me) {
    const icon =
        me.icon || (typeof me.checked === 'boolean' ? `b-fw-icon b-icon-${me.checked ? '' : 'un'}checked` : ''),
      iconExtraCls = bIcon.test(icon) ? ' b-icon' : bFa.test(icon) ? ' b-fa' : '',
      tag = me.href ? 'a' : 'div';

    return TemplateHelper.tpl`
            <${tag} ${tag === 'a' ? `href="${me.href}"` : ''} ${
      tag === 'a' && me.target ? `target="${me.target}"` : ''
    } class="${me.hasMenu ? 'b-has-submenu' : ''}" ${me.name ? `data-name="${me.name}"` : ''} tabIndex="-1">
                ${icon ? `<i class="b-menuitem-icon ${icon}${iconExtraCls}" reference="iconElement"></i>` : ''}
                <span class="b-menu-text" reference="textElement">${me.text}</span>
                ${me.hasMenu ? '<i class="b-fw-icon b-icon-sub-menu" reference="subMenuIcon"></i>' : ''}
            </${tag}>`;
  }

  get focusElement() {
    return this.element;
  }

  get contentElement() {
    return this.textElement;
  }

  get isFocusable() {
    const focusElement = this.focusElement;

    // We are only focusable if the focusEl is deeply visible, that means
    // it must have layout - an offsetParent. Body does not have offsetParent.
    // Disabled menu items are focusable but cannot be activated.
    // https://www.w3.org/TR/wai-aria-practices/#h-note-17
    return focusElement && this.isVisible && (focusElement === document.body || focusElement.offsetParent);
  }

  onFocusIn(e) {
    super.onFocusIn(e);
    if (!this.disabled && this.menu) {
      this.openMenu();
    }
  }

  onFocusOut(e) {
    super.onFocusOut(e);
    this.closeMenu();
  }

  openMenu(andFocus) {
    const menu = this.menu;

    if (!this.disabled && menu) {
      menu.focusOnToFront = andFocus;
      menu.show();
      this.owner.currentSubMenu = menu;
    }
  }

  closeMenu() {
    if (this._menu instanceof Widget) {
      this.menu.close();
    }
  }

  /**
   * Get/sets the checked state of thie `MenuItem` and fires the {@link #event-toggle}
   * event upon change.
   *
   * Note that this must be configured as a `Boolean` to enable the checkbox UI.
   * @property {Boolean}
   */
  set checked(checked) {
    const me = this,
      { isConfiguring } = me;

    // If we began life as a non-checkitem, then reject attempts to set checked status.
    if (!isConfiguring && !(typeof me._checked === 'boolean')) {
      return;
    }

    // Ensure we're always dealing with a Boolean
    checked = !!checked;

    // Reject non-changes.
    if (checked !== me._checked) {
      me._checked = checked;

      // During config this is initial state; do not fire change events.
      // Initial icon state is set in the template.
      if (!isConfiguring) {
        me.iconElement.classList[checked ? 'add' : 'remove']('b-icon-checked');
        me.iconElement.classList[checked ? 'remove' : 'add']('b-icon-unchecked');

        /**
         * The checked state of this menu item has changed.
         *
         * Note that this event bubbles up through parents and can be
         * listened for on a top level {@link Common.widget.Menu Menu} for convenience.
         * @event toggle
         * @param {Common.widget.MenuItem} item - The menu item whose checked state changed.
         * @param {Common.widget.Menu} menu - Menu containing the menu item
         * @param {Boolean} checked - The _new_ checked state.
         */
        me.trigger('toggle', {
          menu: me.owner,
          item: me,
          checked: me._checked,
          element: me.element,
          bubbles: true
        });
      }
    }
  }

  get checked() {
    return this._checked;
  }

  set menu(menu) {
    this._menu = menu;
  }

  get text() {
    return this.html;
  }

  set text(text) {
    this.html = text;
  }

  /**
   * Returns the instantiated menu widget as configured by {@link #config-menu}.
   * @property {Common.widget.Widget}
   * @readonly
   */
  get menu() {
    const me = this;

    let result = me._menu;

    if (result && !(result instanceof Widget)) {
      // This covers both Array and Object which are valid items config formats.
      // menu could be { itemRef : { text : 'sub item 1 } }. But if it has
      // child items or html property in it, it's the main config
      if (typeof result === 'object' && !('items' in result || 'widgets' in result || 'html' in result)) {
        result = {
          items: result
        };
      }
      result = me.menu = WidgetHelper.createWidget(
        Object.assign(
          {
            type: 'menu',
            autoShow: false,
            autoClose: true,
            scrollAction: me.owner.scrollAction,
            constrainTo: me.owner.constrainTo,
            forElement: me.element,
            align: 'l0-r0',
            anchor: true,
            owner: me,
            cls: 'b-sub-menu' // Makes the anchor hoverable to avoid mouseleave
          },
          result
        )
      );
    }

    return result;
  }

  set closeParent(closeParent) {
    this._closeParent = closeParent;
  }

  get closeParent() {
    const result = typeof this.checked === 'boolean' ? this._closeParent : this._closeParent !== false;

    return result && !this.hasMenu;
  }

  get hasMenu() {
    const menu = this.isConfiguring ? this.initialConfig.menu : this._menu;

    return menu && (menu instanceof Widget || typeof menu === 'object' || menu.length > 0);
  }
}

MenuItem._$name = 'MenuItem';
BryntumWidgetAdapterRegister.register('menuitem', MenuItem);

const validKeys = {
  ArrowUp: 1,
  ArrowDown: 1,
  ArrowRight: 1,
  ArrowLeft: 1,
  Enter: 1,
  Escape: 1
};

/**
 * @module Common/widget/Menu
 */

/**
 * Menu widget, displays a list of items which the user can select from using mouse or keyboard. Can have submenus.
 *
 * @extends Common/widget/Popup
 *
 * @example
 * let menu = new Menu({
 *     forElement : btn.element,
 *     items      : [{
 *         icon : 'b-icon b-icon-add',
 *         text : 'Add'
 *     }, {
 *         icon : 'b-icon b-icon-trash',
 *         text : 'Remove'
 *     }, {
 *         text : 'Sub menu',
 *         menu : [{
 *             icon : 'b-icon fa-play',
 *             text : 'Play'
 *         }]
 *     }],
 *     // Method is called for all ancestor levels
 *     onItem({ item }) {
 *         Toast.show('You clicked ' + item.text);
 *     }
 * });
 *
 * @classType menu
 * @externalexample widget/Menu.js
 */
class Menu extends Popup {
  //region Config

  static get defaultConfig() {
    return {
      align: 't-b',

      scrollAction: 'hide',

      /**
       * Specify false to prevent the menu from getting focus when hovering items
       * @default
       * @config {Boolean}
       */
      focusOnHover: null,

      // We do need a Scroller so that we can use its API to scroll around.
      // But the overflow flags default to false.
      scrollable: false,

      defaultType: 'menuitem'
    };
  }

  //endregion

  /**
   * A descendant menu item has been activated.
   *
   * Note that this event bubbles up through parents and can be
   * listened for on a top level {@link Common.widget.Menu Menu} for convenience.
   * @event item
   * @param {Common.widget.MenuItem} item - The menu item which is being actioned.
   * @param {Common.widget.Menu} menu - Menu containing the menu item
   */

  /**
   * The checked state of a descendant menu item has changed.
   *
   * Note that this event bubbles up through parents and can be
   * listened for on a top level {@link Common.widget.Menu Menu} for convenience.
   * @event toggle
   * @param {Common.widget.MenuItem} item - The menu item whose checked state changed.
   * @param {Common.widget.Menu} menu - Menu containing the menu item
   * @param {Boolean} checked - The _new_ checked state.
   */

  //region Init

  construct(config) {
    if (Array.isArray(config)) {
      config = {
        items: config
      };
    }

    super.construct(config);

    EventHelper.on({
      element: this.element,
      click: 'onMouseClick',
      mouseover: 'onMouseOver',
      mouseleave: 'onMouseLeave',
      thisObj: this
    });
  }

  afterShow(resolveFn) {
    // Don't instantiate all our items' subMenus right now.
    // Use our private _menu property which will still be a config item.
    const hasSubmenu = this.items.some((item) => Boolean(item._menu));

    // afterShow is called before alignment, so this is the correct time
    // to mutate things which will change this Widget's size.
    if (hasSubmenu) {
      this.element.classList.add('b-menu-with-submenu');
    }

    // Add CSS class to menu if any item has an icon, to allow aligning icon-less items
    const hasIcon = this.items.some((item) => item.icon);

    if (hasIcon) {
      this.element.classList.add('b-menu-with-icon');
    }

    super.afterShow(resolveFn);
  }

  createWidget(item) {
    if (typeof item === 'string') {
      item = {
        text: item
      };
    }

    return super.createWidget(item);
  }

  get focusElement() {
    const fromParentMenu = this.parentMenu && this.parentMenu.element.contains(document.activeElement),
      firstWidget = this.items[0];

    if (fromParentMenu || !(firstWidget instanceof MenuItem)) {
      return super.focusElement;
    }
    return this.element;
  }

  //endregion

  onDocumentMouseDown(event) {
    // It's not a click outside if its a click on our owner Menu
    if (!this.parentMenu || !this.parentMenu.owns(event.event.target)) {
      super.onDocumentMouseDown(event);
    }
  }

  //region Show

  hide(animate) {
    if (this.currentSubMenu) {
      this.currentSubMenu.hide(animate);
    }

    super.hide(animate);

    if (this.parentMenu) {
      this.parentMenu.currentSubMenu = null;
    }
  }

  //endregion

  //region Events

  /**
   * Activates a menu item if user clicks on it
   * @private
   */
  onMouseClick(event) {
    const me = this,
      menuItem = event.target.closest('.b-menuitem');

    if (menuItem) {
      me.triggerElement(menuItem, event);

      // IE / Edge still triggers event listeners that were removed in a listener - prevent this
      event.stopImmediatePropagation();
    }
  }

  /**
   * Activates menu items on hover. On real mouse hover, not on a touchstart.
   * @private
   */
  onMouseOver(event) {
    if (this.focusOnHover !== false) {
      const fromItemElement = DomHelper.up(event.relatedTarget, '.b-widget'),
        toItemElement = DomHelper.up(event.target, '.b-widget'),
        overItem = IdHelper.fromElement(toItemElement);

      if (!DomHelper.isTouchEvent && toItemElement && toItemElement !== fromItemElement && overItem.parent === this) {
        overItem && overItem.focus();
      }
    }
  }

  // unselect any menu item if mouse leaves the menu element (unless it enters a child menu)
  onMouseLeave(event) {
    const me = this,
      { relatedTarget } = event,
      leavingToChild = relatedTarget && me.owns(relatedTarget);

    let targetCmp = relatedTarget && relatedTarget instanceof HTMLElement && IdHelper.fromElement(relatedTarget),
      shouldHideMenu = !leavingToChild;

    if (targetCmp) {
      while (targetCmp.ownerCmp) {
        targetCmp = targetCmp.ownerCmp;
      }

      // Or was found and does not belong to current menu DOM tree
      // This condition will not allow possibly existing picker to hide
      // Covered by Menu.t.js
      shouldHideMenu &= !DomHelper.getAncestor(targetCmp.element, [event.target]);
    }

    if (!leavingToChild && shouldHideMenu) {
      me.currentSubMenu && me.currentSubMenu.hide();
      me.currentSubMenu = me.selectedElement = null;

      // Deactivate currently active *menu items* on mouseleave
      if (me.element.contains(document.activeElement) && document.activeElement.matches('.b-menuitem')) {
        me.element.focus();
      }
    }
  }

  /**
   * Keyboard navigation. Up/down, close with esc, activate with enter
   * @private
   */
  onInternalKeyDown(event) {
    const sourceWidget = IdHelper.fromElement(event),
      isFromWidget = sourceWidget && sourceWidget !== this && !(sourceWidget instanceof MenuItem);

    if (event.key === 'Escape') {
      // Only close this menu if the ESC was in a child input Widget
      (isFromWidget ? this : this.rootMenu).close();
      return;
    }

    super.onInternalKeyDown(event);

    // Do not process keys from certain elemens
    if (isFromWidget) {
      return;
    }

    if (validKeys[event.key]) {
      event.preventDefault();
    }

    const active = document.activeElement,
      el = this.element;

    this.navigateFrom(active !== el && el.contains(active) ? active : null, event.key, event);
  }

  navigateFrom(active, key, event) {
    const me = this,
      treeWalker = me.treeWalker,
      item = active && me.getItemFromElement(active);

    let toActivate;

    switch (key) {
      case 'ArrowUp':
        treeWalker.currentNode = active || (active = me.bottomFocusTrap);
        treeWalker.previousNode();
        toActivate = treeWalker.currentNode;
        break;

      case 'ArrowDown':
        treeWalker.currentNode = active || (active = me.topFocusTrap);
        treeWalker.nextNode();
        toActivate = treeWalker.currentNode;
        break;

      case ' ':
        if (active && !active.classList.contains('b-disabled')) {
          if (item && item.menu) {
            me.openSubMenu(active, item);
          } else {
            me.triggerElement(active, event);
          }
        }
        break;

      case 'ArrowRight':
        if (active && item && item.menu && !active.classList.contains('b-disabled')) {
          // opening with arrow keys highlights first item (as in menus on mac)
          const openedMenu = me.openSubMenu(active, item);

          // If show hs not been vetoed, ask it to focus.
          // Container will delegate focus inward if possible.
          if (openedMenu) {
            openedMenu.focus();
          }
        } else {
          treeWalker.currentNode = active || (active = me.topFocusTrap);
          treeWalker.nextNode();
          toActivate = treeWalker.currentNode;
        }
        break;

      case 'ArrowLeft':
        if (me.isSubMenu) {
          me.hide();
        } else if (!active) {
          treeWalker.currentNode = active || (active = me.topFocusTrap);
          treeWalker.nextNode();
          toActivate = treeWalker.currentNode;
        }
        break;

      case 'Enter':
        if (active && !active.classList.contains('b-disabled')) {
          me.triggerElement(active, event);
        }
        break;
    }

    // Move focus to wherever we have calculated
    if (toActivate) {
      // Previous moved to encapsulating element; wrap from end
      if (toActivate === me.element) {
        me.navigateFrom(me.bottomFocusTrap, 'ArrowUp', event);
      }
      // Next could not move because we're at the end; wrap from top
      else if (toActivate === active) {
        me.navigateFrom(me.topFocusTrap, 'ArrowDown', event);
      } else {
        toActivate.focus();
      }
    }
  }

  //endregion

  //region Activate menu item

  getItemFromElement(menuItemElement) {
    return IdHelper.fromElement(menuItemElement, 'menuitem', this.contentElement);
  }

  /**
   * Activate a menu item (from its element)
   * @private
   * @fires item
   * @param menuItemElement
   */
  triggerElement(menuItemElement, event) {
    const menu = this,
      item = menu.getItemFromElement(menuItemElement);

    // If the trigger gesture happened on a non-MenuItem
    // item will be undefined. Do not action on a non-MenuItem
    // or a disabled MenuItem
    if (item && !item.disabled) {
      item.doAction(event);
    }
  }

  /**
   * Returns true if this menu is a sub menu.
   * To find out which menu is the parent, check {@link #property-parentMenu}.
   * @type {boolean}
   * @readonly
   */
  get isSubMenu() {
    return this.owner && this === this.owner.menu;
  }

  /**
   * Opens a submenu anchored to a menu item
   * @private
   * @param element
   * @param item
   */
  openSubMenu(element, item) {
    const me = this,
      subMenu = item.menu;

    if (subMenu) {
      if (!subMenu.isVisible) {
        const event = { item, element };

        if (me.trigger('beforeSubMenu', event) === false) {
          return;
        }
        if (item.onBeforeSubMenu && item.onBeforeSubMenu(event) === false) {
          return;
        }
        subMenu.show();
      }

      /**
       * Currently open sub menu, if any
       * @member {Common.widget.Menu} currentSubMenu
       * @readonly
       */
      return (me.currentSubMenu = subMenu);
    }
  }

  /**
   * Get/set focused menu item.
   * Shows submenu if newly focused item has a menu and is not disabled.
   * @property {HTMLElement}
   */
  set selectedElement(element) {
    const me = this,
      lastSelected = me._selectedElement;

    if (lastSelected) {
      const lastItem = me.getItemFromElement(lastSelected),
        lastItemMenu = lastItem && lastItem.menu;

      if (lastItemMenu) {
        lastItemMenu.hide();
      }
      lastSelected.classList.remove('b-active');
    }

    me._selectedElement = element;

    // might set to null to deselect
    if (element) {
      const doFocus = DomHelper.isFocusable(element);

      element.classList.add('b-active');
      me.scrollable.scrollIntoView(element, {
        animate: !doFocus,
        focus: doFocus
      });
    }
  }

  get selectedElement() {
    return this._selectedElement;
  }

  selectFirst() {
    const treeWalker = this.treeWalker;

    treeWalker.currentNode = this.topFocusTrap;
    treeWalker.nextNode();

    // If we are under keyboard control, this must happen in the next
    // animation frame so that the keydown event doesn't fire on the
    // newly focused node.
    this.requestAnimationFrame(() => treeWalker.currentNode.focus());
  }

  //endregion

  //region Close

  /**
   * Gets the parent Menu if this Menu is a submenu.
   * @returns {Common.widget.Menu} The parent menu if this is a submenu, otherwise, `undefined`.
   */
  get parentMenu() {
    let result = this.owner;

    if (result instanceof MenuItem) {
      result = result.owner;
    }
    if (result instanceof Menu) {
      return result;
    }
  }

  /**
   * Gets this menus root menu, the very first menu shown in a sub menu hierarchy
   * @property {Common.widget.Menu}
   * @private
   */
  get rootMenu() {
    let menu = this;

    while (menu.parentMenu && menu.parentMenu instanceof this.constructor) {
      menu = menu.parentMenu;
    }

    return menu;
  }

  //endregion
}

Menu._$name = 'Menu';
BryntumWidgetAdapterRegister.register('menu', Menu);

/**
 * Basic toast. Toasts are stacked on top of each other
 * @example
 * // simplest possible
 * Toast.show('Just toasting');
 *
 * // with config
 * Toast.show({
 *   html: 'Well toasted',
 *   showProgress: false
 * });
 *
 * // as instance (instance is also returned from Toast.show()
 * let toast = new Toast({
 *   html: 'Not going away',
 *   timeout: 0
 * });
 *
 * toast.show();
 *
 * @classType toast
 * @externalexample widget/Toast.js
 */
class Toast extends Widget {
  static get defaultConfig() {
    return {
      floating: true,

      /**
       * Timeout (in ms) until the toast is automatically dismissed. Set to 0 to never hide.
       * @config {Number}
       * @default
       */
      timeout: 2500,

      /**
       * Show a progress bar indicating the time remaining until the toast is dismissed.
       * @config {Boolean}
       * @default
       */
      showProgress: true,

      /**
       * Toast color (should have match in toast.scss or your custom styling).
       * Valid values in Bryntum themes are:
       * * b-amber
       * * b-blue
       * * b-dark-gray
       * * b-deep-orange
       * * b-gray
       * * b-green
       * * b-indigo
       * * b-lime
       * * b-light-gray
       * * b-light-green
       * * b-orange
       * * b-purple
       * * b-red
       * * b-teal
       * * b-white
       * * b-yellow
       *
       * ```
       * new Toast({
       *    color : 'b-blue'
       * });
       * ```
       *
       * @config {String}
       */
      color: null,

      bottomMargin: 20
    };
  }

  doDestroy() {
    const index = Toast.toasts.indexOf(this.element);

    if (index > -1) {
      Toast.toasts.splice(index, 1);
    }

    super.doDestroy();
  }

  // Toasts must not create their element until show.
  set element(element) {}

  get element() {
    // Toasts must not create their element until show.
    if (!this._element && !this.isConfiguring) {
      const me = this,
        topToast = Toast.toasts.length && Toast.toasts[0],
        bottom = topToast ? topToast._nextBottom : me.bottomMargin,
        element = (super.element = DomHelper.createElement({
          parent: me.appendTo || Widget.floatRoot,
          children: me.showProgress
            ? [
                {
                  className: 'b-toast-progress',
                  style: `animation-duration:${me.timeout / 1000}s;`
                }
              ]
            : null,
          html: me._html,
          className: me.color || '',
          style: me._style || ''
        }));

      EventHelper.on({
        element,
        click: 'hide',
        thisObj: me
      });

      Toast.toasts.unshift(element);

      element._nextBottom = bottom + element.offsetHeight + me.bottomMargin;

      // Transitioned style props must be set dynamically
      element.style.cssText += `;bottom:${bottom}px;transform:translateY(0)`;
    }
    return super.element;
  }

  /**
   * Show the toast
   */
  show() {
    super.show();

    if (this.timeout > 0) {
      this.hideTimeout = this.setTimeout('hide', this.timeout);
    }
  }

  /**
   * Hide the toast
   */
  hide() {
    const me = this;
    if (!me.destroyTimeout) {
      me.element.classList.add('b-toast-hide');
      me.element.style.bottom = '';
      me.animationTimeout = me.setTimeout('destroy', 200);
    }
  }

  /**
   * Easiest way to show a toast
   * @param {String|Object} msgOrConfig Message or toast config object
   * @returns {Common.widget.Toast}
   * @example
   * Toast.show('Hi');
   * @example
   * Toast.show({
   *   html   : 'Read quickly, please',
   *   timeout: 1000
   * });
   */
  static show(msgOrConfig) {
    const toast = new Toast(typeof msgOrConfig === 'string' ? { html: msgOrConfig } : msgOrConfig);
    toast.show();
    return toast;
  }
}

Toast.toasts = [];

Toast._$name = 'Toast';
BryntumWidgetAdapterRegister.register('toast', Toast);

const realignTransitions = {
  left: true,
  right: true,
  top: true,
  bottom: true,
  transform: true
};

/**
 * @module Common/widget/Tooltip
 */

/**
 * Tooltip. Easiest way of assigning a tooltip to a widget is by setting {@link Common.widget.Widget#config-tooltip}, see example below.
 *
 * ```javascript
 * button.tooltip = 'Click me and you wont believe what happens next';
 * ```
 *
 * ## Showing async content
 * To create async tooltip and show {@link #config-loadingMsg}, set {@link #property-html} to `false`:
 *
 * ```javascript
 * new Tooltip({
 *     listeners : {
 *         beforeShow : ({ source : tip }) => {
 *             tip.html = false;
 *             AjaxHelper.get('someurl').then(response => tip.html = 'Done!');
 *         }
 *     }
 * });
 * ```
 *
 * @extends Common/widget/Widget
 * @classType tooltip
 * @externalexample widget/Tooltip.js
 */
class Tooltip extends Popup {
  //region Default config

  static get defaultConfig() {
    return {
      /**
       * Horizontal offset from mouse when {@link #config-anchorToTarget} is `false`
       * @config {Number}
       * @default
       */
      mouseOffsetX: 15,

      /**
       * Vertical offset from mouse when {@link #config-anchorToTarget} is `false`
       * @config {Number}
       * @default
       */
      mouseOffsetY: 15,

      floating: true,

      /**
       * Set to a function that returns a string to update tooltips contents. Called on each mouse move event.
       * @config {Function}
       */
      getHtml: null,

      /**
       * DOM element to attach tooltip to. By default, the mouse entering this element will kick off a timer
       * (see {@link #config-hoverDelay}) to show itself.
       *
       * If the {@link #config-forSelector} is specified, then mouse entering matching elements within the `forElement`
       * will trigger the show timer to start.
       *
       * Note that when moving from matching element to matching element within the `forElement`, the tooltip
       * will remain visible for {@link #config-hideDelay} milliseconds after exiting one element, so that rapidly
       * entering another matching element will not cause hide+show flicker. To prevent this behaviour configure
       * with `hideDelay: 0`.
       * @config {HTMLElement}
       */
      forElement: null,

      trackMouse: null,

      /**
       * Shows tooltip for all elements that match this selector within the {@link #config-forElement}.
       * @config {String}
       */
      forSelector: null,

      /**
       * By default, when moving rapidly from target to target, if, when mouseing over
       * a new target, the tip is still visible, the tooltip does not hide, it remains
       * visible, but updates its content however it is configured to do so.
       *
       * Configure `hideOnDelegateChange : true` to have the tip hide, and then trigger
       * a new show delay upon entry of a new target while still visible.
       * @config {Boolean}
       * @default false
       */
      hideOnDelegateChange: null,

      /**
       * Set to true to anchor tooltip to the triggering target. If set to `false`, the tooltip
       * will align to the mouse position. When set to `false`, it will also set `anchor: false`
       * to hide anchor arrow.
       * @config {Boolean}
       * @default true
       */
      anchorToTarget: true,

      /**
       * Show on hover
       * @config {Boolean}
       * @default
       */
      showOnHover: false,

      /**
       * The amount of time to hover before showing
       * @config {Number}
       * @default
       */
      hoverDelay: 500,

      /**
       * Show immediately when created
       * @config {Boolean}
       * @default
       */
      autoShow: false,

      /**
       * The time (in milliseconds) that the Tooltip should stay visible for when it shows over its
       * target. If the tooltip is anchored to its target, then moving the mouse during this time
       * resets the timer so that the tooltip will remain visible.
       *
       * Defaults to `0` which means the Tooltip will persist until the mouse leaves the target.
       * @config {Number}
       * @default
       */
      dismissDelay: 0,

      /**
       * The time (in milliseconds) for which the Tooltip remains visible when the mouse leaves the target.
       *
       * May be configured as `false` to persist visible after the mouse exits the target element. Configure it
       * as 0 to always retrigger `hoverDelay` even when moving mouse inside `fromElement`
       * @config {Number}
       * @default
       */
      hideDelay: 500,

      /**
       * Loading message for async tooltips.
       * @config {String}
       * @default
       */
      loadingMsg: 'Loading...',

      /**
       * Keep the tooltip open if user hovers it
       * @config {Boolean}
       * @default
       */
      allowOver: false,

      /**
       * Specify `true` for a tooltip used to show unformatted text. It will apply the `b-tooltip-text-content`
       * class which specifies a default max width that makes long text more readable.
       */
      textContent: false,

      anchor: true,
      align: 'b-t',
      axisLock: true,

      showAnimation: null,
      hideAnimation: null
    };
  }

  //endregion

  //region Events

  /**
   * Triggered when a mouseover event is detected on a potential target element.
   * Return false to prevent the action
   * @event pointerOver
   * @param {Common.widget.Tooltip} sourceThe tooltip instance.
   * @param {Event} event The mouseover event.
   */

  //endregion

  //region Properties

  /**
   * The HTML element that triggered this Tooltip to show
   * @member {HTMLElement} activeTarget
   */

  //endregion

  //region Init & destroy

  afterConstruct() {
    const me = this,
      { forSelector } = me;

    if (forSelector) {
      me.showOnHover = true;
      if (!me.forElement) {
        me.trackMouse = true;
        me.forElement = document.body;
      }
    }

    super.afterConstruct();

    // There's a triggering element, and we're showing on hover, add the mouse listeners
    if (me.forElement && me.showOnHover) {
      EventHelper.on({
        element: me.forElement,
        mouseover: 'internalOnPointerOver',
        mouseout: 'onPointerOut',
        transitionend: 'onTransitionEnd',
        thisObj: me
      });
    }

    if (me.autoShow) {
      me.show();
    }

    if (me.allowOver) {
      EventHelper.on({
        element: me.element,
        mouseenter: 'onOwnElementMouseEnter',
        mouseleave: 'onPointerOut',
        thisObj: me
      });
    }
  }

  get focusElement() {
    const result = super.focusElement;
    if (result !== this.element) {
      return result;
    }
  }

  get anchorToTarget() {
    return this._anchorToTarget;
  }

  set anchorToTarget(anchorToTarget) {
    this._anchorToTarget = anchorToTarget;
    if (!anchorToTarget) this.anchor = false;
  }

  set trackMouse(trackMouse) {
    this._trackMouse = trackMouse;
  }

  get trackMouse() {
    // We do not track the mouse if we are anchored to (aligned to) the target
    return this._trackMouse && !this.anchorToTarget;
  }

  //endregion

  //region Hovering, show and hide

  internalOnPointerOver(event) {
    const me = this,
      forElement = me.forElement,
      forSelector = me.forSelector,
      activeTarget = me.activeTarget;
    let newTarget;

    if (me.disabled) {
      return;
    }

    // If the mouse moves over this tooltip, it is theoretically a mouseout of its
    // forElement, but allowOver lets us tolerate this ane remain visible.
    if (me.allowOver && me.element.contains(event.target)) {
      return;
    }

    // There's been a mouseover. If we have a forSelector, we have to check
    // if it's an enter of a matching child
    if (forSelector) {
      // Moving inside a forSelector matching element
      if (activeTarget && activeTarget.contains(event.target) && activeTarget.contains(event.relatedTarget)) {
        return;
      }
      newTarget = event.target.closest(forSelector);

      // Mouseovers while within a target do nothing
      if (newTarget && event.relatedTarget && event.relatedTarget.closest(forSelector) === newTarget) {
        return;
      }
    }
    // There's no forSelector, so check if we moved from outside the target
    else if (!forElement.contains(event.relatedTarget)) {
      newTarget = forElement;
    }
    // Mouseover caused by moving from child to child inside the target
    else {
      return;
    }

    // If pointer entered the target or a forSelector child, then show.
    if (newTarget) {
      me.handleForElementOver(event, newTarget);
    }
    // If over a non-forSelector child, behave as in forElement out
    else if (activeTarget) {
      me.handleForElementOut();
    }
  }

  // Handle a transitioned reposition when the activeTarget moved beneath the pointer.
  // When it comes to an end, if the mouseout has not hidden, then realign at the new position
  // if the activeTarget is still beneath the pointer.
  onTransitionEnd(event) {
    const me = this,
      currOver = Tooltip.currentOverElement;

    if (realignTransitions[event.propertyName]) {
      // Don't realign if the mouse is over this, and is allowed to be over this
      // If user is interacting with this Toolltip, they won't expect it to move.
      if (me.allowOver && me.element.contains(currOver)) {
        return;
      }

      // If we are still visible, and mouse is still over the activeTarget, realign
      if (me.isVisible && me.activeTarget.contains(currOver) && !me.trackMouse) {
        me.realign();
      }
    }
  }

  handleForElementOver(event, newTarget) {
    const me = this;

    // Vetoed, then behave as is a targetout
    if (me.trigger('pointerOver', { event, target: newTarget }) === false) {
      me.onPointerOut(event);
    } else {
      me.pointerEvent = event;
      me.abortDelayedHide();

      // We are over a new target. If we are still visible, we
      // do not want to hide to avoid flickering. But if there is a
      // beforeshow listener which may mutate us, we still have to
      // consult it. If it returns a veto, then we do in fact hide.
      // Under normal circumstances we just alignTo the new target.
      // We must handle the post show tasks like starting the dismiss timer etc.
      if (me.isVisible && !me.hideOnDelegateChange) {
        me.updateActiveTarget(newTarget);
        if (me.trigger('beforeShow') === false) {
          return me.hide();
        }
        me.alignTo({
          target: me.anchorToTarget
            ? newTarget
            : new Point(
                me.pointerEvent.pageX - window.pageXOffset + me.mouseOffsetX,
                me.pointerEvent.pageY - window.pageYOffset + me.mouseOffsetY
              ),
          overlap: !(me.anchorToTarget && me.anchor)
        });
        me.trigger('show');
        me.afterShowByTarget();
      } else {
        if (me.hideOnDelegateChange) {
          me.hide();
        }
        me.updateActiveTarget(newTarget);
        me.delayShow(newTarget);
      }
    }
  }

  delayShow(target) {
    const me = this;

    // Caught in an animation - cancel it
    if (me.currentAnimation) {
      me.cancelHideShowAnimation();
      me._hidden = true;
    }

    if (!me.isVisible && !me.hasTimeout('show')) {
      // Allow hoverDelay:0 or rapid movement from delegate to delegate to show immediately
      if (!me.hoverDelay || (me.forSelector && Date.now() - me.lastHidden < me.quickShowInterval)) {
        me.showByTarget(target);
      } else {
        // If we're not going to anchor to the hovered element, then we need to keep track
        // of mousemoves until the show happens so we can show where the mouse currently is.
        if (!me.listeningForMouseMove && !me.anchorToTarget) {
          me.mouseMoveRemover = EventHelper.on({
            element: document,
            mousemove: 'onMouseMove',
            thisObj: me
          });
        }
        // If a tap event triggered, do not wait. Show immediately.
        me.setTimeout(
          () => me.showByTarget(target),
          !me.pointerEvent || me.pointerEvent.type === 'mouseover' ? me.hoverDelay : 0,
          'show'
        );
      }
    } else if (me.isVisible) {
      me.showByTarget(target);
    }
  }

  showByTarget(target) {
    const me = this;

    if (me.mouseMoveRemover) {
      me.mouseMoveRemover();
      me.mouseMoveRemover = null;
    }

    // Show by the correct thing.
    // If we are not anchored to the target, then it's the current pointer event.
    // Otherwise it's the activeTarget.
    me.showBy({
      target: me.anchorToTarget
        ? target
        : new Point(
            me.pointerEvent.pageX - window.pageXOffset + me.mouseOffsetX,
            me.pointerEvent.pageY - window.pageYOffset + me.mouseOffsetY
          ),
      overlap: !(me.anchorToTarget && me.anchor)
    });
  }

  afterShowByTarget() {
    const me = this,
      dismissDelay = me.dismissDelay;

    me.abortDelayedShow();
    if (dismissDelay) {
      me.setTimeout('hide', dismissDelay);
    }
    me.toFront();
  }

  updateActiveTarget(newTarget) {
    const me = this,
      lastTarget = me.activeTarget;

    me.activeTarget = newTarget;

    if (!me.isConfiguring) {
      me.trigger('overtarget', { newTarget, lastTarget });
    }
  }

  onPointerOut(event) {
    const me = this,
      toElement = event.relatedTarget;

    // Edge case: If there is no space to fit the tooltip, and as a result of showing the tooltip - the mouse is over the tooltip
    // Make sure we don't end up in an infinite hide/show loop
    if (me.allowOver && me.element.contains(toElement)) {
      return;
    }

    // If we were in an allowOver situation and exited
    // into the activeTarget, do nothing; in this situation
    // the tip is treated as if it were part of the target.
    if (me.element.contains(event.target) && me.activeTarget && me.activeTarget.contains(toElement)) {
      return;
    }

    // We have exited the active target
    if (me.activeTarget && !me.activeTarget.contains(event.relatedTarget)) {
      me.handleForElementOut();
    }
  }

  handleForElementOut() {
    // Separated from onTargetOut so that subclasses can handle target out in any way.
    const me = this,
      { hideDelay } = me;

    me.abortDelayedShow();

    // Even if there is a hide timer, it's a *dismiss* timer which hides the tip
    // after a hover time. We begin a new delay on target out.
    if (me.isVisible && hideDelay !== false) {
      me.abortDelayedHide();
      if (hideDelay > 0) {
        me.setTimeout('hide', hideDelay);
      } else {
        // Hide immediately when configured with `hideDelay: 0`. Used by async cell tooltips that always should
        // retrigger `hoverDelay`, to not spam the backend
        me.hide();
      }
    }
  }

  show() {
    const me = this;

    // If we know what element to show it by, and we are anchoring to it
    // and there's no ambiguity with a selector for sub elements,
    // then show it by our forElement (Unless we're being called from showBy)
    if (me.forElement && me.anchorToTarget && !me.forSelector && !me.inShowBy) {
      me.showByTarget(me.forElement);
    }
    // All we can do is the basic Widget show.
    else {
      if (me.inShowBy) {
        me.y = -10000;
      }
      super.show();
    }

    me.afterShowByTarget();
    // If we've shown, and are tracking the mouse and not anchored to (aligned to) the target, track the mouse
    if (!me.mouseMoveRemover && !me._hidden && me.trackMouse) {
      me.mouseMoveRemover = EventHelper.on({
        element: document,
        mousemove: 'onMouseMove',
        thisObj: me
      });
    }
  }

  hide() {
    const me = this;

    if (me.isVisible) {
      me.abortDelayedShow();
      me.abortDelayedHide();

      super.hide();

      me.lastHidden = Date.now();
      me.activeTarget = null;
      if (me.mouseMoveRemover) {
        me.mouseMoveRemover();
        me.mouseMoveRemover = null;
      }

      me.listeningForMouseMove = false;
    }
  }

  abortDelayedShow() {
    const me = this;
    if (me.hasTimeout('show')) {
      me.clearTimeout('show');
      if (me.mouseMoveRemover) {
        me.mouseMoveRemover();
        me.mouseMoveRemover = null;
      }
    }
  }

  /**
   * Stops both timers which may hide this tooltip, the one which counts down from mouseout
   * and the one which counts down from mouseover show for dismissDelay ms
   * @private
   */
  abortDelayedHide() {
    this.clearTimeout('hide');
  }

  realign(el) {
    const me = this,
      spec = me.lastAlignSpec,
      clippedBy = me.clippedBy;

    // If we are hidden because our align target scrolled, or otherwise
    // moved out of its clipping boundaries, then check if it's moved back in.
    // For example EventDrag might move the element outside of the scheduler
    // SubGrid, which will cause the tip to hide, but then moving it back in
    // must reshow it.
    if (!me.isConfiguring && clippedBy && !me.isVisible && spec.targetHidden) {
      const target = Rectangle.from(spec.target, me.positioned ? me.element.offsetParent : null, !me.positioned),
        clippedTarget = target.intersect(clippedBy);

      // If there is an intersecting Rectangle with the forElement, align
      if (clippedTarget) {
        me.show();
        spec.targetHidden = false;
      }
    }

    super.realign(el);
  }

  alignTo(spec) {
    const me = this;

    if (!me.isVisible) return;

    // getHtml implies update on align.
    // Must update HTML before calculating position
    if (me.getHtml) {
      // If mouse pointer is over this, do not attempt
      // to call the getHtml method.
      if (!(me.pointerEvent && me.element.contains(me.pointerEvent.target))) {
        if (spec.nodeType === 1) {
          spec = {
            target: spec
          };
        }
        const xy =
          spec instanceof Point
            ? spec
            : spec.position || (spec.target.nodeType === 1 ? Rectangle.from(spec.target) : spec.target);

        // setHtml attempts to realign to previous alignment unless this flag is set
        me.isAligning = true;

        me.html = me.getHtml({
          tip: me,
          element: me.element,
          forElement: me.activeTarget,
          x: xy.x,
          y: xy.y,
          event: me.pointerEvent
        });
        me.isAligning = false;
      }
    }

    if (me.isVisible) {
      super.alignTo(spec);
    }
  }

  //endregion

  //region Tooltip contents

  set textContent(value) {
    this._textContent = value;

    this.element.classList[value ? 'add' : 'remove']('b-tooltip-text-content');
  }

  get textContent() {
    return this._textContent;
  }

  set html(html) {
    const me = this;

    // setting to false signals async tooltip, show loading message.
    // TODO: Load masking should be a general Widget ability.
    if (html === false) {
      html = `<div class="b-tooltip-loading"><div class="b-icon b-icon-spinner"></div>${me.L(me.loadingMsg)}</div>`;
    } else if (html != null) {
      html = String(html); // in case a number was passed in
    }

    // we have something to show...
    if (html) {
      // When setting the html, we must inhibit any configured html getter
      let getHtml = me.getHtml;
      me.getHtml = null;
      super.html = html;
      // Must realign before restoring getHtml, to not get stuck in infinite html setting loop
      if (!me.isAligning) {
        me.realign();
      }
      me.getHtml = getHtml;

      me.trigger('innerHtmlUpdate');
    } else {
      // do not show empty tooltips
      me.hide();
    }
  }

  /**
   * Get/set HTML to display. When specifying HTML, this widget's element will also have `b-html` added to its
   * classList, to allow targeted styling. To create async tooltip and show {@link #config-loadingMsg}, set it to `false`.
   * For example:
   *
   * ```javascript
   * new Tooltip({
   *     listeners : {
   *         beforeShow : ({ source : tip }) => {
   *             tip.html = false;
   *             AjaxHelper.get('someurl').then(response => tip.html = 'Done!');
   *         }
   *     }
   * });
   * ```
   *
   * @property {String}
   * @category DOM
   */
  get html() {
    return super.html;
  }

  //endregion

  //region Events

  /**
   * Mouse move event listener which updates tooltip
   * @private
   */
  onMouseMove(event) {
    const me = this,
      x = event.pageX - window.pageXOffset + me.mouseOffsetX,
      y = event.pageY - window.pageYOffset + me.mouseOffsetY,
      // If we are trackMouse: true
      // we must keep out of the way of the mouse by continuing
      // to track if we are on the way out due to a hide timer.
      isHiding = me.hasTimeout('hide'),
      target = event.target;

    // MouseMove is listened for during the hover show timer wait phase if anchorToTarget is false
    // so that when the timer fires, it can show near the most recent pointer position.
    // It's also listened for after show when we are not anchored to the target and so tracking the mouse.
    me.pointerEvent = event;

    // Check that we are still valid to be visible, and if so, track the mouse.
    if (!me._hidden) {
      // Check whether the element we are over is still a valid delegate matching the forSelector,
      // or it's the tip element, and we're allowOver. If not, we have to hide.
      // nodeType check is for FF on Linux, event.target is sometimes a text node
      if (
        me.forSelector &&
        !isHiding &&
        target.nodeType === 1 &&
        !target.matches(me.forSelector) &&
        !(me.allowOver && me.element.contains(target))
      ) {
        me.handleForElementOut();
      }
      // If we are not hiding due to moving mouse outside our forElement, tooltip stays visible and optionally realigns based on trackMouse setting.
      else if (!isHiding || me.forElement.contains(target)) {
        // Mousemoves restart the dismiss timer.
        if (me.dismissDelay && !isHiding) {
          me.setTimeout('hide', me.dismissDelay);
        }

        // If we're not anchoring to the target, track the mouse
        if (me.trackMouse) {
          me.alignTo({
            position: new Point(x, y),
            ignorePageScroll: true
          });
        }
      }
    }
  }

  onOwnElementMouseEnter(event) {
    this.abortDelayedHide();
  }
  //endregion
}

EventHelper.on({
  element: document,
  mouseenter: (event) => (Tooltip.currentOverElement = event.target),
  capture: true
});

/**
 * Updated dynamically with the current element that the mouse is over. For use when showing a Tooltip
 * from code which is not triggered by a pointer event so that a tooltip can be positioned.
 * @member {HTMLElement} currentOverElement
 * @readonly
 * @static
 */

Tooltip._$name = 'Tooltip';
BryntumWidgetAdapterRegister.register('tooltip', Tooltip);

/**
 * @module Common/widget/mixin/Badge
 */

/**
 * Mixin that allows a widget to display a badge (mostly done as css)
 *
 * @example
 * // show badge
 * button.badge = 5;
 *
 * // hide badge
 * button.badge = null;
 *
 * @externalexample widget/Badge.js
 *
 * @mixin
 */
var Badge = (Target) =>
  class Badge extends (Target || Base) {
    construct(config) {
      super.construct(config);

      // set after we have element to display badge from start
      if (this._badge) this.badge = this._badge;
    }

    /**
     * Initial text to show in badge
     * @config {String} badge
     */

    /**
     * Get/sets and display badge, set to null or empty string to hide
     * @property {String}
     */
    set badge(badge) {
      const { element } = this;

      this._badge = badge;

      if (element) {
        if (badge != null && badge !== '') {
          element.dataset.badge = badge;
          element.classList.add('b-badge');
        } else {
          if (element.dataset.badge) delete element.dataset.badge;
          element.classList.remove('b-badge');
        }
      }
    }

    get badge() {
      return this._badge;
    }

    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {
      // If we don't have a badge, our classList doesn't include "b-badge"
      if (this.badge) {
        return 'b-badge';
      }
    }
  };

//TODO: should togglebutton be own class implemented as input type=checkbox?
//TODO: A toggling widget's focusElement should be an opacity:0 input type=checkbox which covers the clickable area.

/**
 * @module Common/widget/Button
 */

const bIcon$1 = /^b-icon-/,
  bFa$1 = /^b-fa-/;

/**
 * Button widget, wraps and styles a regular <code>&lt;button&gt;</code> element. Can display text and icon and allows specifying button color.
 *
 * @extends Common/widget/Widget
 * @mixes Common/widget/mixin/Badge
 *
 * @example
 * // button with text and icon
 * let button = new Button({
 *   icon: 'b-fa-plus-circle',
 *   text: 'Add',
 *   color: 'green',
 *   onClick: () => {}
 * });
 *
 * @classType button
 * @externalexample widget/Button.js
 */
class Button extends Badge(Widget) {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Button icon class.
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * Otherwise this is a developer-defined CSS class string which results in the desired icon.
       * @config {String}
       */
      icon: null,

      /**
       * Icon class for the buttons pressed state. Only applies to toggle buttons
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * Otherwise this is a developer-defined CSS class string which results in the desired icon.
       *
       * ```
       * new Button({
       *    // Icon for unpressed button
       *    icon        : 'b-fa-wine-glass',
       *
       *    // Icon for pressed button
       *    pressedIcon : 'b-fa-wine-glass-alt',
       *
       *    // Only applies to toggle buttons
       *    toggleable  : true
       * });
       * ```
       *
       * @config {String}
       */
      pressedIcon: null,

      /**
       * Button icon alignment. May be `'start'` or `'end'`. Defaults to `'start'`
       * @config {String}
       */
      iconAlign: 'start',

      /**
       * Button text
       * @config {String}
       */
      text: '',

      /**
       * Button color (should have match in button.scss or your custom styling). Valid values in Bryntum themes
       * are:
       * * b-amber
       * * b-blue
       * * b-dark-gray
       * * b-deep-orange
       * * b-gray
       * * b-green
       * * b-indigo
       * * b-lime
       * * b-light-gray
       * * b-light-green
       * * b-orange
       * * b-purple
       * * b-red
       * * b-teal
       * * b-white
       * * b-yellow
       * Combine with specifying `b-raised` for raised/filled style (theme dependent).
       *
       * ```
       * new Button({
       *    color : 'b-teal b-raised'
       * });
       * ```
       *
       * @config {String}
       */
      color: null,

      /**
       * Enabled toggling of the button (stays pressed when pressed).
       * @config {Boolean}
       * @default
       */
      toggleable: false,

      /**
       * Initially pressed or not. Only applies with `toggleable = true`.
       * ```
       * const toggleButton = new Button({
       *    toggleable : true,
       *    text : 'Enable cool action'
       * });
       * ```
       * @config {Boolean}
       * @default
       */
      pressed: false,

      /**
       * Indicate that this button is part of a group where only one button can be pressed. Assigning a value
       * also sets `toggleable` to `true`.
       * ```
       * const yesButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'Yes'
       * });
       *
       * const noButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'No'
       * });
       * ```
       * @config {String}
       */
      toggleGroup: null,

      ripple: {
        radius: 75
      },

      defaultBindProperty: 'text',

      localizableProperties: ['text'],

      /**
       * A submenu configuration object, or an array of MenuItem configuration
       * objects from which to create a submenu which is shown when this button is pressed.
       *
       * Note that this does not have to be a Menu. The `type` config can be used
       * to specify any widget as the submenu.
       * @config {Object|Object[]}
       */
      menu: null
    };
  }

  template() {
    const me = this;

    return TemplateHelper.tpl`
            <button class="${me.color || ''} ${me.toggleable && me.pressed ? 'b-pressed' : ''}" ${
      me.toggleGroup ? `data-group="${me.toggleGroup}"` : ''
    }>
                \xa0
            </button>
        `;
  }

  //endregion

  //region Construct/Destroy

  construct(config = {}, ...args) {
    if (config.toggleGroup) {
      config.toggleable = true;
    }

    super.construct(config, ...args);

    EventHelper.on({
      element: this.element,
      click: 'onInternalClick',
      thisObj: this
    });
  }

  doDestroy() {
    this.destroyProperties('menu');
    super.doDestroy();
  }

  //endregion

  //region Getters/Setters

  get focusElement() {
    return this.element;
  }

  /**
   * Get/set text displayed on the button.
   * @property {String}
   */
  get text() {
    return this._text;
  }

  set text(text) {
    const { element } = this;

    if (text === null || text === undefined) text = '';

    element.lastChild.data = this._text = text;
    element.classList[text ? 'add' : 'remove']('b-text');
  }

  /**
   * Returns the instantiated menu widget as configured by {@link #config-menu}.
   * @property {Common.widget.Widget}
   * @readonly
   */
  get menu() {
    const me = this;

    let result = me._menu;

    if (result && !(result instanceof Widget)) {
      // This covers both Array and Object which are valid items config formats.
      // menu could be { itemRef : { text : 'sub item 1 } }. But if it has
      // child items or html property in it, it's the main config
      if (typeof result === 'object' && !('items' in result || 'widgets' in result || 'html' in result)) {
        result = {
          items: result
        };
      }
      result = me.menu = WidgetHelper.createWidget(
        Object.assign(
          {
            type: 'menu',
            autoShow: false,
            autoClose: true,
            scrollAction: 'realign',
            constrainTo: document.body,
            forElement: me.element,
            align: 't0-b0',
            owner: me,
            onHide() {
              // In case the reason for the hide is a mousedown
              // on this button, wait until after any impending
              // click handler to sync our state with the visibility.
              me.setTimeout(() => me.toggle(false), 300);
            }
          },
          result
        )
      );
    }

    return result;
  }

  set menu(menu) {
    this._menu = menu;

    // We are toggleable if there's a menu.
    // Pressed means menu visible, not pressed means menu hidden.
    this.toggleable = Boolean(menu);
  }

  /**
   * Get/set button pressed state
   * @property {Boolean}
   */
  set pressed(pressed) {
    const me = this;

    if (pressed && me.toggleGroup) {
      DomHelper.forEachSelector(`button[data-group=${me.toggleGroup}]`, (btnEl) => {
        if (btnEl !== me.element) {
          WidgetHelper.getById(btnEl.id).toggle(false);
        }
      });
    }

    me._pressed = pressed;

    if (me.element) me.element.classList[pressed ? 'add' : 'remove']('b-pressed');
  }

  get pressed() {
    return this._pressed;
  }

  /**
   * Get/set the Button icon
   * @property {String}
   */
  set icon(icon) {
    this._icon = icon;
    this.syncIconCls();
  }

  get icon() {
    return this._icon;
  }

  /**
   * Get/set the Button pressed icon
   * @property {String}
   */
  set pressedIcon(icon) {
    this._pressedIcon = icon;
    this.syncIconCls();
  }

  get pressedIcon() {
    return this._pressedIcon;
  }

  /**
   * Get/Set the Button icon alignment.
   * May be `'start'` or `'end'`. Defaults to `'start'`
   * @property {String}
   */

  set iconAlign(iconAlign) {
    const me = this,
      oldAlign = me._iconAlign;

    if (iconAlign !== oldAlign) {
      if (oldAlign) {
        me.element.classList.remove(`b-icon-align-${oldAlign}`);
      }
      me.element.classList.add(`b-icon-align-${iconAlign}`);
      me._iconAlign = iconAlign;
    }
  }

  get iconAlign() {
    return this._iconAlign;
  }

  //endregion

  //region Events

  /**
   * Triggers events when user clicks button
   * @fires click
   * @fires action
   * @private
   */
  onInternalClick(event) {
    const me = this,
      bEvent = { event };

    if (me.toggleable) {
      // Clicking the pressed button in a toggle group should do nothing
      if (me.toggleGroup && me.pressed) {
        return;
      }

      me.toggle(!me.pressed);
    }

    /**
     * User clicked button
     * @event click
     * @property {Common.widget.Button} button - Clicked button
     * @property {Event} event - DOM event
     */
    me.trigger('click', bEvent);

    /**
     * User performed the default action (clicked the button)
     * @event action
     * @property {Common.widget.Button} button - Clicked button
     * @property {Event} event - DOM event
     */
    // A handler may have resulted in destruction.
    if (!me.isDestroyed) {
      me.trigger('action', bEvent);
    }

    // since Widget has Events mixed in configured with 'callOnFunctions' this will also call onClick and onAction

    // stop the event since it has been handled
    event.preventDefault();
    event.stopPropagation();
  }

  //endregion

  //region Toggle

  /**
   * Toggle button state (only use with toggleable = true)
   * @param {Boolean} pressed Specify to force a certain toggle state
   * @fires toggle
   */
  toggle(pressed = null) {
    const me = this,
      { menu } = me;

    if (!me.toggleable) {
      return;
    }

    if (pressed === null) {
      pressed = !me.pressed;
    }

    me.pressed = pressed;

    // For handlers from the code below to detect and avoid recursion
    me.toggling = true;

    if (menu) {
      menu.minWidth = me.width;
      menu[pressed ? 'show' : 'hide']();
    }

    me.syncIconCls();

    /**
     * Button state was toggled
     * @event toggle
     * @property {Common.widget.Button} button - Button
     * @property {Boolean} pressed - New pressed state
     */
    me.trigger('toggle', { pressed });

    me.toggling = false;
  }

  //endregion

  //region Other

  syncIconCls() {
    const me = this;
    let iconEl = me._iconEl;

    if (me.icon) {
      if (!iconEl) {
        iconEl = me._iconEl = DomHelper.createElement({
          tag: 'i',
          nextSibling: me.element.firstChild
        });
      }

      const iconCls = me.pressed && me.pressedIcon ? me.pressedIcon : me.icon;
      me._iconEl.className = iconCls;

      // if it's a supplied icon class b-fa-xxx or b-icon-xxx, add extra class
      // so user doesn't have to; they can just specify the icon
      if (bIcon$1.test(iconCls)) {
        iconEl.classList.add('b-icon');
      } else if (bFa$1.test(iconCls)) {
        iconEl.classList.add('b-fa');
      }
    } else {
      iconEl && iconEl.remove();
    }
  }

  //endregion
}

Button._$name = 'Button';
BryntumWidgetAdapterRegister.register('button', Button);

/**
 * @module Common/widget/ButtonGroup
 */

/**
 * A specialized container that holds buttons, displaying them in a horizontal group with borders adjusted to make them
 * stick together.
 *
 * Trying to add other widgets than buttons will throw an exception.
 *
 * ```javascript
 * new ButtonGroup({
 *   items : [
 *       { icon : 'b-fa b-fa-kiwi-bird' },
 *       { icon : 'b-fa b-fa-kiwi-otter' },
 *       { icon : 'b-fa b-fa-kiwi-rabbit' },
 *       ...
 *   ]
 * });
 * ```
 *
 * @externalexample widget/ButtonGroup.js
 * @classType buttonGroup
 * @extends Common/widget/Container
 */
class ButtonGroup extends Container {
  static get defaultConfig() {
    return {
      defaultType: 'button',

      /**
       * Custom CSS class to add to element. When using raised buttons (cls 'b-raised' on the buttons), the group
       * will look nicer if you also set that cls on the group.
       *
       * ```
       * new ButtonGroup({
       *   cls : 'b-raised,
       *   items : [
       *       { icon : 'b-fa b-fa-unicorn', cls : 'b-raised' },
       *       ...
       *   ]
       * });
       * ```
       *
       * @config {String}
       * @category CSS
       */
      cls: null,

      /**
       * An array of Buttons or typed Button config objects.
       * @config {Object[]|Common.widget.Button[]}
       */
      items: null,

      /**
       * Default color to apply to all contained buttons, see {@link Common.widget.Button#config-color Button#color}.
       * Individual buttons can override the default.
       * @config {String}
       */
      color: null,

      /**
       * Set to `true` to turn the ButtonGroup into a toggle group, assigning a generated value to each contained
       * buttons {@link Common.widget.Button#config-toggleGroup toggleGroup config}. Individual buttons can
       * override the default.
       */
      toggleGroup: null
    };
  }

  createWidget(widget) {
    const me = this;

    if (me.color && !widget.color) {
      widget.color = me.color;
    }

    if (me.toggleGroup && !widget.toggleGroup) {
      if (typeof me.toggleGroup === 'boolean') {
        me.toggleGroup = IdHelper.generateId('toggleGroup');
      }

      widget.toggleGroup = me.toggleGroup;
    }

    const button = super.createWidget(widget);

    if (!(button instanceof Button)) {
      throw new Error('A ButtonGroup can only contain buttons');
    }

    return button;
  }
}

ButtonGroup._$name = 'ButtonGroup';
BryntumWidgetAdapterRegister.register('buttonGroup', ButtonGroup);

/**
 * @module Common/util/ClickRepeater
 */

/**
 * A helper class, which, when applied to an {@link #config-element} means that a mousedown
 * and hold on that element will, after a configured {@link #config-delay}, begin
 * autorepeating `click` events on that element, starting at a rate of
 * {@link #config-startRate} clicks per second, and over {@link #config-accelerateDuration}
 * milliseconds, accelerate to firing clicks at {@link #config-endRate} times per second.
 *
 * An example of this is used by the {@link Common.widget.NumberField NumberField}'s
 * spinner triggers.
 */
class ClickRepeater extends Delayable(Base) {
  static get defaultConfig() {
    return {
      /**
       * The element on which to fire autorepeating `click` events when the mouse is held down.
       * @config {HTMLElement}
       */
      element: null,

      /**
       * A query selector which specifies subtargets of this ClickRepeater's {@link #config-element}
       * which act as the click auto repeat event targets.
       * @config {String}
       * @default
       */
      delegate: null,

      /**
       * How long in milliSeconds to pause before starting the click repeats.
       * @config {Number}
       * @default
       */
      delay: 500,

      /**
       * Clicks per second to start firing after the initial {@link #config-delay}
       * @config {Number}
       * @default
       */
      startRate: 2,

      /**
       * Clicks per second to fire at top speed, after accelerating over the {@link #config-accelerateDuration}
       * @config {Number}
       * @default
       */
      endRate: 20,

      /**
       * How long in millieconds to accelerate from the
       * {@link #config-startRate} to the {@link #config-startRate}.
       * @config {Number}
       * @default
       */
      accelerateDuration: 4000
    };
  }

  doDestroy() {
    this.mousedownRemover && this.mousedownRemover();
    super.doDestroy();
  }

  set element(element) {
    this._element = element;

    this.mousedownRemover = EventHelper.on({
      element,
      mousedown: 'onMouseDown',
      thisObj: this
    });
  }

  get element() {
    return this._element;
  }

  onMouseDown(e) {
    const me = this,
      target = me.delegate ? e.target.closest(me.delegate) : me.element;

    if (target) {
      me.triggerEvent = e;
      EventHelper.lockComposedPath(me.triggerEvent);

      me.activeListenerRemover = EventHelper.on({
        mouseup: {
          element: document,
          handler: 'onMouseUp'
        },
        mousemove: {
          element: target,
          handler: 'onTargetMouseMove'
        },
        mouseleave: {
          element: target,
          handler: 'onTargetMouseLeave'
        },
        mouseenter: {
          element: target,
          handler: 'onTargetMouseEnter'
        },
        thisObj: me
      });

      me.setTimeout('startAutoRepeat', me.delay);
    }
  }

  onMouseUp(e) {
    const me = this;

    me.acceleration && me.acceleration.cancel();
    me.activeListenerRemover && me.activeListenerRemover();
    me.clearTimeout('startAutoRepeat');
    me.clearInterval(me.repeatTimer);
  }

  onTargetMouseLeave() {
    this.clearInterval(this.repeatTimer);
  }

  onTargetMouseEnter(e) {
    this.triggerEvent = e;
    this.fireClick();
  }

  onTargetMouseMove(e) {
    this.triggerEvent = e;
  }

  startAutoRepeat() {
    const me = this;

    me.interval = me.startInterval = 1000 / me.startRate;
    me.accelerationDelta = me.startInterval - 1000 / me.endRate;

    // Begin animating the interval from 1000/me.startRate to 1000/me.endRate
    me.fireClick();
    me.acceleration = FunctionHelper.animate(me.accelerateDuration, me.nextTick, me, 'easeOutQuad');
  }

  nextTick(progress) {
    this.interval = this.startInterval - this.accelerationDelta * progress;
  }

  fireClick() {
    const me = this,
      clickEvent = new MouseEvent('click', me.triggerEvent);

    me.triggerEvent.target.dispatchEvent(clickEvent);
    me.repeatTimer = me.setTimeout(me.fireClick, me.interval);
  }
}
ClickRepeater._$name = 'ClickRepeater';

/**
 * @module Common/widget/Field
 */

const byWeight$1 = (l, r) => (l.weight || 0) - (r.weight || 0),
  byWeightReverse$1 = (l, r) => (r.weight || 0) - (l.weight || 0),
  arrayOption = { array: true };

/**
 * Base class for TextField and NumberField. Not to be used directly.
 * @extends Common/widget/Widget
 * @mixes Common/widget/mixin/Badge
 * @abstract
 */
class Field extends Badge(Widget) {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Text to display in empty field.
       * @config {String}
       */
      placeholder: '',

      /**
       * Default value
       * @config {String}
       */
      value: '',

      /**
       * Label, prepended to field
       * @config {String}
       */
      label: null,

      /**
       * Configure as `true` to indicate that a `null` field value is to be marked as invalid.
       * @config {Boolean}
       * @default false
       */
      required: null,

      /**
       * Show a trigger to clear field, and allow `ESC` key to clear field if this field is
       * not {@link #config-readOnly}. The trigger is available in the {@link #property-triggers} object
       * under the name `clear`.
       * @config {Boolean}
       * @default false
       */
      clearable: null,

      /**
       * The width to apply to the `<label>` element. If a number is specified, `px` will be used.
       * @config {String|Number}
       */
      labelWidth: null,

      /**
       * The width to apply to the `<input>` element. If a number is specified, `px` will be used.
       * @config {String|Number}
       */
      inputWidth: null,

      /**
       * The delay in milliseconds to wait after the last keystroke before triggering a change event.
       * Set to 0 to not trigger change events from keystrokes (listen for input event instead to have
       * immediate feedback, change will still be triggered on blur)
       * @config {Number}
       * @default
       */
      keyStrokeChangeDelay: 0,

      /**
       * Makes the field unmodifiable by user action. The input area is not editable.
       * @config {Boolean}
       */
      readOnly: null,

      /**
       * Set to false to prevent user from editing the field. For TextFields it is basically the same as setting
       * {@link #config-readOnly}, but for PickerFields there is a distinction where it allows you to pick a value but not to type
       * one in the field.
       * @config {Boolean}
       * @default true
       */
      editable: true,

      defaultAction: 'change',

      /**
       * The triggers to add either before or after the input field. Each property name is the reference by which an
       * instantiated Trigger Widget may be retrieved from the live `{@link #property-triggers}` property.
       * Each trigger may have the following properties:
       * * `cls` The CSS class to apply.
       * * `handler` A method in the field to call upon click
       * * `align` `'start'` or `'end'` which end of the field the trigger should go.
       * * `weight` (Optional) Heigher weighted triggers gravitate towards the input field.
       * @config {Object}
       */
      triggers: null,

      /**
       * Specify `false` to prevent field from being highlighted when on external value changes
       * @config {Boolean}
       */
      highlightExternalChange: true,

      localizableProperties: ['label', 'title'],

      autoSelect: false,

      /**
       * Sets the native `autocomplete` property of the underlying input element. For more information, please refer to
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete)
       * @config {String}
       * @default
       */
      autoComplete: 'off'
    };
  }

  /**
   * A singleton error tooltip which activates on hover of invalid fields.
   * before show, it gets a reference to the field and interrogates its
   * active error list to display as the tip content.
   * @member {Common.widget.Tooltip}
   * @readonly
   */
  get errorTip() {
    return this.constructor.errorTip;
  }

  /**
   * A singleton error tooltip which activates on hover of invalid fields.
   * before show, it gets a reference to the field and interrogates its
   * active error list to display as the tip content.
   * @member {Common.widget.Tooltip}
   * @readonly
   * @static
   */
  static get errorTip() {
    // TODO Check errorTip html for IE11 (#7878)
    if (BrowserHelper.isIE11 && Field._errorTip && Field._errorTip.html === '') {
      Field._errorTip.destroy();
      Field._errorTip = null;
    }

    return (
      Field._errorTip ||
      (Field._errorTip = new Tooltip({
        cls: 'b-field-error-tip',
        forSelector: '.b-field.b-invalid .b-field-inner',
        align: 'l-r',
        scrollAction: 'realign',
        onBeforeShow() {
          const tip = this,
            field = IdHelper.fromElement(tip.activeTarget);

          if (field) {
            const errors = field.getErrors();

            if (errors) {
              tip.html = errors.join('<br>');
              tip.field = field;
              return true;
            }
          }

          // Veto show
          return false;
        }
      }))
    );
  }

  //endregion

  //region Event
  /**
   * User typed into the field
   * @event input
   * @param {Common.widget.Field} source - The field
   * @param {String} value - Value
   */

  /**
   * Fired when the field value changes
   * @event change
   * @param {String} value - Value
   * @param {String} oldValue - Previous value
   * @param {Boolean} userAction - Triggered by user taking an action (`true`) or by setting a value (`false`)
   * @param {Common.widget.Field} source - Field
   */

  /**
   * User performed default action (typed into the field)
   * @event click
   * @param {Common.widget.Field} field - Field
   * @param {String} value - Value
   */

  /**
   * User clicked fields clear icon
   * @event clear
   * @param {Common.widget.Field} field - Field
   */

  /*
   * User clicked on one of the field's {@link #property-triggers}
   * @event trigger
   * @param {Common.widget.Field.Trigger} trigger The trigger activated by click or touch tap.
   * @param {Common.widget.Field} trigger.field The trigger's owning Field.
   */

  //endregion

  //region Init

  construct(config) {
    const me = this;

    me.highlightChanged = me.createOnFrame('addUpdatedCls');
    super.construct(config);

    if (me.keyStrokeChangeDelay) {
      me.changeOnKeyStroke = me.buffer(me.internalOnChange, me.keyStrokeChangeDelay);
    }
  }

  onFocusOut(e) {
    super.onFocusOut(e);

    // Check field consistency on blur
    this.onEditComplete();
  }

  /**
   * Template function which may be implemented by subclasses to synchronize
   * input state and validity state upon completion of the edit.
   * @internal
   */
  onEditComplete() {}

  set element(element) {
    const me = this,
      value = me.initialConfig.value,
      innerElements = DomHelper.createElementFromTemplate(me.inputTemplate(me), arrayOption),
      children = [
        {
          className: 'b-field-inner',
          reference: 'inputWrap',
          children: innerElements
        }
      ],
      startTriggers = [],
      endTriggers = [];

    if (me.label) {
      children.unshift({
        tag: 'label',
        reference: 'labelElement',
        htmlFor: `${me.id}_input`,
        html: me.label
      });
    }

    // Read the clearable config which will force evaluation of triggers
    // to include clearable trigger.
    me._thisIsAUsedExpression(me.clearable);

    for (const triggerRef in me.triggers) {
      const trigger = me.triggers[triggerRef];

      if (trigger.align === 'start') {
        startTriggers.unshift(trigger);
      } else {
        endTriggers.push(trigger);
      }
    }

    // The triggers at each end are sorted "gavitationally".
    // Higher weight sorts towards the center which is the input element.
    startTriggers.sort(byWeight$1);
    endTriggers.sort(byWeightReverse$1);
    innerElements.unshift(...startTriggers.map((t) => t.element));
    innerElements.push(...endTriggers.map((t) => t.element));

    super.element = {
      className: me.label ? 'b-has-label' : '',
      children
    };

    // Value must be injected into the input element after it has been constructed, not in the
    // initial template, otherwise the caret position will not be as expected.
    if (value != null) {
      me.value = value;
    }

    me.updateEmpty();
    me.updateInvalid();
  }

  get element() {
    return super.element;
  }

  //endregion

  //region Focus & select

  get focusElement() {
    return this.input;
  }

  /**
   * Selects the field contents. Optionally may be passed a start and end.
   * NOTE: This method is async for IE11
   * @param {Number} [start] The start index from which to select the input.
   * @param {Number} [end] The index at which to end the selection of the input.
   */
  select(start, end) {
    // Use focusElement which is the input field in this class
    // but allows subclasses to use other elements.
    // See, for example, TextAreaField
    const input = this.focusElement;

    if (input.value.length) {
      if (arguments.length === 0) {
        this.selectAll();
        return;
      }

      // Only allowed to select range in certain element / input types
      if (!this.supportsTextSelection) {
        return;
        // throw new Error('Trying to select text on an invalid element type');
      }

      if (BrowserHelper.isIE11) {
        // this.clearTimeout(this.selectTimeout);

        // HACK: IE focus processing is async and we can't select text until field is focused
        // Getting flaky exception in IE, something timing related. Found no way to detect it so using this
        // workaround for now
        input.focus();
        input.setSelectionRange(start, end);
        //
        // this.selectTimeout = this.setTimeout(() => {
        //     input && input.setSelectionRange(start, end);
        // }, 10);
      } else {
        input.setSelectionRange(start, end);
      }
    }
  }

  moveCaretToEnd() {
    const input = this.input;

    if (input.createTextRange) {
      const range = input.createTextRange();
      range.collapse(false);
      range.select();
    } else if (this.supportsTextSelection) {
      // Move caret to the end if possible
      this.select(input.value.length, input.value.length);
    }
  }

  selectAll() {
    this.focusElement.select();
  }

  // called on value changes to update styling of empty vs non-empty field
  updateEmpty() {
    const { isEmptyInput, isEmpty, element, clearIcon } = this,
      empty = isEmptyInput && isEmpty;

    if (element) {
      if (clearIcon) {
        // IE11...
        clearIcon.classList[empty ? 'add' : 'remove']('b-icon-hidden');
      }

      // IE11...
      element.classList[empty ? 'add' : 'remove']('b-empty');
    }
  }

  updateInvalid() {
    const { isValid, element, errorTip, inputWrap } = this;

    if (element) {
      element.classList[isValid ? 'remove' : 'add']('b-invalid');

      // We achieved validity, so ensure the error tip is hidden
      if (isValid) {
        if (errorTip.isVisible && errorTip.field === this) {
          errorTip.hide();
        }
      }

      // If the mouse is over, the tip should spring into view
      else if (inputWrap.contains(Tooltip.currentOverElement)) {
        // Already shown by this field's inputWrap, just update content.
        if (errorTip.activeTarget === inputWrap && errorTip.isVisible) {
          errorTip.onBeforeShow();
        } else {
          errorTip.activeTarget = inputWrap;
          errorTip.showBy(inputWrap);
        }
      }
    }
  }

  //endregion

  //region Getters/setters

  get editable() {
    return this._editable && !this.readOnly;
  }

  set editable(editable) {
    const me = this,
      input = me.input;

    me._editable = editable;

    if (input) {
      if (!me.readOnly) {
        input.readOnly = editable === false ? 'readOnly' : null;
      }

      if (editable !== false) {
        me.inputListenerRemover = EventHelper.on({
          element: input,
          thisObj: me,
          focus: 'internalOnInputFocus',
          change: 'internalOnChange',
          input: 'internalOnInput',
          keydown: 'internalOnKeyPress',
          keypress: 'internalOnKeyPress',
          keyup: 'internalOnKeyPress'
        });
      } else {
        me.inputListenerRemover && me.inputListenerRemover();
      }
    }
  }

  set clearable(clearable) {
    this._clearable = clearable;
    if (clearable && !this.triggers) {
      this.triggers = {};
    }
  }

  get clearable() {
    return this._clearable;
  }

  /**
   * The trigger Widgets as specified by the {@link #config-triggers} configuration and the {@link #config-clearable} configuration.
   * Each is a {@link Common.widget.Widget Widget} instance which may be hidden, shown and observed and styled just like any other widget.
   * @property {Object}
   */
  set triggers(triggers) {
    const me = this,
      myTriggers = (me._triggers = {});

    if (me.clearable) {
      (triggers || (triggers = {})).clear = {
        cls: 'b-icon-remove',
        handler() {
          me._isUserAction = true;
          me.clear();
          me._isUserAction = false;
        },
        weight: 1000
      };
    }

    for (const triggerRef in triggers) {
      myTriggers[triggerRef] = WidgetHelper.createWidget(
        ObjectHelper.assign(
          {
            type: 'trigger',
            reference: triggerRef,
            parent: me
          },
          triggers[triggerRef]
        ),
        me.defaultTriggerType || 'trigger'
      );
    }
  }

  get triggers() {
    return this._triggers;
  }

  set labelWidth(labelWidth) {
    if (this.labelElement) {
      this.labelElement.style.flex = `0 0 ${DomHelper.setLength(labelWidth)}`;

      // If there's a label width, the input must conform with it, and not try to expand to 100%
      this.inputWrap.style.flexBasis = labelWidth == null ? '' : 0;
    }
  }

  /**
   * Get/set fields label. Please note that the Field needs to have a label specified from start for this to work,
   * otherwise no element is created.
   * @property {String}
   */
  get label() {
    return this._label;
  }

  set label(label) {
    if (label === null || label === undefined) label = '';
    this._label = label;
    // since value is used in template it is not certain that element is available
    // TODO: move the code from template here instead
    if (this.labelElement) {
      // using innerHTML since we sometimes use icons as label
      this.labelElement.innerHTML = label;
    }
  }

  /**
   * Get/set read only
   * @property {Boolean}
   */
  get readOnly() {
    // Fields which are disabled cannot be updated.
    // This ensures ESC and clear click won't be able to clear disabled fields.
    return this._readOnly || this.disabled;
  }

  set readOnly(readOnly) {
    this._readOnly = readOnly;

    this.element.classList[readOnly ? 'add' : 'remove']('b-readonly');
    if (readOnly) {
      this.input.setAttribute('readonly', '');
    } else {
      this.input.removeAttribute('readonly');
    }
  }

  /**
   * Returns true if the field value is valid
   * @type {Boolean}
   * @readonly
   */
  get isValid() {
    if (this.errors && ObjectHelper.getTruthyValues(this.errors).length) {
      return false;
    }
    if (this.input && this.input.validity) {
      return this.input.validity.valid;
    }

    return true;
  }

  /**
   * Returns true if the field value is empty
   * @type {boolean}
   * @readonly
   */
  get isEmpty() {
    return this.value == null || this.value === '';
  }

  /**
   * Returns true if the field's input is empty
   * @type {boolean}
   * @readonly
   */
  get isEmptyInput() {
    return !this.input || this.input.value == null || this.input.value === '';
  }

  /**
   * Gets or sets the value. The returned type will depend upon the Field subclass.
   *
   * `TextField` returns a `String`.
   *
   * `NumberField` returns a `Number`.
   *
   * `DateField` and `TimeField` return a `Date` object, and `null` if the field is empty.
   *
   * `Combo` will return a `String` if configured with `items` as a simple string array.
   * Otherwise it will return the {@link Common.widget.Combo#config-valueField} value from the
   * selected record, or `null` if no selection has been made.
   * @property {*}
   */
  get value() {
    return this._value;
  }

  set value(value) {
    const me = this,
      oldValue = me._value;

    if (me.hasChanged(oldValue, value)) {
      // lastValue is used for IE to check if a change event should be triggered when pressing ENTER
      if (!me.inputting) {
        me._lastValue = value;
      }

      me._value = value;

      if (me.required && (value == '' || value == null)) {
        me.setError('fieldRequired', true);
      } else {
        me.clearError('fieldRequired', true);
      }

      // Do not trigger change event during configuration phase
      // or during keyboard input
      if (!me.isConfiguring && !me.inputting) {
        // trigger change event, signaling that origin is from set operation,
        // makes it easier to ignore such events in applications that set value on load etc
        me.trigger('change', { value: me.value, oldValue, userAction: Boolean(me._isUserAction), valid: me.isValid });
      }

      me.syncInputFieldValue();
    }
  }

  /**
   * Compare's this field's value with its previous value. May be overridden in subclasses
   * which have more complex value types. See, for example, {@link Common.widget.DurationField}.
   * @param {*} oldValue
   * @param {*} newValue
   * @private
   */
  hasChanged(oldValue, newValue) {
    return newValue !== oldValue;
  }

  /**
   * Called by the base Field class's `set value` to sync the state of the UI with the field's value.
   *
   * Relies upon the class implementation of `get inputValue` to return a string representation of
   * the value for user consumption and editing.
   * @private
   */
  syncInputFieldValue() {
    const me = this,
      input = me.input;

    // If we are updating from internalOnInput, we must not update the input field
    if (input && !me.inputting) {
      // Subclasses may implement their own read only inputValue property.
      me.input.value = me.inputValue;

      // If it's being manipulated from the outside, highlight it
      if (!me.isConfiguring && !me.containsFocus && me.highlightExternalChange) {
        input.classList.remove('b-field-updated');
        me.clearTimeout('removeUpdatedCls');
        me.highlightChanged();
      }
    }
    me.updateEmpty();
    me.updateInvalid();
  }

  addUpdatedCls() {
    this.input.classList.add('b-field-updated');
    this.setTimeout('removeUpdatedCls', 1500);
  }

  removeUpdatedCls() {
    this.input.classList.remove('b-field-updated');
  }

  /**
   * A String representation of the value of this field for {@link #function-syncInputFieldValue} to use
   * as the input element's value.
   *
   * Subclasses may override this to create string representations.
   *
   * For example, {@link Common.widget.DateField}'s implementation will format the field date
   * value according to its configured {@link Common.widget.DateField#config-format}. And {@link Common.widget.Combo}'s
   * implementation will return the {@link Common.widget.Combo#config-displayField} of the selected record.
   * @internal
   * @readOnly
   */
  get inputValue() {
    // Do not use the _value property. If called during configuration, this
    // will import the configured value from the config object.
    return this.value == null ? '' : this.value;
  }

  get supportsTextSelection() {
    const input = this.focusElement;

    // Text selection using setSelectionRange is allowed in Chrome for certain elements. Edge supports it even for input[type=number]
    return (
      input &&
      (input.tagName.toLowerCase() === 'textarea' ||
        (input.type && (/text|search|password|tel|url/.test(input.type) || BrowserHelper.isEdge)))
    );
  }

  //endregion

  //region Events

  internalOnInputFocus() {
    const length = this.input.value.length;

    // Help IE to set caret at the end like the other browsers
    if (BrowserHelper.isIE11 && length && !this.autoSelect) {
      this.select(length, length);
    }
  }

  /**
   * Trigger event when fields input changes
   * @fires change
   * @private
   */
  internalOnChange(event) {
    const me = this,
      value = me.value,
      oldValue = me._lastValue;

    // Don't trigger change if we enter invalid value or if value has not changed (for IE when pressing ENTER)
    if (me.isValid && value !== oldValue) {
      me._lastValue = value;

      // trigger change event, signaling that origin is from user
      me.trigger('change', { value, oldValue, event, userAction: true });

      // per default Field triggers action event on change, but might be reconfigured in subclasses (such as Combo)
      if (me.defaultAction === 'change') {
        me.trigger('action', { value, oldValue, event });
      }
    }

    // since Widget has Events mixed in configured with 'callOnFunctions' this will also call onClick and onAction
  }

  /**
   * Trigger event when user inputs into field
   * @fires input
   * @param event
   * @private
   */
  internalOnInput(event) {
    const me = this;

    // Keep the value synced with the inputValue at all times.
    me.inputting = true;
    me.value = me.input.value;
    me.inputting = false;

    me.trigger('input', { value: me.value, event });

    me.changeOnKeyStroke && me.changeOnKeyStroke(event);

    // since Widget has Events mixed in configured with 'callOnFunctions' this will also call onInput
  }

  internalOnKeyPress(event) {
    const me = this;

    if (event.type === 'keydown') {
      if (event.key === 'Escape' && !me.readOnly && me.clearable) {
        me.clear();

        // don't allow further processing of this event if it had destructive consequences
        if (me.isDestroyed) {
          event.stopImmediatePropagation();
          return;
        }
      }
      // #5730 - IE11 doesn't trigger "change" event by Enter click
      else if (event.key === 'Enter' && BrowserHelper.isIE11) {
        this.internalOnChange(event);
      }
    }

    me.trigger(event.type, { event });
  }

  clear() {
    this.value = null;

    this.trigger('clear');
  }

  //endregion

  //region Error

  /**
   * Adds an error message to the list of errors on this field.
   * By default the field's valid/invalid state is updated; pass
   * `false` as the second parameter to disable that if multiple
   * changes are being made to the error state.
   * @param {String} error A locale string, or message to use as an error message.
   * @param {Boolean} [silent=false] Pass as `true` to skip updating the field's valid/invalid state.
   */
  setError(error, silent) {
    (this.errors || (this.errors = {}))[error] = this.L(error);

    if (!silent) {
      this.updateInvalid();
    }
  }

  /**
   * Removes an error message from the list of errors on this field.
   * By default the field's valid/invalid state is updated; pass
   * `false` as the second parameter to disable that if multiple
   * changes are being made to the error state.
   * @param {String} error A locale string, or message to remove.
   * @param {Boolean} [silent=false] Pass as `true` to skip updating the field's valid/invalid state.
   */
  clearError(error, silent) {
    if (this.errors) {
      delete this.errors[error];
    }
    if (!silent) {
      this.updateInvalid();
    }
  }

  /**
   * Returns an array of error messages as set by {@link #function-setError}, or
   * `undefined` if there are currently no errors.
   * @return {String[]} The errors for this field, or `undefined` if there are no errors.
   */
  getErrors() {
    if (!this.isValid) {
      const errors = this.errors
        ? ObjectHelper.getTruthyValues(this.errors)
        : [this.input.validationMessage || this.L('invalidValue')];

      if (errors && errors.length) {
        return errors;
      }
    }
  }

  //endregion
}

/**
 * Base class for field triggers May be configured with a `cls` and a `handler` which is a function (or name of a function)
 * in the owning Field.
 * @extends Common/widget/Widget
 */
Field.Trigger = class FieldTrigger extends Widget {
  static get defaultConfig() {
    return {
      align: null
    };
  }

  template() {
    return `<div class="b-icon b-align-${this.align || 'end'}"></div>`;
  }

  construct(config) {
    super.construct(config);

    EventHelper.on({
      element: this.element,
      click: {
        handler: 'onClick',
        thisObj: this
      },
      mousedown: {
        handler: 'onMousedown',
        thisObj: this
      }
    });
  }

  onClick(e) {
    const me = this,
      field = me.field,
      handler = typeof me.handler === 'function' ? me.handler : field[me.handler];

    if (field.disabled || field.readOnly) {
      return;
    }

    if (
      handler &&
      field.trigger('trigger', {
        trigger: me
      }) !== false
    ) {
      handler.call(field, e);
    }
  }

  onMousedown(e) {
    const field = this.field,
      isKeyEvent = 'key' in e;

    // If it's a touch tap on the trigger of an editable, then
    // avoid the keyboard by setting the field to not be editable
    // before focusing the field. Reset to be editable after focusing
    // has happened. Keyboard will not appear.
    if (!isKeyEvent && DomHelper.isTouchEvent) {
      if (field.editable) {
        field.editable = false;
        field.setTimeout(() => (field.editable = true), 500);
      }
    }

    e.preventDefault();
    if (document.activeElement !== field.input) {
      field.focus();
    }
  }

  get field() {
    return this.parent;
  }
};

Field.SpinTrigger = class SpinTrigger extends Field.Trigger {
  static get defaultConfig() {
    return {
      repeat: true
    };
  }

  template() {
    return `<div class="b-icon b-align-${this.align || 'end'}">
                    <div reference="upButton" class="b-icon b-spin-up"></div>
                    <div reference="downButton" class="b-icon b-spin-down"></div>
                </div>`;
  }

  set repeat(repeat) {
    const me = this;

    if (repeat) {
      me.clickRepeater = new ClickRepeater(
        Object.assign(
          {
            element: me.element
          },
          repeat
        )
      );
    } else if (me.clickrepeater) {
      me.clickRepeater.destroy();
      me.clickrepeater = null;
    }
  }

  onClick(e) {
    const me = this,
      field = me.field;

    if (field.disabled) {
      return;
    }

    if (e.target === me.upButton) {
      field.doSpinUp();
    } else if (e.target === me.downButton) {
      field.doSpinDown();
    }
  }
};

// Those two classes are defined in a very unusual manner, have to specify names directly
Field.Trigger._$name = 'FieldTrigger';
Field.SpinTrigger._$name = 'SpinTrigger';

Field._$name = 'Field';
BryntumWidgetAdapterRegister.register('trigger', Field.Trigger);
BryntumWidgetAdapterRegister.register('spintrigger', Field.SpinTrigger);

/**
 * @module Common/widget/Checkbox
 */

/**
 * Checkbox field, wraps <code>&lt;input type="checkbox"&gt;</code>.
 * Color can be specified and you can optionally configure {@link #config-text}
 * to display in a label to the right of the checkbox in addition to a standard
 * field {@link #config-label}.
 *
 * @extends Common/widget/Field
 *
 * @example
 * // checkbox with a label and a handler
 * let checkbox = new Checkbox({
 *   text: 'Check me, please',
 *   onAction: () => {}
 * });
 *
 * @classType checkbox
 * @externalexample widget/Checkbox.js
 */
class Checkbox extends Field {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Text to display on checkbox label
       * @config {String}
       */
      text: '',

      /**
       * Checkbox color, must have match in css
       * @config {String}
       */
      color: null,

      /**
       * Sets input fields value attribute
       * @config {String}
       */
      value: '',

      defaultBindProperty: 'value'
    };
  }

  //endregion

  //region Init

  construct(config) {
    super.construct(config);

    const me = this;

    if (me.initialConfig.readOnly) me.readOnly = true;
  }

  inputTemplate() {
    const me = this;

    return TemplateHelper.tpl`
            <input type="checkbox" id="${me.id}_input" reference="input"/>
            <label class="b-checkbox-label" for="${me.id}_input" reference="textLabel">${me.text || ''}</label>
        `;
  }

  set element(element) {
    const me = this;

    super.element = element;

    if (me.color) {
      me.element.classList.add(me.color);
    }
    if (me.text) {
      me.element.classList.add('b-text');
    }
  }

  get element() {
    return super.element;
  }
  //endregion

  //region Toggle

  /**
   * Get/set label
   * @property {String}
   */
  get text() {
    return this._text;
  }

  set text(value) {
    this._text = value;
    if (this.textLabel) {
      this.textLabel.innerHTML = value;
    }
  }

  /**
   * Get/set value
   * @property {String}
   */
  get value() {
    return this.input.value;
  }

  set value(value) {
    this.input.value = value;
  }

  /**
   * Get/set checked state
   * @property {Boolean}
   */
  get checked() {
    return this.input.checked;
  }

  set checked(checked) {
    checked = Boolean(checked);

    // Only do action if change needed.
    if (this.input.checked !== checked) {
      this.input.checked = checked;

      // The change event does not fire on programmatic change of input.
      if (!this.isConfiguring) {
        this.triggerChange(false);
      }
    }
  }

  /**
   * Get/set readonly state (disabled underlying input)
   * @property {Boolean}
   */
  get readOnly() {
    return this._readOnly;
  }

  set readOnly(readOnly) {
    this._readOnly = readOnly;
    this.element.classList[readOnly ? 'add' : 'remove']('b-readonly');
    this.input.disabled = readOnly;
  }

  /**
   * Check the box
   */
  check() {
    this.checked = true;
  }

  /**
   * Uncheck the box
   */
  uncheck() {
    this.checked = false;
  }

  /**
   * Toggle checked state. If you want to force a certain state, assign to {@link #property-checked} instead.
   */
  toggle() {
    this.checked = !this.checked;
  }

  //endregion

  //region Events

  /**
   * Triggers events when user toggles the checkbox
   * @fires beforeChange
   * @fires change
   * @fires action
   * @private
   */
  internalOnChange(event) {
    /**
     * Fired before checkbox is toggled. Returning false from a listener prevents the checkbox from being toggled.
     * @event beforeChange
     * @preventable
     * @param {Common.widget.Checkbox} source Checkbox
     * @param {Boolean} checked Checked or not
     */

    /**
     * Fired when checkbox is toggled
     * @event change
     * @param {Common.widget.Checkbox} source Checkbox
     * @param {Boolean} checked Checked or not
     */

    this.triggerChange(true);
  }

  /**
   * Triggers events when checked state is changed
   * @fires beforeChange
   * @fires change
   * @fires action
   * @private
   */
  triggerChange(userAction) {
    const me = this;

    // Since Widget has Events mixed in configured with 'callOnFunctions' this will also call onBeforeChange, onChange and onAction
    const prevented = !me.callPreventable(
      'change',
      {
        checked: me.input.checked,
        userAction
      },
      (eventObject) => {
        /**
         * User performed the default action (toggled the checkbox)
         * @event action
         * @param {Common.widget.Checkbox} source Checkbox
         * @param {Boolean} checked Checked or not
         */
        me.trigger('action', eventObject);

        return true;
      }
    );

    // If prevented need to rollback the checkbox input
    if (prevented) {
      // Input change is not preventable, so need to revert the changes
      // The change event does not fire on programmatic change of input, so no need to suspend
      me.input.checked = !me.input.checked;
    }
  }

  //endregion
}

Checkbox._$name = 'Checkbox';
BryntumWidgetAdapterRegister.register('checkbox', Checkbox);
BryntumWidgetAdapterRegister.register('check', Checkbox);

/**
 * @module Common/mixin/InstancePlugin
 */

/**
 * Base class for plugins. Published functions will be available from the other class. `this` in published functions is
 * referenced to the plugin, access the other class using `this.pluggedInto`.
 *
 * Observe that plugin doesn't apply itself on class level but instead on instance level. Plugin is its own instance
 * that can have own functions and data that is not exposed to target class.
 *
 * Functions can be published in four ways:
 *
 * * `assign` (when function is not already available on target)
 * * `before` (when function is already available on target, will be called before original function)
 * * `after` (when function is already available on target, will be called after original function)
 * * `override` (replaces function on target, but old function can be reached)
 *
 * To configure which functions get published and in what way, specify `pluginConfig` getter on plugin:
 *
 * ```
 * class Sort extends InstancePlugin {
 *   static get pluginConfig {
 *      return {
 *          before   : ['init'],
 *          after    : ['destroy', 'onElementClick'],
 *          override : ['render']
 *      };
 *   }
 * }
 * ```
 *
 * @mixes Common/localization/Localizable
 * @mixes Common/mixin/Events
 */
class InstancePlugin extends Localizable(Events(Base)) {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * The plugin disabled state
       * @config {Boolean}
       * @default
       */
      disabled: false
    };
  }

  //endregion

  //region Init

  /**
   * Call from another instance to add plugins to it.
   * @example
   * InstancePlugin.initPlugins(this, Search, Stripe);
   * @param plugInto Instance to mix into (usually this)
   * @param plugins Classes to plug in
   * @internal
   */
  static initPlugins(plugInto, ...plugins) {
    let property = plugInto.plugins || (plugInto.plugins = {});

    for (let PluginClass of plugins) {
      property[PluginClass.$name] = new PluginClass(plugInto);
    }
  }

  /**
   * Initializes the plugin.
   * @internal
   * @param plugInto Target instance to plug into
   * @function constructor
   */
  construct(plugInto, config) {
    /**
     * The Widget which was passed into the constructor,
     * which is the Widget we are providing extra services for.
     * @property {Common.widget.Widget}
     * @readonly
     */
    this.client = plugInto;

    super.construct(config);

    this.applyPluginConfig(plugInto);
  }

  /**
   * Applies config as found in plugInto.pluginConfig, or published all if no config found.
   * @private
   * @param plugInto Target instance to plug into
   */
  applyPluginConfig(plugInto) {
    let me = this,
      config = me.pluginConfig || me.constructor.pluginConfig,
      assign = config && config.assign,
      chain = config && (config.chain || config.after),
      before = config && config.before,
      override = config && config.override;

    me.pluggedInto = plugInto;

    // fill unpublished[] with all fnNames not in chain or override

    // apply chains and overrides.
    if (assign) me.applyAssign(plugInto, assign);
    if (chain) me.applyChain(plugInto, chain);
    if (before) me.applyChain(plugInto, before, false);
    if (override) me.applyOverride(plugInto, override);
  }

  /**
   * Applies assigning for specified functions.
   * @private
   * @param plugInto
   * @param fnNames
   */
  applyAssign(plugInto, fnNames) {
    fnNames.forEach((fnName) => this.assign(plugInto, fnName));
  }

  /**
   * Applys chaining for specified functions.
   * @private
   * @param plugInto
   * @param fnNames
   * @param after
   */
  applyChain(plugInto, fnNames, after = true) {
    const me = this;
    fnNames.forEach((fnName) => {
      if (plugInto[fnName]) {
        me.chain(plugInto, fnName, after);
      } else {
        me.assign(plugInto, fnName);
      }
    });
  }

  /**
   * Applies override for specified functions.
   * @private
   * @param plugInto
   * @param fnNames
   */
  applyOverride(plugInto, fnNames) {
    const me = this;

    if (!me.overridden) me.overridden = {};

    fnNames.forEach((fnName) => {
      if (!me[fnName]) {
        throw new Error(
          this.L('overrideFnMissing', {
            plugIntoName: plugInto.$name,
            pluginName: me.$name,
            fnName: fnName
          })
        );
      }
      // override
      if (typeof plugInto[fnName] === 'function') me.overridden[fnName] = plugInto[fnName].bind(plugInto);

      plugInto[fnName] = me[fnName].bind(me);
    });
  }

  /**
   * Assigns specified functions.
   * @private
   * @param plugInto
   * @param fnName
   */
  assign(plugInto, fnName) {
    let me = this,
      property = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(me), fnName);

    if (property && (property.get || property.set)) {
      // getter/setter, define corresponding property on target
      Object.defineProperty(plugInto, fnName, {
        configurable: true,
        enumerable: true,
        get: property.get && property.get.bind(me),
        set: property.set && property.set.bind(me)
      });
    } else {
      plugInto[fnName] = me[fnName].bind(me);
    }
  }

  //endregion

  //region Chaining

  /**
   * Chains functions. When the function is called on the target class all functions in the chain will be called in
   * the order they where added.
   * @private
   * @param plugInto
   * @param key
   */
  chain(plugInto, key, after = true) {
    let me = this,
      chain = plugInto.pluginFunctionChain || (plugInto.pluginFunctionChain = {});

    // duplicate function, make chain and use function to run all functions in it upon call...
    if (!chain[key]) {
      chain[key] = [plugInto[key].bind(plugInto)];
    }

    if (!me[key]) {
      throw new Error(
        this.L('fnMissing', {
          plugIntoName: plugInto.$name,
          pluginName: me.$name,
          fnName: key
        })
      );
      //throw new Error(`Trying to plug function ${plugInto.$name}#${key}, but InstancePlugin ${me.$name}#${key} does not exist`);
    }

    if (after) {
      chain[key].push(me[key].bind(me));
    } else {
      chain[key].unshift(me[key].bind(me));
    }

    // use function to run all functions in chain on call
    plugInto[key] = (...params) => me.functionChainRunner(key, ...params);
  }

  /**
   * Used to run multiple plugged in functions with the same name, see chain above. Returning false from a
   * function will abort chain.
   * @private
   * @param fnName
   * @param params
   * @returns value returned from last function in chain (or false if any returns false)
   */
  functionChainRunner(fnName, ...params) {
    const chain = this.pluggedInto.pluginFunctionChain[fnName];
    let returnValue;

    // changed from for..of to try and fix Edge problems
    for (let i = 0; i < chain.length; i++) {
      returnValue = chain[i](...params);
      if (returnValue === false) return false;
    }

    return returnValue;
  }

  //endregion

  /**
   * Get/set the plugin disabled state
   * @property {Boolean}
   */
  get disabled() {
    return this._disabled;
  }

  set disabled(disabled) {
    this._disabled = disabled;
  }
}
InstancePlugin._$name = 'InstancePlugin';

/**
 * @module Common/mixin/Pluggable
 */

/**
 * Enables using plugins for a class by specifing property plugins as an array of plugin classes. If only a single plugin
 * is used, just give the plugin class instead of an array. This class isn't required for using plugins, just makes it
 * easier. Without mixin you can otherwise use `InstancePlugin.initPlugins(this, PluginClass)`.
 *
 * @example
 * new Store({
 *   plugins: [PluginClass, ...]
 * });
 *
 * @mixin
 */
var Pluggable = (Target) =>
  class Pluggable extends (Target || Base) {
    /**
     * Specify plugins (an array of classes) in config
     * @config {Function[]} plugins
     * @category Misc
     */

    /**
     * Map of applied plugins
     * @property {Object}
     * @readonly
     * @category Misc
     */
    get plugins() {
      if (!this._plugins) {
        this._plugins = {};
      }
      return this._plugins;
    }

    set plugins(plugins) {
      if (plugins) {
        if (!Array.isArray(plugins)) plugins = [plugins];
        InstancePlugin.initPlugins(this, ...plugins);
      }
      this.initPlugins();
    }

    /**
     * Template method which may be implemented in subclasses to initialize any plugins.
     * This method is empty in the `Pluggable` base class.
     * @internal
     */
    initPlugins() {}

    /**
     * Adds plugins to an instance.
     * @param plugins Plugins to add
     */
    addPlugins(...plugins) {
      InstancePlugin.initPlugins(this, ...plugins);
    }

    /**
     * Checks if instance has plugin.
     * @param pluginClassOrName Plugin or name to check for
     * @returns {Boolean}
     */
    hasPlugin(pluginClassOrName) {
      return this.getPlugin(pluginClassOrName) != null;
    }

    /**
     * Get a plugin instance.
     * @param pluginClassOrName
     * @returns {Object}
     */
    getPlugin(pluginClassOrName) {
      if (typeof pluginClassOrName === 'function') pluginClassOrName = pluginClassOrName.$name;
      return this.plugins && this.plugins[pluginClassOrName];
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Common/mixin/State
 */

/**
 * Mixin that simplifies handling state for an ui component. Classes that uses this mixin must implement `getState()` and
 * `applyState(state)`.
 *
 * ```
 * class MyUIComponent extends State() {
 *   getState() {
 *     return {
 *       this.text,
 *       this.size
 *     }
 *   }
 *
 *   applyState(state) {
 *      this.text = state.text;
 *      this.size = state.size;
 *   }
 * }
 * ```
 *
 * @demo state
 *
 * @mixin
 */
var State = (Target) =>
  class State extends (Target || Base) {
    //getState() {}

    //applyState(State) {}

    /**
     * Gets or sets a component´s state
     * @property {Object}
     */
    get state() {
      this._state = this.getState();
      return this._state;
    }

    set state(state) {
      this._state = state;
      this.applyState(state);
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Common/data/stm/mixin/ModelStm
 */

const STM_PROP = Symbol('STM_PROP');

/**
 * Mixin making a model compatible with {@link Common/data/stm/StateTrackingManager}
 *
 * @mixin
 */
var ModelStm = (Target) =>
  class ModelStm extends (Target || Base) {
    static get defaultConfig() {
      return {
        /**
         * Reference to STM manager
         * @config {Common.data.stm.StateTrackingManager}
         * @default
         * @category Misc
         */
        stm: null
      };
    }

    joinStore(store) {
      super.joinStore && super.joinStore(store);

      if (!this.stm) {
        this.stm = store.stm;
      }
    }

    unJoinStore(store) {
      if (this.stm === store.stm) {
        this.stm = null;
      }

      super.unJoinStore && super.unJoinStore(store);
    }

    get stm() {
      return this[STM_PROP];
    }

    set stm(stm) {
      this[STM_PROP] = stm;
    }

    /**
     * Overridden to collect initial data for the fields about to be changed.
     * The method is called from within {@link Common/data/Model#function-set} method.
     *
     * @private
     */
    beforeSet(field, value, silent, fromRelationUpdate) {
      const preResult = super.beforeSet ? super.beforeSet(field, value, silent, fromRelationUpdate) : [];

      const stm = this.stm;

      if (stm && !stm.disabled) {
        let newDataCandidate, oldDataCandidate;

        if (typeof field == 'object') {
          [newDataCandidate, oldDataCandidate] = Object.keys(field).reduce(
            (data, fName) => {
              data[0][fName] = field[fName];
              data[1][fName] = this.get(fName);
              return data;
            },
            [{}, {}]
          );
        } else {
          newDataCandidate = { [field]: value };
          oldDataCandidate = { [field]: this.get(field) };
        }

        preResult.push([newDataCandidate, oldDataCandidate]);
      }

      return preResult;
    }

    /**
     * Overridden to store initial data of the changed fields and to notify STM
     * manager about the change action if anything has been changed in result.
     *
     * The method is called from within {@link Common/data/Model#function-set} method.
     *
     * @private
     */
    afterSet(field, value, silent, fromRelationUpdate, beforeResult, wasSet) {
      const stm = this.stm;

      if (stm && !stm.disabled) {
        const preResult = beforeResult.pop();

        if (wasSet) {
          let [newDataCandidate, oldDataCandidate] = preResult;

          let [newData, oldData] = Object.keys(wasSet).reduce(
            (data, fName) => {
              data[0][fName] = newDataCandidate[fName];
              data[1][fName] = oldDataCandidate[fName];
              return data;
            },
            [{}, {}]
          );

          stm.onModelUpdate(this, newData, oldData);
        }
      }

      super.afterSet && super.afterSet(field, value, silent, fromRelationUpdate, beforeResult, wasSet);
    }

    /**
     * Called from {@link Common/data/mixin/TreeNode#function-insertChild} to obtain inserted
     * records initial parents and parent index, to be able to restore the state back upon undo.
     *
     * @param {Common.data.Model[]} childRecords
     * @return {Array} Array of results from this call and any of super calls if any.
     *               This result is consumed by {@link #function-afterInsertChild} which pops
     *               from the result array to take only results of this method call and leave
     *               results from super calls untouched.
     *
     * @private
     */
    beforeInsertChild(childRecords) {
      const preResult = super.beforeInsertChild ? super.beforeInsertChild(childRecords) : [];

      const stm = this.stm;

      if (stm && !stm.disabled) {
        preResult.push(
          childRecords.reduce((result, childRecord) => {
            // We are interested only in records from the same root node.
            // Removing (which is done before insertion) of the records
            // from another root (and store) should
            // be handled by that store STM instance.
            if (childRecord.root === this.root) {
              result.set(childRecord, {
                parent: childRecord.parent,
                index: childRecord.parent ? childRecord.parentIndex : undefined
              });
            }

            return result;
          }, new Map())
        );
      }

      return preResult;
    }

    /**
     * Called from {@link Common/data/mixin/TreeNode#function-insertChild} to notify {@link Common/data/stm/StateTrackingManager}
     * about children insertion. Provides it with all necessary context information collected
     * in {@link #function-beforeInsertChild} required to undo/redo the action.
     *
     * @private
     */
    afterInsertChild(index, childRecords, beforeResult, inserted) {
      const stm = this.stm;

      if (stm && !stm.disabled) {
        const context = beforeResult.pop();

        if (inserted) {
          stm.onModelInsertChild(this, index, inserted, context);
        }
      }

      super.afterInsertChild && super.afterInsertChild(index, childRecords, beforeResult, inserted);
    }

    /**
     * Called from {@link Common/data/mixin/TreeNode#function-removeChild} to obtain removed
     * records initial parent index, to be able to restore the state back upon undo.
     *
     * @param {Common.data.Model[]} childRecords
     * @param {Boolean} isMove
     * @return {Array} Array of results from this call and any of super calls if any.
     *               This result is consumed by {@link #function-afterRemoveChild} which pops
     *               from the result array to take only results of this method call and leave
     *               results from super calls untouched.
     *
     * @private
     */
    beforeRemoveChild(childRecords, isMove) {
      const preResult = super.beforeRemoveChild ? super.beforeRemoveChild(childRecords, isMove) : [];

      const stm = this.stm;

      // If it's move then InsertChildAction will handle this case
      if (stm && !stm.disabled && !isMove) {
        // Child records we receive are guaranteed to be direct children
        // of this node, see Common/data/mixin/TreeNode#removeChild method

        // Here we interested in the original index for each child removed,
        // we collect it and store for future use in RemoveChildAction
        preResult.push(
          childRecords.reduce((result, childRecord) => {
            result.set(childRecord, childRecord.parentIndex);
            return result;
          }, new Map())
        );
      }

      return preResult;
    }

    /**
     * Called from {@link Common/data/mixin/TreeNode#function-removeChild} to notify {@link Common/data/stm/StateTrackingManager}
     * about children removing. Provides it with all necessary context information collected
     * in {@link #function-beforeRemoveChild} required to undo/redo the action.
     *
     * @private
     */
    afterRemoveChild(childRecords, beforeResult, isMove) {
      const stm = this.stm;

      // If it's move then InsertChildAction will handle this case
      if (stm && !stm.disabled && !isMove) {
        const context = beforeResult.pop();

        if (childRecords && childRecords.length) {
          stm.onModelRemoveChild(this, childRecords, context);
        }
      }

      super.afterRemoveChild && super.afterRemoveChild(childRecords, beforeResult, isMove);
    }
  };

/**
 * @module Common/data/mixin/TreeNode
 */

/**
 * Mixin for Model with tree node related functionality. This class is mixed into the {@link Common/data/Model} class.
 *
 * ## Adding and removing child nodes
 * ```
 * const parent = store.getById(1),
 *
 * firstBorn = parent.insertChild({
 *      name : 'Child node'
 *  }, parent.children[0]); // Insert a child at a specific place in the children array
 *
 * parent.removeChild(parent.children[0]); // Removes a child node
 * parent.appendChild({ name : 'New child node' }); // Appends a child node
 * ```
 *
 * @mixin
 */
var TreeNode = (Target) =>
  class TreeNode extends (Target || Base) {
    /**
     * This is a read-only field provided in server synchronization packets to specify
     * which record id is the parent of the record.
     * @readonly
     * @field {String|Number} parentId
     */

    ingestChildren(childRecord, stores = this.stores) {
      const store = stores[0],
        MyClass = this.constructor,
        { inProcessChildren } = this;

      if (childRecord === true) {
        if (inProcessChildren) {
          return true;
        }
        return [];
      }
      if (childRecord) {
        if (!Array.isArray(childRecord)) {
          childRecord = [childRecord];
        }
        let i = 0,
          len = childRecord.length,
          result = [],
          child;

        for (; i < len; i++) {
          child = childRecord[i];
          child =
            child instanceof Model ? child : store ? store.createRecord(child) : new MyClass(child, null, null, true);
          result.push(child);
        }
        return result;
      }
    }

    /**
     * Child nodes. To allow loading children on demand, specify `children : true` in your data.
     * @member {Common.data.Model[]} children
     * @category Parent & children
     */

    /**
     * Called during creation to also turn any children into Models joined to the same stores as this model
     * @internal
     * @category Parent & children
     */
    processChildren(stores = this.stores) {
      const me = this;

      me.inProcessChildren = true;

      const children = me.ingestChildren(me.data[me.constructor.childrenField], stores);

      if (children) {
        if (children.length) {
          // We are processing a remote load
          if (me.children === true) {
            me.children = [];
          }
          me.appendChild(children);
        }
        // Flagged for load on demand
        else if (children === true) {
          me.children = true;
        }
      }
      me.inProcessChildren = false;
    }

    /**
     * This property is `true` if this record has all expanded ancestors and is therefore
     * eligible for inclusion in a UI.
     * @property {Boolean}
     * @readonly
     * @category Parent & children
     */
    ancestorsExpanded(store) {
      const { parent } = this;

      return !parent || (parent.isExpanded(store) && parent.ancestorsExpanded(store));
    }

    /**
     * Used by stores to assess the record's collapsed/expanded state in that store.
     * @param {Common.data.Store} store
     * @category Parent & children
     */
    isExpanded(store) {
      const mapMeta = this.instanceMeta(store.id);

      // Default initial expanded/collapsed state when in the store
      // to the record's original expanded property.
      if (!mapMeta.hasOwnProperty('collapsed')) {
        mapMeta.collapsed = !this.expanded;
      }

      return !mapMeta.collapsed;
    }

    // A read-only property. It provides the initial state upon load
    // The UI's expanded/collapsed state is in the store's meta map.
    get expanded() {
      return this.data.expanded;
    }

    /**
     * Depth in the tree at which this node exists. First visual level of nodes are at level 0, their direct children at
     * level 1 and so on.
     * @property {Number}
     * @readonly
     * @category Parent & children
     */
    get childLevel() {
      return this.parent ? this.parent.childLevel + 1 : this.isRoot ? -1 : 0;
    }

    /**
     * Is a leaf node in a tree structure?
     * @property {Boolean}
     * @readonly
     * @category Parent & children
     */
    get isLeaf() {
      return Boolean(!this.children || (this.constructor.convertEmptyParentToLeaf && !this.children.length));
    }

    /**
     * Is a parent node in a tree structure?
     * @property {Boolean}
     * @readonly
     * @category Parent & children
     */
    get isParent() {
      return !this.isLeaf;
    }

    /**
     * Returns true for parent nodes with children loaded (there might still be no children)
     * @property {Boolean}
     * @readonly
     * @category Parent & children
     */
    get isLoaded() {
      return this.isParent && Array.isArray(this.children);
    }

    /**
     * Count all children (including sub-children) for a node (in its `firstStore´)
     * @member {Number}
     * @category Parent & children
     */
    get descendantCount() {
      return this.getDescendantCount();
    }

    /**
     * Count visible (expanded) children (including sub-children) for a node (in its `firstStore`)
     * @member {Number}
     * @category Parent & children
     */
    get visibleDescendantCount() {
      return this.getDescendantCount(true);
    }

    /**
     * Count visible (expanded)/all children for this node, optionally specifying for which store.
     * @param {Boolean} [onlyVisible] Specify `true` to only count visible (expanded) children.
     * @param {Common.data.Store} [store] A Store to which this node belongs
     * @returns {Number}
     * @category Parent & children
     */
    getDescendantCount(onlyVisible = false, store = this.firstStore) {
      const children = this.children;

      if (!children || !Array.isArray(children) || (onlyVisible && !this.isExpanded(store))) {
        return 0;
      }

      return children.reduce((count, child) => count + child.getDescendantCount(onlyVisible), children.length);
    }

    /**
     * Retrieve all children (by traversing sub nodes)
     * @returns {Common.data.Model[]}
     * @category Parent & children
     */
    get allChildren() {
      const children = this.children;
      if (!children) return [];

      return children.reduce((all, child) => {
        all.push(child);

        // push.apply is faster than push with array spread:
        // https://jsperf.com/push-apply-vs-push-with-array-spread/1
        all.push.apply(all, child.allChildren);
        return all;
      }, []);
    }

    /**
     * Get the first child of this node
     * @returns {Common.data.Model}
     * @category Parent & children
     */
    get firstChild() {
      const children = this.children;

      return (children && children.length && children[0]) || null;
    }

    /**
     * Get the last child of this node
     * @returns {Common.data.Model}
     * @category Parent & children
     */
    get lastChild() {
      const children = this.children;

      return (children && children.length && children[children.length - 1]) || null;
    }

    /**
     * Returns count of all preceding sibling nodes (including their children).
     * @property {Number}
     * @category Parent & children
     */
    get previousSiblingsTotalCount() {
      let task = this.previousSibling,
        count = this.parentIndex;

      while (task) {
        count += task.descendantCount;
        task = task.previousSibling;
      }

      return count;
    }

    get root() {
      return (this.parent && this.parent.root) || this;
    }

    /**
     * Reading this property returns the id of the parent node, if this record is a child of a node.
     *
     * Setting this property appends this record to the record with the passed
     * id **in the same store that this record is already in**.
     *
     * Note that setting this property is **only valid if this record is already
     * part of a tree store**.
     *
     * This is not intended for general use. This is for when a server responds to a record
     * mutation and the server decides to move a record to a new parent. If a `parentId` property
     * is passed in the response data for a record, that record will be moved.
     * @property {Number|String}
     * @category Parent & children
     */
    get parentId() {
      return this.parent && !this.parent.isRoot ? this.parent.id : null;
    }

    set parentId(parentId) {
      const me = this,
        { parent } = me,
        newParent = parentId && me.firstStore.getById(parentId);

      // Handle exact equality of parent.
      // Also handle one being null and the other being undefined meaning no change.
      if (!(newParent === parent || (!parent && !newParent))) {
        // If we are batching, we do not trigger a change immediately.
        // endBatch will set the field which will set the property again.
        if (me.isBatchUpdating) {
          me.meta.batchChanges.parentId = parentId;
        } else {
          if (newParent) {
            newParent.appendChild(me);
          } else {
            me.parent.removeChild(me);
          }
        }
      }
    }

    static set parentIdField(parentIdField) {
      // Maintainer: the "this" references in here reference two different contexts.
      // Outside of the property definition, it's the Model Class.
      // In the getter and setter, it's the record instance.
      this._parentIdField = parentIdField;

      Object.defineProperty(this.prototype, parentIdField, {
        set: function(parentId) {
          // no arrow functions here, need `this` to change to instance
          // noinspection JSPotentiallyInvalidUsageOfClassThis
          this.parentId = parentId;
        },
        get: function() {
          // no arrow functions here, need `this` to change to instance
          // noinspection JSPotentiallyInvalidUsageOfClassThis
          return this.parentId;
        }
      });
    }

    static get parentIdField() {
      return this._parentIdField || 'parentId';
    }

    /**
     * Traverses all child nodes recursively calling the passed function
     * on a target node **before** iterating the child nodes.
     * @param fn
     * @category Parent & children
     */
    traverse(fn, skipSelf = false) {
      const me = this;

      if (!skipSelf) {
        fn.call(me, me);
      }
      if (me.isLoaded) me.children.forEach((child) => child.traverse(fn));
    }

    /**
     * Traverses all child nodes recursively calling the passed function
     * on child nodes of a target **before** calling it it on the node.
     * @param fn
     * @category Parent & children
     */
    traverseBefore(fn, skipSelf = false) {
      const me = this;

      if (me.isLoaded) {
        me.children.forEach((child) => child.traverse(fn));
      }
      if (!skipSelf) {
        fn.call(me, me);
      }
    }

    /**
     * Traverses child nodes recursively while fn returns true
     * @param {Function} fn
     * @category Parent & children
     * @returns {Boolean}
     */
    traverseWhile(fn, skipSelf = false) {
      const me = this;

      let goOn = true;

      if (!skipSelf) {
        goOn = fn.call(me, me) !== false;
      }

      if (goOn && me.isLoaded) {
        goOn = me.children.every((child) => child.traverseWhile(fn));
      }

      return goOn;
    }

    /**
     * Bubbles up from this node, calling the specified function with each node.
     *
     * @param {Function} fn
     * @category Parent & children
     */
    bubble(fn, skipSelf = false) {
      let me = this;

      if (!skipSelf) {
        fn.call(me, me);
      }

      while (me.parent) {
        me = me.parent;
        fn.call(me, me);
      }
    }

    /**
     * Bubbles up from this node, calling the specified function with each node,
     * while the function returns true.
     *
     * @param {Function} fn
     * @category Parent & children
     * @return {Boolean}
     */
    bubbleWhile(fn, skipSelf = false) {
      let me = this,
        goOn = true;

      if (!skipSelf) {
        goOn = fn.call(me, me);
      }

      while (goOn && me.parent) {
        me = me.parent;
        goOn = fn.call(me, me);
      }

      return goOn;
    }

    /**
     * Checks if this model contain another model as one of it's descendants
     *
     * @param {Common.data.Model|String|Number} child
     * @category Parent & children
     * @returns {Boolean}
     */
    contains(childId) {
      if (childId && typeof childId === 'object') {
        childId = childId.id;
      }
      return !this.traverseWhile((node) => node.id != childId);
    }

    getTopParent(all) {
      let result;

      if (all) {
        result = [];
        this.bubbleWhile((t) => {
          result.push(t);
          return t.parent && !t.parent.isRoot;
        });
      } else {
        result = null;
        this.bubbleWhile((t) => {
          if (!t.parent) {
            result = t;
          }
          return t.parent && !t.parent.isRoot;
        });
      }

      return result;
    }

    /**
     * Append a child record(s) to any current children.
     * @param {Common.data.Model|Common.data.Model[]} childRecord
     * @param {Boolean} [silent] Specify true to suppress events
     * @returns {Common.data.Model|Common.data.Model[]}
     * @category Parent & children
     */
    appendChild(childRecord, silent = false) {
      return this.insertChild(childRecord, null, silent);
    }

    /**
     * Insert a child record(s) before an existing child record.
     * @param {Common.data.Model|Common.data.Model[]} childRecord
     * @param {Common.data.Model} [before]
     * @param {Boolean} [silent] Specify true to suppress events
     * @returns {Common.data.Model|Common.data.Model[]}
     * @category Parent & children
     */
    insertChild(childRecord, before, silent = false) {
      // Handle deprecated signature
      if (typeof childRecord === 'number') {
        const index = childRecord;
        childRecord = before;
        before = this.children[index];
      }

      const me = this,
        wasLeaf = me.isLeaf,
        returnArray = Array.isArray(childRecord);

      if (!silent) {
        if (!me.stores.every((s) => s.trigger('beforeAdd', { records: childRecord, parent: me }) !== false)) {
          return null;
        }
      }

      // This call makes child record an array containing Models
      childRecord = me.ingestChildren(childRecord);

      // NOTE: see comment in Model::set() about before/in/after calls approach.
      const index = before ? before.parentIndex : me.children ? me.children.length : 0,
        preResult = me.beforeInsertChild ? me.beforeInsertChild(childRecord) : undefined,
        inserted = me.internalAppendInsert(childRecord, before, silent);

      // If we've transitioned to being a branch node, signal a change event
      // so that the UI updates.
      // Not if it's due to root node loading. StoreTree#onNodeAddChild
      // for the rootNode will fire a store refresh.
      if (me.isLeaf !== wasLeaf && !me.root.isLoading && !silent) {
        me.stores.forEach((s) => {
          const changes = {
            isLeaf: false
          };
          s.trigger('update', { record: me, changes });
          s.trigger('change', { action: 'update', record: me, changes });
        });
      }

      me.afterInsertChild && me.afterInsertChild(index, childRecord, preResult, inserted);

      return returnArray || !inserted ? inserted : inserted[0];
    }

    internalAppendInsert(newRecords, before, silent) {
      const me = this,
        { stores, root } = me,
        { firstStore: rootStore } = root,
        isMove = {};

      let isNoop, start, i, newRecordsCloned;

      // The reference node must be one of our children. If not, fall back to an append.
      if (before && before.parent !== me) {
        before = null;
      }

      // If the records starting at insertAt or (insertAt - 1), are the same sequence
      // that we are being asked to add, this is a no-op.
      if (me.children) {
        const children = me.children,
          insertAt = before ? before.parentIndex : children.length;

        if (children[(start = insertAt)] === newRecords[0] || children[(start = insertAt - 1)] === newRecords[0]) {
          for (isNoop = true, i = 0; isNoop && i < newRecords.length; i++) {
            if (newRecords[i] !== children[start + i]) {
              isNoop = false;
            }
          }
        }
      }

      // Fulfill the contract of appendChild/insertChild even if we did not have to do anything.
      // Callers must be able to correctly postprocess the returned value as an array.
      if (isNoop) {
        return newRecords;
      }

      // Remove incoming child nodes from any current parent.
      for (i = 0; i < newRecords.length; i++) {
        const newRecord = newRecords[i],
          oldParent = newRecord.parent;

        // Store added should not be modified for adds
        // caused by moving.
        isMove[newRecord.id] = newRecord.root === root;

        // Check if any descendants of the added node are moves.
        rootStore &&
          newRecord.traverse((r) => {
            if (r.root === root) {
              isMove[r.id] = true;
            }
          });

        // If the new record has a parent, remove from that parent.
        // This operation may be vetoed by listeners.
        // If it is vetoed, then remove from the newRecords and do not
        // set the parent property
        if (oldParent && oldParent.removeChild(newRecord, isMove[newRecord.id]) === false) {
          if (!newRecordsCloned) {
            newRecords = newRecords.slice();
            newRecordsCloned = true;
          }
          newRecords.splice(i--, 1);
        } else {
          const { parentIdField } = newRecord.constructor,
            parentId = me.isAutoRoot ? null : me.id;

          newRecord.parent = me;
          newRecord.data[parentIdField] = parentId;

          // If we are in the recursive inclusion of children at construction
          // time, or in a store load, that must not be a data modification.
          // Otherwise, we have to signal a change
          if (!(me.inProcessChildren || me.isLoading)) {
            const toSet = {
                parentId
              },
              { modified } = newRecord.meta,
              oldParentId = oldParent ? oldParent.id : null,
              wasSet = {
                [parentIdField]: {
                  value: me.id,
                  oldValue: oldParentId
                }
              };

            // Changing back to its original value
            if (modified[parentIdField] === me.id) {
              delete modified[parentIdField];
            }
            // Cache its original value
            else if (!('parentId' in modified)) {
              modified[parentIdField] = oldParentId;
            }

            newRecord.afterChange(toSet, wasSet);
          }
        }
      }

      // Still records to insert after beforeRemove listeners may have vetoed some
      if (newRecords.length) {
        const children = me.children || (me.children = []),
          // Collect index again after removal from old parent in case it's a move within the
          // same parent.
          insertAt = before ? before.parentIndex : children.length;

        // Insert the new records into the children array
        children.splice(insertAt, 0, ...newRecords);

        // Fix up pointers
        me.fixChildrensParentIndex();

        stores.forEach((store) => {
          if (!store.chained) {
            newRecords.forEach((newRecord) => {
              newRecord.instanceMeta(store.id).collapsed = !newRecord.expanded;
              newRecord.joinStore(store);
            });

            // Add to store (will also add any child records and trigger events)
            store.onNodeAddChild(me, newRecords, insertAt, isMove, silent);
          }
        });
      }

      return newRecords;
    }

    /**
     * Remove a child record. Only direct children of this node can be removed, others are ignored.
     * @param {Common.data.Model|Common.data.Model[]} childRecords The record(s) to remove
     * @param {Boolean} [isMove] Pass `true` if the record is being moved within the same store.
     * @category Parent & children
     */
    removeChild(childRecords, isMove) {
      const me = this,
        wasLeaf = me.isLeaf,
        { children, stores } = me;

      if (!Array.isArray(childRecords)) {
        childRecords = [childRecords];
      }

      childRecords = childRecords.filter((r) => r.parent === me);

      // Allow store listeners to veto the beforeRemove event
      for (const store of stores) {
        if (!store.chained) {
          if (store.trigger('beforeRemove', { parent: me, records: childRecords, isMove }) === false) {
            return false;
          }
        }
      }
      const preResult = me.beforeRemoveChild ? me.beforeRemoveChild(childRecords, isMove) : undefined;

      for (const childRecord of childRecords) {
        const index = childRecord.parentIndex;

        children.splice(index, 1);
        me.fixChildrensParentIndex();

        stores.forEach((store) => {
          if (!store.chained) {
            store.onNodeRemoveChild(me, [childRecord], index, isMove);
          }
        });

        childRecord.parent = childRecord.parentIndex = childRecord.nextSibling = childRecord.previousSibling = null;
      }

      // If we've transitioned to being a leaf node, signal a change event
      // so that the UI updates
      if (me.isLeaf !== wasLeaf) {
        me.stores.forEach((s) => {
          const changes = {
            isLeaf: true
          };
          s.trigger('update', { record: me, changes });
          s.trigger('change', { action: 'update', record: me, changes });
        });
      }

      me.afterRemoveChild && me.afterRemoveChild(childRecords, preResult, isMove);
    }

    clearChildren() {
      const me = this,
        { children, stores } = me;

      if (children) {
        me.children = [];
        stores.forEach((store) => {
          if (!store.chained) {
            store.onNodeRemoveChild(me, children, 0);
          }
        });
      }
    }

    fixChildrensParentIndex() {
      const { children } = this;

      let previousSibling;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];

        child.parentIndex = i;
        child.previousSibling = previousSibling;
        if (previousSibling) {
          previousSibling.nextSibling = child;
        }
        // Last child never has a nextSibling
        if (i === children.length - 1) {
          child.nextSibling = null;
        }
        previousSibling = child;
      }
    }
  };

const internalProps = {
    children: 1,
    data: 1,
    meta: 1
  },
  emptyObject$2 = {},
  convertDate = function(date) {
    if (!(date instanceof Date)) {
      date = DateHelper.parse(date, this.format || this.dateFormat);
    }
    // if parsing has failed, we would like to return `undefined` to indicate the "absence" of data
    // instead of `null` (presence of "empty" data)
    return date || undefined;
  },
  isEqual = (field, oldValue, value) => {
    // using fn to keep field scope
    return field && field.isEqual ? field.isEqual(oldValue, value) : ObjectHelper.isEqual(oldValue, value);
  },
  nullFn = () => {};

/**
 * @module Common/data/Model
 */

/**
 * A Model is a definition for a record in a store. It defines which fields the data contains and exposes an interface
 * to access and manipulate that data. Models are created from json objects, the raw json is stored in `Model#data`.
 *
 * ## Defining fields
 * A Model can either define its fields explicitly or have them created from its data. This snippet shows a model with
 * two fields:
 *
 * ```
 * class Person extends Model {
 *   static get fields() {
 *     return [
 *       'name',
 *       { name : 'birthday', type : 'date', dateFormat : 'YYYY-MM-DD' },
 *       { name : 'shoeSize', type : 'number', defaultValue : 11 },
 *       { name : 'age', readOnly : true }
 *     ];
 * }
 * ```
 *
 * The first field (name) has an unspecified type, which is fine in most cases since this is JavaScript. The second
 * field (birthday) is defined to be a date, which will make the model parse any supplied value into an actual date.
 * Currently date is the only specified type available.
 *
 * You can also set a defaultValue that will be used if the data doesn't contain a value for the field.
 *
 * ```
 *       { name : 'shoeSize', type : 'number', defaultValue : 11 }
 * ```
 *
 * To create a record from a Model, supply data to its constructor:
 *
 * ```
 * let guy = new Person({
 *   id       : 1,
 *   name     : 'Dude',
 *   birthday : '2014-09-01'
 * });
 * ```
 *
 * If no id is specified, a temporary id will be generated.
 *
 * ## Persisting fields
 * By default all fields are persisted. If you don't want particular field to get saved to the server, configure it with
 * `persist: false`. In this case field will not be among changes which are sent by
 * {@link Common/data/AjaxStore#function-commit store.commit()}, otherwise its behavior doesn't change.
 *
 * ```
 * class Person extends Model {
 *     static get fields() {
 *         return [
 *             'name',
 *             { name : 'age', persist : false }
 *         ];
 *     }
 * }
 * ```
 *
 * ## Id field
 * By default Model expects its id to be stored in a field named "id". The name of the field can be customized by
 * setting {@link #property-idField-static}:
 *
 * ```
 * // Id drawn from 'id' property by default; use custom field here
 * Person.idField = 'personId';
 *
 * let girl = new Person({
 *    personId : 2,
 *    name     : 'Lady',
 *    birthday : '2011-11-05'
 * });
 * ```
 *
 * ## Getting and setting values
 * Fields are used to generate getters and setters on the records. Use them to access or modify values (they are
 * reactive):
 *
 * ```
 * console.log(guy.name);
 * girl.birthday = new Date(2011,10,6);
 * ```
 *
 * NOTE: In an application with multiple different models you should subclass Model, since the prototype is decorated
 * with getters and setters. Otherwise you might got unforeseen collisions.
 *
 * ## Field data mapping
 * By default fields are mapped to data using their name. If you for example have a "name" field it expects data to be
 * `{ name: 'Some name' }`. If you need to map it to some other property, specify `dataSource` in your field definition:
 *
 * ```
 * class Person extends Model {
 *   static get fields {
 *     return [
 *       { name : 'name', dataSource : 'TheName' }
 *     ];
 * }
 *
 * // This is now OK:
 * let dude = new Person({ TheName : 'Manfred' });
 * console.log(dude.name); // --> Manfred
 * ```
 *
 * ## Tree API
 * This class mixes in the {@link Common/data/mixin/TreeNode TreeNode} mixin which provides an API for tree related functionality (only relevant if your
 * store is configured to be a {@link Common/data/Store#config-tree tree}).
 *
 * @mixes Common/data/mixin/TreeNode
 * @mixes Common/data/stm/mixin/ModelStm
 */
class Model extends TreeNode(ModelStm()) {
  /**
   * Specify `true` to consider an empty parent to be a leaf.
   * @property {Boolean}
   * @category Parent & children
   */
  static set convertEmptyParentToLeaf(value) {
    this._convertEmptyParentToLeaf = value;
  }

  static get convertEmptyParentToLeaf() {
    return this._convertEmptyParentToLeaf;
  }

  /**
   * The name of the data field which provides the ID of instances of this Model.
   * @property {String}
   * @category Fields
   */
  static set idField(idField) {
    this._assignedIdField = true;
    this._idField = idField;
  }

  static get idField() {
    return this._idField;
  }

  /**
   * The name of the data field which holds children of this Model when used in a tree structure
   * ```javascript
   * MyModel.childrenField = 'kids';
   * const parent = new MyModel({
   *   name : 'Dad',
   *   kids : [
   *     { name : 'Daughter' },
   *     { name : 'Son' }
   *   ]
   * });
   * ```
   * @property {String}
   * @category Fields
   */
  static set childrenField(childrenField) {
    this._childrenField = childrenField;
  }

  static get childrenField() {
    return this._childrenField || 'children';
  }

  /**
   * Returns index path to this node. This is the index of each node in the node path
   * starting from the topmost parent. (only relevant when its part of a tree store).
   * @returns {Number[]} The index of each node in the path from the topmost parent to this node.
   * @category Parent & children
   * @private
   */
  get indexPath() {
    const indices = [];

    for (let task = this; task && !task.isRoot; task = task.parent) {
      indices.unshift(task.parentIndex + 1);
    }

    return indices;
  }

  /**
   * Unique identifier for the record. Might be mapped to another dataSource using idField, but always exposed as
   * record.id. Will get a generated value if none is specified in records data.
   * @member {String|Number} id
   * @category Identification
   */

  //region Init

  /**
   * Constructs a new record from the supplied data.
   * @param {Object} [data] Raw data
   * @param {Common.data.Store} [store] Data store
   * @param {Object} [meta] Meta data
   * @function constructor
   * @category Misc
   */
  construct(data = {}, store = null, meta = null, skipExpose = false) {
    const me = this,
      { constructor } = me,
      { fieldMap } = constructor,
      stores = store ? (Array.isArray(store) ? store : [store]) : [];

    store = stores[0];

    me.meta = Object.assign(
      {
        modified: {}
      },
      constructor.metaConfig,
      meta
    );

    // null passed to Base construct inhibits config processing.
    super.construct(null);

    // make getters/setters for fields, needs to be done before processing data to make sure defaults are available
    if (skipExpose) {
      if (!constructor.hasOwnProperty('fieldMap')) {
        constructor.exposeProperties();
      }
    } else {
      constructor.exposeProperties(data);
    }

    // It's only valid to do this once, on construction of the first instance
    if (!constructor.hasOwnProperty('idFieldProcessed')) {
      // idField can be overridden from meta, or from the store if we have not had an idField set programmatically
      // and if we have not had an id field defined above the base Model class level.

      let overriddenIdField = me.meta.idField;

      if (!overriddenIdField) {
        // Might have been set to Model after construction but before load
        if (constructor._assignedIdField) {
          overriddenIdField = constructor.idField;
        }
        // idField on store was deprecated, but should still work to not break code
        // TODO: Remove in 3.0? Or reintroduce it...
        else if (store) {
          overriddenIdField = store.idField;
        }
      }

      // If it's overridden to something different than we already have, replace the 'id' field in the fieldMap
      if (overriddenIdField && overriddenIdField !== fieldMap.id.dataSource) {
        constructor.createFieldDefinition({
          name: 'id',
          dataSource: overriddenIdField
        });
      }
      constructor.idFieldProcessed = true;
    }

    // assign internalId, unique among all records
    me._internalId = Model._internalIdCounter++;

    // relation code expects store to be available for relation lookup, but actual join done below
    me.stores = [];

    // Superclass constructors may set this in their own way before this is called.
    if (!me.originalData) {
      me.originalData = data;
    }
    me.data = constructor.processData(data);
    if (me.id === undefined) {
      // Assign a generated id silently, record should not be considered modified
      me.setData('id', me.generateId());
    }
    if (me.data[constructor.childrenField]) {
      me.processChildren(stores);
    }
    me.generation = 0;
  }

  /**
   * Processes raw data, converting values and setting defaults.
   * @private
   * @param {Object} data Raw data
   * @param {Boolean} [ignoreDefaults] Ignore setting default values, used when updating
   * @returns {Object} Processed data
   * @category Fields
   */
  static processData(data, ignoreDefaults = false) {
    const { fieldMap, defaultValues } = this;
    let processed = Object.assign({}, data),
      fieldName;

    if (!ignoreDefaults) {
      for (fieldName in defaultValues) {
        if (processed[fieldName] === undefined) processed[fieldName] = defaultValues[fieldName];
      }
    }

    // Convert field types which need converting
    for (fieldName in fieldMap) {
      const fieldDefinition = fieldMap[fieldName],
        { name, dataSource } = fieldDefinition,
        // Value might have been supplied either using mapped dataSource (when loading JSON etc. for example
        // event.myStartDate) or as field name (from internal code, for example event.startDate). If [name]
        // exists but not [dataSource], use it.
        useNameForValue = dataSource !== name && !ObjectHelper.pathExists(data, dataSource) && name in data;

      // Only action field definitions which have a convert function or remap data
      if (useNameForValue || fieldDefinition.convert) {
        const value = useNameForValue ? data[name] : data[dataSource];

        // When ignoringDefaults, do not convert unspecified values
        if (!ignoreDefaults || (useNameForValue && name in data) || (!useNameForValue && dataSource in data)) {
          ObjectHelper.setPath(processed, dataSource, fieldDefinition.convert ? fieldDefinition.convert(value) : value);
          // Remove [startDate] from internal data holder, only keeping [myStartDate]
          if (useNameForValue) {
            delete processed[name];
          }
        }
      }
    }

    return processed;
  }

  /**
   * Makes getters and setters for fields (from definitions and data). Called once when class is defined and once when
   * data is loaded first time.
   * @internal
   * @param {Object} data Raw data
   * @category Fields
   */
  static exposeProperties(data) {
    const me = this,
      superclass = me.superclass,
      rawFields = me.hasOwnProperty('fields') && me.fields;

    // Ensure that the class hierarchy processes its fields on first construction.
    if (superclass.exposeProperties && !superclass.hasOwnProperty('fieldMap')) {
      superclass.exposeProperties();
    }

    // Don't expose field properties if already done
    if (!me.hasOwnProperty('propertiesExposed')) {
      // Clone the superclass's defaults, and override that with our own defaults.
      // As we find fields with a defaultValue, more defaults may be added
      me.defaultValues = Object.assign(
        {},
        superclass.defaultValues,
        me.hasOwnProperty('defaults') ? me.defaults : null
      );

      // Hook up our field maps with the class hierarchy's fieldMaps.
      // We need to be able to look up field definitions by the name, or by the dataSource property name

      /**
       * An object containing all the _defined_ fields for this Model class. This will include all superclass's
       * defined fields through its prototype chain. So be aware that `Object.keys` and `Object.entries` will only
       * access this class's defined fields.
       * @member {Object} fieldMap
       * @static
       * @readonly
       * @category Fields
       */
      me.fieldMap = Object.setPrototypeOf({}, superclass.fieldMap || emptyObject$2);
      me.fieldDataSourceMap = Object.setPrototypeOf({}, superclass.fieldDataSourceMap || emptyObject$2);

      // Hook up our propertiesExposed with the superclass's version
      me.propertiesExposed = Object.setPrototypeOf({}, superclass.propertiesExposed || emptyObject$2);

      // If the idField is overridden at this level, create a new field
      if (me.hasOwnProperty('idField')) {
        me.createFieldDefinition({
          name: 'id',
          dataSource: me.idField
        });
        me.propertiesExposed[me.idField] = true;
      }

      // Process fields defined in the class definition
      if (rawFields && rawFields.length) {
        rawFields.map(me.createFieldDefinition, me);
      }
    }

    // Process the raw data properties and expose them as fields unless the property name
    // has already been used by the "dataSource" of a defined field.
    if (me.autoExposeFields && data && !me.hasOwnProperty('propertiesExposedForData')) {
      for (let dataProperty in data) {
        if (!me.propertiesExposed[dataProperty]) {
          // Create a field definition in our fieldMap with the flag that it's from data
          me.createFieldDefinition({
            name: dataProperty,
            dataSource: dataProperty,
            fromData: true
          });
        }
      }
      me.propertiesExposedForData = true;
    }

    me.exposeRelations();
  }

  static createFieldDefinition(fieldDef) {
    if (fieldDef == null) {
      return;
    }

    if (typeof fieldDef === 'string') {
      fieldDef = {
        name: fieldDef
      };
    }

    const me = this,
      { propertiesExposed, defaultValues } = me,
      { name } = fieldDef,
      dataSource = fieldDef.dataSource || (fieldDef.dataSource = name);

    if (!fieldDef.hasOwnProperty('persist')) {
      fieldDef.persist = true;
    }

    if (fieldDef.type === 'date') {
      fieldDef.convert = convertDate;
    }
    me.fieldMap[name] = fieldDef;

    if (!me.fieldDataSourceMap[dataSource]) {
      me.fieldDataSourceMap[dataSource] = fieldDef;
    }

    // When iterating through the raw data, if autoExposeFields is set
    // We do not need to create properties for raw property names we've processed here
    if (dataSource.indexOf('.') === -1) {
      propertiesExposed[dataSource] = true;
    }
    // With complex mapping avoid exposing object as model field
    else {
      fieldDef.complexMapping = true;
      propertiesExposed[dataSource.split('.')[0]] = true;
    }

    // Maintain an object of defaultValues for fields.
    if ('defaultValue' in fieldDef) {
      defaultValues[dataSource] = fieldDef.defaultValue;
    }

    // Create a property on this Model's prototype, named for the defined field name
    // which reads the correct property out of the raw data object.
    me.createFieldProperty(name, dataSource, fieldDef);

    return fieldDef;
  }

  /**
   * Create getter and setter functions for the specified field name under the specified key.
   *
   * @param {String} fieldName The defined field name (or property name if this is created by exposing a raw property)
   * @param {String} propertyName The property name to read off the data property
   * @param {Object} fieldDef The full field definition.
   * @private
   * @category Fields
   */
  static createFieldProperty(fieldName, propertyName, fieldDef) {
    const me = this;

    // checking (fieldName in me.prototype) instead of hasOwnProperty to catch cases where getters/setters are
    // manually created on some parent
    if (!internalProps[propertyName]) {
      if (!(fieldName in me.prototype)) {
        Object.defineProperty(me.prototype, fieldName, {
          enumerable: true,
          get: function() {
            // no arrow functions here, need `this` to change to instance
            // noinspection JSPotentiallyInvalidUsageOfClassThis
            return this.get(fieldName);
          },
          // Only create a real setter if the field is read/write.
          // privately, we will use setData to set a field's value
          set:
            fieldDef && fieldDef.readOnly
              ? nullFn
              : function(value) {
                  // no arrow functions here, need `this` to change to instance
                  // noinspection JSPotentiallyInvalidUsageOfClassThis
                  this.set(fieldName, value);
                }
        });
      }
    }
  }

  /**
   * Makes getters and setters for related records. Populates a Model#relation array with the relations, to allow it
   * to be modified later when assigning stores.
   * @internal
   * @category Relations
   */
  static exposeRelations() {
    const me = this;

    if (me.hasOwnProperty('relationsExposed')) return;

    if (me.relationConfig) {
      me.relationsExposed = true;
      me.relations = [];

      me.relationConfig.forEach((relation) => {
        me.relations.push(relation);

        let name = relation.relationName;

        // getter and setter for related object
        if (!Reflect.ownKeys(me.prototype).includes(name)) {
          Object.defineProperty(me.prototype, name, {
            enumerable: true,
            get: function() {
              // noinspection JSPotentiallyInvalidUsageOfClassThis
              return this.getForeign(name);
            },
            set: function(value) {
              // noinspection JSPotentiallyInvalidUsageOfClassThis
              this.setForeign(name, value, relation);
            }
          });
        }
      });
    }
  }

  //endregion

  //region Fields

  /**
   * Flag checked from Store when loading data that determines if fields found in first records should be exposed in
   * same way as predefined fields.
   * @returns {Boolean}
   * @category Fields
   */
  static get autoExposeFields() {
    return true;
  }

  /**
   * Predefined fields, none per default, override in subclasses to add fields.
   * @returns {Object[]}
   * @readonly
   * @category Fields
   */
  static get fields() {
    return [];
  }

  static get internalFields() {
    const { fieldMap } = this;

    let result = this._internalFields;

    // Produce the array lazily - it probably will never be used.
    // Only available when we have exposed our properties.
    if (this.hasOwnProperty('fieldMap') && !result) {
      result = this._internalFields = [];
      for (let fieldName in fieldMap) {
        result.push(fieldMap[fieldName]);
      }
    }
    return result;
  }

  /**
   * Convenience getter to get field definitions from class.
   * @returns {Array}
   * @category Fields
   */
  get fields() {
    return this.constructor.internalFields || this.constructor.fields;
  }

  /**
   * Convenience function to get the definition for a field from class.
   * @param {String} fieldName Field name
   * @returns {Object}
   * @category Fields
   */
  getFieldDefinition(fieldName) {
    return this.constructor.getFieldDefinition(fieldName);
  }

  /**
   * Get the names of all fields in data.
   * @returns {String[]} Field names
   * @readonly
   * @category Fields
   */
  get fieldNames() {
    return Object.keys(this.data);
  }

  /**
   * Get the definition for a field by name. Caches results.
   * @param {String} fieldName Field name
   * @returns {Object} Field definition or null if none found
   * @category Fields
   */
  static getFieldDefinition(fieldName) {
    return this.fieldMap[fieldName];
  }

  /**
   * Get the data source used by specified field. Returns the fieldName if no data source specified.
   * @param {String} fieldName Field name
   * @returns {String}
   * @category Fields
   */
  getDataSource(fieldName) {
    const def = this.constructor.getFieldDefinition(fieldName);
    if (def) return def.dataSource || def.name;
  }

  /**
   * Processes input to a field, converting to expected type.
   * @param {String} fieldName Field dataSource
   * @param {*} value Value to process
   * @returns {*} Converted value
   * @category Fields
   */
  static processField(fieldName, value) {
    const field = this.fieldMap[fieldName];

    if (field && field.convert) {
      return field.convert(value);
    }
    return value;
  }

  //endregion

  //region Relations

  /**
   * Initializes model relations. Called from store when adding a record.
   * @private
   * @category Relations
   */
  initRelations() {
    const me = this,
      relations = me.constructor.relations;

    if (!relations) return;

    // TODO: feels strange to have to look at the store for relation config but didn't figure out anything better.
    // TODO: because other option would be to store it on each model instance, not better...

    me.stores.forEach((store) => {
      if (!store.modelRelations) store.initRelations();

      // TODO: not at all tested for multiple stores, can't imagine it works as is
      const relatedRecords = [];

      store.modelRelations &&
        store.modelRelations.forEach((config) => {
          relatedRecords.push({ related: me.initRelation(config), config });
        });
      store.updateRecordRelationCache(me, relatedRecords);
    });
  }

  /**
   * Initializes/updates a single relation.
   * @param config Relation config
   * @returns {Common.data.Model} Related record
   * @private
   * @category Relations
   */
  initRelation(config) {
    const me = this,
      keyValue = me.get(config.fieldName),
      foreign = keyValue !== undefined && typeof config.store !== 'string' && config.store.getById(keyValue),
      placeHolder = { id: keyValue, placeHolder: true };

    if (!me.meta.relationCache) me.meta.relationCache = {};
    // apparently scheduler tests expect cache to work without matched related record, thus the placeholder
    me.meta.relationCache[config.relationName] = foreign || (keyValue != null ? placeHolder : null);

    return foreign;
  }

  removeRelation(config) {
    // (have to check for existence before deleting to work in Safari)
    if (this.meta.relationCache[config.relationName]) {
      delete this.meta.relationCache[config.relationName];
      if (config.nullFieldOnRemove) {
        // Setting to null silently, to not trigger additional relation behaviour
        this.setData(config.fieldName, null);
      }
    }
  }

  getForeign(name) {
    return this.meta.relationCache && this.meta.relationCache[name];
  }

  setForeign(name, value, config) {
    let id = Model.asId(value);
    return this.set(config.fieldName, id);
  }

  //endregion

  //region Get/set values, data handling

  /**
   * Get value for specified field name. You can also use the generated getters if loading through a Store.
   * If model is currently in batch operation this will return updated batch values which are not applied to Model
   * until endBatch() is called.
   * @param {String} fieldName Field name to get value from
   * @returns {*} Fields value
   * @category Fields
   */
  get(fieldName) {
    const me = this,
      recData = me.meta.batchChanges ? Object.assign({}, me.data, me.meta.batchChanges) : me.data,
      field = me.constructor.fieldMap[fieldName],
      dataSource = field ? field.dataSource : fieldName;

    if (dataSource) {
      if (field && field.complexMapping) {
        return ObjectHelper.getPath(recData, dataSource);
      }

      return dataSource in recData ? recData[dataSource] : recData[fieldName];
    }
  }

  /**
   * Internal function used to update a records underlying data block (record.data) while still respecting field
   * mappings. Needed in cases where a field needs setting without triggering any associated behaviour and it has a
   * dataSource with a different name.
   *
   * For example:
   * ```javascript
   * // startDate mapped to data.beginDate
   * { name : 'startDate', dataSource : 'beginDate' }
   *
   * // Some parts of our code needs to update the data block without triggering any of the behaviour associated with
   * // calling set. This would then not update "beginDate":
   * record.data.startDate = xx;
   *
   * // But this would
   * record.setData('startDate', xx);
   * ```
   * @internal
   * @category Editing
   */
  setData(fieldName, value) {
    const field = this.constructor.fieldMap[fieldName],
      dataSource = field ? field.dataSource : fieldName;

    if (dataSource) {
      ObjectHelper.setPath(this.data, dataSource, value);
    }
  }

  /**
   * Silently updates record's id with no flagging the property as modified.
   * Triggers onModelChange event for changed id.
   * @param {String|Number} value id value
   * @private
   */
  syncId(value) {
    const oldValue = this.id;
    if (oldValue !== value) {
      this.setData('id', value);
      const data = { id: { value, oldValue } };
      this.triggerChanges(data, data);
    }
  }

  /**
   * Set value for the specified field. You can also use the generated setters if loading through a Store.
   * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call
   * @param {*} value Value to set
   * @param {Boolean} [silent] Set to true to not trigger events
   * @fires Store#idChange
   * @fires Store#update
   * @fires Store#change
   * @example
   * person.set('name', 'Donald');
   * @category Editing
   */
  set(field, value, silent = false, fromRelationUpdate = false) {
    const me = this;

    // We use beforeSet/inSet/afterSet approach here because mixin interested in overriding set() method
    // like STM, for example, might be mixed before Model class or after. In general I have no control over this.
    // STM mixed before, so the only option to wrap set() method body is actually to call
    // beforeSet()/afterSet().

    if (me.isBatchUpdating) {
      me.inBatchSet(field, value);
      return null;
    } else {
      const preResult = me.beforeSet ? me.beforeSet(field, value, silent, fromRelationUpdate) : undefined,
        wasSet = me.inSet(field, value, silent, fromRelationUpdate);
      me.afterSet && me.afterSet(field, value, silent, fromRelationUpdate, preResult, wasSet);
      return wasSet;
    }
  }

  fieldToKeys(field, value) {
    let result;
    if (typeof field !== 'string') {
      result = {};
      // will get in trouble when setting same field on multiple models without this
      Reflect.ownKeys(field).forEach((key) => (result[key] = field[key]));
    } else {
      result = {
        [field]: value
      };
    }
    return result;
  }

  inBatchSet(field, value) {
    const toSet = this.fieldToKeys(field, value);
    Object.keys(toSet).forEach((key) => {
      // Store batch changes
      this.meta.batchChanges[key] = this.constructor.processField(key, toSet[key]);
    });
  }

  inSet(field, value, silent, fromRelationUpdate) {
    const me = this,
      fieldMap = me.constructor.fieldMap,
      myProto = me.constructor.prototype,
      data = me.data,
      wasSet = {},
      toSet = me.fieldToKeys(field, value);
    let changed = false;

    // Give a chance to cancel action before records updated.
    if (!silent && !me.triggerBeforeUpdate(toSet)) {
      return null;
    }

    Object.keys(toSet).forEach((key) => {
      let field = fieldMap[key],
        readOnly = field && field.readOnly,
        mapping = field ? field.dataSource : key,
        useProp = !field && key in myProto,
        oldValue = useProp ? me[mapping] : ObjectHelper.getPath(data, mapping),
        value = me.constructor.processField(key, toSet[key]),
        val = (toSet[key] = { value }),
        relation = me.getRelationConfig(key);

      if (!readOnly && !isEqual(field, oldValue, value)) {
        // Indicate to observers that data has changed.
        me.generation++;
        val.oldValue = oldValue;

        changed = true;

        // changing back to old value? remove from modified
        // `modified` should contain mapped field name, it is used in sync
        if (isEqual(field, me.meta.modified[key], value)) {
          delete me.meta.modified[key];
        } else {
          // store info on modification
          me.meta.modified[key] = oldValue;
          if (val.oldValue === undefined && 'oldValue' in val) {
            delete val.oldValue;
          }
        }

        // The wasSet object keys must be the field *name*, not its dataSource.
        wasSet[key] = val;

        // If we don't have a field, but we have a property defined
        // eg, the fullDuration property defined in TaskModel, then
        // use the property
        if (useProp) {
          me[key] = value;
        }
        // Otherwise, push the value through into the data.
        else {
          ObjectHelper.setPath(data, mapping, value);
        }

        // changing foreign key
        if (relation && !fromRelationUpdate) {
          me.initRelation(relation);
          me.stores.forEach((store) => store.cacheRelatedRecord(me, value, relation.relationName, val.oldValue));
        }
      } else {
        delete toSet[key];
      }
    });

    if (changed) {
      me.afterChange(toSet, wasSet, silent);
    }

    return changed ? wasSet : null;
  }

  afterChange(toSet, wasSet, silent) {
    const me = this;

    // TODO: these lines of logic should move to store
    me.stores.forEach((store) => {
      // add or removed from modified
      if (me.isModified) {
        if (!store.modified.includes(me) && !store.added.includes(me)) {
          store.modified.add(me);
          if (store.autoCommit) {
            store.commit();
          }
        }
      } else {
        store.modified.remove(me);
      }
    });

    if (!silent) {
      me.triggerChanges(toSet, wasSet);
    }
  }

  /**
   * True if this model has any uncommitted changes.
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isModified() {
    return Boolean(this.meta.modified && Object.keys(this.meta.modified).length > 0);
  }

  /**
   * Returns true if this model has uncommitted changes for the provided field.
   * @param {String} fieldName Field name
   * @returns {Boolean} True if the field is changed
   */
  isFieldModified(fieldName) {
    return this.isModified && this.meta.modified[fieldName];
  }

  /**
   * Returns field value that should be persisted, or `undefined` if field is configured with `persist: false`.
   * @param {String} name Name of the field to get value
   * @private
   * @category Fields
   */
  getFieldPersistentValue(name) {
    const field = this.getFieldDefinition(name);
    let result;

    if (!field || field.persist) {
      result = this[name];
      // if serialize function is provided we use it to prepare the persistent value
      if (field && field.serialize) {
        result = field.serialize.call(this, result, this);
      }
    }

    return result;
  }

  /**
   * Get modifications in form of an object.
   * @property {Object}
   * @readonly
   * @category Editing
   */
  get modifications() {
    const me = this;

    if (!me.isModified) {
      return null;
    }

    const data = {};
    Object.keys(me.meta.modified).forEach((key) => {
      // TODO: isModified will report record as modified even if a modification wont be persisted here. Should it?
      const value = me.getFieldPersistentValue(key);
      if (value !== undefined) {
        data[key] = value;
      }
    });
    data[me.constructor.idField] = me.id;

    return data;
  }

  /**
   * Get persistable data in form of an object.
   * @property {Object}
   * @internal
   * @readonly
   * @category Editing
   */
  get persistableData() {
    const me = this,
      data = {};

    Object.keys(me.data).forEach((key) => {
      const value = me.getFieldPersistentValue(key);
      if (value !== undefined) {
        data[key] = value;
      }
    });

    return data;
  }

  /**
   * True if this models changes are currently being committed.
   * @property {boolean}
   * @category Editing
   */
  get isCommitting() {
    return Boolean(this.meta.committing);
  }

  /**
   * Clear stored changes, used on commit. Does not revert changes.
   * @param {Boolean} [removeFromStoreChanges] Update related stores modified collection or not
   * @param {Boolean} [includeDescendants] Set true to clear store descendants
   * @category Editing
   * @private
   */
  clearChanges(removeFromStoreChanges = true, includeDescendants = true) {
    const me = this,
      { meta } = me;

    meta.modified = {};
    meta.committing = false;

    if (removeFromStoreChanges) {
      me.stores.forEach((store) => {
        store.modified.remove(me);
        store.added.remove(me);
        if (includeDescendants) {
          const descendants = store.collectDescendants(me).all;
          store.added.remove(descendants);
          store.modified.remove(descendants);
        }
      });
    }
  }

  //endregion

  //region Id

  /**
   * Gets the records internalId. It is assigned during creation, guaranteed to be globally unique among models.
   * @property {Number}
   * @category Identification
   */
  get internalId() {
    return this._internalId;
  }

  /**
   * Returns true if the record is new and has not been persisted (and received a proper id).
   * @property {Boolean}
   * @readonly
   * @category Identification
   */
  get isPhantom() {
    return this.id === '' || this.id == null || this.hasGeneratedId;
  }

  /**
   * Checks if record has a generated id. New records are assigned a generated id (starting with _generated), which should be
   * replaced on commit.
   * @property {Boolean}
   * @category Identification
   */
  get hasGeneratedId() {
    return this.id && typeof this.id === 'string' && this.id.startsWith('_generated');
  }

  /**
   * Generates id for new record which starts with _generated.
   * @category Identification
   */
  generateId() {
    if (!this.constructor.generatedIdIndex) this.constructor.generatedIdIndex = 0;
    return '_generated' + this.$name + ++this.constructor.generatedIdIndex;
  }

  /**
   * Gets the id of specified model or the value if passed string/Number.
   * @param {Common.data.Model|String|Number} model
   * @returns {String|Number} id
   * @category Identification
   */
  static asId(model) {
    return model instanceof Model ? model.id : model;
  }

  //endregion

  //region JSON

  /**
   * Get the records data as a json string.
   * @member {String}
   * @category Misc
   */
  get json() {
    return JSON.stringify(this.data);
  }

  /**
   * Used by JSON.stringify to correctly convert this record to json. No point in calling it directly.
   * @private
   * @category Misc
   */
  toJSON() {
    return this.data;
  }

  //endregion

  //region Batch

  /**
   * True if this Model is currently batching its changes.
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isBatchUpdating() {
    return Boolean(this.batching);
  }

  /**
   * Begin a batch, which stores changes and commits them when the batch ends.
   * Prevents events from being fired during batch.
   * ```
   * record.beginBatch();
   * record.name = 'Mr Smith';
   * record.team = 'Golden Knights';
   * record.endBatch();
   * ```
   * Please note that you can also set multiple fields in a single call using {@link #function-set}, which in many
   * cases can replace using a batch:
   * ```
   * record.set({
   *   name : 'Mr Smith',
   *   team : 'Golden Knights'
   * });
   * ```
   * @category Editing
   */
  beginBatch() {
    const me = this;
    if (!me.batching) {
      me.batching = 0;
      me.meta.batchChanges = {};
    }
    me.batching++;
  }

  /**
   * End a batch, triggering events if data has changed.
   * @param {Boolean} [silent] Specify `true` to not trigger events
   * @category Editing
   */
  endBatch(silent = false) {
    const me = this,
      { parentIdField } = me.constructor;

    if (!me.batching) {
      return;
    }

    me.batching--;

    if (me.batching > 0) {
      return;
    }

    // Set pending batch changes
    if (!ObjectHelper.isEmpty(me.meta.batchChanges)) {
      const batchChanges = Object.assign({}, me.meta.batchChanges);
      me.meta.batchChanges = null;

      // Move to its new parent before applying the other changes.
      if (batchChanges[parentIdField]) {
        me.parentId = batchChanges[parentIdField];
        delete batchChanges[parentIdField];
      }

      me.set(batchChanges, undefined, silent);
      me.cancelBatch();
    }
  }

  /**
   * Cancels current batch operation. Any changes during the batch are discarded.
   * @category Editing
   */
  cancelBatch() {
    this.batching = null;
    this.meta.batchChanges = null;
  }

  //endregion

  //region Events

  /**
   * Triggers beforeUpdate event for each store and checks if changes can be made from event return value.
   * @param {Object} changes Data changes
   * @returns {Boolean} returns true if data changes are accepted
   * @private
   */
  triggerBeforeUpdate(changes) {
    return !this.stores.some((s) => {
      if (s.trigger('beforeUpdate', { record: this, changes }) === false) {
        return true;
      }
    });
  }

  /**
   * Triggers idChange, update and change events for each store.
   * @param {Object} toSet Data to be changed
   * @param {Object} wasSet Actually changed data
   * @private
   */
  triggerChanges(toSet, wasSet) {
    this.stores.forEach((store) => store.onModelChange(this, toSet, wasSet));
  }

  //endregion

  //region Additional functionality

  /**
   * Makes a copy of this model, assigning the specified id or a generated id.
   * @param {Number|String|Object} [newId] Id to set (or config object), leave out to use generated id or specify false to also copy id
   * @param {Number|String} [newId.id] Id to set, leave out to use generated id or specify false to also copy id
   * @param {Boolean} [newId.deep] True to also clone children
   * @returns {Common.data.Model} Copy of this model
   * @category Editing
   */
  copy(newId = null) {
    let data = Object.assign({}, this.data),
      returnInstance = true,
      idField = this.constructor.idField,
      deep,
      id,
      copy;

    if (newId && typeof newId === 'object') {
      deep = newId.deep;
      id = newId.id;

      // Only use id once to avoid collisions
      delete newId.id;
    } else {
      id = newId;
    }

    // Iterate over instance children, because data may not reflect actual children state
    if (deep && this.children) {
      returnInstance = false;
      data.children = this.children.map((child) => child.copy(newId));
    } else {
      delete data.children;
      delete data.expanded;
    }

    if (id) {
      data[idField] = id;
    } else if (id == null) {
      data[idField] = this.generateId();
    }

    if (returnInstance) {
      copy = new this.constructor(data);
    } else {
      copy = data;
    }

    // Store original record internal id to lookup from copy later
    copy.originalInternalId = this.internalId;

    return copy;
  }

  /**
   * Removes this record from all stores (and in a tree structure, also from its parent if it has one).
   * @param {Boolean} [silent] Specify `true` to not trigger events
   * @category Editing
   */
  remove(silent = false) {
    const me = this,
      { parent } = this;

    // Remove from parent if we're in a tree structure.
    // This informs the owning store(s)
    if (parent) {
      parent.removeChild(me);
    }
    // Store handles remove
    else if (me.stores.length) {
      // Not sure what should happen if you try to remove a special row (group row for example), bailing out
      if (!me.meta.specialRow) {
        me.stores.forEach((s) => s.remove(me, silent, false, true));
      }
    }
  }

  /**
   * Get the first store that this model is assigned to.
   * @returns {Common.data.Store}
   * @category Misc
   */
  get firstStore() {
    return this.stores.length > 0 && this.stores[0];
  }

  /**
   * Get a relation config by name, from the first store.
   * @param {String} name
   * @returns {Object}
   * @private
   * @category Relations
   */
  getRelationConfig(name) {
    // using first store for relations, might have to revise later..
    return (
      this.firstStore &&
      this.firstStore.modelRelations &&
      this.firstStore.modelRelations.find((r) => r.fieldName === name)
    );
  }

  //endregion

  //region Validation

  /**
   * Check if record has valid data. Default implementation returns true, override in your model to do actual validation.
   * @returns {Boolean}
   * @category Editing
   */
  get isValid() {
    return true;
  }

  //endregion

  //region Store

  /**
   * Joins this record and any children to specified store, if not already joined.
   * @internal
   * @param {Common.data.Store} store Store to join
   * @category Misc
   */
  joinStore(store) {
    const me = this,
      { stores } = me;

    if (!stores.includes(store)) {
      super.joinStore && super.joinStore(store);
      store.register(me);
      stores.push(store);
      me.isLoaded && me.children.forEach((child) => child.joinStore(store));
      me.initRelations();
    }
  }

  /**
   * Unjoins this record and any children from specified store, if already joined.
   * @internal
   * @param {Common.data.Store} store Store to join
   * @category Misc
   */
  unJoinStore(store) {
    const me = this,
      { stores } = me;

    if (stores.includes(store)) {
      store.unregister(me);
      me.children && me.children.forEach((child) => child.unJoinStore(store));
      stores.splice(stores.indexOf(store), 1);
      super.unJoinStore && super.unJoinStore(store);

      // remove from relation cache
      store.uncacheRelatedRecord(me);
    }
    if (!stores.length) {
      me.meta.removed = true;
    }
  }

  /**
   * Returns true if this record is contained in the specified store, or in any store if store param is omitted.
   * @internal
   * @param {Common.data.Store} store Store to join
   * @returns {Boolean}
   * @category Misc
   */
  isPartOfStore(store) {
    if (store) {
      return store.indexOf(this) >= 0;
    }

    return this.stores.length > 0;
  }
  //endregion

  //region Per instance meta

  /**
   * Used to set per external instance meta data. For example useful when using a record in multiple grids to store some state
   * per grid.
   * @param {String|Object} instanceOrId External instance id or the instance itself, if it has id property
   * @private
   * @category Misc
   */
  instanceMeta(instanceOrId) {
    const { meta } = this,
      id = instanceOrId.id || instanceOrId;
    if (!meta.map) meta.map = {};
    return meta.map[id] || (meta.map[id] = {});
  }

  //endregion
}

Model._idField = 'id';
Model._internalIdCounter = 1;
Model._assignedIdField = false;

Model.exposeProperties();
Model._$name = 'Model';

//inspired by http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/

const base = (baseClass) => ({
  mixes: (...mixins) => {
    return mixins.reduce((result, mixin) => mixin(result), baseClass || Base);
  }
});

/**
 * @module Common/util/Bag
 */

/**
 * A simple collection class to contain unique, keyed items.
 */
class Bag {
  constructor(config) {
    const me = this;

    me.generation = 0;
    me.items = new Set();
    me.idMap = {};
    me.idProperty = 'id';

    if (config) {
      if (config.idProperty) {
        me.idProperty = config.idProperty;
      }
      if (config.values) {
        me.values = config.values;
      }
    }

    me.idProperty = (config && config.idProperty) || 'id';
  }

  /**
   * Returns the item with the passed `id`.
   *
   * @param {*} id The `id` to find.
   * @returns {Object} The found item, or `undefined`.
   */
  get(key) {
    return this.idMap[safeIndexKey(key)];
  }

  /**
   * The number of items in this Bag.
   * @property {Number}
   * @readonly
   */
  get count() {
    return this.items.size;
  }

  /**
   * Adds the passed item(s) to this Bag. Existing items with the same ID
   * will be replaced.
   * @param {Object|Object[]} toAdd Item(s) to add.
   */
  add(toAdd) {
    if (!Array.isArray(toAdd)) {
      toAdd = [toAdd];
    }

    const me = this,
      { items, idMap, idProperty } = me,
      len = toAdd.length;

    for (let i = 0; i < len; i++) {
      const item = toAdd[i],
        key = safeIndexKey(item[idProperty]),
        existingItem = idMap[key];

      // Not already present
      if (existingItem == null) {
        idMap[key] = item;
        items.add(item);
        me.generation++;
      }
      // Already present, replace it if different. No generational change.
      // IDs rule.
      else if (existingItem !== item) {
        idMap[key] = item;
        items.delete(existingItem);
        items.add(item);
      }
    }
  }

  /**
   * Removes the passed item(s) from this Bag.
   * @param {Object|Object[]} toAdd Item(s) to remove.
   */
  remove(toRemove) {
    if (!Array.isArray(toRemove)) {
      toRemove = [toRemove];
    }

    const { items, idMap, idProperty } = this,
      len = toRemove.length;

    for (let i = 0; i < len; i++) {
      const item = toRemove[i],
        key = safeIndexKey(item[idProperty]),
        existingItem = idMap[key];

      // Found natch, so delete it
      if (existingItem != null) {
        items.delete(existingItem);
        delete idMap[key];
        this.generation++;
      }
    }
  }

  clear() {
    this.items.clear();
    this.idMap = {};
    this.generation++;
  }

  /**
   * Change the id of an existing member by mutating its idProperty.
   * @param {String|Number|Object} item The item or id of the item to change.
   * @param {String|Number} newId The id to set in the existing member.
   */
  changeId(item, newId) {
    const me = this,
      { idMap, idProperty } = me,
      oldId = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]),
      member = me.get(oldId);

    if (member) {
      const existingMember = me.get(newId);

      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }

      member[idProperty] = newId;
      delete idMap[oldId];
      idMap[newId] = member;
    }
  }

  /**
   * Returns `true` if this Collection includes an item with the same `id` as the passed item.
   *
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @returns {Boolean} True if the passed item is found.
   */
  includes(item) {
    const key = keyTypes[typeof item] ? item : safeIndexKey(item[this.idProperty]);

    return Boolean(this.idMap[key]);
  }

  /**
   * Extracts the content of this Bag into an array based upon the passed
   * value extraction function.
   * @param {Function} fn A function, which, when passed an item, returns a value to place into the resulting array.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   * @returns {Object[]} An array of values extracted from this Bag.
   */
  map(fn, thisObj) {
    const { items } = this,
      result = new Array(items.size);

    // Set has no map
    let i = 0;
    items.forEach((item) => (result[i] = fn.call(thisObj, item, i, items)));

    return result;
  }

  /**
   * Executes the passed function for each item in this Bag, passing in the item.
   * @param {Function} fn The function to execute.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   */
  forEach(fn, thisObj) {
    return this.items.forEach(fn, thisObj);
  }

  /**
   * Returns the first item in this Bag which elicits a *truthy* return value from the passed funtion.
   * @param {Function} fn A function, which, when passed an item, returns `true` to select it as the item to return.
   * @returns {Object} The matched item, or `undefined`.
   */
  find(fn) {
    for (const div of this.items) {
      if (fn(div)) {
        return div;
      }
    }

    return undefined;
  }

  /**
   * Iterator that allows you to do for (let item of bag)
   */
  [Symbol.iterator]() {
    return this.items[Symbol.iterator]();
  }

  /**
   * The set of values of this Bag.
   *
   * Setting this property replaces the data set.
   * @property {Object[]}
   */
  get values() {
    return [...this.items];
  }

  set values(values) {
    const { generation } = this;

    this.clear();
    this.add(values);
    this.generation = generation + 1;
  }
}
Bag._$name = 'Bag';

/**
 * @module Common/data/mixin/StoreCRUD
 */

/**
 * Mixin for Store that handles modifying records (add, remove etc).
 *
 * @example
 * // add new record to store
 * store.add({ id: 1, team: 'FC Krasnodar' });
 *
 * // remove a record from store, using id
 * store.remove(1);
 *
 * @mixin
 */
var StoreCRUD = (Target) =>
  class StoreCRUD extends (Target || Base) {
    //region Config

    static get defaultConfig() {
      return {
        /**
         * Commit changes automatically
         * @config {Boolean}
         * @default
         * @category Common
         */
        autoCommit: false
      };
    }

    //endregion

    //region Events

    /**
     * Fired after removing all records
     * @event removeAll
     * @param {Common.data.Store} source This Store
     */

    /**
     * Fired before committing changes. Return false from handler to abort commit
     * @event beforeCommit
     * @param {Common.data.Store} source This Store
     * @param {Object} changes Modification data
     */

    /**
     * Fired after committing changes
     * @event commit
     * @param {Common.data.Store} source This Store
     * @param {Object} changes Modification data
     */

    /**
     * Fired before records are removed from this store by the {@link #function-remove} or {@link #function-removeAll}.
     * Also fired when removing a child record in a tree store using {@link Common.data.mixin.TreeNode#function-removeChild}.
     * The remove may be vetoed by returning `false` from a handler.
     * @event beforeRemove
     * @param {Common.data.Store} source This Store
     * @param {Common.data.Model[]} records The records which are to be removed.
     * @param {Common.data.Model} parent The record from which children are being removed when using a tree store
     * @param {Boolean} isMove Set to `true` if the child node is being removed by
     * {@link Common.data.mixin.TreeNode#function-appendChild appendChild} to be moved
     * _within the same tree_.
     */

    /**
     * Fired before records are added to this store by the {@link #function-add} or {@link #function-insert}. In a tree
     * store, also fired by {@link Common.data.mixin.TreeNode#function-appendChild} and
     * {@link Common.data.mixin.TreeNode#function-insertChild}. The add or insert may be vetoed by returning `false`
     * from a handler.
     * @event beforeAdd
     * @param {Common.data.Store} source This Store
     * @param {Common.data.Model[]} records The records which are to be added
     * @param {Common.data.Model} parent The parent node when using a tree store
     * @preventable
     */

    /**
     * Fired after adding/inserting record(s). If the record was added to a parent, the `isChild` flag is set on the
     * event. If it was inserted, event contains `index`
     * @event add
     * @param {Common.data.Store} source This Store
     * @param {Common.data.Model[]} records Added records. In case of tree store, if branch is added, only branch root
     * is returned
     * @param {Common.data.Model[]} [allRecords] Flat list of all added records. In case of tree store, if branch is
     * added, all new records are returned, not only branch root
     * @param {Common.data.Model} [parent] If due to a {@link Common.data.mixin.TreeNode#function-appendChild appendChild}
     * call, this is the parent node added to.
     * @param {Number} [index] Set if record was inserted as opposed to appended/added
     * @param {Number} [oldIndex] Set if inserted record was moved within the store
     * @param {Boolean} [isChild] Flag which is set to true if the record is added to a parent record
     * @param {Boolean} [isExpand] Flag which is set to true if records are added to the store by expanding parent
     * @param {Common.data.Model} [oldParent] Previous parent if this record was moved within a tree structure
     * @param {Boolean} [isMove] Passed as `true` if the add was part of a move operation within this Store.
     */

    /**
     * Fired when a record has been removed
     * @event remove
     * @param {Common.data.Store} source This Store
     * @param {Common.data.Model[]} records Removed records. In case of tree store, if branch is removed, only branch root
     * is returned
     * @param {Common.data.Model[]} [allRecords] Flat list of all removed records. In case of tree store, if branch is
     * removed, all removed records are returned, not only branch root
     * @param {Common.data.Model} [parent] If due to a {@link Common.data.mixin.TreeNode#function-removeChild removeChild}
     * call, this is the parent node removed from.
     * @param {Number} [index] Visible index at which record was removed. In case record is removed from the collapsed
     * branch -1 is returned.
     * @param {Boolean} [isChild] Flag which is set to true if the record is added to a parent record
     * @param {Boolean} [isCollapse] Flag which is set to true if records are removed from the store by collapsing parent
     * @param {Boolean} [isMove] Passed as `true` if the remove was part of a move operation within this Store.
     */
    //endregion

    //region Add, insert & remove

    /**
     * Removes a record from this store.
     * @param {String|String[]|Number|Number[]|Common.data.Model|Common.data.Model[]} records Record/array of records (or record ids) to remove
     * @param {Boolean} silent Specify true to suppress events/autoCommit
     * @returns {Common.data.Model[]} Removed records
     * @fires beforeRemove
     * @fires remove
     * @fires change
     * @category CRUD
     */
    remove(records, silent = false, fromRemoveChild) {
      const me = this;

      // Ensure we have an array of records in case we are passed IDs
      records = (Array.isArray(records) ? records : [records]).reduce((result, r) => {
        r = me.getById(r);
        if (r) {
          result.push(r);
        }
        return result;
      }, []);

      if (records.length) {
        if (me.tree) {
          // In case it's a set of records from different parents, group them by parent
          const removeChildArgs = records.reduce((result, child) => {
            const parent = child.parent;

            if (parent) {
              if (!result[parent.id]) {
                result[parent.id] = [parent, []];
              }
              result[parent.id][1].push(child);
            }
            return result;
          }, {});

          // Remove the records each from their correct parent
          for (const argBlock of Object.values(removeChildArgs)) {
            argBlock[0].removeChild(argBlock[1], false, fromRemoveChild);
          }

          return records;
        }

        // Give chance to veto or take action before records disappear.
        if (!records.length || (!silent && me.trigger('beforeRemove', { records }) === false)) {
          return null;
        }

        if (silent) {
          me.suspendEvents();
        }

        me.storage.remove(records);

        if (silent) {
          me.resumeEvents();
        }

        if (me.autoCommit) {
          me.commit();
        }
      }

      return records;
    }

    /**
     * Clears store data. Used by removeAll, separate function for using with chained stores.
     * @private
     * @category CRUD
     */
    clear(removing = true) {
      const me = this,
        { storage } = me;

      if (me.storage.totalCount) {
        // Give chance to veto or take action before records disappear.
        if (removing && me.trigger('beforeRemove', { records: storage.allValues, removingAll: true }) === false) {
          return null;
        }

        if (!removing) {
          // If !removing, we suspend events, and Store#onDataChange won't get to
          // do all this stuff.
          const allRecords = Object.values(me.idRegister);

          for (let i = allRecords.length - 1, rec; i >= 0; i--) {
            rec = allRecords[i];
            if (rec && !rec.isDestroyed) {
              rec.unJoinStore(me);
            }
          }
          me.removed.clear();
        }

        if (!removing) storage.suspendEvents();
        // Clearing the storage will trigger 'removeAll' and 'change' if `removing`
        storage.clear();
        if (!removing) storage.resumeEvents();

        me.added.clear();
        me.modified.clear();
      }
    }

    /**
     * Removes all records from the store.
     * @param silent
     * @fires removeAll
     * @fires change
     * @category CRUD
     */
    removeAll(silent) {
      const me = this,
        storage = me.storage;

      // No reaction to the storage Collection's change event.
      if (silent) {
        storage.suspendEvents();

        // If silent, the storage Collection won't fire the event we react to
        // to unjoin, and we allow the removing flag in remove() to be true,
        // so *it* will not do the unJoin, so if silent, so do it here.
        const allRecords = Object.values(me.idRegister);

        for (let i = allRecords.length - 1, rec; i >= 0; i--) {
          rec = allRecords[i];
          if (rec && !rec.isDestroyed) {
            rec.unJoinStore(me);
          }
        }
      }

      me.clear();

      if (silent) {
        storage.resumeEvents();
      }
    }

    /**
     * Add records to store.
     * @param {Common.data.Model|Common.data.Model[]|Object|Object[]} records Array of records/data or a single record/data to add to store
     * @param {Boolean} [silent] Specify true to suppress events
     * @returns {Common.data.Model[]} Added records
     * @fires add
     * @fires change
     * @category CRUD
     */
    add(records, silent = false) {
      const me = this,
        storage = me.storage,
        added = [];

      if (!Array.isArray(records)) {
        records = [records];
      } else if (!records.length) {
        // Adding zero records, bail out
        return;
      }

      me.tree = me.tree || Boolean(me.autoTree && records[0].children);

      if (me.tree) {
        return me.rootNode.appendChild(records, silent);
      }

      // Give chance to cancel action before records added.
      if (!silent) {
        if (me.trigger('beforeAdd', { records }) === false) {
          return null;
        }
      }

      records.forEach((data) => {
        added.push(data instanceof Model ? data : me.createRecord(data));
      });

      if (silent) {
        me.suspendEvents();
      }
      storage.add(added);
      if (silent) {
        me.resumeEvents();
      }

      if (me.autoCommit) {
        me.commit();
      }

      return added;
    }

    /**
     * Insert records to store.
     * @param index Index to insert at
     * @param records Record(s) or data to insert
     * @returns {Common.data.Model[]} Inserted records
     * @fires add
     * @fires change
     * @category CRUD
     */
    insert(index, records, silent = false) {
      const me = this,
        storage = me.storage,
        added = [],
        insertBefore = me.getAt(index),
        _records = storage.values,
        removeIndices = [];

      if (!Array.isArray(records)) records = [records];

      // Give chance to cancel action before records added.
      if (me.trigger('beforeAdd', { records }) === false) {
        return null;
      }

      let isNoop, start, i;

      // If the records starting at index or (index - 1), are the same sequence
      // that we are being asked to add, this is a no-op.
      if (_records[(start = index)] === records[0] || _records[(start = index - 1)] === records[0]) {
        for (isNoop = true, i = 0; isNoop && i < records.length; i++) {
          if (records[i] !== _records[start + i]) {
            isNoop = false;
          }
        }
      }
      if (isNoop) {
        return;
      }

      records.forEach((data) => {
        let record = data instanceof Model ? data : me.createRecord(data),
          removedAtIndex = storage.indexOf(record);

        if (record.children && record.children.length && me.autoTree) {
          me.tree = true;
        }

        added.push(record);

        // already in store, do some cleanup
        if (removedAtIndex > -1) {
          if (removedAtIndex < index && insertBefore) index--;
          removeIndices.push(removedAtIndex);
        }

        // Store previous index to be able to determine that it is a move, since Collection does not handle that
        record.meta.previousIndex = removedAtIndex;
      });

      if (me.tree) {
        const root = me.rootNode;

        return root.insertChild(records, root.children && root.children[index]);
      }

      // Silently remove them, so that they will be inserted into place.
      // Collection is stable by default, and inserting an existing item
      // is a no-op.
      me.suspendEvents();
      me.storage.remove(removeIndices);
      me.resumeEvents();

      if (silent) {
        me.suspendEvents();
      }
      storage.splice(index, 0, ...added);
      if (silent) {
        me.resumeEvents();
      }

      if (me.autoCommit) {
        me.commit();
      }

      return added;
    }

    /**
     * Moves an individual item to another location.
     * @param {Object} item The item to move.
     * @param {Object} beforeItem the item to insert the first item before.
     */
    move(item, beforeItem) {
      this.storage.move(item, beforeItem);
    }

    //endregion

    //region Update multiple

    setMultiple(filterFn, field, value) {
      const me = this,
        records = [],
        changes = [];

      me.forEach((r) => {
        if (filterFn(r)) {
          changes.push(r.set(field, value, true));
          records.push(r);
        }
      });

      // TODO: should consolidate with update, make it take an array instead? to only have to listen for one event outside of store?

      me.trigger('updateMultiple', { records, all: me.records.length === records.length });
      me.trigger('change', { action: 'updatemultiple', records, all: me.records.length === records.length });

      if (me.reapplyFilterOnUpdate && me.isFiltered) me.filter();
    }

    setAll(field, value) {
      const me = this,
        changes = [];

      me.forEach((r) => {
        changes.push(r.set(field, value, true));
      });

      me.trigger('updateMultiple', { records: me.records, all: true });
      me.trigger('change', { action: 'updatemultiple', records: me.records, all: true });

      if (me.reapplyFilterOnUpdate && me.isFiltered) me.filter();
    }

    //endregion

    //region Commit

    /**
     * Commits changes, per default only returns changes and resets tracking.
     * @returns {Object} Changes, see Store#changes
     * @fires beforeCommit
     * @fires commit
     * @category CRUD
     */
    commit() {
      // resets stores tracking of changed records, doesn't store changes, only returns them
      const me = this,
        changes = me.changes;

      return me.callPreventable('commit', { changes }, () => {
        me.modified.forEach((r) => r.clearChanges(false));

        me.added.clear();
        me.modified.clear();
        me.removed.clear();

        return changes;
      });
    }

    /**
     * Discards changes in the store.
     * @fires change
     * @category CRUD
     * @private
     */
    // TODO: Need to think of its name. `reject` is a candidate.
    clearChanges() {
      const me = this;

      me.remove(me.added.values, true);
      me.modified.forEach((r) => r.clearChanges(false));

      // TODO: removed records should be restored
      me.added.clear();
      me.modified.clear();
      me.removed.clear();

      me.trigger('change', { action: 'clearchanges' });
    }

    /**
     * Get uncommitted changes as an object of added/modified/removed arrays of records.
     *
     * ```
     * // Format:
     * {
     *      added: [], // array of Common.data.Model
     *      modified: [], // array of Common.data.Model
     *      removed: [] // array of Common.data.Model
     * }
     * ```
     *
     * @property {Object} changes
     * @property {Array} changes.added Records that have been added
     * @property {Array} changes.modified Records that have been updated
     * @property {Array} changes.removed Records that have been removed
     * @readonly
     * @category Records
     */
    get changes() {
      const me = this;

      return me.added.count || me.modified.count || me.removed.count
        ? {
            // Slicing to have changes intact when triggering commit
            added: me.added.values.slice(),
            modified: me.modified.values.slice(),
            removed: me.removed.values.slice()
          }
        : null;
    }

    /**
     * Setting autoCommit to true automatically commits changes to records.
     * @property {Boolean}
     * @category Records
     */
    get autoCommit() {
      return this._autoCommit;
    }

    set autoCommit(auto) {
      this._autoCommit = auto;
      if (auto && this.changes) this.commit();
    }

    //endregion

    //region Changes from other store

    /**
     * Applies changes from another store to this store. Usefull if cloning records in one store to display in a
     * grid in a popup etc. to reflect back changes.
     * @param {Common.data.Store} otherStore
     * @category CRUD
     */
    applyChangesFromStore(otherStore) {
      const me = this,
        changes = otherStore.changes;

      if (!changes) return;

      if (changes.added) {
        me.add(changes.added);
      }

      if (changes.removed) {
        // Remove using id, otherwise indexOf in remove fn won't yield correct result
        me.remove(changes.removed.map((r) => r.id));
      }

      if (changes.modified) {
        changes.modified.forEach((record) => {
          const localRecord = me.getById(record.id);
          localRecord.set(record.modifications);
        });
      }
    }

    //endregion
  };

/**
 * @module Common/data/mixin/StoreFilter
 */

/**
 * Mixin for Store that handles filtering.
 * Filters are instances of {@link Common.util.CollectionFilter CollectionFilter} class.
 *
 * - Adding a filter for the same property will replace the current one (unless a unique {@link Common.util.CollectionFilter#config-id Id} is specified),
 * but will not clear any other filters.
 * - Adding a filter through the {@link #function-filterBy} function is ultimate.
 * It will clear all the property based filters and replace the current filterBy function if present.
 * - Removing records from the store does not remove filters!
 * The filters will be reapplied if {@link #config-reapplyFilterOnAdd}/{@link #config-reapplyFilterOnUpdate} are true and you add new records or update current.
 *
 * ```
 * // Add a filter
 * store.filter({
 *   property : 'score',
 *   value    : 10,
 *   operator : '>'
 * });
 *
 * // Reapply filters
 * store.filter();
 * ```
 *
 * @mixin
 */
var StoreFilter = (Target) =>
  class StoreFilter extends (Target || Base) {
    //region Config

    static get defaultConfig() {
      return {
        /**
         * Specify a filter config to use initial filtering
         * @config {Object}
         * @category Filtering
         */
        filters: null,

        /**
         * Specify true to reapply filters when a record is added to the store.
         * @config {Boolean}
         * @default
         * @category Filtering
         */
        reapplyFilterOnAdd: false,

        /**
         * Specify true to reapply filters when a record is updated in the store.
         * @config {Boolean}
         * @default
         * @category Filtering
         */
        reapplyFilterOnUpdate: false
      };
    }

    //endregion

    //region Events

    /**
     * Fired after applying filters to the store
     * @event filter
     * @param {Common.data.Store} source This Store
     * @param {Common.util.Collection} filters Filters used by this Store
     * @param {Common.data.Model[]} records Filtered records
     */

    //endregion

    //region Properties

    /**
     * Currently applied filters. A collection of {@link Common.util.CollectionFilter} instances.
     * @type {Common.util.Collection}
     * @readonly
     * @category Sort, group & filter
     */
    set filters(filters) {
      const me = this,
        collection = me.filters;

      collection.clear();

      // Invalidate the filtersFunction so that it has to be recalculated upon next access
      me._filtersFunction = null;

      // If we are being asked to filter, parse the filters.
      if (filters) {
        if (filters.constructor.name === 'Object') {
          for (const f of Object.entries(filters)) {
            // Entry keys are either a field name with its value being the filter value
            // or, there may be one filterBy property which specifies a filering function.
            if (f[0] === 'filterBy' && typeof f[1] === 'function') {
              collection.add(
                new CollectionFilter({
                  filterBy: f[1]
                })
              );
            } else {
              collection.add(
                new CollectionFilter(
                  f[1].constructor.name === 'Object'
                    ? Object.assign(
                        {
                          property: f[0]
                        },
                        f[1]
                      )
                    : {
                        property: f[0],
                        value: f[1]
                      }
                )
              );
            }
          }
        } else if (Array.isArray(filters)) {
          // Make sure we are adding CollectionFilters
          collection.add(
            ...filters.map((filterConfig) => {
              if (filterConfig instanceof CollectionFilter) {
                return filterConfig;
              }
              return new CollectionFilter(filterConfig);
            })
          );
        } else if (filters.isCollection) {
          // Use supplied collection? Opting to use items from it currently
          collection.add(...filters.values);
        } else {
          collection.add(
            new CollectionFilter({
              filterBy: filters
            })
          );
        }

        collection.forEach((item) => (item.owner = me));
      }
    }

    get filters() {
      return this._filters || (this._filters = new Collection({ extraKeys: ['property'] }));
    }

    set filtersFunction(filtersFunction) {
      this._filtersFunction = filtersFunction;
    }

    get filtersFunction() {
      const me = this,
        { filters, isGrouped } = me;

      if (!me._filtersFunction) {
        if (filters.count) {
          const generatedFilterFunction = CollectionFilter.generateFiltersFunction(filters);

          me._filtersFunction = (candidate) => {
            // A group record is filtered in if it has passing groupChildren.
            if (isGrouped && candidate.meta.specialRow) {
              return candidate.groupChildren.some(generatedFilterFunction);
            } else {
              return generatedFilterFunction(candidate);
            }
          };
        } else {
          me._filtersFunction = FunctionHelper.returnTrue;
        }
      }

      return me._filtersFunction;
    }

    /**
     * Check if store is filtered
     * @returns {Boolean}
     * @readonly
     * @category Sort, group & filter
     */
    get isFiltered() {
      return this.filters.values.some((filter) => !filter.disabled);
    }

    //endregion

    traverseFilter(record) {
      let me = this,
        hitsCurrent = !record.isRoot && me.filtersFunction(record),
        hitsChild = false,
        children = record.unfilteredChildren || record.children;

      // leaf, bail out
      if (!children || !children.length) {
        return hitsCurrent;
      }

      if (!record.unfilteredChildren) {
        record.unfilteredChildren = record.children.slice();
      }

      record.children = record.unfilteredChildren.filter((r) => {
        return me.traverseFilter(r);
      });

      if (record.children.length) hitsChild = true;

      return hitsCurrent || hitsChild;
    }

    traverseClearFilter(record) {
      const me = this;

      if (record.children) {
        record.children = record.unfilteredChildren || record.children;
        record.children.forEach((r) => me.traverseClearFilter(r));
      }
    }

    // TODO: Get rid of this.
    // The Filter feature of a Grid pokes around in the Store to ask this question.
    get latestFilterField() {
      return this.filters.last ? this.filters.last.property : null;
    }

    processFieldFilter(filter, value) {
      if (typeof filter === 'string') {
        filter = {
          property: filter,
          value: value
        };
      }

      filter = filter instanceof CollectionFilter ? filter : new CollectionFilter(filter);

      // We want notification upon change of field, value or operator
      filter.owner = this;

      // Collection will replace any already existing filter on the field, unless it has id specified
      this.filters.add(filter);
    }

    /**
     * Filters the store by *adding* the specified filter or filters to the existing filters applied to this Store. Call without arguments to reapply filters.
     * ```
     * // Add a filter
     * store.filter({
     *   property : 'age',
     *   operator : '>',
     *   value    : 90
     * });
     *
     * // Reapply filters
     * store.filter();
     * ```
     * @param {String|Object|Object[]|function} field Field name or a filter config or a function to use for filtering
     * @param value Value, used if field is a field name and not a config
     * @fires filter
     * @fires change
     * @category Sort, group & filter
     */
    filter(field, value, silent = false) {
      const me = this,
        { storage, filters, rootNode } = me,
        oldCount = me.count;

      if (field) {
        const fieldType = typeof field;

        // We will not be informed about Filter mutations while configuring.
        me.isConfiguring = true;

        // If we provide array of objects looking like :
        //  {
        //      field : 'fieldName',
        //      value : 'someValue',
        //      [operator : '>']
        //  }
        //  or ...
        //  {
        //      field : 'fieldName',
        //      filterBy : function (value, record) {
        //          return value > 50;
        //      }
        //  }
        if (Array.isArray(field)) {
          // we omit "value" argument in this case
          silent = value;
          field.forEach(me.processFieldFilter, me);
        } else if (fieldType === 'function') {
          me.filters = field;
        } else {
          me.processFieldFilter(field, value);
        }

        // Open up to recieving Filter mutation notifications again
        me.isConfiguring = false;

        // We added a disabled filter to either no filters, or all disabled filters, so no change.
        if (!me.isFiltered) {
          return;
        }
      }

      // Invalidate the filtersFunction so that it has to be recalculated upon next access
      me.filtersFunction = null;

      if (me.tree) {
        if (me.isFiltered) {
          me.traverseFilter(rootNode);
        } else {
          me.traverseClearFilter(rootNode);
        }
        storage.replaceValues(me.collectDescendants(rootNode).visible, true);
      } else {
        if (me.isFiltered) {
          storage.addFilter({
            id: 'primary-filter',
            filterBy: me.filtersFunction
          });
        } else {
          storage.filters.clear();
        }
      }

      me.resetRelationCache();

      if (!silent) {
        me.triggerFilterEvent({ action: 'filter', filters, oldCount, records: me.storage.values });
      }
    }

    get filtered() {
      return this.storage.isFiltered;
    }

    // Used from filter() and StoreCRUD when reapplying filters
    triggerFilterEvent(event) {
      this.trigger('filter', event);
      this.trigger('refresh', event);
      this.trigger('change', event);
    }

    /**
     * Filter store using a function to test each record. Return true from the function to include record in filtered set
     * @param {Function} fn Function used to test records
     * @example
     * store.filterBy(record => record.age > 25 && record.name.startsWith('A'));
     * @category Sort, group & filter
     */
    filterBy(fn) {
      this.filter(fn);
    }

    /**
     * Removes filtering from the specified field.
     * @param {String} field Field to not filter the store on any longer
     * @private
     * @deprecated
     * Only used by the Grid Filtering plugin which assumes one Filter per field.
     * @category Sort, group & filter
     */
    removeFieldFilter(field, silent) {
      const me = this,
        filter = me.filters.getBy('property', field);

      // If we have such a filter, remove it.
      if (filter) {
        me.filters.remove(filter);

        // Invalidate the filtersFunction so that it has to be recalculated upon next access
        me._filtersFunction = null;

        if (!silent) {
          me.filter();
        }
      }
    }

    /**
     * Removes all filters from the store.
     * @category Sort, group & filter
     */
    clearFilters(silent) {
      this.filters.clear();
      this.filter(undefined, undefined, silent);
    }

    convertFilterToString(field) {
      let filter = this.filters.getBy('property', field),
        result = '';

      if (filter && !filter.filterBy) {
        result = String(filter);
      }

      return result;
    }

    get filterState() {
      return this.filters.values.map((filter) => ObjectHelper.cleanupProperties(filter.config));
    }
  };

/**
 * @module Common/data/mixin/StoreGroup
 */

const resortActions = {
  add: 1,
  replace: 1
};

/**
 * Mixin for Store that handles grouping.
 *
 * @example
 * store.group('city');
 *
 * @mixin
 */
var StoreGroup = (Target) =>
  class StoreGroup extends (Target || Base) {
    //region Config

    static get defaultConfig() {
      return {
        /**
         * Initial groupers, specify to have store grouped automatically after initially setting data
         * @config {Object[]}
         * @category Common
         */
        groupers: []
      };
    }

    //endregion

    //region Events

    /**
     * Fired when grouping is stopped
     * @event groupingOff
     * @param {Common.data.Store} source This Store
     */

    //endregion

    //region Init

    construct(config) {
      super.construct(config);

      // For handling record mutation, *not* add/remove of records.
      // Sorts dataset if necessary.
      this.on('change', this.onDataChanged);
    }

    onDataChange({ source: storage, action, removed }) {
      const me = this;
      let records = storage.values;

      // When records are added or removed, re-evaluate the group records
      // so that when the events are fired by the super call, the group
      // records are in place.
      if (me.isGrouped) {
        if (action === 'splice' && removed && removed.length) {
          const { groupRecords } = me,
            // Current collapsed state for groups
            collapsed = {};

          // Remember which groups are collapsed
          if (groupRecords && groupRecords.length) {
            groupRecords.forEach((r) => {
              if (me.expand(r)) {
                collapsed[r.id] = true;
              }
            });
            me.storage.replaceValues(me.removeHeadersAndFooters(me.storage.values), true);
          }

          me.storage.replaceValues(me.prepareGroupRecords(me.storage.values), true);

          // Re-collapse the groups
          Object.keys(collapsed).forEach((id) => me.collapse(me.getById(id)));
        }
      }
      // Remove all group headers and footers
      else {
        storage.replaceValues(me.removeHeadersAndFooters(records), true);
      }

      super.onDataChange && super.onDataChange(...arguments);
    }

    // private function that collapses on the data level
    // TODO: make public and trigger events for grid to react to?
    collapse(groupRecord) {
      if (groupRecord && !groupRecord.meta.collapsed) {
        this.excludeGroupRecords(groupRecord);
        groupRecord.meta.collapsed = true;
        return true;
      }
      return false;
    }

    // private function that expands on the data level
    // TODO: make public and trigger events for grid to react to?
    expand(groupRecord) {
      if (groupRecord && groupRecord.meta.collapsed) {
        this.includeGroupRecords(groupRecord);
        groupRecord.meta.collapsed = false;
        return true;
      }
      return false;
    }

    removeHeadersAndFooters(records) {
      const me = this;

      return records.filter((r) => {
        if (r.meta.specialRow) {
          me.unregister(r);
          return false;
        } else {
          return true;
        }
      }, true);
    }

    prepareGroupRecords(records = this.storage.values) {
      const me = this;

      if (!me.isGrouped) {
        return me.removeHeadersAndFooters(records);
      }

      const groupedRecords = [],
        field = me.groupers[0].field,
        groupRecords = [];

      let curGroup = null,
        curGroupRecord = null,
        childCount = 0;

      function addFooter() {
        const val = curGroupRecord.meta.groupRowFor,
          id = `group-footer-${typeof val === 'number' ? val : StringHelper.createId(val)}`,
          footer =
            me.getById(id) ||
            new me.modelClass({ id }, me, {
              specialRow: true,
              groupFooterFor: val,
              groupRecord: curGroupRecord
            });

        me.register(footer);
        footer.groupChildren = curGroupRecord.groupChildren;
        groupRecords.push(footer);
        groupedRecords.push(footer);
        me.allRecords.push(footer);
        curGroupRecord.groupChildren.push(footer);
        childCount++;
        return footer;
      }

      records.forEach((record) => {
        const val = record[field],
          id = `group-header-${typeof val === 'number' ? val : StringHelper.createId(val)}`;

        // A group header or footer record of an empty group.
        // Remove from the data
        if (record.groupChildren && !record.groupChildren.length) {
          me.unregister(record);
          return;
        }

        if (!ObjectHelper.isEqual(val, curGroup)) {
          if (curGroupRecord) {
            // also add group footer? used by GroupSummary feature
            if (me.useGroupFooters) {
              addFooter(curGroupRecord);
            }

            curGroupRecord.meta.childCount = childCount;
          }

          curGroupRecord =
            me.getById(id) ||
            new me.modelClass({ id }, me, {
              specialRow: true,
              groupRowFor: val,
              groupField: field
            });

          me.register(curGroupRecord);
          curGroupRecord.groupChildren = [];
          groupedRecords.push(curGroupRecord);
          me.allRecords.push(curGroupRecord);
          groupRecords.push(curGroupRecord);
          curGroup = val;
          childCount = 0;
        }

        record.instanceMeta(me.id).groupParent = curGroupRecord;
        groupedRecords.push(record);
        curGroupRecord.groupChildren.push(record);
        childCount++;
      });

      // misses for last group without this
      if (curGroupRecord) {
        curGroupRecord.meta.childCount = childCount;

        // footer for last group
        if (me.useGroupFooters) {
          addFooter();
        }
      }

      me.groupRecords = groupRecords;

      return groupedRecords;
    }

    //endregion

    //region Group and ungroup

    /**
     * Is store currently grouped?
     * @property {Boolean}
     * @readonly
     * @category Sort, group & filter
     */
    get isGrouped() {
      return Boolean(this.groupers.length);
    }

    /**
     * Currently used groupers
     * @readonly
     * @member {Object[]} groupers
     * @category Sort, group & filter
     */

    /**
     * Group records.
     * @param {String} field Field to group by
     * @param {Boolean} ascending Group direction
     * @param {Boolean} add Add grouper (true) or use only this grouper (false)
     * @param {Boolean} performSort Trigger sort directly, which does the actual grouping
     * @param {Boolean} silent True to not fire events
     * @fires group
     * @fires refresh
     * @category Sort, group & filter
     */
    group(field, ascending, add = false, performSort = true, silent = false) {
      const me = this;

      let newGrouper;

      if (add) {
        me.groupers.push(
          (newGrouper = {
            field: field,
            ascending: ascending,
            complexMapping: field.includes('.')
          })
        );
      } else if (field) {
        if (ascending == undefined) {
          ascending = me.groupInfo && me.groupInfo.field === field ? !me.groupInfo.ascending : true;
        }

        me.groupInfo = newGrouper = {
          field: field,
          ascending: ascending,
          complexMapping: field.includes('.')
        };

        me.groupers = [me.groupInfo];
      }

      if (newGrouper) {
        const { prototype } = me.modelClass;

        // Create a getter for complex field names like "get resource.city"
        if (newGrouper.complexMapping && !prototype.hasOwnProperty(field)) {
          Object.defineProperty(prototype, field, {
            get() {
              return ObjectHelper.getPath(this, field);
            }
          });
        }
      }

      // as far as the store is concerned, grouping is just more sorting. so trigger sort
      if (performSort !== false) {
        me.sort(null, null, false, true);
      }

      if (!silent) {
        /**
         * Fired when grouping changes
         * @event group
         * @param {Common.data.Store} source This Store
         * @param {Object[]} groupers Applied groupers
         * @param {Common.data.Model[]} records Grouped records
         */
        me.trigger('group', { isGrouped: me.isGrouped, groupers: me.groupers, records: me.storage.values });
        me.trigger('refresh', {
          action: 'group',
          isGrouped: me.isGrouped,
          groupers: me.groupers,
          records: me.storage.values
        });
      }
    }

    // Internal since UI does not support multi grouping yet
    /**
     * Add a grouping level (a grouper).
     * @param {String} field Field to group by
     * @param {Boolean} ascending Group direction
     * @category Sort, group & filter
     * @internal
     */
    addGrouper(field, ascending = true) {
      this.group(field, ascending, true);
    }

    // Internal since UI does not support multi grouping yet
    /**
     * Removes a grouping level (a grouper)
     * @param {String} field Grouper to remove
     * @category Sort, group & filter
     * @internal
     */
    removeGrouper(field) {
      const me = this,
        index = me.groupers.findIndex((grouper) => grouper.field === field);
      if (index > -1) {
        me.groupers.splice(index, 1);

        me.group();
      }
    }

    /**
     * Removes all groupers, turning store grouping off.
     * @fires groupingOff
     * @category Sort, group & filter
     */
    clearGroupers() {
      const me = this,
        { groupers } = me;

      if (groupers.length) {
        groupers.length = 0;
        me.groupRecords.forEach((r) => {
          if (r.meta.collapsed) {
            me.includeGroupRecords(r);
          }
        });
        me.storage.replaceValues(me.removeHeadersAndFooters(me.storage.values), true);
        me.group(null, null, null, false);
        if ('groupRecords' in me) {
          delete me.groupRecords;
        }
      }
    }

    //endregion

    //region Get and check

    /**
     * Check if a record belongs to a certain group (only for the first grouping level)
     * @param {Common.data.Model} record Record
     * @param groupValue Groups value
     * @returns {Boolean} True if the record belongs to the group, otherwise false
     * @category Sort, group & filter
     */
    isRecordInGroup(record, groupValue) {
      if (!this.isGrouped) return null;

      const me = this,
        groupField = me.groupers[0] && me.groupers[0].field;

      return record[groupField] === groupValue && !record.meta.specialRow;
    }

    /**
     * Returns all records in the group with specified groupValue.
     * @param groupValue
     * @returns {Common.data.Model[]} Records in specified group or null if store not grouped
     * @category Sort, group & filter
     */
    getGroupRecords(groupValue) {
      const me = this;

      if (!me.isGrouped) return null;

      return me.storage.values.filter((record) => me.isRecordInGroup(record, groupValue));
    }

    /**
     * Get all group titles.
     * @returns {String[]} Group titles
     * @category Sort, group & filter
     */
    getGroupTitles() {
      const me = this;

      if (!me.isGrouped) return null;

      return this.getDistinctValues(me.groupers[0] && me.groupers[0].field);
    }

    //endregion

    onDataChanged(event) {
      if (
        this.isGrouped &&
        // If an action flagged as requiring resort is performed...
        ((!event.changes && resortActions[event.action]) ||
          // ...or if the group field has changes...
          (event.changes && this.groupers.some((grouper) => grouper.field in event.changes)))
      ) {
        // ...then resort
        this.sort();
      }
    }

    /**
     * Adds or removes records in a group from storage. Used when expanding/collapsing groups.
     * @private
     * @param {Common.data.Model} groupRecord Group which records should be added or removed
     * @param {Boolean} include Include (true) or exclude (false) records
     * @category Grouping
     */
    internalIncludeExcludeGroupRecords(groupRecord, include) {
      const me = this,
        index = me.indexOf(groupRecord),
        mapId = me.id;

      // prevent removing from already collapsed and vice versa
      if (groupRecord.meta.collapsed && !include) return;
      if (!groupRecord.meta.collapsed && include) return;

      groupRecord.groupChildren.forEach((child) => (child.instanceMeta(mapId).hiddenByCollapse = !include));

      if (include) {
        me.storage.values.splice(index + 1, 0, ...groupRecord.groupChildren);
      } else {
        me.storage.values.splice(index + 1, groupRecord.groupChildren.length);
      }
      me.storage._indicesInvalid = true;
      me._idMap = null;
    }

    /**
     * Removes records in a group from storage. Used when collapsing a group.
     * @private
     * @param groupRecord Group which records should be removed
     * @category Grouping
     */
    excludeGroupRecords(groupRecord) {
      this.internalIncludeExcludeGroupRecords(groupRecord, false);
    }

    /**
     * Adds records in a group to storage. Used when expanding a group.
     * @private
     * @param groupRecord Group which records should be added
     * @category Grouping
     */
    includeGroupRecords(groupRecord) {
      this.internalIncludeExcludeGroupRecords(groupRecord, true);
    }

    /**
     * Collects all group headers + children, whether expanded or not
     * @private
     * @returns {Common.data.Model[]}
     */
    collectGroupRecords() {
      return this.records.reduce((records, record) => {
        if (record.meta.specialRow) {
          records.push(record);

          if ('groupRowFor' in record.meta) {
            records.push.apply(records, record.groupChildren);
          }
        }

        return records;
      }, []);
    }
  };

/**
 * @module Common/data/mixin/StoreRelation
 */

/**
 * Mixin for Store that handles relations with other stores (actually defined on model).
 *
 * @private
 *
 * @mixin
 */
var StoreRelation = (Target) =>
  class StoreRelation extends (Target || Base) {
    //region Init

    /**
     * Initialized relations, called from constructor
     * @private
     */
    initRelations(reset) {
      const me = this,
        relations = me.modelClass.relations;

      if (reset && me.modelRelations) {
        // reset will reinit all relations, stop listening for store events on existing ones
        me.modelRelations.forEach((relation) => {
          if (relation.storeDetacher) relation.storeDetacher();
        });
      }

      if ((!me.modelRelations || me.modelRelations.length === 0 || reset) && relations) {
        me.modelRelations = [];

        // foreignKeys is filled when model exposes its properties
        relations &&
          relations.forEach((modelRelationConfig) => {
            const config = Object.assign({}, modelRelationConfig),
              relatedStore = typeof config.store === 'string' ? me[config.store] : config.store;

            config.dependentStore = me;

            me.modelRelations.push(config);

            if (relatedStore) {
              config.storeProperty = config.store;
              config.store = relatedStore; // repeated from initRelationStores, needed if stored is assigned late

              const dependentStoreConfigs = relatedStore.dependentStoreConfigs;

              // Add link to dependent store
              if (dependentStoreConfigs.has(me)) {
                dependentStoreConfigs.get(me).push(config);
              } else {
                dependentStoreConfigs.set(me, [config]);
              }

              // if foreign key specifies collectionName the related store should also be configured
              if (config.collectionName) {
                relatedStore.initRelationCollection(config, me);
              }

              if (relatedStore.count > 0) {
                relatedStore.updateDependentStores('dataset', relatedStore.records);
              }
            }
          });
      }
    }

    /**
     * Called from other end of an relation when this store should hold a collection of related records.
     * @private
     * @param config
     * @param collectionStore
     */
    initRelationCollection(config, collectionStore) {
      // TODO: parts of this should move to model?
      const me = this,
        name = config.collectionName;

      if (!me.collectionStores) {
        me.collectionStores = {};
      }

      me.collectionStores[name] = {
        store: collectionStore,
        config: config
      };

      if (!me[name + 'Store']) {
        me[name + 'Store'] = collectionStore;
      }

      if (me.count > 0) {
        me.initModelRelationCollection(name, me.records);
      }
    }

    initModelRelationCollection(name, records) {
      const me = this;
      // add collection getter to each model
      records.forEach((record) => {
        // Needs to work in trees also, if not a tree traverse just calls fn on self
        record.traverse((node) => {
          !(name in node) &&
            Object.defineProperty(node, name, {
              enumerable: true,
              get: function() {
                return me.getCollection(this, name);
              },
              set: function(value) {
                return me.setCollection(this, name, value);
              }
            });
        });
      });
    }

    //TODO: Do diff update, this is called on filtering and will be heavy with lots of records

    /**
     * Updates relationCache for all records.
     * @private
     */
    resetRelationCache() {
      this.relationCache = {};
      this.forEach((record) => record.initRelations());
    }

    /**
     * Caches related records from related store on the local store.
     * @private
     * @param record Local record
     * @param relations Relations to related store
     */
    updateRecordRelationCache(record, relations) {
      const me = this;

      relations &&
        relations.forEach((relation) => {
          // use related records id, or if called before "binding" is complete use foreign key
          let foreignId = relation.related ? relation.related.id : record.get(relation.config.fieldName);
          // cache on that id, removing previously cached value if any
          foreignId !== undefined && me.cacheRelatedRecord(record, foreignId, relation.config.relationName, foreignId);
        });
    }

    //endregion

    //region Getters

    /**
     * Returns records from a collection of related records. Not to be called directly, called from Model getter.
     * TODO: Move to Model?
     * @private
     * @param model
     * @param name
     * @returns {*}
     */
    getCollection(model, name) {
      const { config, store } = this.collectionStores[name];

      return (store.relationCache[config.relationName] && store.relationCache[config.relationName][model.id]) || [];
    }

    /**
     * Sets a collection of related records. Will updated the related store and trigger events from it. Not to be called
     * directly, called from Model setter.
     * @private
     */
    setCollection(model, name, records) {
      const { config, store } = this.collectionStores[name];

      if (!store.relationCache[config.relationName]) store.relationCache[config.relationName] = {};

      const old = (store.relationCache[config.relationName][model.id] || []).slice(),
        added = [],
        removed = [];

      store.suspendEvents();

      // Remove any related records not in the new collection
      old.forEach((record) => {
        if (!records.includes(record)) {
          record[config.fieldName] = null;
          store.remove(record);
          removed.push(record);
        }
      });

      // Add records from the new collection not already in store
      records.forEach((record) => {
        if (record instanceof Model) {
          if (!record.stores.includes(store)) {
            store.add(record);
            added.push(record);
          }
        } else {
          [record] = store.add(record);
          added.push(record);
        }

        // Init relation
        record[config.fieldName] = model.id;
      });

      store.resumeEvents();

      if (removed.length) {
        store.trigger('remove', { records: removed });
        store.trigger('change', { action: 'remove', records: removed });
      }

      if (added.length) {
        store.trigger('add', { records: added });
        store.trigger('change', { action: 'add', records: added });
      }
    }

    //endregion

    //region Caching

    /**
     * Adds a record to relation cache, optionally removing it if already there.
     * @private
     * @param record
     * @param id
     * @param name
     * @param uncacheId
     */
    cacheRelatedRecord(record, id, name, uncacheId = null) {
      const me = this,
        cache = me.relationCache[name] || (me.relationCache[name] = {});

      if (uncacheId !== null) {
        me.uncacheRelatedRecord(record, name, uncacheId);
      }

      if (id) {
        // Only include of not already in relation cache, which might happen when removing and re-adding the same instance
        ArrayHelper.include(cache[id] || (cache[id] = []), record);
      }
    }

    /**
     * Removes a record from relation cache, for a specific relation (specifiy relation name and id) or for all relations
     * @private
     * @param record Record to remove from cache
     * @param name Optional, relation name
     * @param id Optional, id
     */
    uncacheRelatedRecord(record, name = null, id = null) {
      const me = this;

      function remove(relationName, relatedId) {
        const cache = me.relationCache[relationName],
          oldCache = cache && cache[relatedId];

        // When unjoining a record from a filtered store the relationCache will also be filtered
        // and might give us nothing, in which case we have nothing to clean up and bail out
        if (oldCache) {
          const uncacheIndex = oldCache.indexOf(record);
          uncacheIndex >= 0 && oldCache.splice(uncacheIndex, 1);

          if (oldCache.length === 0) {
            delete cache[relatedId];
          }
        }
      }

      if (id !== null) {
        remove(name, id);
      } else {
        if (record.meta.relationCache) {
          Object.entries(record.meta.relationCache).forEach(([relationName, relatedRecord]) => {
            const relatedId = relatedRecord && relatedRecord.id;

            remove(relationName, relatedId);
          });
        }
      }
    }

    /**
     * Updates related stores when store is cleared, a record is removed or added.
     * @private
     * @param {String} action
     * @param {Common.data.Model[]} records
     */
    updateDependentStores(action, records) {
      this.dependentStoreConfigs.forEach((configs) => {
        configs.forEach((config) => {
          const dependentStore = config.dependentStore,
            cache = dependentStore.relationCache[config.relationName];

          if (action === 'dataset') {
            config.collectionName && this.initModelRelationCollection(config.collectionName, records);

            dependentStore.forEach((record) => {
              const foreign = record.initRelation(config);
              foreign && dependentStore.cacheRelatedRecord(record, foreign.id, config.relationName, foreign.id);
            });

            return;
          }

          if (action === 'removeall') {
            dependentStore.forEach((record) => {
              record.removeRelation(config);
            });

            delete dependentStore.relationCache[config.relationName];

            return;
          }

          if (action === 'add') {
            config.collectionName && this.initModelRelationCollection(config.collectionName, records);
          }

          if (action === 'add' || action === 'remove') {
            records.forEach((record) => {
              let dependentRecords = cache && cache[record.id];

              switch (action) {
                case 'remove':
                  // removing related record removes from cache on model and store
                  if (dependentRecords) {
                    dependentRecords.forEach((dependentRecord) => dependentRecord.removeRelation(config));
                    // Altered to not delete on self, simplifies taking actions on related records after remove if relation still lives
                    //delete cache[relatedRecord.id];
                  }
                  // TODO: Should removing related set foreign key to null? (removing Team sets Player.teamId to null)
                  break;
                case 'add':
                  // adding a new record in related store checks if any foreign keys match the new id,
                  // and if so it sets up the relation
                  dependentStore.forEach((dependentRecord) => {
                    if (dependentRecord.get(config.fieldName) == record.id) {
                      dependentRecord.initRelation(config);
                      dependentStore.cacheRelatedRecord(dependentRecord, record.id, config.relationName);
                    }
                  });
                  break;
              }
            });
          }
        });
      });
    }

    /**
     * Updates relation cache and foreign key value when a related objects id is changed.
     * @private
     */
    updateDependentRecordIds(oldValue, value) {
      this.dependentStoreConfigs &&
        this.dependentStoreConfigs.forEach((configs) => {
          configs.forEach((config) => {
            const dependentStore = config.dependentStore,
              cache = dependentStore.relationCache[config.relationName],
              localRecords = cache && cache[oldValue] && cache[oldValue].slice();

            localRecords &&
              localRecords.forEach((localRecord) => {
                localRecord.set(config.fieldName, value, false, true);
                dependentStore.cacheRelatedRecord(localRecord, value, config.relationName, oldValue);
              });
          });
        });
    }

    //endregion
  };

/**
 * @module Common/data/mixin/StoreSum
 */

/**
 * Mixin for Store that handles summaries.
 *
 * @mixin
 */
var StoreSum = (Target) =>
  class StoreSum extends (Target || Base) {
    /**
     * Returns sum calculated by adding value of specified field for specified records. Defaults to using all records
     * in store
     * @param {String} field Field to summarize by
     * @param {Common.data.Model[]} records Records to summarize, uses all records if unspecified.
     * @returns {Number}
     */
    sum(field, records = this.storage.values) {
      if (!records) return 0;

      return records.reduce((sum, record) => {
        if (record.meta.specialRow) return sum;
        const v = Number(record[field]);

        return isNaN(v) ? sum : sum + v;
      }, 0);
    }

    /**
     * Returns min value for the specified field. Defaults to look through all records in store
     * @param {String} field Field to find min value for
     * @param {Common.data.Model[]} records Records to process, uses all records if unspecified
     * @returns {Number}
     */
    min(field, records = this.storage.values) {
      if (!records || !records.length) return 0;

      return records.reduce((min, record) => {
        if (record[field] < min) min = record[field];
        return min;
      }, records[0][field]);
    }

    /**
     * Returns max value for the specified field. Defaults to look through all records in store
     * @param {String} field Field to find max value for
     * @param {Common.data.Model[]} records Records to process, uses all records if unspecified
     * @returns {Number}
     */
    max(field, records = this.storage.values) {
      if (!records || !records.length) return 0;

      return records.reduce((max, record) => {
        if (record[field] > max) max = record[field];
        return max;
      }, records[0][field]);
    }

    /**
     * Returns the average value for the specified field. Defaults to look through all records in store
     * @param {String} field Field to calculate average value for
     * @param {Common.data.Model[]} records Records to process, uses all records if unspecified
     * @returns {Number}
     */
    average(field, records = this.storage.values) {
      if (!records || !records.length) return 0;

      let count = 0,
        sum = records.reduce((sum, record) => {
          if (record.meta.specialRow) return sum;
          const v = parseFloat(record[field]);

          if (!isNaN(v)) {
            count++;
            return sum + v;
          } else {
            return sum;
          }
        }, 0);

      return sum / count;
    }

    /**
     * Returns sum by adding value of specified field for records in the group with the specified groupValue.
     * @param groupValue Group to summarize
     * @param {String} field Field to summarize by
     * @returns {Number} Sum or null if store not grouped
     */
    groupSum(groupValue, field) {
      return this.sum(field, this.getGroupRecords(groupValue));
    }
  };

/**
 * @module Common/data/mixin/StoreSearch
 */

const stringFound = (value, find) =>
    String(value)
      .toLowerCase()
      .indexOf(find) !== -1,
  comparisons = {
    string: stringFound,
    number: stringFound,
    boolean: stringFound,
    date: (value, find) => {
      if (value instanceof Date && find instanceof Date) {
        return String(value) === String(find);
      }
      return (
        String(value.getMonth() + 1).indexOf(find) !== -1 ||
        String(value.getDate()).indexOf(find) !== -1 ||
        String(value.getFullYear()).indexOf(find) !== -1
      );
    }
  };

/**
 * Mixin for Store that handles searching (multiple records) and finding (single record).
 *
 * @example
 * // find all records that has a field containing the string john
 * let hits = store.search('john');
 *
 * @mixin
 */
var StoreSearch = (Target) =>
  class StoreSearch extends (Target || Base) {
    //region Search (multiple hits)

    /**
     * Find all hits.
     * @param find Value to search for
     * @param {Object[]} fields Fields to search value in
     * @returns {*} Array of hits, in the format { index: x, data: record }
     */
    search(find, fields = null) {
      const records = this.storage.values,
        len = records.length,
        found = [];

      if (find == null) {
        return null;
      }

      if (typeof find === 'string') {
        find = String(find).toLowerCase();
      }

      let i, record, value, valueType, comparison;

      for (i = 0; i < len; i++) {
        record = records[i];
        for (let key of fields || record.fieldNames) {
          value = record[key];
          valueType = value instanceof Date ? 'date' : typeof value;
          comparison = comparisons[valueType];
          if (value && comparison && comparison(value, find)) {
            found.push({
              index: i,
              data: record,
              field: key,
              id: record.id
            });
          }
        }
      }

      return found;
    }

    /**
     * Find all hits in a column
     * @param field The store field to search in
     * @param value Value to search for
     * @returns {*} Array of hits, in the format { index: x, data: record }
     */
    findByField(field, value) {
      let records = this.storage.values,
        i,
        len = records.length,
        record,
        found = [],
        fieldValue;

      if (value !== null && value !== undefined) {
        value = String(value).toLowerCase();
      }

      for (i = 0; i < len; i++) {
        record = records[i];
        fieldValue = record[field];

        let type = fieldValue instanceof Date ? 'date' : typeof fieldValue;

        let comparison = {
          date: () => Boolean(fieldValue) && fieldValue.toLocaleString().includes(value),
          string: () => Boolean(fieldValue) && fieldValue.toLowerCase().includes(value),
          number: () => typeof fieldValue === 'number' && fieldValue.toString().includes(value),
          object: () => fieldValue === value, // typeof null === object
          undefined: () => fieldValue === value
        };

        if (((value === null || value === undefined) && fieldValue === value) || (value && comparison[type]())) {
          found.push({
            id: record.id,
            index: i,
            data: record
          });
        }
      }

      return found;
    }

    //endregion

    //region Find (single hit)

    /**
     * Finds the first record for which the specified function returns true
     * @param {Function} fn Comparison function, called with record as parameter
     * @returns {Common.data.Model} Record or null if none found
     *
     * @example
     * store.find(record => record.color === 'blue');
     */
    find(fn) {
      return this.storage.values.find(fn);
    }

    /**
     * Finds the first record for which the specified field has the specified value
     * @param {String} fieldName Field name
     * @param {*} value Value to find
     * @returns {Common.data.Model} Record or null if none found
     */
    findRecord(fieldName, value, searchAllRecords = false) {
      const matchFn = (r) => ObjectHelper.isEqual(r[fieldName], value);

      if (this.tree) {
        return this.query(matchFn)[0];
      }
      return (searchAllRecords ? this.storage.allValues : this.storage.values).find(matchFn);
    }

    /**
     * Searches the Store records using the passed function.
     * @param fn A function that is called for each record. Return true to indicate a match
     * @returns {Common.data.Model[]} An array of the matching Records
     */
    query(fn) {
      if (this.isTree) {
        const matches = [];

        this.traverse((node) => {
          if (fn(node)) {
            matches.push(node);
          }
        });
        return matches;
      }

      return this.storage.values.filter(fn);
    }
    //endregion

    //region Others

    /**
     * Returns true if the supplied function returns true for any record in the store
     * @param fn
     * @returns {Boolean}
     *
     * @example
     * store.some(record => record.age > 95); // true if any record has age > 95
     */
    some(fn) {
      return this.storage.values.some(fn);
    }

    //endregion
  };

/**
 * @module Common/data/mixin/StoreSort
 */

/**
 * Mixin for Store that handles simple sorting as well as multi-level sorting.
 *
 * ```javascript
 * // single sorter
 * store.sort('age');
 *
 * // single sorter as object, descending order
 * store.sort({ field : 'age', ascending : false });
 *
 * // multiple sorters
 * store.sort(['age', 'name']);
 *
 * // using locale specific sort (slow)
 * store.sort({ field : 'name', useLocaleSort : 'sv-SE' });
 * ```
 *
 * @mixin
 */
var StoreSort = (Target) =>
  class StoreSort extends (Target || Base) {
    //region Config

    static get defaultConfig() {
      return {
        /**
         * Default sorters, format is [{ field: '', ascending: false }, ...]
         * @config {Object[]|string[]}
         * @category Common
         */
        sorters: [],

        /**
         * Use `localeCompare()` when sorting, which lets the browser sort in a locale specific order. Set to `true`,
         * a locale string or a locale config to enable.
         *
         * Enabling this has big negative impact on sorting
         * performance. For more info on `localeCompare()`, see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
         *
         * Examples:
         *
         * ```javascript
         * const store = new Store({
         *     // Swedish sorting
         *     useLocaleSort : 'sv-SE'
         * });
         *
         * const store = new Store({
         *     // Swedish sorting with custom casing order
         *     useLocaleSort : {
         *         locale    : 'sv-SE',
         *         caseFirst : 'upper'
         *     }
         * });
         * ```
         *
         * Can also be configured on a per sorter basis:
         *
         * ```javascript
         * store.sort({ field: 'name', useLocaleSort : 'sv-SE' });
         * ```
         *
         * @config {Boolean|String|Object}
         * @default false
         */
        useLocaleSort: null
      };
    }

    //endregion

    //region Events

    /**
     * Fired before sorting
     * @event beforeSort
     * @param {Common.data.Store} source This Store
     * @param {Object[]} sorters Sorter configs
     * @param {Common.data.Model[]} records Records to sort
     */

    /**
     * Fired after sorting
     * @event sort
     * @param {Common.data.Store} source This Store
     * @param {Object[]} sorters Sorter configs
     * @param {Common.data.Model[]} records Sorted records
     */

    //endregion

    //region Properties

    /**
     * Currently applied sorters
     * @member {Object[]} sorters
     * @readonly
     * @category Sort, group & filter
     */

    /**
     * Is store sorted?
     * true
     * @property {Boolean}
     * @readonly
     */
    get isSorted() {
      return Boolean(this.sorters.length) || this.isGrouped;
    }

    //endregion

    //region Add & remove sorters

    /**
     * Sort records, either by replacing current sorters or by adding to them. A sorter can specify a custom sorter
     * function which will be called with arguments (ascending, recordA, recordB). Works in the same way as a standard
     * array sorter, except that returning null triggers the stores normal sorting routine.
     * ```
     * store.sort('age');
     * store.sort(['age', 'name']);
     * store.sort({ field: 'age', fn: (a, b, dir) => sorting logic... }
     * store.sort({ field : 'name', useLocaleSort : 'sv-se' });
     * ```
     * @param {String|Object} field Field to sort by (can also be an array of sorters or a config containing a custom sort fn)
     * @param {Boolean} [ascending] Sort order (used only if field specified as string)
     * @param {Boolean} [add] Add a sorter or use only this sorter (used only if field specified as string)
     * @param {Boolean} [silent] Set as true to not fire events
     * @category Sort, group & filter
     * @fires beforeSort
     * @fires sort
     * @fires refresh
     */
    sort(field, ascending, add = false, silent = false) {
      const me = this,
        records = me.allRecords,
        currentSorters = me.sorters.slice();

      let currentDir = null,
        curSort;

      if (field) {
        if (Array.isArray(field)) {
          me.sorters = field.map((sorter) => {
            if (typeof sorter === 'string') return { field: sorter };
            return sorter;
          });
        } else {
          // extract field name if sorting by config object
          const fieldName = typeof field === 'object' ? field.field : field;

          // check if currently sorted by this field
          curSort = me.sorters.find((sorter) => sorter.field === fieldName);

          // sort in opposite direction if not specified and already sorted, default to sorting ascending
          if (ascending === undefined || ascending === null) {
            let sameField =
              curSort &&
              ((typeof field === 'string' && curSort.field === field) ||
                (typeof field === 'object' && curSort.field === field.field));

            ascending = sameField ? !curSort.ascending : true;
          }

          const sorter = {
            field: fieldName,
            ascending: ascending
          };

          if (typeof field === 'object') {
            sorter.fn = field.fn;
            sorter.useLocaleSort = field.useLocaleSort;
          }

          if (add) {
            // Field already among sorters? change sort direction instead of adding new sorter
            if (curSort) {
              currentDir = curSort.ascending;
              curSort.ascending = ascending;
            } else {
              me.sorters.push(sorter);
            }
          } else {
            me.sorters = [sorter];
          }
        }
      }

      if (!silent && me.trigger('beforeSort', { sorters: me.sorters, records, currentSorters }) === false) {
        // Restore sorters
        me.sorters = currentSorters;

        // Restore sorting direction if toggled
        if (currentDir !== null) {
          curSort.ascending = currentDir;
        }

        return;
      }

      me.performSort(silent);

      if (!silent) {
        me.trigger('sort', { sorters: me.sorters, records });
        me.trigger('refresh', { action: 'sort', sorters: me.sorters, records });
      }
    }

    /**
     * Add a sorting level (a sorter).
     * @param {String|Object} field Field to sort by (can also be an array of sorters or a config containing a custom sort fn)
     * @param {Boolean} ascending Sort order (used only if field specified as string)
     * @category Sort, group & filter
     */
    addSorter(field, ascending = true) {
      this.sort(field, ascending, true);
    }

    /**
     * Remove a sorting level (a sorter)
     * @param field Stop sorting by this field
     * @category Sort, group & filter
     */
    removeSorter(field) {
      let me = this,
        sorterIndex = me.sorters.findIndex((sorter) => sorter.field == field);
      if (sorterIndex > -1) {
        me.sorters.splice(sorterIndex, 1);
        me.sort();
      }
    }

    /**
     * Removes all sorters, turning store sorting off.
     * @category Sort, group & filter
     */
    clearSorters() {
      const me = this;

      me.sorters.length = 0;

      me.sort();
    }

    //region

    //region Sorting logic

    /**
     * Creates a function used with Array#sort when sorting the store. Override to use your own custom sorting logic.
     * @param sorters
     * @returns {Function}
     * @category Sort, group & filter
     */
    createSorterFn(sorters) {
      const storeLocaleSort = this.useLocaleSort;

      return (lhs, rhs) => {
        for (let { field, ascending = true, fn = null, useLocaleSort = storeLocaleSort } of sorters) {
          const direction = ascending ? 1 : -1;

          if (fn) {
            const val = fn(lhs, rhs);
            if (val !== null) return val * direction;
          }

          const lhsValue = lhs[field],
            rhsValue = rhs[field];

          if (lhsValue == null) return -direction;
          if (rhsValue == null) return direction;

          if (useLocaleSort) {
            // Use systems locale
            if (useLocaleSort === true) {
              return String(lhsValue).localeCompare(rhsValue) * direction;
            }

            // Use specified locale
            if (typeof useLocaleSort === 'string') {
              return String(lhsValue).localeCompare(rhsValue, useLocaleSort) * direction;
            }

            // Use locale config
            if (typeof useLocaleSort === 'object') {
              return String(lhsValue).localeCompare(rhsValue, useLocaleSort.locale, useLocaleSort) * direction;
            }
          }

          if (lhsValue > rhsValue) return direction;
          if (lhsValue < rhsValue) return -direction;
        }

        return 0;
      };
    }

    /**
     * Internal function that performs the sort
     * @private
     * @category Sort, group & filter
     */
    performSort() {
      const me = this,
        { rootNode, storage, sorters, groupRecords } = me,
        // Current collapsed state for groups
        collapsed = {},
        sorter = me.createSorterFn(me.isGrouped ? me.groupers.concat(sorters) : sorters);

      // Temporarily remove group headers, will be re-added after sort
      if (me.isGrouped && groupRecords && groupRecords.length) {
        groupRecords.forEach((r) => {
          if (r.meta.collapsed) {
            me.includeGroupRecords(r);
            collapsed[r.id] = true;
          }
        });
        storage.replaceValues(me.removeHeadersAndFooters(storage.values), true);
      }

      if (me.tree) {
        rootNode.traverse((node) => {
          if (node.isLoaded && node.isParent) {
            node.children = node.children.sort(sorter);
            // Since child nodes change order their parentIndex needs to be updated
            node.fixChildrensParentIndex();
          }
        });
        storage.replaceValues(me.collectDescendants(rootNode).visible, true);
      } else {
        storage.replaceValues(storage.values.sort(sorter), true);
      }

      me._idMap = null;

      // Apply grouping
      if (me.isGrouped) {
        storage.replaceValues(me.prepareGroupRecords(storage.values), true);

        Object.keys(collapsed).forEach((id) => {
          const groupRecord = me.getById(id);
          if (groupRecord) {
            me.excludeGroupRecords(groupRecord);
            groupRecord.meta.collapsed = true;
          }
        });
      }
    }

    //endregion
  };

// TODO: turn into plugin instead?

/**
 * @module Common/data/mixin/StoreChained
 */

/**
 * A chained Store contains a subset of records from a master store. Which records to include is determined by a
 * filtering function, {@link #config-chainedFilterFn}.
 *
 * @example
 * masterStore.makeChained(record => record.percent < 10);
 *
 * // or
 *
 * new Store({
 *   chained         : true,
 *   masterStore     : masterStore,
 *   chainedFilterFn : record => record.percent < 10
 * });
 *
 * @mixin
 */
var StoreChained = (Target) =>
  class StoreChained extends (Target || Base) {
    //region Config

    static get defaultConfig() {
      return {
        /**
         * Create a chained store, must also specify masterStore and chainedFilterFn
         * @config {Boolean}
         * @default
         * @category Chained store
         */
        chained: false,

        /**
         * Function used to filter records in the masterStore into a chained store
         * @config {Function}
         * @category Chained store
         */
        chainedFilterFn: null,

        /**
         * Array of fields that should trigger filtering of chained store when the fields are updated.
         * @config {String[]}
         * @category Chained store
         */
        chainedFields: null,

        /**
         * Master store that a chained store gets its records from.
         * @config {Store}
         * @category Chained store
         */
        masterStore: null,

        /**
         * Method names calls to which should be relayed to master store.
         * @config {String[]}
         * @category Chained store
         */
        doRelayToMaster: ['add', 'remove', 'insert', 'removeAll'],

        /**
         * Method names calls to which shouldn't be relayed to master store.
         * @config {String}
         * @category Chained store
         */
        dontRelayToMaster: [],

        /**
         * Flag showing whether to keep added/removed uncommitted records when filling the store from master.
         * @config {Boolean}
         * @category Chained store
         */
        keepUncommittedChanges: false
      };
    }

    //endregion

    construct(config) {
      const me = this;

      super.construct(config);

      // TODO: No need for two configs which both mean the same thing. masterStore configured means it's changed.
      if (me.chained) {
        if (!me.masterStore) {
          throw new Error('masterStore required on a chained store');
        }

        me.methodNamesToRelay.forEach((fnName) => (me[fnName] = (...params) => me.relayToMaster(fnName, params)));

        // TODO: prevent other functions?

        me.masterStore.on({
          change: me.onMasterDataChanged,
          prio: 1,
          thisObj: me
        });

        if (!me.masterStore.chainedStores) {
          me.masterStore.chainedStores = [];
        }
        me.masterStore.chainedStores.push(me);

        me.fillFromMaster();
      }
    }

    //region Properties

    /**
     * Is this a chained store?
     * @property {Boolean}
     * @readonly
     * @category Store
     */
    get isChained() {
      return this.chained;
    }

    set chainedFilterFn(chainedFilterFn) {
      this._chainedFilterFn = this.thisObj ? chainedFilterFn.bind(this.thisObj) : chainedFilterFn;
    }

    get chainedFilterFn() {
      return this._chainedFilterFn;
    }

    get methodNamesToRelay() {
      const doIsArray = Array.isArray(this.doRelayToMaster),
        dontIsArray = Array.isArray(this.dontRelayToMaster);

      return (
        (doIsArray && this.doRelayToMaster.filter((name) => !dontIsArray || !this.dontRelayToMaster.includes(name))) ||
        []
      );
    }

    //endregion

    //region Internal

    updateChainedStores() {
      if (this.chainedStores) {
        this.chainedStores.forEach((store) => store.fillFromMaster());
      }
    }

    /**
     * Updates records available in a chained store by filtering the master store records using
     * {@link #config-chainedFilterFn}
     * @internal
     */
    fillFromMaster() {
      const me = this;

      if (!me.chained) {
        throw new Error('fillFromMaster only allowed on chained store');
      }

      if (me.keepUncommittedChanges) {
        me.data = [].concat(
          me.added.values.filter((r) => !me.removed.includes(r)),
          me.masterStore.allRecords.filter(
            (r) => !me.removed.includes(r) && !me.added.includes(r) && me.chainedFilterFn(r)
          )
        );
      } else {
        me.data = me.masterStore.allRecords.filter(me.chainedFilterFn);
      }
    }

    /**
     * Commits changes back to master.
     * - the records deleted from chained store and present in master will be deleted from master
     * - the records added to chained store and missing in master will added to master
     * Internally calls {Store#function-commit commit()}.
     * @returns {Object} Changes, see Store#changes
     * @internal
     */
    commitToMaster() {
      const me = this,
        master = me.masterStore;

      if (!me.chained) {
        throw new Error('commitToMaster only allowed on chained store');
      }

      master.beginBatch();
      master.remove(me.removed.values);
      master.add(me.added.values);
      master.endBatch();

      return me.commit();
    }

    /**
     * Relays some function calls to the master store
     * @private
     */
    relayToMaster(fnName, params) {
      if (fnName === 'remove' && params.length === 4 && params[3] === true) return;
      return this.masterStore[fnName](...params);
    }

    /**
     * Handles changes in master stores data. Updates the chained store accordingly
     * @private
     */
    onMasterDataChanged({ action, changes }) {
      const me = this;

      if (action === 'update') {
        // if a field not defined in chainedFields is changed, ignore the change.
        // there is no need to refilter the store in such cases, the change will be available anyhow since data is
        // shared
        const refilter = me.chainedFields && me.chainedFields.some((field) => field in changes);

        if (!refilter) return;
      }

      me.fillFromMaster();
    }

    //endregion
  };

/**
 * @module Common/data/mixin/StoreState
 */

/**
 * Mixin for Store that handles store states.
 *  * sorters
 *  * groupers
 *  * filters
 * @private
 * @mixin
 */
var StoreState = (Target) =>
  class StoreState extends (Target || Base) {
    /**
     * Get store state. Used by State-plugin to serialize state
     * @private
     * @returns {{ sorters, groupers }}
     */
    getState() {
      const me = this,
        state = {};

      if (me.sorters && me.sorters.length) state.sorters = me.sorters.slice();
      if (me.groupers && me.groupers.length) state.groupers = me.groupers.slice();
      if (me.filters && me.filters.values.length) state.filters = me.filterState;

      return state;
    }

    /**
     * Apply store state. Used by State-plugin to restore a previously serialized state
     * @private
     * @param {{ sorters, groupers }} state
     */
    applyState(state) {
      const me = this;
      if ('sorters' in state) me.sorters = state.sorters.slice();
      if ('groupers' in state) me.groupers = state.groupers.slice();
      if ('sorters' in state || 'groupers' in state) me.sort();

      if ('filters' in state) {
        me.filters = state.filters.slice();
        me.filter();
      }
    }
  };

/**
 * @module Common/data/mixin/StoreTree
 */

/**
 * Mixin for store with tree related functionality. To learn more about working tree nodes please see the {@link Common/data/mixin/TreeNode} class and [this guide](#guides/data/treedata.md).
 * @mixin
 */
var StoreTree = (Target) =>
  class StoreTree extends (Target || Base) {
    //region Getters

    /**
     * True if this Store is configured to handle tree data (with `tree : true`).
     * @property {Boolean}
     * @readonly
     * @category Tree
     */
    get isTree() {
      return this.tree;
    }

    /**
     * Get all leaves in store with tree data
     * @returns {Common.data.Model[]}
     * @category Tree
     */
    get leaves() {
      const me = this,
        result = [];

      if (me.tree) {
        me.traverse((record) => {
          if (record.isLeaf) {
            result.push(record);
          }
        });

        return result;
      } else {
        me.allRecords.forEach((r) => {
          if (r.isLeaf) {
            result.push(r);
          }
          r.traverse((record) => {
            if (record.isLeaf) {
              result.push(record);
            }
          }, true);
        });
      }
      return result;
    }

    //endregion

    //region Children

    /**
     * Loads children for a parent node that uses load on demand (when expanding it). Base implementation does nothing,
     * either use AjaxStore which implements it, create your own subclass with an implementation or listen for
     * `toggleNode` and insert records when you have them available.
     * @param {Common.data.Model} parentRecord
     */
    async loadChildren(parentRecord) {}

    /**
     * Called from Model when adding children. Not to be called directly, use Model#appendChild() instead.
     * @internal
     * @param {Common.data.mixin.TreeNode} parent
     * @param {Common.data.mixin.TreeNode[]} children
     * @param {Number} index
     * @param {Object} isMove
     * @param {Boolean} [silent]
     * @fires add
     * @fires change
     */
    onNodeAddChild(parent, children, index, isMove, silent) {
      const me = this,
        isRootLoad = parent === me.rootNode && parent.isLoading,
        { storage } = me,
        toAddToUI = [],
        toAdd = [],
        previousSibling = children[0].previousSibling;

      let storeInsertionPoint;

      me.collectDescendants(children, toAddToUI, toAdd, !(parent.isExpanded(me) && parent.ancestorsExpanded(me)));

      // Keep CRUD caches up to date unless it's a root load
      if (!isRootLoad && toAdd.length) {
        for (const record of toAdd) {
          // Only considered an add if not modified or moved
          if (!me.modified.includes(record) && !isMove[record.id]) {
            me.added.add(record);
            me.removed.remove(record);
          }
        }
      }

      // Root node inserted first
      if (isRootLoad && me.rootVisible) {
        toAddToUI.unshift(parent);
        toAdd.unshift(parent);
      }

      if (toAddToUI.length) {
        // Calculate the insertion point into the flat store.
        // If the new node is the first, then it goes after the parent node.
        if (index === 0 || !previousSibling) {
          storeInsertionPoint = storage.indexOf(parent);
        }
        // Otherwise it has to go after the previous visible node which has
        // to be calculated. See indexOfPreviousVisibleNode for explanation.
        else {
          storeInsertionPoint = storage.indexOf(previousSibling) + previousSibling.getDescendantCount(true, me);
        }

        // Insert added child nodes at correct location in storage.
        // We must not react to change - we fire the events here.
        storage.suspendEvents();
        me.storage.splice(++storeInsertionPoint, 0, toAddToUI);
        storage.resumeEvents();
      }

      // Since we do not pass through Store#onDataChange we have to handle relations manually here. And since they are
      // not tied to flat part of store, use all children
      me.updateDependentStores('add', children);

      // If it's a root level set data op, then signal 'dataset'
      if (isRootLoad && toAddToUI.length) {
        // If we have initial sorters, perform a silent sort before triggering `dataset`
        // NOTE: Records in toAddToUI will be in the original order, not affected by the sort
        if (me.sorters.length) {
          me.sort(null, null, false, true);
        }

        if (!silent) {
          const event = { action: 'dataset', data: me._data, records: toAddToUI };
          me.trigger('refresh', event);
          me.trigger('change', event);
        }
      }
      // Else, continue as before to signal a bizarre "isChild" add.
      else if (!silent) {
        const event = {
          action: 'add',
          parent,
          isChild: true,
          isMove,
          records: children,
          allRecords: toAdd,
          index: storeInsertionPoint
        };
        me.trigger('add', event);
        me.trigger('change', event);
      }
    }

    onNodeRemoveChild(parent, children, index, isMove) {
      const me = this,
        { storage } = me,
        toRemoveFromUI = [],
        toRemove = [];

      me.collectDescendants(
        children,
        toRemoveFromUI,
        toRemove,
        !(parent.isExpanded(me) && parent.ancestorsExpanded(me))
      );

      if (!isMove) {
        // Unjoin is recursive, use flat children array
        for (let record of children) {
          record.unJoinStore(me);
        }

        // Keep CRUD caches up to date
        if (toRemove.length) {
          for (let record of toRemove) {
            if (record.stores.includes(me)) {
              record.unJoinStore(me);
            }

            // If was newly added, remove from added list
            if (me.added.includes(record)) {
              me.added.remove(record);
            }
            // Else add to removed list
            else {
              me.removed.add(record);
            }
          }
          me.modified.remove(toRemove);
        }
      }

      // Remove removed child nodes at correct location in storage
      if (toRemoveFromUI.length) {
        index = storage.indexOf(toRemoveFromUI[0]);
        // We must not react to change - we fire the events here.
        storage.suspendEvents();
        storage.splice(index, toRemoveFromUI.length);
        storage.resumeEvents();
      } else {
        // If nothing is removed from UI (storage) return -1, showing that removed node was in the collapsed branch
        index = -1;
      }

      const event = { action: 'remove', parent, isChild: true, isMove, records: children, allRecords: toRemove, index };
      me.trigger('remove', event);
      me.trigger('change', event);
    }

    collectDescendants(node, visible = [], all = [], inCollapsedBranch = false) {
      const me = this,
        children = Array.isArray(node) ? node : node.children;

      if (children) {
        for (let i = 0, len = children.length, child; i < len; i++) {
          child = children[i];
          if (!inCollapsedBranch) {
            visible.push(child);
          }
          all.push(child);
          me.collectDescendants(child, visible, all, inCollapsedBranch || !child.isExpanded(me));
        }
      }
      return { visible, all };
    }

    /**
     * Includes or excludes all records beneath parentRecord in storage. Used when expanding or collapsing
     * nodes.
     * @private
     * @param parentRecord Parent record
     * @param include Include (true) or exclude (false)
     * @category Tree
     */
    internalToggleTreeSubRecords(parentRecord, include) {
      const me = this,
        { storage } = me,
        index = storage.indexOf(parentRecord),
        children = [];

      let excludeCount = 0,
        parentCollapsed = -1;

      parentRecord.traverse((child) => {
        const isExpanded = child.isExpanded(me),
          mapMeta = child.instanceMeta(me.id);

        // at new subparent at the same (or lower) level as previous, reset collapsed check
        if (parentCollapsed && child.childLevel <= parentCollapsed) parentCollapsed = -1;
        // records under already collapsed parent wont be processed
        if (parentCollapsed === -1) {
          // at a parent and it is collapsed, store its level for collapsed check
          if (!child.isLeaf && !isExpanded) parentCollapsed = child.childLevel;

          if (include) {
            // if including subrecords, add those who are not hidden by a collapsed sub parent
            children.push(child);
          } else if (!mapMeta.hidden) {
            children.push(child);
            // excluding, only need to count how many visible we have
            excludeCount++;
          }
        }
        mapMeta.hidden = !include;
      }, true);

      // If we expanded a node which is yet to load children, the collected children
      // array will be empty, so do not broadcast any change event.
      // If we are collapsing a record which isn't visible (because parent is collapsed) we won't get an index,
      // which is fine since it is already removed from processedRecords
      if (children.length && index !== false) {
        // We must not react to change - we fire the events here with a flag
        // to tell responders that it's due to an expoand or collapse.
        storage.suspendEvents();

        if (include) {
          storage.splice(index + 1, 0, ...children);

          const event = { action: 'add', isExpand: true, records: children, index: index + 1 };
          me.trigger('add', event);
          me.trigger('change', event);
        } else {
          storage.splice(index + 1, excludeCount);

          const event = { action: 'remove', isCollapse: true, records: children, index: index + 1 };
          me.trigger('remove', event);
          me.trigger('change', event);
        }
        storage.resumeEvents();
      }
    }

    /**
     * Remove all records beneath parentRecord from storage.
     * @private
     * @param parentRecord Parent record
     * @category Tree
     */
    onNodeCollapse(parentRecord) {
      return this.internalToggleTreeSubRecords(parentRecord, false);
    }

    /**
     * Add all records beneath parentRecord from storage.
     * @private
     * @param parentRecord Parent record
     * @category Tree
     */
    onNodeExpand(parentRecord) {
      return this.internalToggleTreeSubRecords(parentRecord, true);
    }

    //endregion
  };

/**
 * @module Common/data/stm/mixin/StoreStm
 */

const STM_PROP$1 = Symbol('STM_PROP');

/**
 * Store mixin to make it compatible with {@link Common.data.stm.StateTrackingManager}.
 * @mixin
 */
var StoreStm = (Target) =>
  class StoreStm extends (Target || Base) {
    static get defaultConfig() {
      return {
        /**
         * Reference to STM manager
         *
         * @config {Common.data.stm.StateTrackingManager}
         * @default
         */
        stm: null
      };
    }

    get stm() {
      return this[STM_PROP$1];
    }

    set stm(stm) {
      const me = this;

      if (me.stm != stm) {
        if (me.stm && me.stm.hasStore(me)) {
          me.stm.removeStore(me);
        }

        me[STM_PROP$1] = stm;

        if (me.stm && !me.stm.hasStore(me)) {
          me.stm.addStore(me);
        }
      }
    }

    /**
     * Overridden to notify STM about flat add action
     *
     * @private
     */
    add(records, silent = false) {
      let result;

      const stm = this.stm;

      // Tree adding is routed via rootNode.appendChild() it has it's own
      // STM override thus if the store is tree we ignore the action
      if (!this.tree && stm && !stm.disabled) {
        // Flat adding here only, the only data needed to undo/redo the action
        // is the list of records added.
        result = super.add(records, silent);
        // If adding wasn't vetoed and something has been added then
        // notifying the STM about the fact.
        if (result && result.length) {
          stm.onStoreModelAdd(this, result, silent);
        }
      } else {
        result = super.add(records, silent);
      }

      return result;
    }

    /**
     * Overridden to notify STM about flat insert action
     *
     * @private
     */
    insert(index, records, silent = false) {
      let result;

      const stm = this.stm;

      // Tree inserting is routed via rootNode.insertChild() it has it's own
      // STM override thus if the store is tree we ignore the action
      if (!this.tree && stm && !stm.disabled) {
        // Flat inserting here only, the only data needed to undo/redo the action is:
        // - the list of record inserted
        // - index they are inserted at
        // - index they have been at if they are part of this store already and are moved

        // Here we are getting indexes of records which are in this store already
        // not all records might be from this store, some might be new or from another store
        const context = (Array.isArray(records) ? records : [records]).reduce((context, r) => {
          const index = r instanceof Model ? this.indexOf(r) : undefined;

          if (index !== undefined && index !== -1) {
            context.set(r, index);
          }

          return context;
        }, new Map());

        // Result here is the array of Models inserted or undefined,
        // and it might be different from `records` we received as argument.
        result = super.insert(index, records);

        // Here we check if anything has been actually inserted.
        // The insertion action might be vetoed by event handler or something
        if (result && result.length) {
          // We can't rely on `index` we've got as argument since `result` might
          // differ from records.
          index = this.indexOf(result[0]);
          // Notifying STM manager about the insertion action providing all
          // the required data to undo/redo.
          stm.onStoreModelInsert(this, index, result, context, silent);
        }
      } else {
        result = super.insert(index, records, silent);
      }

      return result;
    }

    /**
     * Overridden to notify STM about flat removing action
     *
     * @private
     */
    remove(recordsOrIds, silent = false, fromRemoveChild) {
      let result;

      const stm = this.stm;

      // Tree removing is routed via rootNode.removeChild() it has it's own
      // STM override thus if the store is tree we ignore the action
      if (!this.tree && stm && !stm.disabled) {
        // Flat removing here only, the only date needed to undo/redo the actions is:
        // - the list of records removed
        // - their original index to re-insert them back correctly
        const recordsOrIdsNormalized = (Array.isArray(recordsOrIds) ? recordsOrIds : [recordsOrIds])
          .map((r) => this.getById(r))
          .filter((r) => !!r);

        const context = recordsOrIdsNormalized.reduce((context, r) => {
          const index = this.indexOf(r);

          if (index !== undefined && index != -1) {
            context.set(r, index);
          }

          return context;
        }, new Map());

        // Calling original store method
        result = super.remove(recordsOrIds, silent, fromRemoveChild);

        // Here we check if anything has been actually removed.
        // The removing action might be vetoed by event handler or something
        if (result && result.length) {
          stm.onStoreModelRemove(this, result, context, silent);
        }
      } else {
        result = super.remove(recordsOrIds, silent, fromRemoveChild);
      }

      return result;
    }

    /**
     * Overridden to notify STM about flat clear action
     *
     * @private
     */
    removeAll(silent) {
      const stm = this.stm;

      if (stm && !stm.disabled) {
        // Here we are to detect if anything has been removed
        // the only way is to check if store has anything before removing all
        // and has nothing after.
        const allRecords = this.allRecords.slice(0);

        super.removeAll(silent);

        // The trick here is to destinguis tree and flat case
        // For the flat case it's simple we just store all records
        // For the tree we are to store root node children only
        // Upon restoring store.add() will do the right thing for the flat case and tree case regardless.
        if (allRecords.length && this.count === 0) {
          stm.onStoreRemoveAll(this, this.tree ? allRecords[0].children : allRecords, silent);
        }
      } else {
        super.removeAll(silent);
      }
    }
  };

/**
 * @module Common/data/Store
 */

/**
 * The Store represents a data container which holds flat data or tree structures. An item in the Store is often called a ´record´ and it is simply an instance of the
 * {@link Common.data.Model} (or any subclass thereof). Typically you load data into a store to display it in a Grid or a ComboBox. The Store is the backing data component for any component that is showing data in a list style UI.
 *
 * * {@link Grid.view.Grid}
 * * {@link Grid.view.TreeGrid}
 * * {@link Common.widget.List}
 * * {@link Common.widget.Combo}
 *
 * <h3>Data format</h3>
 * Data is store in a JSON array the Store offers an API to edit, filter, group and sort the records.
 *
 * <h3>Store with flat data</h3>
 * To create a flat store simply provide an array of objects that describe your records
 *
 * ```javascript
 * let store = new Store({
 *   data : [
 *     { id : 1, name : 'ABBA', country : 'Sweden' },
 *     { id : 2, name : 'Beatles', country : 'UK' }
 *   ]
 * });
 *
 * // retrieve record by id
 * let beatles = store.getById(2);
 * ```
 *
 * <h3>Store with tree data</h3>
 * To create a tree store use `children` property for descendant records
 *
 * ```javascript
 * let store = new Store({
 *   tree: true,
 *   data : [
 *     { id : 1, name : 'ABBA', country : 'Sweden', children: [
 *       { id: 2, name: 'Agnetha' },
 *       { id: 3, name: 'Bjorn' },
 *       { id: 4, name: 'Benny' },
 *       { id: 5, name: 'Anni-Frid' }
 *     ]},
 *   ]
 * });
 *
 * // retrieve record by id
 * let benny = store.getById(4);
 * ```
 *
 * <h3>Sharing stores</h3>
 * You cannot directly share a Store between widgets, but the data in a Store can be shared. There are two different
 * approaches depending on your needs, sharing data and chaining stores:
 *
 * <h4>Shared data</h4>
 * To create 2 widgets that share data, you can create 2 separate stores and pass records of the first store as the
 * dataset of the second store.
 *
 * ```javascript
 * let combo1 = new Combo({
 *     appendTo : document.body,
 *     store    : new Store({
 *         data : [
 *             { id : 1, name : 'ABBA', country : 'Sweden' },
 *             { id : 2, name : 'Beatles', country : 'UK' }
 *         ]
 *     }),
 *     valueField   : 'id',
 *     displayField : 'name'
 * });
 *
 * let combo2 = new Combo({
 *     appendTo : document.body,
 *     store    : new Store({
 *         data : combo1.store.records
 *     }),
 *     valueField   : 'id',
 *     displayField : 'name'
 * });
 *
 * combo1.store.first.name = 'foo';
 * combo2.store.first.name; // "foo"
 * ```
 *
 * <h4>Chained stores</h4>
 * Another more powerful option to share data between widgets is to create {@link Common.data.mixin.StoreChained chained stores}.
 * The easiest way to create a chained store is to call {@link #function-chain} function.
 *
 * ```javascript
 * let combo1 = new Combo({
 *     appendTo : document.body,
 *     store    : new Store({
 *         data : [
 *             { id : 1, name : 'ABBA', country : 'Sweden' },
 *             { id : 2, name : 'Beatles', country : 'UK' }
 *         ]
 *     }),
 *     valueField   : 'id',
 *     displayField : 'name'
 * });
 *
 * let combo2 = new Combo({
 *     appendTo : document.body,
 *     store    : combo1.store.chain(),
 *     valueField   : 'id',
 *     displayField : 'name'
 * });
 *
 * combo1.store.first.name = 'foo';
 * combo2.store.first.name; // "foo"
 * ```
 *
 * A chained store can optionally be created with a filtering function, to only contain a subset of the records from
 * the main store. In addition, the chained store will reflect record removals/additions to the master store, something
 * the shared data approach will not.
 *
 * @mixes Common/data/mixin/StoreChained
 * @mixes Common/data/mixin/StoreCRUD
 * @mixes Common/data/mixin/StoreFilter
 * @mixes Common/data/mixin/StoreGroup
 * @mixes Common/data/mixin/StoreRelation
 * @mixes Common/data/mixin/StoreSearch
 * @mixes Common/data/mixin/StoreSort
 * @mixes Common/data/mixin/StoreState
 * @mixes Common/data/mixin/StoreSum
 * @mixes Common/data/mixin/StoreTree
 * @mixes Common/mixin/Events
 * @mixes Common/data/stm/mixin/StoreStm
 *
 * @extends Common/Base
 */
class Store extends base(Base).mixes(
  Events,
  Pluggable,
  State,
  StoreFilter,
  StoreCRUD,
  StoreRelation,
  StoreSum,
  StoreSearch,
  StoreSort,
  StoreGroup,
  StoreChained,
  StoreState,
  StoreTree,
  StoreStm
) {
  //region Config & properties

  static get properties() {
    return {
      relationCache: {},
      dependentStoreConfigs: new Map()
    };
  }

  static get defaultConfig() {
    return {
      /**
       * Deprecated in favour of {@link #config-id}
       * @config {String|Number}
       * @deprecated 2.0.0
       */
      storeId: null,

      /**
       * Store's unique identifier. When set the store is added to a store map accessible through Store#getStore(id)
       * @config {String|Number}
       * @category Common
       */
      id: true,

      /**
       * An array of field definitions used to create a Model (modelClass) subclass. Optional. If the Model
       * already has fields defined, these fields will extend those.
       * @config {Object[]}
       * @category Common
       */
      fields: null,

      /**
       * Automatically detect from set data if used as tree store or flat store
       * @config {Boolean}
       * @default
       * @category Tree
       */
      autoTree: true,

      /**
       * Class used to represent records
       * @config {Common.data.Model}
       * @default
       * @category Common
       * @typings { new(data: object): Model }
       */
      modelClass: Model,

      /**
       * Raw data to load initially
       * @config {Object[]}
       * @category Common
       */
      data: null,

      /**
       * `true` to act as a tree store.
       * @config {Boolean}
       * @category Tree
       */
      tree: false,

      callOnFunctions: true,

      /**
       * A {@link Common.util.Collection Collection}, or Collection config object
       * to use to contain this Store's constituent records.
       * @config {Common.util.Collection/Object}
       */
      storage: null
    };
  }

  //endregion

  //region Events

  /**
   * Fired when the id of a record has changed
   * @event idChange
   * @param {Common.data.Store} source This Store
   * @param {Common.data.Model} record Modified record
   * @param {String|Number} oldValue Old id
   * @param {String|Number} value New id
   */

  /**
   * Fired before record is modified in this store.
   * Modification may be vetoed by returning `false` from a handler.
   * @event beforeUpdate
   * @param {Common.data.Store} source This Store
   * @param {Common.data.Model} record Modified record
   * @param {Object} toSet Modification data
   */

  /**
   * Fired when a record is modified
   * @event update
   * @param {Common.data.Store} source This Store
   * @param {Common.data.Model} record Modified record
   * @param {Object} toSet Modification data
   */

  /**
   * Fired when the root node is set
   * @event rootChange
   * @param {Common.data.Store} source This Store
   * @param {Common.data.Model} oldRoot The old root node.
   * @param {Common.data.Model} rootNode The new root node.
   */

  /**
   * Data in the store was changed. This is a catch-all event which is fired for all changes
   * which take place to the store's data.
   *
   * This includes mutation of individual records, adding and removal of records, as well as
   * setting a new data payload using the {@link #property-data} property, sorting, filtering,
   * and calling {@link Common.data.mixin.StoreCRUD#function-removeAll}.
   *
   * Simple databound widgets may use to the `change` event to refresh their UI without having to add multiple
   * listeners to the {@link #event-update}, {@link Common.data.mixin.StoreCRUD#event-add}, {@link Common.data.mixin.StoreCRUD#event-remove}, {@link #event-refresh}
   * and {@link Common.data.mixin.StoreCRUD#event-removeAll} events.
   *
   * A more complex databound widget such as a grid may use the more granular events to perform less
   * destructive updates more appropriate to each type of change. The properties will depend upon the value of the `action` property.
   * @event change
   * @param {Common.data.Store} source This Store.
   * @param {String} action Name of action which triggered the change. May be one of:
   * * `'remove'`
   * * `'removeAll'`
   * * `'add'`
   * * `'updatemultiple'`
   * * `'clearchanges'`
   * * `'filter'`
   * * `'sort'`
   * * `'update'`
   * * `'dataset'`
   * * `'replace'`
   */

  /**
   * Data in the store has completely changed, such as by a filter, or sort or load operation.
   * @event refresh
   * @param {Common.data.Store} source This Store.
   * @param {Boolean} batch Flag set to `true` when the refresh is triggered by ending a batch
   * @param {String} action Name of action which triggered the change. May be one of:
   * * `'dataset'`
   * * `'sort'`
   * * `'filter'`
   * * `'create'`
   * * `'update'`
   * * `'delete'`
   * * `'group'`.
   */

  //endregion

  //region Init

  construct(config = {}) {
    const me = this;

    me.added = new Bag();
    me.removed = new Bag();
    me.modified = new Bag();
    me.idRegister = {};
    me.internalIdRegister = {};
    super.construct(config);

    me.on({
      idChange: me.onRecordIdChange,
      update: me.onUpdateRecord,
      thisObj: me
    });

    me.initRelations();
  }

  doDestroy() {
    const me = this,
      allRecords = Object.values(me.idRegister);

    for (let i = allRecords.length - 1, rec; i >= 0; i--) {
      rec = allRecords[i];
      if (rec && !rec.isDestroyed) {
        rec.unJoinStore(me);
      }
    }

    me.storage.destroy();
    delete Store.storeMap[me.id];

    // Events superclass fires destroy event.
    super.doDestroy();
    //TODO abort any ongoing loads
  }

  /**
   * Stops this store from firing events until {@link #function-endBatch} is called. Multiple calls to `beginBatch`
   * stack up, and will require an equal number of `endBatch` calls to resume events.
   *
   * Upon call of {@link #function-endBatch}, a {@link #event-refresh} event is triggered to allow UIs to
   * update themselves based upon the new state of the store.
   *
   * This is extremely useful when making a large number of changes to a store. It is important not to trigger
   * too many UI updates for performance reasons. Batching the changes ensures that UIs attached to this
   * store are only updated once at the end of the updates.
   */
  beginBatch() {
    this.suspendEvents();
  }

  /**
   * Ends event suspension started by {@link #function-beginBatch}. Multiple calls to {@link #function-beginBatch}
   * stack up, and will require an equal number of `endBatch` calls to resume events.
   *
   * Upon call of `endBatch`, a {@link #event-refresh} event with `action: batch` is triggered to allow UIs to update
   * themselves based upon the new state of the store.
   *
   * This is extremely useful when making a large number of changes to a store. It is important not to trigger
   * too many UI updates for performance reasons. Batching the changes ensures that UIs attached to this
   * store are only updated once at the end of the updates.
   */
  endBatch() {
    if (this.resumeEvents()) {
      this.trigger('refresh', {
        action: 'batch',
        data: this.storage.values,
        records: this.storage.values
      });
    }
  }

  set storage(storage) {
    const me = this;

    if (storage && storage.isCollection) {
      me._storage = storage;
    } else {
      me._storage = new Collection(storage);
    }
    me._storage.autoFilter = me.reapplyFilterOnAdd;

    // Join all the constituent records to this Store
    for (const r of me._storage) {
      r.joinStore(me);
    }
    me._storage.on({
      change: 'onDataChange',
      thisObj: me
    });
  }

  get storage() {
    if (!this._storage) {
      this.storage = {};
    }
    return this._storage;
  }

  get allRecords() {
    const me = this;

    if (me.tree) {
      const result = me.collectDescendants(me.rootNode).all;

      if (me.rootVisible) {
        result.unshift(me.rootNode);
      }
      return result;
    } else {
      return me.isGrouped ? me.collectGroupRecords() : me.storage.allValues;
    }
  }

  /**
   * Responds to mutations of the underlying storage Collection
   * @param {Object} event
   * @private
   */
  onDataChange({ source: storage, action, added, removed, replaced, oldCount, item, from, to }) {
    const me = this,
      addedCount = added && added.length,
      removedCount = removed && removed.length;

    let record, filtersWereReapplied;

    me._idMap = null;

    if (addedCount) {
      added.forEach((added) => {
        added.joinStore(me);
      });
    }

    replaced &&
      replaced.forEach(([oldRecord, newRecord]) => {
        oldRecord.unJoinStore(me);
        newRecord.joinStore(me);
      });

    // Allow mixins to mutate the storage before firing events.
    // StoreGroup does this to introduce group records into the mix.
    super.onDataChange(...arguments);

    // Join/unjoin incoming/outgoing records unless its as a result of TreeNode operations.
    // If we are a tree, joining is done when nodes are added/removed
    // as child nodes of a joined parent.
    if (!me.tree) {
      if (addedCount) {
        for (record of added) {
          record.joinStore(me);
        }
        me.added.add(added);
        me.removed.remove(added);

        // Re-evaluate the current filter set silently so that the information we
        // are broadcasting below is up to date.
        filtersWereReapplied = me.filtered && me.reapplyFilterOnAdd;
        if (filtersWereReapplied) {
          me.filter(null, null, true);
        }
      }
      if (removedCount) {
        for (record of removed) {
          record.unJoinStore(me);

          // If was newly added, remove from added list
          if (me.added.includes(record)) {
            me.added.remove(record);
          }
          // Else add to removed list
          else {
            me.removed.add(record);
          }
        }
        me.modified.remove(removed);

        filtersWereReapplied = me.filtered;
        if (filtersWereReapplied) {
          me.filter(null, null, true);
        }
      }
    }

    switch (action) {
      case 'clear':
        // Clear our own relationCache, since we will be empty
        me.relationCache = {};

        // Signal to stores that depend on us
        me.updateDependentStores('removeall');

        me.trigger('removeAll');
        me.trigger('change', {
          action: 'removeall'
        });
        break;

      case 'splice':
        if (addedCount) {
          me.updateDependentStores('add', added);

          const // Collection does not handle moves, figure out if and where a record was moved from by checking
            // previous index value stored in meta
            oldIndex = added.reduce((lowest, record) => {
              const { previousIndex } = record.meta;
              if (previousIndex > -1 && previousIndex < lowest) lowest = previousIndex;
              return lowest;
            }, added[0].meta.previousIndex),
            index = storage.indexOf(added[0]),
            params = {
              records: added,
              index
            };

          // Only include param oldIndex when used
          if (oldIndex > -1) {
            params.oldIndex = oldIndex;
          }

          me.trigger('add', params);

          me.trigger('change', Object.assign({ action: 'add' }, params));

          if (filtersWereReapplied) {
            me.triggerFilterEvent({ action: 'filter', filters: me.filters, oldCount, records: me.storage.allValues });
          }
        }

        if (removed.length) {
          me.updateDependentStores('remove', removed);

          me.trigger('remove', {
            records: removed
          });
          me.trigger('change', {
            action: 'remove',
            records: removed
          });
        }

        if (replaced.length) {
          // TODO: Remove in 2.2 if no problems til then
          // me.trigger('updateMultiple', {
          //     records : removed,
          //     all     : me.records.length === replaced.length
          // });
          me.trigger('replace', {
            records: replaced,
            all: me.records.length === replaced.length
          });
          me.trigger('change', {
            action: 'replace',
            replaced,
            all: me.records.length === replaced.length
          });
        }
        break;

      case 'filter':
        // Reapply grouping/sorting to make sure unfiltered records get sorted correctly
        if (me.isGrouped) {
          me.group();
        } else if (me.isSorted) {
          me.performSort();
        }
        break;

      case 'move':
        // update parentIndex of records affected
        for (let allRecords = me.storage.allValues, i = Math.min(from, to); i <= Math.max(from, to); i++) {
          allRecords[i].parentIndex = i;
        }

        /**
         * Fired when a record has been moved within this Store
         * @event move
         * @param {Common.data.Store} source This Store
         * @param {Common.data.Model} record The record moved.
         * @param {Number} from The index from which the record was removed.
         * @param {Number} to The index at which the record was inserted.
         */
        me.trigger('move', {
          record: item,
          from,
          to
        });
        me.trigger('change', {
          action,
          record: item,
          from,
          to
        });
    }
  }

  onModelChange(record, toSet, wasSet) {
    const me = this,
      idField = record.constructor.idField;

    if (idField in toSet) {
      const { oldValue, value } = toSet[idField];

      me.updateDependentRecordIds(oldValue, value);

      me.trigger('idChange', {
        store: me,
        record,
        oldValue,
        value
      });
    }
    const event = {
      record,
      changes: wasSet
    };

    if (record.batching != null) {
      event.batch = true;
    }

    me.trigger('update', event);
    me.trigger('change', Object.assign({ action: 'update' }, event));
  }

  get idMap() {
    const me = this,
      processedRecords = me.storage.values,
      needsRebuild = !me._idMap,
      idMap = me._idMap || (me._idMap = {});

    if (needsRebuild) {
      for (let record, index = 0, visibleIndex = 0; index < processedRecords.length; index++) {
        record = processedRecords[index];
        idMap[record.id] = { index, visibleIndex, record };
        if (!record.meta.specialRow) {
          visibleIndex++;
        }
      }
    }
    return idMap;
  }

  /**
   * Class used to represent records. Defaults to class Model.
   * @property {Common.data.Model}
   * @category Records
   * @typings { new(data: object): Model }
   */
  get modelClass() {
    return this._modelClass;
  }

  set modelClass(ClassDef) {
    const fields = this.fields;

    // noinspection JSRedeclarationOfBlockScope
    let ClassDefEx = null;

    // Ensure our modelClass is exchanged for an extended of modelClass decorated with any configured fields.
    if (fields && fields.length) {
      ClassDefEx = class extends ClassDef {
        static get fields() {
          return fields;
        }
      };
    }
    // If we expose properties on Model we will pollute all other models, use internal subclass instead
    else {
      ClassDefEx = class extends ClassDef {};
    }

    // Need to properly expose relations on this new subclass
    ClassDefEx.exposeRelations();

    this._modelClass = ClassDefEx;
  }

  //endregion

  //region Store id & map

  // Deprecated.
  // TODO: Remove in 2.0 when all references have been removed from Scheduler and Gantt
  set storeId(storeId) {
    this.id = storeId;
  }
  get storeId() {
    return this.id;
  }

  /**
   * Get/set id, an unique identifier for the store.
   * Used to build a store map, use Store#getStore() to retrieve a store from the map.
   * @property {String|Number}
   * @category Store
   */
  set id(id) {
    const me = this;

    if (me._id) {
      delete Store.storeMap[me._id];
    }
    me._id = id === true ? IdHelper.generateId('store-') : id;
    if (id) {
      Store.storeMap[id] = me;
    }
  }

  get id() {
    return this._id;
  }

  get tree() {
    return this._tree;
  }

  set tree(tree) {
    this._tree = tree;

    if (tree && !this.rootNode) {
      this.rootNode = this.buildRootNode();
    }
  }

  // a hook to build a customized root node
  buildRootNode() {
    return {};
  }

  /**
   * Get a store from the store map by id.
   * @param {String|Number|Object[]} id The id of the store to retrieve, or an array of objects
   * from which to create the contents of a new Store.
   * @returns {Common.data.Store} The store with the specified id
   */
  static getStore(id, storeClass) {
    if (id instanceof Store) {
      return id;
    }
    if (this.storeMap[id]) {
      return this.storeMap[id];
    }
    if (Array.isArray(id)) {
      let storeModel;

      const storeData = id.map((item) => {
        if (item instanceof Model) {
          storeModel = item.constructor;
        } else if (typeof item === 'string') {
          item = {
            text: item
          };
        }
        return item;
      });

      id = {
        autoCreated: true,
        data: storeData,
        modelClass: storeModel || class extends Model {}
      };
      if (!storeClass) {
        storeClass = Store;
      }
    }
    if (storeClass) {
      return new storeClass(id);
    }
  }

  /**
   * Get all registered stores
   * @returns {Common.data.Store[]}
   */
  static get stores() {
    return Object.values(this.storeMap);
  }

  //endregion

  //region Data

  /**
   * The invisible root node of this tree.
   * @property {Common.data.Model}
   * @readonly
   */
  get rootNode() {
    return this._rootNode;
  }

  set rootNode(rootNode) {
    const me = this,
      oldRoot = me._rootNode;

    // No change
    if (rootNode === oldRoot) {
      return;
    }

    if (oldRoot) {
      me.clear(false);
    }
    if (rootNode instanceof Model) {
      // We insist that the rootNode is expanded otherwise no children will be added
      rootNode.instanceMeta(me).collapsed = false;

      me._rootNode = rootNode;
    } else {
      me._rootNode = rootNode = new me.modelClass(
        Object.assign(
          {
            expanded: true,
            [me.modelClass.idField]: `${me.id}-rootNode`
          },
          rootNode
        ),
        me,
        null,
        true
      );
      rootNode.isAutoRoot = true;
    }
    me._tree = true;
    rootNode.isRoot = true;
    rootNode.joinStore(me);

    // If there are nodes to be inserted into the flat storage
    // then onNodeAddChild knows how to do that and what events
    // to fire based upon rootNode.isLoading.
    if ((rootNode.children && rootNode.children.length) || me.rootVisible) {
      rootNode.isLoading = true;
      me.onNodeAddChild(rootNode, rootNode.children || [], 0);
      rootNode.isLoading = false;
    }

    me.trigger('rootChange', { oldRoot, rootNode });
  }

  /**
   * Sets data in the store, called on initialization if data is in config otherwise call it yourself after
   * ajax call etc. Can also be used to get the raw original data.
   * @property {Object[]}
   * @fires refresh
   * @fires change
   * @category Records
   */
  set data(data) {
    const me = this;

    // Make sure that if the plugins have not been processed yet, we call
    // the temporary property getter which configuration injects to
    // process plugins at this point. Some plugins are required to
    // operate on incoming data.
    me._thisIsAUsedExpression(me.plugins);

    me._data = data;

    // Convert to being a tree store if any of the new rows have a children property
    me.tree =
      !me.chained && (me.tree || Boolean(me.autoTree && data && data.some((r) => r[me.modelClass.childrenField])));

    // This means load the root node
    if (me.tree) {
      const root = me.rootNode;

      // Should signal stores to clear which clears UIs
      root.clearChildren();

      root.isLoading = true;
      // Append child will detect that this is a dataset operation and trigger sort + events needed
      root.appendChild(data);

      me.updateDependentStores('dataset', [root]);

      root.isLoading = false;
    } else {
      me.loadData(data);
    }

    // loading the store discards all tracked changes
    me.added.clear();
    me.removed.clear();
    me.modified.clear();
  }

  loadData(data) {
    const me = this,
      storage = me.storage;

    if (me.allCount) {
      // clear without marking as removed
      me.clear(false);
    }

    me._idMap = null;

    if (data) {
      const isRaw = !(data[0] instanceof Model);

      if (isRaw) {
        me.modelClass.exposeProperties(data[0]);
        const count = data.length,
          records = new Array(count);

        for (let i = 0; i < count; i++) {
          records[i] = me.createRecord(data[i], true);
          records[i].parentIndex = i;
        }
        storage.replaceValues(records, true, true);
      } else {
        storage.replaceValues(data.slice(), true, true);
      }

      me.storage.allValues.forEach((r) => {
        r.joinStore(me);
      });

      // The three operations below, filter, store and sort, all are passed
      // the "silent" parameter meaning they do not fire their own events.
      // The 'refresh' and 'change' events after are used to update UIs.
      if (me.isFiltered) {
        me.filter(null, null, true);
      }

      // TODO: groupers must just be promoted to be the primary sorters.
      if (me.groupers.length > 0 && me.isGrouped) {
        me.group(null, null, false, !me.sorters.length, true);
      }
      if (me.sorters.length) {
        me.sort(null, null, false, true);
      }

      // Check for duplicate ids
      const idMap = me.idMap;
      if (Object.keys(idMap).length < me.storage.values.length) {
        // idMap has fewer entries than expected, a duplicate id was used. pick idMap apart to find out which
        const collisions = [];
        me.storage.values.forEach((r) => (idMap[r.id] ? delete idMap[r.id] : collisions.push(r)));

        throw new Error(`Id collision on ${collisions.map((r) => r.id)}`);
      }

      const event = { action: 'dataset', data, records: me.storage.values };

      me.updateDependentStores(event.action, event.records);

      me.trigger('refresh', event);
      me.trigger('change', event);
    } else {
      me._data = null;
    }
  }

  get data() {
    return this._data;
  }

  /**
   * Creates an array of records from this store from the `start` to the `end' - 1
   * @param {Number} [start] The index of the first record to return
   * @param {Number} [end] The index *after* the last record to return `(start + length)`
   * @return {Common.data.Model[]} The requested records.
   * @category Records
   */
  getRange(start, end, all = true) {
    return (all ? this.storage.allValues : this.storage.values).slice(start, end);
  }

  /**
   * Creates a model instance, used internally when data is set/added. Override this in a subclass to do your own custom
   * conversion from data to record.
   * @param data Json data
   * @param skipExpose Supply true when batch setting to not expose properties multiple times
   * @category Records
   */
  createRecord(data, skipExpose = false) {
    return new this.modelClass(data, this, null, skipExpose);
  }

  refreshData() {
    this.filter();
    this.sort();
  }

  onRecordIdChange({ record, oldValue, value }) {
    const me = this,
      idMap = me._idMap,
      { idRegister } = me;

    me.storage._indicesInvalid = true;

    if (idMap) {
      delete idMap[oldValue];
      idMap[value] = record;
    }
    me.added.changeId(oldValue, value);
    me.removed.changeId(oldValue, value);
    me.modified.changeId(oldValue, value);

    delete idRegister[oldValue];
    idRegister[value] = record;

    record.index = me.storage.indexOf(record);
  }

  onUpdateRecord({ record, changes }) {
    const { internalId } = changes,
      { internalIdRegister } = this;

    if (internalId) {
      this.storage._indicesInvalid = true;
      delete internalIdRegister[internalId.oldValue];
      internalIdRegister[internalId.value] = record;
    }

    // Reapply filters when records change?
    if (this.reapplyFilterOnUpdate && this.isFiltered) {
      this.filter();
    }
  }

  //endregion

  //region Count

  /**
   * Number of records in the store
   * @param countProcessed Count processed (true) or real records (false)
   * @returns {Number} Record count
   * @category Records
   */
  getCount(countProcessed = true) {
    return countProcessed ? this.count : this.originalCount;
  }

  /**
   * Record count, for data records. Not including records added for group headers etc.
   * @property {Number}
   * @readonly
   * @category Records
   */
  get originalCount() {
    return this.storage.totalCount;
  }

  /**
   * Record count, including records added for group headers etc.
   * @property {Number}
   * @readonly
   * @category Records
   */
  get count() {
    return this.storage.count;
  }

  get allCount() {
    return this.tree ? this.rootNode.descendantCount : this.storage.totalCount;
  }

  //endregion

  //region Get record(s)

  /**
   * Returns all "visible" records
   * @property {Common.data.Model[]}
   * @readonly
   * @category Records
   */
  get records() {
    return this.storage.values;
  }

  /**
   * Get the first record in the store.
   * @property {Common.data.Model}
   * @readonly
   * @category Records
   */
  get first() {
    return this.storage.values[0];
  }

  /**
   * Get the last record in the store.
   * @property {Common.data.Model}
   * @readonly
   * @category Records
   */
  get last() {
    return this.storage.values[this.storage.values.length - 1];
  }

  /**
   * Get the record at the specified index
   * @param {Number} index Index for the record
   * @returns {Common.data.Model} Record at the specified index
   * @category Records
   */
  getAt(index, all = false) {
    // all means include filtered out records
    return this.storage.getAt(index, all);
  }

  // These are called by Model#join and Model#unjoin
  // register a record as a findable member keyed by id and internalId
  register(record) {
    const me = this,
      // Test for duplicate IDs on register only when a tree store.
      // loadData does it in the case of a non-tree
      existingRec = me.tree && me.idRegister[record.id];

    if (existingRec && existingRec !== record) {
      throw new Error(`Id collision on ${record.id}`);
    }
    me.idRegister[record.id] = record;
    me.internalIdRegister[record.internalId] = record;
  }
  unregister(record) {
    delete this.idRegister[record.id];
    delete this.internalIdRegister[record.internalId];
  }

  /**
   * Get a record by id. Find the record even if filtered out, part of collapsed group or collapsed node
   * @param {Common.data.Model|String|Number} id Id of record to return.
   * @returns {Common.data.Model} A record with the specified id
   * @category Records
   */
  getById(id) {
    // In case `id` is a record, we use its ID to try to find the record in the store,
    // because if the record is removed from the store it shouldn't be found.
    // if (id instanceof Model) {
    //     id = id.id;
    // }

    if (id instanceof Model) {
      return id;
    }

    //return this.tree ? this.idRegister[id] : this.storage.get(id);
    return this.idRegister[id];
  }

  /**
   * Checks if a record is visible, in the sense that it is not filtered out,
   * hidden in a collapsed group or in a collapsed node.
   * Deprecated in 2.2.3, please use {@link #function-isAvailable} instead
   * @param {Common.data.Model|String|Number} recordOrId Record to check
   * @returns {Boolean}
   * @deprecated 2.2.3
   */
  isVisible(recordOrId) {
    return this.storage.includes(this.getById(recordOrId));
  }

  /**
   * Checks if a record is available, in the sense that it is not filtered out,
   * hidden in a collapsed group or in a collapsed node.
   * @param {Common.data.Model|String|Number} recordOrId Record to check
   * @returns {Boolean}
   */
  isAvailable(recordOrId) {
    return this.storage.includes(this.getById(recordOrId));
  }

  /**
   * Get a record by internalId.
   * @param {Number} internalId The internalId of the record to return
   * @returns {Common.data.Model} A record with the specified internalId
   * @category Records
   */
  getByInternalId(internalId) {
    return this.internalIdRegister[internalId];
  }

  /**
   * Checks if the specified record is contained in the store
   * @param {Common.data.Model|String|Number} recordOrId Record, or `id` of record
   * @returns {Boolean}
   * @category Records
   */
  includes(recordOrId) {
    if (this.tree) {
      return this.idRegister[Model.asId(recordOrId)] != null;
    }

    return this.indexOf(recordOrId) > -1;
  }

  //endregion

  //region Get index

  /**
   * Returns the index of the specified record or record id.
   * @param {Common.data.Model|String|Number} recordOrId Record, or `id` of record to return the index of.
   * @param {Boolean} [visibleRecords] Pass `true` to find the visible index
   * as opposed to the dataset index. This omits group header records.
   * @returns {Number} Index for the record/id, or `undefined` if not found.
   * @category Records
   */
  indexOf(recordOrId, visibleRecords = false) {
    if (recordOrId instanceof Model) {
      recordOrId = recordOrId.id;
    }
    if (!recordOrId) {
      return -1;
    }

    // When a tree, indexOf is always in the visible records - filtering is different in trees.
    if (this.tree) {
      return this.storage.indexOf(recordOrId);
    } else {
      const found = this.idMap[recordOrId];

      return found ? found[visibleRecords ? 'visibleIndex' : 'index'] : -1;
    }
  }

  allIndexOf(recordOrId) {
    if (this.tree) {
      let result = -1;
      const record = recordOrId instanceof Model ? recordOrId : this.getById(recordOrId);

      // Use the tree structure to get the index in tree walk order
      if (record) {
        record.bubble((n) => {
          if (n.parent) {
            result += n.parentIndex + 1;
          } else if (n === this.rootNode && this.rootVisible) {
            result += 1;
          }
        });
      }
      return result;
    } else {
      return this.storage.indexOf(recordOrId, true);
    }
  }

  //endregion

  //region Get values

  /**
   * Gets distinct values for the specified field.
   * @param field Field to extract values for
   * @returns {Array} Array of values
   * @category Values
   */
  getDistinctValues(field) {
    const me = this,
      values = [],
      keys = {};
    let value;

    me.forEach((r) => {
      if (!r.meta.specialRow && !r.isRoot) {
        value = r.get(field);
        if (!keys[value]) {
          values.push(value);
          keys[value] = 1;
        }
      }
    });

    return values;
  }

  /**
   * Counts how many times specified value appears in the store
   * @param field Field to look in
   * @param value Value to look for
   * @returns {Number} Found count
   * @category Values
   */
  getValueCount(field, value) {
    let me = this,
      count = 0;

    me.forEach((r) => {
      if (ObjectHelper.isEqual(r.get(field), value)) count++;
    });

    return count;
  }

  //endregion

  //region JSON & console

  get json() {
    return JSON.stringify(this, null, 4);
  }

  toJSON() {
    // extract entire structure.
    // If we're a tree, then that consists of the payload of the rootNode.
    return (this.tree ? this.rootNode.children : this).map((record) => record.toJSON());
  }

  //endregion

  //region Iteration & traversing

  /**
   * Iterates over all normal records in store. Omits group header and footer records
   * if this store is grouped.
   * @param {Function} fn A function that is called for each record. Returning false from that function cancels iteration
   * @param {Object} thisObj `this` reference for the function
   * @category Iteration
   */
  forEach(fn, thisObj = this) {
    const callback = (r, i) => {
      if (!r.isRoot && !r.meta.specialRow) {
        return fn.call(thisObj, r, i);
      }
    };

    if (this.tree) {
      this.rootNode.traverseWhile(callback);
    } else {
      // native forEach cannot be aborted by returning false, have to loop "manually"
      const records = this.storage.values;
      for (let i = 0; i < records.length; i++) {
        if (callback(records[i], i) === false) {
          return;
        }
      }
    }
  }

  /**
   * Equivalent to Array.map(). Creates a new array with the results of calling a provided function on every record
   * @param {Function} fn
   * @returns {Array}
   * @category Iteration
   */
  map(fn, thisObj = this) {
    return this.storage.values.map(fn, thisObj);
  }

  /**
   * Equivalent to Array.reduce(). Applies a function against an accumulator and each record (from left to right) to
   * reduce it to a single value.
   * @param {Function} fn
   * @param initialValue
   * @returns {*}
   * @category Iteration
   */
  reduce(fn, initialValue = [], thisObj = this) {
    if (thisObj !== this) {
      fn = fn.bind(thisObj);
    }

    return this.storage.values.reduce(fn, initialValue, thisObj);
  }

  /**
   * Iterator that allows you to do for (let record of store)
   * @category Iteration
   */
  [Symbol.iterator]() {
    return this.storage.values[Symbol.iterator]();
  }

  /**
   * Traverse all tree nodes
   * @param {Function} fn
   * @category Traverse
   */
  traverse(fn) {
    if (this.tree) {
      this.rootNode.traverse(fn, true);
    } else {
      for (let record of this.storage) {
        record.traverse(fn);
      }
    }
  }

  /**
   * Finds the next record.
   * @param recordOrId Current record or its id
   * @param {Boolean} wrap Wrap at start/end or stop there
   * @returns {Common.data.Model} Next record or null if current is the last one
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @category Traverse
   */
  getNext(recordOrId, wrap = false, skipSpecialRows = false) {
    let me = this,
      records = me.storage.values,
      idx = me.indexOf(recordOrId);

    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }

    const record = records[idx + 1];

    // Skip the result if it's a specialRow and we are told to skip them
    if (skipSpecialRows && record && record.meta.specialRow) {
      return me.getNext(records[idx + 1], wrap, true);
    }

    return record;
  }

  /**
   * Finds the previous record.
   * @param recordOrId Current record or id
   * @param {Boolean} wrap Wrap at start/end or stop there
   * @returns {Common.data.Model} Previous record or null if current is the last one
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @category Traverse
   */
  getPrev(recordOrId, wrap = false, skipSpecialRows = false) {
    let me = this,
      records = me.storage.values,
      idx = me.indexOf(recordOrId);

    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }

    const record = records[idx - 1];

    // Skip the result if it's a specialRow and we are told to skip them
    if (skipSpecialRows && record && record.meta.specialRow) {
      return me.getNext(records[idx + 1], wrap, true);
    }

    return record;
  }

  /**
   * Gets the next or the previous record. Optionally wraps from first -> last and vice versa
   * @param {String|Model} recordOrId Record or records id
   * @param {Boolean} next Next (true) or previous (false)
   * @param {Boolean} wrap Wrap at start/end or stop there
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @returns {Common.data.Model}
   * @category Traverse
   * @internal
   */
  getAdjacent(recordOrId, next = true, wrap = false, skipSpecialRows = false) {
    return next ? this.getNext(recordOrId, wrap, skipSpecialRows) : this.getPrev(recordOrId, wrap, skipSpecialRows);
  }

  /**
   * Finds the next record among leaves (in a tree structure)
   * @param recordOrId Current record or its id
   * @param {Boolean} wrap Wrap at start/end or stop there
   * @returns {Common.data.Model} Next record or null if current is the last one
   * @category Traverse
   * @internal
   */
  getNextLeaf(recordOrId, wrap = false) {
    let me = this,
      records = me.leaves,
      record = me.getById(recordOrId),
      idx = records.indexOf(record);

    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }

    return records[idx + 1];
  }

  /**
   * Finds the previous record among leaves (in a tree structure)
   * @param recordOrId Current record or id
   * @param {Boolean} wrap Wrap at start/end or stop there
   * @returns {Common.data.Model} Previous record or null if current is the last one
   * @category Traverse
   * @internal
   */
  getPrevLeaf(recordOrId, wrap = false) {
    let me = this,
      records = me.leaves,
      record = me.getById(recordOrId),
      idx = records.indexOf(record);

    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }

    return records[idx - 1];
  }

  /**
   * Gets the next or the previous record among leaves (in a tree structure). Optionally wraps from first -> last and
   * vice versa
   * @param {String/Model} recordOrId Record or records id
   * @param {Boolean} next Next (true) or previous (false)
   * @param {Boolean} wrap Wrap at start/end or stop there
   * @returns {Common.data.Model}
   * @category Traverse
   * @internal
   */
  getAdjacentLeaf(recordOrId, next = true, wrap = false) {
    return next ? this.getNextLeaf(recordOrId, wrap) : this.getPrevLeaf(recordOrId, wrap);
  }

  //endregion

  //region Chained store

  /**
   * Creates a chained store, a new Store instance that contains a subset of the records from current store.
   * Which records is determined by a filtering function, which is reapplied when data in the base store changes.
   * @param {Function} chainedFilterFn Function called for each records that determines if it should be included
   * (return true) or not (return false). Defaults to including all records (fn always returning true)
   * @param {String[]} chainedFields Array of fields that trigger filtering when they are updated
   * @param {Object} config Additional chained store configuration
   * @returns {Common.data.Store}
   * @example
   * let oldies = store.makeChained(record => record.age > 40);
   */
  makeChained(chainedFilterFn = () => true, chainedFields, config) {
    return new this.constructor(
      Object.assign(config || {}, {
        chained: true,
        tree: false,
        autoTree: false,
        masterStore: this,
        chainedFilterFn,
        chainedFields
      })
    );
  }

  /**
   * Alias for {@link #function-makeChained}
   * @param {Function} chainedFilterFn Function called for each records that determines if it should be included
   * (return true) or not (return false). Defaults to including all records (fn always returning true)
   * @param {String[]} chainedFields Array of fields that trigger filtering when they are updated
   * @param {Object} config Additional chained store configuration
   * @returns {Common.data.Store}
   */
  chain() {
    return this.makeChained(...arguments);
  }

  //endregion
}

Store.storeMap = {};
Store._$name = 'Store';

//TODO: label should be own element

/**
 * @module Common/widget/TextField
 */

/**
 * Textfield widget. Wraps native &lt;input type="text"&gt;
 *
 * @extends Common/widget/Field
 *
 * @example
 * let textField = new TextField({
 *   placeholder: 'Enter some text'
 * });
 *
 * @classType textfield
 * @externalexample widget/TextField.js
 */
class TextField extends Field {
  inputTemplate() {
    const me = this,
      style = 'inputWidth' in me ? `style="width:${DomHelper.setLength(me.inputWidth)}"` : '';

    return TemplateHelper.tpl`<input type="${me.inputType || 'text'}"
            reference="input"
            class="${me.inputCls || ''}"
            placeholder="${me.placeholder}" 
            autocomplete="${me.autoComplete}"
            name="${me.name || me.id}"
            id="${me.id + '_input'}"
            ${style}/>`;
  }

  set value(value) {
    super.value = this.$name === 'TextField' && value == null ? '' : value;
  }

  get value() {
    return super.value;
  }
}

TextField._$name = 'TextField';
BryntumWidgetAdapterRegister.register('textfield', TextField);
BryntumWidgetAdapterRegister.register('text', TextField);

/**
 * @module Common/widget/PickerField
 */

/**
 * Base class used for {@link Common.widget.Combo Combo}, {@link Common.widget.DateField DateField}, and {@link Common.widget.TimeField TimeField}.
 * Displays a picker ({@link Common.widget.List List}, {@link Common.widget.DatePicker DatePicker}) anchored to the field.
 * Not intended to be used directly
 *
 * When focused by means of *touch* tapping on the trigger element (eg, the down arrow on a Combo)
 * on a tablet, the keyboard will not be shown by default to allow for interaction with the dropdown.
 *
 * A second tap on the input area will then show the keyboard is required.
 *
 * @extends Common/widget/TextField
 * @abstract
 */
class PickerField extends TextField {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * User can edit text in text field (otherwise only pick from attached picker)
       * @config {Boolean}
       * @default
       */
      editable: true,

      /**
       * The name of the element property to which the picker should size and align itself.
       * @config {String}
       * @default element
       */
      pickerAlignElement: 'inputWrap',

      // Does not get set, but prevents PickerFields inheriting value:'' from Field.
      value: null,

      triggers: {
        expand: {
          cls: 'bars'
        }
      },

      /**
       * Configure as `true` to have the picker expand upon focus enter.
       * @config {Boolean}
       */
      autoExpand: null,

      /**
       * A config object which is merged into the generated picker configuration to allow specific use cases
       * to override behaviour. For example:
       *
       *     picker: {
       *         align: {
       *             anchor: true
       *         }
       *     }
       *
       * @config {Object}
       * @default
       */
      picker: null,

      inputType: 'text',

      // We need to realign the picker if we resize (eg a multiSelect Combo's ChipView wrapping)
      monitorResize: true
    };
  }

  //endregion

  //region Init & destroy

  doDestroy() {
    const me = this;

    // Remove touch keyboard showing listener if we added it
    me.globalTapListener && me.globalTapListener();

    if (me._picker) {
      me.hidePicker();
      me._picker.destroy();
      me.pickerVisible = false;
    }

    super.doDestroy();
  }

  finalizeInit() {
    super.finalizeInit();

    const me = this,
      element = me.element;

    if (me.editable === false) {
      element.classList.add('b-not-editable');
      EventHelper.on({
        element: me.input,
        click: 'onTriggerClick',
        thisObj: me
      });
    } else {
      // In case the field was temporarily set to readOnly="true" to prevent
      // the intrusive keyboard (This happens when tapping the trigger
      // and when focused by the container in response to a touch tap),
      // allow a subsequent touch tap to show the keyboard.
      me.globalTapListener = GlobalEvents.on({
        globaltap: 'showKeyboard',
        thisObj: me
      });
    }
  }

  //endregion

  /**
   * Check if field value is valid
   * @internal
   */
  onEditComplete() {
    super.onEditComplete();

    if (this.pickerVisible) {
      this.hidePicker();
    }
  }

  onElementResize(resizedElement) {
    const me = this;

    // If the field changes size while the picker is visible, the picker
    // must be kept in alignment. For example a multiSelect: true
    // ComboBox with a wrapped ChipView.
    if (me.pickerVisible) {
      me.picker.realign();
    }

    super.onElementResize(resizedElement);
  }

  focus() {
    const input = this.input;

    // If we are focusing an editable PickerField from a touch event, temporarily
    // set it to readOnly to prevent the showing of the intrusive keyboard.
    // It's more likely that a user on a touch device will interact with the picker
    // rather than the input field.
    // A second touch tap on an already focused input will show the keyboard;
    // see the showKeyboard method.
    if (DomHelper.isTouchEvent && this.editable) {
      input.readOnly = true;
      setTimeout(() => (input.readOnly = false), 500);
    }
    super.focus();
  }

  //region Events

  /**
   * Allows using arrow keys to open/close list. Relays other keypresses to list if open.
   * @private
   */
  onInternalKeyDown(event) {
    const me = this;

    if (me.disabled) return;

    if (me.pickerVisible) {
      const { picker } = me;

      if (event.key === 'Escape') {
        event.stopPropagation();
        me.hidePicker();
      } else if (picker.onInternalKeyDown) {
        // if picker is visible, give it a shot at the event
        picker.onInternalKeyDown(event);
      } else if (event.key === 'ArrowDown') {
        if (picker.focusable) {
          picker.focus();
        }
      }
    } else if (event.key === 'ArrowDown') {
      me.onTriggerClick(event);
    }
  }

  onFocusIn(e) {
    super.onFocusIn(e);
    if (this.autoExpand) {
      this.onTriggerClick(e);
    }
  }

  onFocusOut(e) {
    this.hidePicker();
    super.onFocusOut(e);
  }

  /**
   * User clicked trigger icon, toggle list.
   * @private
   */
  onTriggerClick(event) {
    if (!this.disabled) {
      // Pass focus flag as true if invoked by a key event
      this.togglePicker('key' in event);
    }
  }

  /**
   * User clicked on an editable input field. If it's a touch event
   * ensure that the keyboard is shown.
   * @private
   */
  showKeyboard({ event }) {
    const input = this.input;

    if (DomHelper.isTouchEvent && document.activeElement === input && event.target === input) {
      GlobalEvents.suspendFocusEvents();
      input.blur();
      input.focus();
      GlobalEvents.resumeFocusEvents();
    }
  }

  //endregion

  //region Toggle picker

  /**
   * Toggle picker display
   */
  togglePicker(focusPicker) {
    if (this.pickerVisible) {
      this.hidePicker();
    } else {
      this.showPicker(focusPicker);
    }
  }

  /**
   * Show picker
   */
  showPicker(focusPicker) {
    const me = this,
      picker = me.picker;

    if (!me.pickerHideShowListenersAdded) {
      picker.on({
        show: 'onPickerShow',
        hide: 'onPickerHide',
        thisObj: me
      });
      me.pickerHideShowListenersAdded = true;
    }

    picker.show();

    // Not been vetoed
    if (picker.isVisible) {
      if (focusPicker) {
        me.focusPicker();
      }
    }
  }

  onPickerShow() {
    const me = this;

    me.pickerVisible = true;
    me.element.classList.add('b-open');
    me.trigger('togglePicker', { show: true });
    me.pickerTapOutRemover = GlobalEvents.on({
      globaltap: 'onPickerTapOut',
      thisObj: me
    });
    me.pickerKeyDownRemover = EventHelper.on({
      element: me.picker.element,
      keydown: 'onPickerKeyDown',
      thisObj: me
    });
  }

  onPickerHide() {
    const me = this;

    me.pickerVisible = false;
    me.element.classList.remove('b-open');
    me.trigger('togglePicker', { show: false });
    me.pickerTapOutRemover && me.pickerTapOutRemover();
    me.pickerKeyDownRemover && me.pickerKeyDownRemover();
  }

  onPickerTapOut({ event }) {
    if (!this.owns(event.target)) {
      this.hidePicker();
    }
  }

  onPickerKeyDown(event) {
    if (event.key === 'Tab') {
      const activeEl = document.activeElement;

      // Offer our own element a shot at the TAB event.
      // Some widgets or plugins may actively navigate.
      this.input.dispatchEvent(new KeyboardEvent('keydown', event));

      // No listener intervened, point the TAB event at the input,
      // and user agent default navigation will proceed.
      if (document.activeElement === activeEl) {
        this.input.focus();
      }
      // Some listener *did* navigate, prevent user agent default.
      else {
        event.preventDefault();
      }

      // If listeners have not destroyed us, close our picker.
      if (!this.isDestroyed) {
        this.hidePicker();
      }
    }
  }

  /**
   * Hide picker
   */
  hidePicker() {
    if (this.pickerVisible) {
      this.picker.hide();
    }
  }

  focusPicker() {}

  //endregion
}
PickerField._$name = 'PickerField';

/**
 * @module Common/helper/util/Navigator
 */

/**
 * A helper class which allows keyboard navigation within the {@link #config-target} element.
 * @private
 */
class Navigator extends Events(Base) {
  static get defaultConfig() {
    return {
      /**
       * The owning Widget which is using this Navigator.
       * @config {Common.widget.Widget}
       */
      ownerCmp: null,

      /**
       * The encapsulating element in which navigation takes place.
       * @config {HTMLElement}
       */
      target: null,

      /**
       * The element which provides key events for navigation. Optional. Defaults to the {@link #config-target} element.
       * @config {HTMLElement}
       */
      keyEventTarget: null,

      /**
       * An optional key event processor which may preprocess the key event. Returning `null` prevents processing of the event.
       * @config {Function}
       */
      processEvent: null,

      /**
       * A query selector which identifies descendant elements within the {@link #config-target} which are navigable.
       * @config {String}
       */
      itemSelector: null,

      /**
       * A CSS class name to add to focused elements.
       * @config {String}
       * @default
       */
      focusCls: 'b-active',

      /**
       * An object containing key definitions keys by the key name eg:
       *
       * ```javascript
       *  keys : {
       *      "CTRL+SPACE" : 'onCtrlSpace',
       *      ENTER        : 'onEnterKey'
       *  }```
       *
       * The {@link #config-ownerCmp} is used as the `this` reference and to resolve string method names.
       *
       * Modified key names must be created prepending one or more `'CTRL+'`, `'SHIFT+'`, `'ALT+'`
       * in that order, for example `"CTRL+SHIFT+ENTER" : 'showMenu'`
       * @config {Object}
       * @default
       */
      keys: null,

      /**
       * Configure as `true` to also navigate when the `CTRL` modifier key is used along with
       * navigation keys.
       * @config {Boolean}
       * @default false
       */
      allowCtrlKey: null,

      /**
       * Configure as `true` to also navigate when the `SHIFT` modifier key is used along with
       * navigation keys.
       * @config {Boolean}
       * @default false
       */
      allowShiftKey: null
    };
  }

  set itemSelector(itemSelector) {
    this._itemSelector = itemSelector;
  }

  get itemSelector() {
    // Defaults to the itemCls of the owning Component (Most likely a List which must have itemCls)
    return this._itemSelector || `.${this.ownerCmp.itemCls}`;
  }

  onKeyDown(keyEvent) {
    const me = this,
      ownerCmp = me.ownerCmp,
      activeItem = me.activeItem,
      firstItem = me.target.querySelector(me.itemSelector),
      keyName = keyEvent.key.trim() || keyEvent.code,
      composedKeyName = `${keyEvent.ctrlKey ? 'CTRL+' : ''}${keyEvent.shiftKey ? 'SHIFT+' : ''}${
        keyEvent.altKey ? 'ALT+' : ''
      }${keyName}`;

    if (firstItem && me.target.offsetParent) {
      // Detect whether the navigable items flow inline or downwards.
      if (me.inlineFlow == null) {
        let itemContainer = firstItem.parentNode,
          itemPositionStyle = DomHelper.getStyleValue(firstItem, 'position'),
          itemDisplayStyle = DomHelper.getStyleValue(firstItem, 'display'),
          itemFloatStyle = DomHelper.getStyleValue(firstItem, 'float');

        // This is how we know that RIGHT and LEFT arrow should be used for next and previous.
        // If inlineFlow is false, we use UP and DOWN. Consider tabs in a tab bar.
        me.inlineFlow =
          itemPositionStyle === 'absolute' ||
          itemDisplayStyle === 'inline' ||
          itemDisplayStyle === 'inline-block' ||
          itemFloatStyle === 'left' ||
          itemFloatStyle === 'right' ||
          (DomHelper.getStyleValue(itemContainer, 'display') === 'flex' &&
            DomHelper.getStyleValue(itemContainer, 'flex-direction') === 'row');

        if (me.inlineFlow) {
          me.prevKey = 'ArrowLeft';
          me.nextKey = 'ArrowRight';
        } else {
          me.prevKey = 'ArrowUp';
          me.nextKey = 'ArrowDown';
        }
      }

      // Feed the key event through our configured processor, process the event that returns if any.
      if (me.processEvent) {
        keyEvent = me.processEvent.call(ownerCmp, keyEvent);
        if (!keyEvent) {
          return;
        }
      }

      if (activeItem) {
        switch (keyName) {
          case me.prevKey:
            if (me.disabled || (keyEvent.ctrlKey && !me.allowCtrlKey)) {
              return;
            }
            if (keyEvent.shiftKey && !me.allowShiftKey) {
              return;
            }
            keyEvent.preventDefault();
            me.navigatePrevious(keyEvent);
            break;
          case me.nextKey:
            if (me.disabled || (keyEvent.ctrlKey && !me.allowCtrlKey)) {
              return;
            }
            if (keyEvent.shiftKey && !me.allowShiftKey) {
              return;
            }
            keyEvent.preventDefault();
            me.navigateNext(keyEvent);
            break;
          default:
            let keyHandler = me.keys && me.keys[composedKeyName];

            if (keyHandler && !me.disabled) {
              me.callback(keyHandler, me.thisObj || ownerCmp, [keyEvent]);
            }
            // Note that even if this.disabled, the ownerCmp will expect
            // to have its key down hander invoked.
            else if (ownerCmp.onInternalKeyDown) {
              ownerCmp.onInternalKeyDown(keyEvent);
            }
        }
      } else {
        me.activeItem = me.previousActiveItem || me.getDefaultNavigationItem(keyEvent);
      }

      if (me.activeItem !== activeItem) {
        /**
         * Fired when a user gesture causes the active item to change _or become `null`_.
         * @event navigate
         * @param {Event} event The browser event which instigated navigation. May be a click or key or focus move event.
         * @param {HTMLElement} item The newly active item, or `null` if focus moved out.
         */
        me.trigger('navigate', {
          event: keyEvent,
          item: me.activeItem
        });
      }
    }
  }

  getDefaultNavigationItem(keyEvent) {
    const { target, itemSelector, prevKey, nextKey } = this;

    // Navigating backwards from after the component, we default to last item
    if (target.compareDocumentPosition(keyEvent.target) & 4 && keyEvent.key === prevKey) {
      return target.querySelector(`${itemSelector}:last-of-type`);
    }
    // Navigating forwards from before the component we default to the first item
    if (target.compareDocumentPosition(keyEvent.target) & 2 && keyEvent.key === nextKey) {
      return target.querySelector(`${itemSelector}`);
    }
  }

  navigatePrevious(keyEvent) {
    const me = this,
      previous = me.previous;

    keyEvent.preventDefault();
    if (previous) {
      me.ownerCmp.scrollable.scrollIntoView(previous, { animate: 50 }).then(() => {
        me.activeItem = previous;
        me.trigger('navigate', {
          event: keyEvent,
          item: me.activeItem
        });
      });
    }
  }

  navigateNext(keyEvent) {
    const me = this,
      next = me.next;

    keyEvent.preventDefault();
    if (next) {
      me.ownerCmp.scrollable.scrollIntoView(next, { animate: 50 }).then(() => {
        me.activeItem = next;
        me.trigger('navigate', {
          event: keyEvent,
          item: me.activeItem
        });
      });
    }
  }

  get owner() {
    return this.ownerCmp;
  }

  get previous() {
    const treeWalker = this.treeWalker;

    treeWalker.currentNode = this.activeItem;
    treeWalker.previousNode();
    if (treeWalker.currentNode !== this.activeItem) {
      return treeWalker.currentNode;
    }
  }

  get next() {
    const treeWalker = this.treeWalker;

    treeWalker.currentNode = this.activeItem;
    treeWalker.nextNode();
    if (treeWalker.currentNode !== this.activeItem) {
      return treeWalker.currentNode;
    }
  }

  onTargetFocusIn(focusInEvent) {
    if (focusInEvent.target.matches(this.itemSelector)) {
      this.activeItem = focusInEvent.target;
    }
  }

  onTargetFocusOut(focusOutEvent) {
    if (!focusOutEvent.relatedTarget || !this.target.contains(focusOutEvent.relatedTarget)) {
      this.activeItem = null;
    }
  }

  onTargetMouseDown(mousedownEvent) {
    // Mousedown is the focus gesture.
    // This holds true even on touch platforms
    // where the mousedown event is synthesized -
    // preventing default prevents focus on the upcoming touchend.
    this.onFocusGesture(mousedownEvent);
  }

  onTargetClick(clickEvent) {
    const me = this;

    if (me.disabled) {
      return;
    }

    // ownerCmp's preprocessing of any navigate event.
    if (me.processEvent) {
      clickEvent = me.processEvent.call(me.ownerCmp, clickEvent);
    }

    if (clickEvent) {
      me.activeItem = clickEvent.target.closest(me.itemSelector);
      me.trigger('navigate', {
        event: clickEvent,
        item: me.activeItem
      });
    }
  }

  // We have to prevent focus moving from eg, an input field when we mousedown
  // or touchtap a non focusable item when ownerCmp has itemsFocusable: false.
  // If the event was not on an item, we must allow it through to allow Lists
  // to contain other widgets.
  onFocusGesture(event) {
    if (
      event.target === this.ownerCmp.contentElement ||
      (event.target.closest(this.itemSelector) && this.ownerCmp.itemsFocusable === false)
    ) {
      event.preventDefault();
    }
  }

  acceptNode(node) {
    return node.offsetParent && node.matches && node.matches(this.itemSelector)
      ? NodeFilter.FILTER_ACCEPT
      : NodeFilter.FILTER_SKIP;
  }

  get activeItem() {
    return this._activeItem;
  }
  set activeItem(activeItem) {
    const me = this,
      scroller = me.ownerCmp.scrollable;

    // Allow index to be passed
    if (typeof activeItem === 'number') {
      activeItem = me.target.querySelectorAll(me.itemSelector)[activeItem];
    }

    // This may be set to null on focusout of the target element.
    if (activeItem) {
      // If we are being called in response to focus movement, it will already be the document.activeElement
      // so in that case, behave is if we were in non-focusing mode, and just add the focused class.
      if (DomHelper.isFocusable(activeItem) && activeItem !== document.activeElement) {
        scroller.scrollIntoView(activeItem, {
          block: 'nearest',
          focus: true,
          silent: me.scrollSilently
        });
      } else {
        if (me.activeItem) {
          me.previousActiveItem = me.activeItem;
          me.activeItem.classList.remove(me.focusCls);
        }

        scroller.scrollIntoView(activeItem, {
          block: 'nearest',
          silent: me.scrollSilently
        });
        activeItem.classList.add(me.focusCls);
        me._activeItem = activeItem;
      }
    } else {
      // We are being called programatically
      if (activeItem === document.activeElement) {
        me.ownerCmp.revertFocus();
      }
      // In response to focus movement
      else if (me.activeItem) {
        me.activeItem.classList.remove(me.focusCls);
      }
      me.previousActiveItem = me.target.contains(me.activeItem) ? me.activeItem : null;
      me._activeItem = null;
    }
  }

  get target() {
    return this._target;
  }
  set target(target) {
    const me = this,
      listeners = {
        element: target,
        thisObj: me,
        focusin: 'onTargetFocusIn',
        focusout: 'onTargetFocusOut',
        click: 'onTargetClick'
      };

    me._target = target;

    if (!me.hasOwnProperty('acceptNode')) {
      me.acceptNode = me.acceptNode.bind(me);
      // https://github.com/webcomponents/webcomponentsjs/issues/556
      // Work around Internet Explorer wanting a function instead of an object.
      // IE also *requires* this argument where other browsers don't.
      me.acceptNode.acceptNode = me.acceptNode;
    }

    if (me.ownerCmp.itemsFocusable === false) {
      listeners.mousedown = 'onTargetMouseDown';
    }
    EventHelper.on(listeners);

    // This Navigator object acts as the filter for the TreeWalker. We must implement acceptNode(node)
    me.treeWalker = document.createTreeWalker(target, NodeFilter.SHOW_ELEMENT, me.acceptNode, false);

    // If we were not configured with an outside key event provider (think the input field providing UP/DOWN keys for the dropdown)
    // then use the target element as the source.
    if (!me.keyEventTarget) {
      me.keyEventTarget = target;
    }

    // If the activeItem gets removed, we must know, and deactivate.
    (me.targetMutationMonitor = new MutationObserver(me.onTargetChildListChange.bind(me))).observe(target, {
      childList: true
    });
  }

  onTargetChildListChange() {
    const activeItem = this.activeItem;

    // On DOM mutation, if the activeItem got changed, pull the one with the same ID out again.
    if (activeItem && !this.target.contains(activeItem)) {
      this.activeItem = this.target.querySelector(`${this.itemSelector}[data-id="${activeItem.dataset.id}"]`);
    }
  }

  get keyEventTarget() {
    return this._keyEventTarget;
  }

  set keyEventTarget(keyEventTarget) {
    this._keyEventTarget = keyEventTarget;

    EventHelper.on({
      element: keyEventTarget,
      keydown: 'onKeyDown',
      thisObj: this
    });
  }
}
Navigator._$name = 'Navigator';

/**
 * @module Common/widget/List
 */

const itemRange = document.createRange();

/**
 * Displays a list of items which the user can navigate using the keyboard and select using either pointer gestures or the keyboard.
 * @extends Common/widget/Widget
 *
 * @classType list
 * @externalexample widget/List.js
 */
class List extends Widget {
  //region Config

  static get defaultConfig() {
    return {
      itemCls: 'b-list-item',

      selectedCls: 'b-selected',

      /**
       * An array of Objects which are converted into records and used to create this
       * List's {@link #config-store}
       * @config {Object[]}
       */
      items: null,

      /**
       * A {@link Common.data.Store} which provides the records which map to List items. Each record is passed through the
       * {@link #config-itemTpl} to produce the DOM structure of the List. May be generated from an array of {@link #config-items}.
       * @config {Object/Common.data.Store}
       */
      store: null,

      navigator: true,

      scrollable: {
        x: false,
        y: true
      },

      itemsFocusable: true,

      multiSelect: false,

      /**
       * Template function which, when passed a record, returns the textual HTML for that item. Defaults to a
       * function returning the value of records `text` field
       * @config {Function} itemTpl
       */
      itemTpl: (record) => record.text,

      /**
       * A {@link Common.util.Collection Collection}, or Collection config object
       * to use to contain this List's selected records.
       * @config {Common.util.Collection/Object}
       */
      selected: {},

      /**
       * Configure as `true` to activate items on mouseover. This is used by the Combo
       * field whenm using a List as its dropdown.
       * @config {Boolean}
       */
      activateOnMouseover: null
    };
  }

  //endregion

  //region Events

  /**
   * User activated an item in the list either by pointer or keyboard.
   * The active record, list item index, and the triggering event are passed.
   * @event item
   * @property {Object} record - Activated record
   * @property {Number} index - List item index
   * @property {Event} event - Triggering event
   */

  //endregion

  construct(config, ...args) {
    const me = this;

    // We can be created from a raw array. It becomes our items which we translate to a Store.
    if (Array.isArray(config)) {
      config = {
        items: config
      };
    }

    super.construct(config, ...args);

    const element = me.element,
      classList = element.classList;

    if (me.multiSelect) {
      classList.add('b-multiselect');
    }
    if (me.store.count) {
      me.refresh();
    } else {
      classList.add('b-empty');
    }

    EventHelper.on({
      element,
      delegate: me.itemSelector,
      mouseover: 'onMouseOver',
      click: 'onClick',
      thisObj: me
    });

    me.storeDetacher = me.store.on({
      change: 'onStoreChange',
      refresh: 'onStoreRefresh',
      thisObj: me
    });
  }

  doDestroy() {
    if (this.storeDetacher) {
      this.storeDetacher();
    }
    super.doDestroy();
  }

  contentTpl() {
    return TemplateHelper.tpl`${this.store.records.map((record, i) => this.itemWrapperTpl(record, i))}`;
  }

  itemWrapperTpl(record, i) {
    return TemplateHelper.tpl`<div class="${this.getItemClasses(record, i)}" data-index="${i}" data-id="${record.id}" ${
      this.itemsFocusable ? 'tabindex="-1"' : ''
    }>
            ${this.itemContentTpl(record, i)}
            </div>`;
  }

  itemContentTpl(record, i) {
    return TemplateHelper.tpl`${
      this.multiSelect ? '<div class="b-selected-icon b-icon b-icon-check"></div>' : ''
    }${this.itemTpl(record, i)}`;
  }

  getItemClasses(record) {
    const me = this,
      activeItem = me._navigator && me._navigator.activeItem,
      isActive = activeItem && activeItem.dataset.id == record.id,
      isSelected = me.selected.includes(record);

    return `${me.itemCls} ${record.cls || ''} ${isSelected ? me.selectedCls : ''} ${
      isActive ? me.navigator.focusCls : ''
    }`;
  }

  onStoreChange({ source: store, action, records, record }) {
    switch (action) {
      case 'remove':
        this.selected.remove(records);
        break;
      case 'clear':
        this.selected.clear();
        break;
      case 'update':
        this.refreshItem(record);
        return;
    }
    this.refresh();
  }

  onStoreRefresh() {
    this.refresh();
  }

  refresh() {
    const me = this;

    if (me.isVisible) {
      me.clearItems().insertNode(DomHelper.createElementFromTemplate(me.contentTpl(), { fragment: true }));
      me.element.classList[me.store.count > 0 ? 'remove' : 'add']('b-empty');
    } else {
      me.on({
        paint: () => me.refresh(),
        once: true
      });
    }
  }

  clearItems() {
    const me = this,
      firstItem = me.contentElement.querySelector(me.itemSelector),
      lastChild = me.contentElement.lastChild;

    if (firstItem) {
      itemRange.setStartBefore(firstItem);
      itemRange.setEndAfter(me.contentElement.querySelector(`${me.itemSelector}:last-of-type`));
      itemRange.deleteContents();
    } else {
      // Allow a static set of elements to be at the top of the list
      if (lastChild) {
        itemRange.setStartAfter(lastChild);
        itemRange.setEndAfter(lastChild);
      } else {
        itemRange.setStart(me.contentElement, 0);
        itemRange.setEnd(me.contentElement, 0);
      }
    }
    return itemRange;
  }

  refreshItem(...records) {
    for (const record of records) {
      const item = this.getItem(record);

      // Maybe a record which is filtered out announces a change.
      // There will be no item.
      if (item) {
        const index = this.store.indexOf(record),
          newItem = DomHelper.createElementFromTemplate(this.itemWrapperTpl(record, index));

        DomHelper.sync(newItem, item);
      }
    }
  }

  getItem(recordOrId) {
    if (typeof recordOrId === 'number') {
      return this.contentElement.querySelector(`[data-index="${recordOrId}"]`);
    }
    if (recordOrId.id != null) {
      recordOrId = recordOrId.id;
    }
    return this.contentElement.querySelector(`[data-id="${recordOrId}"]`);
  }

  getRecord(dom) {
    if (dom.target) {
      dom = dom.target;
    }
    dom = dom.closest(this.itemSelector);

    return this.store.getAt(parseInt(dom.dataset.index));
  }

  //region getters/setters

  /**
   * May be *set* as an array of Objects which are converted into records and used to create this
   * List's {@link #config-store}
   * @property {Object[]}
   */
  set items(items) {
    const me = this;

    if (me.store && me.store.autoCreated) {
      me.store.destroy();
    }

    me.store = Store.getStore(items);
  }

  set selected(selected) {
    if (!(selected && selected instanceof Collection)) {
      selected = new Collection(selected);
    }
    this._selected = selected;
    selected.on({
      change: 'onSelectionChange',
      thisObj: this
    });
  }

  get itemSelector() {
    return `.${this.itemCls}`;
  }

  get selected() {
    return this._selected;
  }

  /**
   * Get the backing store, a {@link Common.data.Store} holding the records used to generate list items
   * @property {Common.data.Store}
   * @readonly
   */
  get store() {
    // Ensure any configured items is processed into a store before we try to return it.
    this._thisIsAUsedExpression(this.items);

    return this._store;
  }

  set store(store) {
    if (!(store instanceof Store)) {
      store = new Store(store);
    }
    this._store = store;
  }

  get navigator() {
    return this._navigator;
  }

  set navigator(navigator) {
    const me = this,
      { element } = me;

    if (element) {
      me._navigator = new (navigator.class || Navigator)(
        Object.assign(
          {
            ownerCmp: me,
            target: element,
            keyEventTarget: element
          },
          navigator
        )
      );
    } else {
      me._navigator = navigator;
    }
  }

  get minHeight() {
    return super.minHeight;
  }

  set minHeight(minHeight) {
    super.minHeight = this._minHeight = minHeight;
  }

  get minAlignHeight() {
    const lastItem = this.element.lastElementChild,
      minHeight = this.minHeight;

    // No minHeight specified, always defer to the items height
    if (minHeight != null) {
      return this.store.count ? Math.min(lastItem.offsetTop + lastItem.offsetHeight, minHeight) : 0;
    }
  }

  //endregion

  //region Hide/Show

  alignTo(...args) {
    // When aligning, if the items total height is less than minHeight, use that.
    super.minHeight = this.minAlignHeight;
    super.alignTo(...args);
  }

  hide() {
    this.navigator.activeItem = null;
    super.hide();
  }

  show() {
    // Restore the configured minHeight
    super.minHeight = this._minHeight;
    let activeItem = this.navigator.previousActiveItem;

    super.show();

    if (activeItem) {
      if (!this.element.contains(activeItem)) {
        activeItem = this.element.querySelector(`[data-id="${activeItem.dataset.id}"]`);
      }
      this.navigator.activeItem = activeItem;
    }
  }

  //endregion

  //region Events

  /**
   * Focuses list items on hover.
   * @private
   */
  onMouseOver(event) {
    const me = this,
      itemElement = event.target.closest(me.itemSelector);

    if (itemElement && me.navigator && me.activateOnMouseover) {
      me.navigator.activeItem = itemElement;
    }
  }

  /**
   * Selects list items on click.
   * @private
   */
  onClick(event) {
    const itemElement = event.target.closest(this.itemSelector);

    if (itemElement) {
      this.onItemClick(itemElement, event);
    }
  }

  /**
   * Key events which are not navigation are delegated up to here by the Navigator
   * @private
   */
  onInternalKeyDown(event) {
    const me = this,
      active = me.navigator.activeItem;

    switch (event.key) {
      case ' ':
        if (!event.target.readOnly) {
          break; // eslint-disable-line
        }
      case 'Enter': // eslint-disable-line
        if (active) {
          this.onItemClick(active, event);

          // Stop the keydown from bubbling.
          // And stop it from creating a keypress event.
          // No further action should be taken after item selection.
          event.stopImmediatePropagation();
          event.preventDefault();
        }
    }
  }

  //endregion

  onItemClick(item, event) {
    const me = this,
      index = parseInt(item.dataset.index),
      record = me.store.getAt(index),
      selected = me.selected,
      isSelected = selected.includes(record);

    me.trigger('item', {
      item,
      record,
      index,
      event
    });

    // Clicking on any element with the data-noselect attribute means no selection
    if (!item.contains(event.target.closest('[data-noselect]'))) {
      if (me.multiSelect) {
        selected[isSelected ? 'remove' : 'add'](record);
      } else {
        selected.splice(0, selected.count, record);
      }
    }

    me.lastClicked = record;
  }

  /**
   * Handles items being added or removed from the selected Collection
   * @param {Object} changeEvent
   * @private
   */
  onSelectionChange({ action, removed, added, replaced }) {
    const me = this,
      { selectedCls } = me;

    let record, item;

    if (action === 'clear') {
      for (item of me.element.querySelectorAll(`.${selectedCls}`)) {
        item.classList.remove(selectedCls);
      }
    } else {
      for (record of removed) {
        item = me.getItem(record);
        item && item.classList.remove(selectedCls);
      }
      for (record of added) {
        item = me.getItem(record);
        item && item.classList.add(selectedCls);
      }
    }
  }
}

List.prototype.navigatorClass = Navigator;

List._$name = 'List';
BryntumWidgetAdapterRegister.register('list', List);

/**
 * @module Common/widget/ChipView
 */

/**
 * Displays an inline series of Chips which may be navigated to, selected and deleted.
 * @extends Common/widget/List
 *
 * @classType chipview
 */
class ChipView extends List {
  //region Config

  static get defaultConfig() {
    return {
      itemCls: 'b-chip',

      /**
       * Configure as `true` to display a clickable close icon after the {@link Common.widget.List#config-itemTpl}.
       * When tapped, the configured {@link #config-closeHandler} is called passing the
       * associated record.
       *
       * Chips may also be selected using the `LEFT` and `RIGHT` arrows (And the `Shift` key to
       * do multiple, contiguous election). Pressing the `DELETE` or `BACKSPACE` key passes the
       * selected records to the {@link #config-closeHandler}
       * @config {Boolean}
       * @default
       */
      closable: true,

      /**
       * A template function, which, when passed a record, returns the markup which
       * encapsulates a chip's icon to be placed before the {@link Common.widget.List#config-itemTpl}.
       * @config {Function}
       */
      iconTpl: null,

      /**
       * If {@link #config-closable} is `true`, this is the name of a callback function
       * to handle what the "close" action means.
       * @config {String|Function}
       */
      closeHandler: null
    };
  }

  itemContentTpl(record, i) {
    const me = this;

    return TemplateHelper.tpl`${me.iconTpl ? this.iconTpl(record) : ''}
            ${me.itemTpl(record, i)}
            ${me.closable ? '<div class="b-icon b-close-icon b-icon-clear" data-noselect></div>' : ''}`;
  }

  onInternalKeyDown(event) {
    if (event.key === 'Delete' || (event.key === 'Backspace' && this.selected.count)) {
      this.callback(this.closeHandler, this.owner, [this.selected.values, { isKeyEvent: true }]);
    } else {
      super.onInternalKeyDown(event);
    }
  }

  onClick(event) {
    const me = this,
      item = event.target.closest(`.${me.itemCls}`);

    if (me.closable && event.target.classList.contains('b-close-icon')) {
      const record = me.store.getAt(parseInt(item.dataset.index));

      me.callback(me.closeHandler, me.owner, [[record]]);
    } else {
      super.onClick(event);
    }
  }
}

ChipView._$name = 'ChipView';
BryntumWidgetAdapterRegister.register('chipview', ChipView);

const comboQueryAll = Symbol('Combo.queryAll'),
  comboQueryLast = Symbol('Combo.queryLast'),
  fieldRequiredErrorName = 'fieldRequired',
  fieldvalidateFilterErrorName = 'validateFilter';

/**
 * @module Common/widget/Combo
 */

/**
 * Combo (dropdown) widget. Consists of a text field with a trigger icon, which displays a List. Can be
 * populated from a Store.
 *
 * @extends Common/widget/PickerField
 *
 * @example
 * // items as strings
 * let combo = new Combo({
 *   items: ['Small', 'Smaller', 'Really small', 'Tiny', 'Super tiny', '?'],
 *   placeholder: 'Pick size of diamond for ring'
 * });
 *
 * @example
 * // items as configs
 * let combo = new Combo({
 *   items: [{ value: 'a', text: 'First' }, { value: 'z', text: 'Last' }]
 * });
 *
 * @example
 * // items from store
 * let combo = new Combo({
 *   store: memberStore,
 *   valueField: 'id',
 *   displayField: 'name'
 * });
 *
 * @classType combo
 * @externalexample widget/Combo.js
 */
class Combo extends PickerField {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Rows to display in the dropdown (list items).
       *
       * If an object, the property names provide the {@link #config-value} for the Combo, and
       * the property values provide the displayed test in the list and input area eg:
       *
       *     items : {
       *         small  : 'Small',
       *         medium : 'Medium',
       *         large  : 'Large'
       *     }
       *
       * If an array, each entry may be
       *  - an object containing properties which must include
       * the {@link #config-valueField} and {@link #config-displayField} which populates the dropdown
       * with text and provides the corresponding field value.
       *  - An array whos first value provides the {@link #config-value} for the Combo and whos
       * second value provides the displayed test in the list and input area.
       *  - An array of values where the {@link #config-valueField} and {@link #config-displayField} are the same.
       *
       * eg:
       *
       *     items : [
       *         {value : 'small',  text : 'Small'},
       *         {value : 'medium', text : 'Medium'},
       *         {value : 'large',  text : 'Large'},
       *     ]
       *
       * or
       *
       *     items : [
       *         ['small',  'Small'],
       *         ['medium', 'Medium'],
       *         ['large',  'Large'],
       *     ]
       *
       * or
       *
       *     items : [ 'Small', 'Medium', 'Large' ]
       *
       * @config {Object[]|String[]|Object}
       */
      items: null,

      /**
       * A store used to populate items
       * @config {Common.data.Store}
       */
      store: null,

      /**
       * Field used for item value when populating from store
       * @config {String}
       */
      valueField: null,

      /**
       * Field used for item text when populating from store
       * @config {String}
       */
      displayField: 'text',

      /**
       * Width of picker, defaults to this combo's {@link #config-pickerAlignElement} width
       * @config {Number}
       */
      pickerWidth: null,

      /**
       * The minimum string length to trigger the filtering, only relevant when {@link #config-editable} is true
       * @config {Number}
       * @default
       */
      minChars: 1,

      selected: null,

      /**
       * Template for rendering list items contents
       * @config {Function}
       */
      listItemTpl: null,

      /**
       * Template function that can be used to customize the displayed value
       * @config {Function}
       */
      displayValueRenderer: null,

      /**
       * CSS class to add to picker
       * @config {String}
       */
      listCls: null,

      triggers: {
        expand: {
          cls: 'b-icon-picker',
          handler: 'onTriggerClick'
        }
      },

      /**
       * This implies that the picker will display an anchor pointer, but also means that the picker will align closer
       * to the input field so that the pointer pierces the {@link #config-pickerAlignElement}
       * @config {Boolean}
       * @default false
       */
      overlayAnchor: null,

      /**
       * The delay in milliseconds to wait after the last keystroke before filtering the list.
       * @config {Number}
       * @default
       */
      keyStrokeFilterDelay: null,

      defaultAction: 'select',

      /**
       * How to query the store upon click of the expand trigger. There are two constants provided:
       *
       * * `Combo.queryAll` - Clear the filter and display the whole dataset in the dropdown.
       * * `Combo.queryLast` - Filter the dataset using the last filter value.
       * * `null`/any other - Use the value in the input field to filter the dataset.
       *
       * @config {Object}
       * @default Combo.QueryAll
       */
      triggerAction: comboQueryAll,

      /**
       * The name of an operator type as implemented in {@link Common.util.CollectionFilter#config-operator}
       * to use when filtering the dropdown list based upon the typed value.
       *
       * This defaults to `'startsWith'`, but the `'*'` operator may be used to match all
       * values which _contain_ the typed value.
       *
       * @config {String}
       */
      filterOperator: 'startsWith',

      /**
       * Configure as `true` to force case matching when filtering the dropdown list based upon the typed value.
       *
       * @config {Boolean}
       * @default false
       */
      caseSensitive: false,

      /**
       * Configure as `true` to allow selection of multiple values from the dropdown list.
       *
       * Each value is displayed as a "Chip" to the left of the input area. Chips may be
       * selected using the `LEFT` and `RIGHT` arrow keys and deleted using the `DELETE` key
       * to remove values from the field. There is also a clickable close icon in each chip.
       *
       * @config {Boolean}
       * @default false
       */
      multiSelect: null,

      /**
       * By default, the picker is hidden on selection in single select mode, and
       * remains to allow more selections when {@link #config-multiSelect} is `true`.
       * Setting this to a `Boolean` value can override that default.
       */
      hidePickerOnSelect: null,

      /**
       * A config object to configure the {@link Common.widget.ChipView} to display the
       * selected value set when {@link #config-multiSelect} is `true.
       *
       * For example the {@link Common.widget.List#config-itemTpl} or
       * {@link Common.widget.ChipView#config-iconTpl} might be configured to display
       * richer chips for selected items.
       * @config {Boolean}
       */
      chipView: null,

      /**
       * When {@link #config-multiSelect} is `true`, you may configure `filterSelected` as
       * `true` to hide items in the dropdown when they are added to the selection.
       * It will appear as if the requested item has "moved" into the field's
       * {@link #config-chipView ChipView}.
       *
       * @config {Boolean}
       * @default false
       */
      filterSelected: null,

      /**
       * Text to display in the drop down when there are no items in the underlying store
       * @config {String}
       * @default
       */
      emptyText: null,

      /**
       * The initial value of this Combo box. In single select mode (default) it's a simple string value, for {@link #config-multiSelect} mode, it should be an array of record ids.
       * @config {String|Number[]|String[]}
       * @default
       */
      value: null,

      /**
       * `true` to cause the field to be in an invalid state while the typed filter string does not match a record in the store.
       * @config {Boolean}
       * @default
       */
      validateFilter: true,

      /**
       * `true` to clear value typed to a multiselect combo when picker is collapsed
       * @config {Boolean}
       * @default
       */
      clearTextOnPickerHide: true
    };
  }

  //endregion

  afterConfigure() {
    super.afterConfigure();
    if (!('_value' in this)) {
      this._value = this.valueField === this.displayField ? '' : null;
    }
  }

  eachWidget(fn, deep = true) {
    for (const widget of [this.chipView, this._picker]) {
      if (widget) {
        if (fn(widget) === false) {
          return;
        }
        if (deep && widget.eachWidget) {
          widget.eachWidget(fn, deep);
        }
      }
    }
  }

  set element(element) {
    const me = this;

    super.element = element;

    // If we are multiSelect, create a ChipView who's store is backed
    // by our valueCollection - the collection of selected records.
    if (me.multiSelect) {
      me.element.classList.add('b-multiselect');
      me.chipView = new MultiSelectChipView(
        ObjectHelper.assign(
          {
            parent: me,
            insertBefore: me.input,
            store: (me.chipStore = new Store({
              storage: me.valueCollection
            })),
            navigator: {
              class: MultiSelectChipNavigator,
              keyEventTarget: me.input
            }
          },
          me.chipView
        )
      );

      // Insert the input field
      me.chipView.element.appendChild(me.input);

      // Focus must flow into this field from the ChipView
      EventHelper.on({
        element: me.chipView.element,
        mousedown: 'onChipViewMousedown',
        thisObj: me
      });
    }
  }

  onChipViewMousedown(mousedownEvent) {
    mousedownEvent.preventDefault();
    if (!this.containsFocus) {
      this.focus();
    }
  }

  onChipClose(records, options = {}) {
    // Do not clean value collection if input field is not empty - probably text is selected
    // and user just wants to remove it, not the picked values
    if ((options.isKeyEvent && this.input.value === '') || !options.isKeyEvent) {
      this.valueCollection.remove(records);
    }
  }

  get element() {
    return super.element;
  }

  //region Getters/setters

  set keyStrokeFilterDelay(delay) {
    const me = this;

    if (delay) {
      me.filterList = me.buffer(me.doFilter, delay);
    }
    me._keyStrokeFilterDelay = delay;
  }

  get keyStrokeFilterDelay() {
    return this._keyStrokeFilterDelay;
  }

  /**
   * Prepares items to work in attached menu (converts strings to items)
   * @private
   */
  set items(items) {
    if (items == null) {
      items = [];
    }

    if (items instanceof Store) {
      return (this.store = items);
    }

    let itemModel,
      valueField = this.valueField,
      storeData;

    const me = this,
      displayField = me.displayField;

    if (Array.isArray(items)) {
      storeData = items.map((item) => {
        let result = item;

        if (item instanceof Model) {
          itemModel = item.constructor;
          if (!valueField) {
            me.valueField = valueField = itemModel.idField;
          }
        } else {
          if (typeof item === 'string') {
            if (!valueField) {
              me.valueField = valueField = me.displayField;
            }
            result = {
              [valueField]: item,
              [displayField]: item
            };
          } else {
            if (!valueField) {
              me.valueField = valueField = 'value';
            }
            if (Array.isArray(item)) {
              result = {
                [valueField]: item[0],
                [displayField]: item[1]
              };
            }
          }
        }

        if (result.selected) {
          me.value = result;
        }
        return result;
      });
    }
    // Must be a value -> text map
    else {
      if (!valueField) {
        me.valueField = valueField = 'value';
      }
      storeData = [];
      Object.entries(items).forEach(([key, value]) => {
        storeData.push({
          [valueField]: key,
          [displayField]: value
        });
      });
    }

    // Allow reconfiguring with a new set of items
    if (me.store) {
      me.store.data = storeData;
    } else {
      const valueFieldDefinition =
        valueField === displayField
          ? {
              name: 'value',
              dataSource: displayField
            }
          : valueField;

      me.store = new Store({
        data: storeData,
        idField: valueField,
        modelClass:
          itemModel ||
          class extends Model {
            static get idField() {
              return valueField;
            }

            static set idField(idField) {
              super.idField = idField;
            }

            static get fields() {
              return [valueFieldDefinition, displayField];
            }
          }
      });
    }
  }

  get items() {
    return this.store.allRecords;
  }

  /**
   * Get/sets combo value, selects corresponding item in the list
   * Setting null clears the field.
   *
   * If {@link #config-multiSelect} is `true`, then multiple values may be passed as an array.
   * If the values are records, these become the selected record set held by {@link #property-valueCollection},
   * and the `value` yielded by this field is an array of all the {@link #config-valueField}s from the records.
   * @fires select
   * @fires action
   * @property {Object}
   */
  set value(value) {
    const me = this;

    if (value === me.value) {
      // prevent highlighting animation on clear
      const old = me.highlightExternalChange;
      me.highlightExternalChange = false;

      me.syncInputFieldValue();

      me.highlightExternalChange = old;
      return;
    }

    if (!me.multiSelect && Array.isArray(value) && value.length > 1) {
      throw new Error('Multiple values cannot be set to a non-multiselect Combo');
    }

    // This forces promotion of the items config into a Store if it has not already been injected
    me._thisIsAUsedExpression(me.items);

    const { valueField, displayField, store, valueCollection } = me;

    // Unfilter the store so we can do the value lookup.
    if (store.filtered) {
      me.primaryFilter.disabled = true;
      store.filter();
    }

    let record;

    if (value != null) {
      const values = Array.isArray(value) ? value : [value];

      for (let i = 0, len = values.length; i < len; i++) {
        let value = values[i];

        if (value instanceof Model) {
          // The required record value may not yet be in the store. Add it if not.
          if (!store.storage.includes(value)) {
            store.add(value);
          }
        } else {
          const isObject = value instanceof Object;

          // If they passed a data object, match the valueField
          if (isObject) {
            value = value[valueField];
          }

          // Use the Store Collection's extra indices to quickly find a match
          record = store.storage.getBy(displayField, value) || store.storage.getBy(valueField, value);

          if (record) {
            // If the incoming value was a matched object, use it to update the record
            if (isObject) {
              record.set(values[i]);
            }
            values[i] = record;
          } else {
            values.splice(i, 1);
            len--;
            i--;
          }
        }
      }

      // Remove all old values, add new values in one shot.
      const vcGen = valueCollection.generation;
      valueCollection.splice(0, valueCollection.count, values);

      // If no change has fed through to onValueCollectionChange, just ensure the input matches
      if (valueCollection.generation === vcGen) {
        me.syncInputFieldValue();
      }

      // If we got no matches, onValueCollectionChange will set the _value to null.
      // Tests specify that the _value should be set to the incoming unmatched value
      if (!values.length) {
        me._value = value;
      }
    } else {
      if (valueCollection.count) {
        valueCollection.clear();
      } else {
        const oldValue = me._value;

        // Cache the value for use by our change handler next time, and also so that
        // when get value yields null, the fallback to ._value will be correct
        me._value = null;

        me.syncInputFieldValue();
        me.updateEmpty();
        if (!me.isConfiguring) {
          me.trigger('change', {
            value,
            oldValue,
            userAction: me._isUserAction,
            valid: me.isValid
          });
        }
      }
    }
  }

  get value() {
    const me = this;

    return me.multiSelect
      ? me.valueCollection.map((r) => r[me.valueField])
      : me.valueCollection.count
      ? me.valueCollection.first[me.valueField]
      : me._value;
  }

  syncInputFieldValue() {
    // We only sync the input's value if we are not multiselecting.
    // If we are multiselecting, our value is represented by a ChipView.
    // The ChipView automatically syncs itself with our valueCollection.
    if (!this.multiSelect) {
      super.syncInputFieldValue();
    }
  }

  get isEmpty() {
    return this.valueCollection.count === 0;
  }

  get isValid() {
    if (this.required && !this.valueCollection.count) {
      this.setError(fieldRequiredErrorName, true);
    }
    return super.isValid;
  }

  get inputValue() {
    // This must be evaluated first, and NOT moved to be directly used as the
    // second expression in the ternary. If called during configuration, this
    // will import the configured value from the config object and ensure the
    // value is matched against the store, and that the "selected" property is set.
    let me = this,
      result = me.value;

    result = me.selected ? me.selected[me.displayField] : result;

    if (me.displayValueRenderer) {
      result = this.displayValueRenderer(me.selected);
    }

    return result == null ? '' : result;
  }

  set displayValueRenderer(value) {
    this._displayValueRenderer = value;
  }

  get displayValueRenderer() {
    return this._displayValueRenderer;
  }

  /**
   * A {@link Common.util.Collection Collection} which holds the currently seleted records
   * from the store which dictates this field's value.
   *
   * Usually, this will contain one record, the record selected.
   *
   * When {@link #config-multiSelect} is `true`, there may be several records selected.
   */
  get valueCollection() {
    if (!this._valueCollection) {
      this._valueCollection = new Collection({
        listeners: {
          noChange: 'onValueCollectionNoChange',
          change: 'onValueCollectionChange',
          prio: -1000, // The ChipView must react to changes first.
          thisObj: this
        }
      });
    }

    return this._valueCollection;
  }

  /**
   * Get/set store to display items from. Also accepts a Store config object
   * @property {Common.data.Store|Object}
   */
  set store(store) {
    const me = this,
      storeFilters = [];

    if (Array.isArray(store)) {
      me.initialConfig.store = null;
      return (me.items = store);
    }

    // Config object supplied, create a store
    if (store && !(store instanceof Store)) {
      store = new Store(store);
    }

    if (!me.valueField) {
      me.valueField = store.modelClass.idField;
    }

    // This is the filter that performs filtering on typing.
    if (!me.primaryFilter) {
      // Need an id to replace any existing combo filter on the store. Precommit hook wont allow it to be set
      // directly...
      const id = 'primary';
      me.primaryFilter = new CollectionFilter({
        id,
        property: me.displayField,
        operator: me.filterOperator,
        disabled: true,
        caseSensitive: me.caseSensitive
      });
    }
    storeFilters.push(me.primaryFilter);
    if (me.filterSelected) {
      me.selectedItemsFilter = (r) => !me.valueCollection.includes(r);
      storeFilters.push(me.selectedItemsFilter);
    }
    store.filter(storeFilters);

    me._store = store;

    // Allow fast lookup by value or displayed value
    store.storage.addIndex(me.displayField);
    store.storage.addIndex(me.valueField);

    if (me.displayValueRenderer) {
      store.on({
        change: () => me.syncInputFieldValue()
      });

      me.syncInputFieldValue();
    }
  }

  get store() {
    return this._store;
  }

  /**
   * Get selected record.
   * @property {Common.data.Model[]}
   * @readonly
   */
  get record() {
    return this.selected;
  }

  /**
   * Get the selected record(s).
   * @property {Common.data.Model[]}
   * @readonly
   */
  get records() {
    return this.valueCollection.values.slice();
  }

  get selected() {
    return this.valueCollection.first;
  }

  //endregion

  //region Value handling

  /**
   * Check if field value is valid
   * @internal
   */
  onEditComplete() {
    const me = this,
      selectionCount = me.valueCollection.count;

    super.onEditComplete();

    // Ensure the input area matches the selected value
    if (selectionCount) {
      me.clearError(fieldvalidateFilterErrorName);
      me.syncInputFieldValue();
    }
    if (me.required && !selectionCount) {
      me.setError(fieldRequiredErrorName);
    }
  }

  //endregion

  //region Events

  /**
   * User clicked trigger icon, toggle list.
   * @private
   */
  onTriggerClick() {
    const me = this;

    if (me.pickerVisible) {
      me.hidePicker();
    } else {
      if (!me.readOnly && !me.disabled) {
        switch (me.triggerAction) {
          case comboQueryAll:
            me.doFilter(null);
            break;
          case comboQueryLast:
            me.doFilter(me.lastQuery);
            break;
          default:
            me.doFilter(me.input.value);
        }
      }
    }
  }

  /**
   * User types into input field in editable combo, show list and filter it.
   * @private
   */
  internalOnInput(event) {
    const me = this,
      inputLen = me.input.value.length;

    // IE11 triggers input event on focus for some reason, ignoring it if not editable
    if (!me.editable) return;

    me.updateEmpty();

    if (inputLen >= me.minChars) {
      me.filterList(me.input.value);
    } else {
      if (me.validateFilter) {
        me[inputLen ? 'setError' : 'clearError'](fieldvalidateFilterErrorName);
      }
      me.hidePicker();
    }

    /**
     * User typed into the field. Please note that the value attached to this event is the raw input field value and
     * not the combos value
     * @event input
     * @param {Common.widget.Combo} source - The combo
     * @param {String} value - Raw input value
     */
    me.trigger('input', { value: me.input.value, event });
  }

  // This is potentially a buffered function to respond to keystrokes in a buffered manner.
  // This only becomes useful as a saving when using remote querying where each filter is an Ajax request.
  filterList(queryString) {
    this.doFilter(queryString);
  }

  doFilter(queryString) {
    const me = this,
      store = me.store,
      disableFilter = queryString == null || queryString == '';

    me.lastQuery = queryString;

    me.primaryFilter.setConfig({
      value: queryString,
      disabled: disableFilter
    });
    store.filter();

    me.showPicker();

    if (store.count) {
      // If we are filtering, activate the first match
      if (!disableFilter) {
        me.picker.navigator.activeItem = 0;
      }
    }
    // If we were actively filtering on a string but there were no matches
    // and we are validateFilter: true, then mark as invalid even though we
    // may have an underlying valid selected value.
    else if (!disableFilter && me.validateFilter) {
      me.setError(fieldvalidateFilterErrorName);
    }
  }

  /**
   * This reacts to our {@link #property-valueCollection} being mutated in any way.
   * The `change`, `select` and `action` events are fired here.
   *
   * This could happen in four ways:
   *
   *  - User selected or deselected an item in the dropdown list.
   *  - `set value` changes the content.
   *  - The {@link #config-multiSelect} Chip view (which uses this in its store) deletes a record.
   *  - The application programmatically mutates the {@link #property-valueCollection}.
   *
   * @private
   */
  onValueCollectionChange({ source: valueCollection }) {
    const me = this,
      { multiSelect } = me,
      hidePicker = 'hidePickerOnSelect' in me ? me.hidePickerOnSelect : !multiSelect,
      record = multiSelect ? valueCollection.values.slice() : valueCollection.first,
      records = valueCollection.values.slice(),
      isUserAction = me._isUserAction || (hidePicker && me.pickerVisible) || false,
      oldValue = me._value;

    if (hidePicker) {
      me.hidePicker();
    }

    if (!valueCollection.count && me.required) {
      me.setError(fieldRequiredErrorName);
    } else {
      me.clearError(fieldRequiredErrorName);
      me.clearError(fieldvalidateFilterErrorName);
    }

    if (me.validateFilter && record) {
      me.clearError(fieldvalidateFilterErrorName);
    }

    // Re-evaluate the filtering so that selected items are filtered out of the dropdown
    if (me.filterSelected) {
      me.store.filter();
    }

    // Clear the cached value so that there's no fallback when we read back the value below
    me._value = null;

    // Cache the value for use by our change handler next time, and also so that
    // if we just cleared the valueCollection, the fallback to ._value will be correct
    const value = (me._value = me.value);

    me.syncInputFieldValue();
    me.updateEmpty();

    if (!me.isConfiguring) {
      me.trigger('change', {
        value,
        oldValue,
        userAction: isUserAction,
        valid: me.isValid
      });

      /**
       * User selected an item in the list
       * @event select
       * @property {Combo} combo - Combo
       * @property {Common.data.Model} record - Selected record
       * @property {Common.data.Model} records - Selected records as an array if {@link #config-multiSelect} is `true`
       */
      me.trigger('select', { record, records });

      /**
       * User performed the default action in the list (selected an item)
       * @event action
       * @property {Combo} combo - Combo
       * @property {Mixed} value - The {@link #valueField} of the selected record
       * @property {Common.data.Model} record - Selected record
       * @property {Common.data.Model} records - Selected records as an array if {@link #config-multiSelect} is `true`
       */
      if (me.defaultAction === 'select') {
        me.trigger('action', { value, record, records });
      }
    }
  }

  /**
   * This listens for when a record from the list is selected, but is already part of
   * the selection and so the {@link #property-valueCollection} rejects that as a no-op.
   * At this point, the user will still expect the picker to hide.
   * @param {Object} event The noChange event containing the splice parameters
   * @private
   */
  onValueCollectionNoChange({ toAdd }) {
    if (!this.multiSelect && toAdd.length && this.pickerVisible) {
      this.picker.hide();
    }
  }

  //endregion

  //region Picker

  get picker() {
    if (!this._picker) {
      this.picker = true;
    }
    return this._picker;
  }

  set picker(picker) {
    const me = this;

    if (me._picker) {
      me._picker.destroy();
    }

    if (picker instanceof Widget) {
      me._picker = picker;
    } else {
      me._picker = me.createPicker(picker);
    }
  }

  showPicker() {
    const me = this,
      { picker } = me;

    super.showPicker();

    // Once we have access to the anchor size, overlay the anchor pointer over the target if configured to do so.
    if (me.overlayAnchor && !picker.align.offset) {
      picker.align.offset = -picker.anchorSize[1];
      picker.realign();
    }

    if (me.selected) {
      picker.navigator.activeItem = me.store.indexOf(me.selected);
    }

    me.input.focus();
  }

  /**
   * Creates default picker widget
   *
   * @internal
   */
  createPicker(pickerConfig) {
    const me = this,
      { multiSelect, pickerWidth } = me,
      picker = new List(
        ObjectHelper.merge(
          {
            owner: me,
            floating: true,
            scrollAction: 'realign',
            itemsFocusable: false,
            activateOnMouseover: true,
            store: me.store,
            selected: me.valueCollection,
            multiSelect,
            cls: me.listCls,
            itemTpl: me.listItemTpl || ((item) => item[me.displayField]),
            forElement: me[me.pickerAlignElement],
            align: {
              align: 't-b',
              axisLock: true,
              matchSize: pickerWidth == null,
              anchor: me.overlayAnchor,
              target: me[me.pickerAlignElement]
            },
            width: pickerWidth,
            navigator: {
              keyEventTarget: me.input
            },
            maxHeight: 324,
            scrollable: {
              overflowY: true
            },
            autoShow: false,
            focusOnHover: false
          },
          pickerConfig
        )
      );

    picker.element.dataset.emptyText = me.emptyText || me.L('No results');

    return picker;
  }

  onPickerHide() {
    const me = this;

    super.onPickerHide();

    // https://app.assembla.com/spaces/bryntum/tickets/7736
    if (me.multiSelect && me.clearTextOnPickerHide) {
      me.input.value = '';
    }
  }

  //endregion
}

// Constants for how to query on clicking the trigger.
// queryAll means disable the primaryFilter
// queryLast means query using the last query string
// Any other value means use the input field's content

/**
 * A constant value for the {@link #config-triggerAction} config to indicate that clicking the trigger should
 * clear the filter and display the whole dataset in the dropdown.
 * @member {Symbol} queryAll
 * @readonly
 * @static
 */
Combo.queryAll = comboQueryAll;

/**
 * A constant value for the {@link #config-triggerAction} config to indicate that clicking the trigger should
 * filter the dataset usiong the last filter query string, *not* the input field value.
 * @member {Symbol} queryLast
 * @readonly
 * @static
 */
Combo.queryLast = comboQueryLast;

class MultiSelectChipView extends ChipView {
  static get defaultConfig() {
    return {
      cls: 'b-combo-chip-list',

      itemsFocusable: false,

      multiSelect: true,

      closeHandler: 'up.onChipClose',

      itemTpl: function(record) {
        return record[this.owner.displayField];
      }
    };
  }
}

class MultiSelectChipNavigator extends Navigator {
  static get defaultConfig() {
    return {
      allowShiftKey: true
    };
  }

  onTargetClick(clickEvent) {
    const item = clickEvent.target.closest(this.itemSelector);

    if (item && !clickEvent.shiftKey && !item.contains(clickEvent.target.closest('[data-noselect]'))) {
      this.ownerCmp.selected.clear();
    }
    // Our own set activeItem also selects because on superclass *key* navigation
    // (which is async on scroll end), it sets activeItem, and we select at that time.
    // So on click we skip this class and go straight to the superclass because the
    // List's onItemClick must run, and that does selection.
    super.activeItem = item;
  }

  onKeyDown(keyEvent) {
    // ENTER does not toggle selectedness in a ChipView.
    // ChipView's selection is bound to navigation.
    if (keyEvent.key !== 'Enter') {
      super.onKeyDown(keyEvent);
    }
  }

  set activeItem(activeItem) {
    const chipView = this.ownerCmp;

    super.activeItem = activeItem;

    // Selection simply follows navigation in a ChipView
    if (activeItem) {
      chipView.selected.add(chipView.getRecord(activeItem));
    }
  }

  get activeItem() {
    return super.activeItem;
  }

  navigatePrevious(keyEvent) {
    const chipView = this.ownerCmp;

    if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
      chipView.selected.clear();
    }
    if (this.previous) {
      super.navigatePrevious(keyEvent);
    } else {
      this.activeItem = null;
    }
  }

  navigateNext(keyEvent) {
    const chipView = this.ownerCmp;

    // SHIFT+navigate preserves selection
    if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
      chipView.selected.clear();
    }
    if (this.next) {
      super.navigateNext(keyEvent);
    } else {
      this.activeItem = null;
    }
  }
}

Combo._$name = 'Combo';
BryntumWidgetAdapterRegister.register('combo', Combo);
BryntumWidgetAdapterRegister.register('combobox', Combo);
BryntumWidgetAdapterRegister.register('dropdown', Combo);

/**
 * @module Common/util/Month
 */

/**
 * A class which encapsulates a calendar view of a month, and offers information about
 * the weeks and days within that calendar view.
 * ```
 *   const m = new Month({
 *       date         : '2018-12-01',
 *       weekStartDay : 1
 *   }) // December 2018 using Monday as week start
 *   m.eachWeek((week, dates) => console.log(dates.map(d => d.getDate())))
 * ```
 */
class Month {
  /**
   * Constructs a Month from a config object which *must* contain a `date` property.
   * @param {Object} config An object containing initialization properties.
   * @param {Date|String|Number} config.date The date which the month should encapsulate. May be
   * a `Date` object, or a value, which, when passed to the `Date` constructor yields a
   * valid `Date` object. Mutating a passed `Date` after initializing a `Month` object
   * has no effect on the `Month` object.
   * @param {Number} [config.weekStartDay] Optional. Week start day override. Defaults to the
   * locale's {@link Common.helper.DateHelper#property-weekStartDay-static}.
   * @param {Boolean} [config.sixWeeks] Optional. Pass `true` to always have the month encapsulate six weeks.
   * This is ueful for UIs which must be a fixed height.
   * @function constructor
   */
  constructor(config) {
    let { date, weekStartDay, sixWeeks } = config;

    this.constructor.updateDayNumbers(weekStartDay);
    this.sixWeeks = sixWeeks;
    this.date = date;
  }

  set date(date) {
    if (!(date instanceof Date)) {
      date = new Date(date);
      if (isNaN(date)) {
        throw new Error('Month constructor must be passed a Date, or a valid argument to the Date constructor');
      }
      // Edge parses YYYY-MM-DD as UTC, not local, so in other locales, the value
      // may end up not being 00:00:00 in the date, so remove any time zone offset.
      const tzo = date.getTimezoneOffset();
      if (tzo) {
        date = DateHelper.add(date, tzo, 'minute');
      }
    }

    const me = this,
      monthStart = DateHelper.getFirstDateOfMonth(date),
      monthEnd = DateHelper.getLastDateOfMonth(monthStart),
      startWeekDay = me.dayNumbers[monthStart.getDay()],
      endWeekDay = me.dayNumbers[monthEnd.getDay()];

    me._date = date;

    // These comments assume ISO standard of Monday as week start day.
    //
    // This is the date of month that is the beginning of the first week row.
    // So this may be -ve. Eg: for Dec 2018, Monday 26th Nov is the first
    // cell on the calendar which is the -4th of December. Note that the 0th
    // of December was 31st of November, so needs -4 to get back to the 26th.
    me.startDayOfMonth = 1 - startWeekDay;

    // This is the date of month that is the end of the last week row.
    // So this may be > month end. Eg: for Dec 2018, Sunday 6th Jan is the last
    // cell on the calendar which is the 37th of December.
    me.endDayOfMonth = monthEnd.getDate() + (6 - endWeekDay);

    if (me.sixWeeks) {
      while (me.weekCount < 6) {
        me.endDayOfMonth += 7;
      }
    }

    me.year = date.getFullYear();
    me.month = date.getMonth();

    const jan1 = new Date(me.year, 0, 1),
      dec31 = new Date(me.year, 1, 31),
      january = me.month
        ? new Month({
            date: jan1,
            weekStartDay: me.weekStartDay
          })
        : me;

    // First 7 days are in last week of previous year if the year
    // starts after our 4th day of week.
    if (me.dayNumbers[jan1.getDay()] > 3) {
      // Week base is calculated from the year start
      me.weekBase = january.startDate;
    }
    // First 7 days are in week 1 of this year
    else {
      // Week base is the start of week before
      me.weekBase = new Date(me.year, 0, january.startDayOfMonth - 7);
    }

    // Our year only has a 53rd week if the year ends before our week's 5th day
    me.has53weeks = dec31.getDay() < 4;
  }

  get date() {
    return this._date;
  }

  /**
   * The number of days in the calendar for this month. This will always be
   * a multiple of 7, because this represents the number of calendar cells
   * occupied by this month.
   * @property {Number}
   * @readonly
   */
  get dayCount() {
    // So for the example month, Dec 2018 has 42 days, from Mon 26th Nov (-4th Dec) 2018
    // to Sun 6th Jan (37th Dec) 2019
    return this.endDayOfMonth + 1 - this.startDayOfMonth;
  }

  /**
   * The number of weeks in the calendar for this month.
   * @property {Number}
   * @readonly
   */
  get weekCount() {
    return this.dayCount / 7;
  }

  /**
   * The date of the first cell in the calendar view of this month.
   * @property {Date}
   * @readonly
   */
  get startDate() {
    return new Date(this.year, this.month, this.startDayOfMonth);
  }

  /**
   * The date of the last cell in the calendar view of this month.
   * @property {Date}
   * @readonly
   */
  get endDate() {
    return new Date(this.year, this.month, this.endDayOfMonth);
  }

  /**
   * Iterates through all calendar cells in this month, calling the passed function
   * for each date.
   * @param {Function} fn The function to call.
   * <h4>Parameters</h4>
   *  - date [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) The date for the cell.
   */
  eachDay(fn) {
    const me = this;

    for (let dayOfMonth = me.startDayOfMonth; dayOfMonth <= me.endDayOfMonth; dayOfMonth++) {
      fn(new Date(me.year, me.month, dayOfMonth));
    }
  }

  /**
   * Iterates through all weeks in this month, calling the passed function
   * for each week. The function is passed the following parameters:
   * @param {Function} fn The function to call.
   * <h4>Parameters</h4>
   *  - week [Number[]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number) An array containing `[year, weekNumber]`.
   *  - date [Date[]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) The dates for the week.
   */
  eachWeek(fn) {
    const me = this,
      { weekCount } = me;

    for (let dayOfMonth = me.startDayOfMonth, week = 0; week < weekCount; week++) {
      const weekDates = [],
        weekOfYear = me.getWeekNumber(new Date(me.year, me.month, Math.max(dayOfMonth, 1)));

      for (let day = 0; day < 7; day++, dayOfMonth++) {
        weekDates.push(new Date(me.year, me.month, dayOfMonth));
      }
      fn(weekOfYear, weekDates);
    }
  }

  getWeekNumber(date) {
    const me = this,
      { weekStartDay } = me;

    date = DateHelper.clearTime(date);

    // If it's a date that our known year does not contain
    // create a new Month to find the answer.
    if (date < me.startDate || date > me.endDate) {
      return new Month({
        date,
        weekStartDay
      }).getWeekNumber(date);
    }

    let weekNo = Math.floor((date - me.weekBase) / 86400000 / 7),
      year = date.getFullYear();

    // No week 0. It's the last week of last year
    if (!weekNo) {
      const lastDec31 = new Date(me.year, 0, 0);

      // Week is the week of last year's 31st Dec
      return new Month({
        date: lastDec31,
        weekStartDay
      }).getWeekNumber(lastDec31);
    }
    // Only week 53 if year ends before our week's 5th day
    else if (weekNo === 53 && !me.has53weeks) {
      weekNo = 1;
      year++;
    }

    // Return array of year and week number
    return [year, weekNo];
  }

  static applyLocale() {
    this.updateDayNumbers();
  }

  static updateDayNumbers(weekStartDay = DateHelper.weekStartDay) {
    const me = this.prototype,
      dayNumbers = (me.dayNumbers = []),
      canonicalDayNumbers = (me.canonicalDayNumbers = []);

    me.weekStartDay = weekStartDay;

    // So, if they set weekStartDay to 1 meaning Monday which is ISO standard, we will
    // have mapping of internal day number to canonical day number (as used by Date class)
    // and to abbreviated day name like this:
    // canonicalDayNumbers = [1, 2, 3, 4, 5, 6, 0] // Use for translation from our day number to Date class's day number
    // dayNumbers          = [6, 0, 1, 2, 3, 4, 5] // Use for translation from Date object's day number to ours
    for (let i = 0; i < 7; i++) {
      const canonicalDay = (weekStartDay + i) % 7;

      canonicalDayNumbers[i] = canonicalDay;
      dayNumbers[canonicalDay] = i;
    }
  }
}

// Update when changing locale
LocaleManagerSingelton.on({
  locale: 'applyLocale',
  thisObj: Month
});
Month._$name = 'Month';

/**
 * @module Common/widget/CalendarPanel
 */

/**
 * A Panel which can display a month of date cells.
 *
 * This is a base class for UI widgets which need to make use of a calendar layout
 * and should not be used directly.
 */
class CalendarPanel extends Panel {
  static get defaultConfig() {
    return {
      /**
       * The week start day, 0 meaning Sunday, 6 meaning Saturday.
       * Defaults to the locale's week start day.
       * @config {Number}
       */
      weekStartDay: null,

      /**
       * Configure as `true` to always show a six week calendar.
       * @config {Boolean}
       * @default
       */
      sixWeeks: true,

      /**
       * Configure as `true` to show a week number column at the start of the calendar block.
       * @config {Boolean}
       */
      showWeekNumber: false,

      /**
       * Either an array of `Date` objects which are to be disabled, or
       * a function, which, when passed a `Date` returns `true` if the
       * date is disabled.
       * @config {Function|Date[]}
       */
      disabledDates: null,

      /**
       * A function which creates content in, and may mutate a day header element.
       * The following parameters are passed:
       *  - cell [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement) The header element.
       *  - day [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number) The day number conforming to the specified {@link #config-weekStartDay}. Will be in the range 0 to 6.
       * @config {Function}
       */
      headerRenderer: null,

      /**
       * A function which creates content in, and may mutate the week cell element at the start of a week row.
       * The following parameters are passed:
       *  - cell [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement) The header element.
       *  - week [Number[]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number) An array containing `[year, weekNumber]`.
       * @config {Function}
       */
      weekRenderer: null,

      /**
       * A function which creates content in, and may mutate a day cell element.
       * The following parameters are passed:
       *  - cell [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement) The header element.
       *  - date [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) The date for the cell.
       * @config {Function}
       */
      cellRenderer: null,

      /**
       * Configure as `true` to render weekends as {@link #config-disabledDates}.
       * @config {Boolean}
       */
      disableWeekends: null,

      /**
       * A config object to create a tooltip which will show on hover of a date cell
       * including disabled, weekend, and "other month" cells.
       *
       * It is the developer's responsibility to hook the `beforeshow` event
       * to either veto the show by returning `false` or provide contextual
       * content for the date.
       *
       * The tip instance will be primed with a `currentDate` property.
       * @config {Object}
       */
      tip: null,

      /**
       * The class name to add to calendar cells.
       * @config {String}
       * @private
       */
      cellCls: 'b-calendar-cell',

      /**
       * The class name to add to disabled calendar cells.
       * @config {String}
       * @private
       */
      disabledCls: 'b-disabled-date',

      /**
       * The class name to add to calendar cells which are in the previous or next month.
       * @config {String}
       * @private
       */
      otherMonthCls: 'b-other-month',

      /**
       * The class name to add to calendar cells which are weekend dates.
       * @config {String}
       * @private
       */
      weekendCls: 'b-weekend',

      /**
       * The class name to add to the calendar cell which contains today's date.
       * @config {String}
       * @private
       */
      todayCls: 'b-today'
    };
  }

  construct(config) {
    LocaleManagerSingelton.on({
      locale: calculateDayNames
    });
    calculateDayNames();
    super.construct(config);
    this.refresh();
  }

  ingestDate(date) {
    if (!(date instanceof Date)) {
      date = new Date(date);
      if (isNaN(date)) {
        throw new Error(
          'CalendarPanel date ingestion must be passed a Date, or a valid argument to the Date constructor'
        );
      }
      // Edge parses YYYY-MM-DD as UTC, not local, so in other locales, the value
      // may end up not being 00:00:00 in the date, so remove any time zone offset.
      const tzo = date.getTimezoneOffset();
      if (tzo) {
        date = DateHelper.add(date, tzo, 'minute');
      }
    }
    return DateHelper.clearTime(date);
  }

  set tip(tip) {
    this._tip = new Tooltip(
      Object.assign(
        {
          forElement: this.element,
          forSelector: '.b-calendar-cell'
        },
        tip
      )
    );
    this._tip.on({
      pointerOver: 'onTipOverCell',
      thisObj: this
    });
  }

  get tip() {
    return this._tip;
  }

  get element() {
    return super.element;
  }

  set element(element) {
    const me = this;

    super.element = element;
    me.weekElements = Array.from(me.element.querySelectorAll('.b-calendar-week'));
    me.cellElements = Array.from(me.element.querySelectorAll('.b-calendar-week > div'));
  }

  /**
   * The date which this CalendarPanel encapsulates. Setting this causes the
   * content to be refreshed.
   * @property {Date}
   */
  set date(date) {
    const me = this;

    date = me._date = me.ingestDate(date);
    if (!me.month || me.month.month !== date.getMonth()) {
      me.month = new Month({
        date,
        weekStartDay: me.weekStartDay,
        sixWeeks: me.sixWeeks
      });
    }
    me.refresh();
  }

  get date() {
    return this._date;
  }

  set showWeekNumber(showWeekNumber) {
    const me = this;

    me.element.classList[showWeekNumber ? 'add' : 'remove']('b-show-week-number');
    if (me.floating) {
      // Must realign because content change might change dimensions
      if (!me.isAligning) {
        me.realign();
      }
    }
  }

  refresh() {
    const me = this,
      today = DateHelper.clearTime(new Date()),
      { cellElements, weekElements, date, month, cellCls, disabledCls, otherMonthCls, weekendCls, todayCls } = me;

    // If we have not been initialized with a current date, use today
    if (!date) {
      return (me.date = today);
    }

    // Clear all content and CSS
    for (let i = 0, len = cellElements.length; i < len; i++) {
      cellElements[i].className = cellElements[i].innerHTML = '';
    }

    for (let i = 0; i < 7; i++) {
      const cell = me.weekdayCells[i];

      cell.className = cell.innerHTML = '';
      if (me.headerRenderer) {
        me.headerRenderer(cell, i);
      } else {
        cell.innerHTML = shortDayNames[me.canonicalDayNumbers[i]];
      }
      cell.classList.add('b-calendar-day-header');
    }

    // Create cell content
    let weekIndex = 0,
      cellIndex = 0;

    month.eachWeek((week, dates) => {
      const weekElement = weekElements[weekIndex],
        weekCells = weekElement.children;

      weekCells[0].className = 'b-week-number-cell';
      if (me.weekRenderer) {
        me.weekRenderer(weekCells[0], week);
      } else {
        weekCells[0].innerHTML = week[1];
      }

      for (let i = 0; i < 7; i++) {
        const cellDate = dates[i],
          cellDay = cellDate.getDay(),
          cell = weekCells[i + 1],
          cellClassList = cell.classList;

        cellClassList.add(cellCls);
        if (me.isDisabledDate(cellDate)) {
          cellClassList.add(disabledCls);
        }
        if (cellDate.getMonth() !== month.month) {
          cellClassList.add(otherMonthCls);
        }
        if (cellDay === 0 || cellDay === 6) {
          cellClassList.add(weekendCls);
        }
        if (cellDate.getTime() === today.getTime()) {
          cellClassList.add(todayCls);
        }
        cell.dataset.date = DateHelper.format(cellDate, 'YYYY-MM-DD');
        cell.dataset.cellIndex = cellIndex;

        if (me.cellRenderer) {
          me.cellRenderer(cell, cellDate);
        } else {
          cell.innerHTML = cellDate.getDate();
        }
        cellIndex++;
      }

      weekIndex++;
    });
    if (me.floating) {
      // Must realign because content change might change dimensions
      if (!me.isAligning) {
        me.realign();
      }
    }
  }

  isDisabledDate(date) {
    const day = date.getDay(),
      disabledDates = this.disabledDates;

    if (this.disableWeekends && (day === 0 || day === 6)) {
      return true;
    }

    if (disabledDates) {
      if (typeof disabledDates === 'function') {
        return disabledDates(date);
      }
      if (Array.isArray(disabledDates)) {
        return disabledDates.some(
          (d) => DateHelper.clearDate(d, true).getTime() === DateHelper.clearDate(date, true).getTime()
        );
      }
    }
  }

  get bodyConfig() {
    const result = super.bodyConfig,
      weeksContainerChildren = [];

    result.children = [
      {
        tag: 'div',
        className: 'b-calendar-row b-calendar-weekdays',
        children: this.dayNameCells
      },
      {
        className: 'b-weeks-container',
        children: weeksContainerChildren
      }
    ];
    for (let i = 0; i < 6; i++) {
      let weekRow = {
        className: 'b-calendar-row b-calendar-week',
        children: []
      };
      // Generate cells for week number plus seven day cells
      for (let j = 0; j < 8; j++) {
        weekRow.children.push({});
      }
      weeksContainerChildren.push(weekRow);
    }

    return result;
  }

  /**
   * Set to 0 for Sunday (the default), 1 for Monday etc.
   */
  set weekStartDay(weekStartDay) {
    const me = this;
    me.dayNames = [];
    me.dayNumbers = [];
    me.canonicalDayNumbers = [];
    me._weekStartDay = weekStartDay != null ? weekStartDay : DateHelper.weekStartDay;

    // So, if they set weekStartDay to 1 meaning Monday which is ISO standard, we will
    // have mapping of internal day number to canonical day number (as used by Date class)
    // and to abbreviated day name like this:
    // canonicalDayNumbers = [1, 2, 3, 4, 5, 6, 0] // Use for translation from our day number to Date class's day number
    // dayNumbers          = [6, 0, 1, 2, 3, 4, 5] // Use for translation from Date object's day number to ours
    // dayNames            = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
    for (let i = 0; i < 7; i++) {
      const canonicalDay = (me._weekStartDay + i) % 7;
      me.canonicalDayNumbers[i] = canonicalDay;
      me.dayNumbers[canonicalDay] = i;
      me.dayNames[i] = shortDayNames[canonicalDay];
    }
  }

  get weekStartDay() {
    if (!this.hasOwnProperty('_weekStartDay')) {
      this.weekStartDay = undefined;
    }
    return this._weekStartDay;
  }

  get dayNameCells() {
    const me = this,
      weekNumberHeader = document.createElement('div'),
      result = [weekNumberHeader],
      weekdayCells = (me.weekdayCells = []);

    weekNumberHeader.className = 'b-week-number-cell';

    // Ensure our week is initialized by set weekStartDay
    me._thisIsAUsedExpression(me.weekStartDay);

    for (let i = 0; i < 7; i++) {
      const cell = document.createElement('div');
      result.push(cell);
      weekdayCells.push(cell);
    }
    return result;
  }

  onTipOverCell({ source: tip, target }) {
    tip.date = DateHelper.parse(target.dataset.date, 'YYYY-MM-DD');
  }
}

function calculateDayNames() {
  shortDayNames.length = 0;
  for (let date = 2; date < 9; date++) {
    d.setDate(date);
    shortDayNames.push(DateHelper.format(d, 'ddd'));
  }
}

// In the Date class, 0=Sunday, 6=Saturday. 2nd Jan 2000 is Sunday.
// Collect local shortDayNames in default order.
const d = new Date('2000-01-01T00:00:00'),
  shortDayNames = [];

CalendarPanel._$name = 'CalendarPanel';
BryntumWidgetAdapterRegister.register('calendarpanel', CalendarPanel);

/**
 * @module Common/widget/DatePicker
 */

/**
 * A Panel which can display a month of date cells, which navigates between the cells,
 * fires events upon user selection actions, optionally navigates to other months
 * in response to UI gestures, and optionally displays information about each date cell.
 *
 * This class is not intended for use in applications. It is used internally by the
 * {@link Common.widget.DateField} class.
 *
 * @classtype datepicker
 */
class DatePicker extends CalendarPanel {
  static get defaultConfig() {
    return {
      focusable: true,

      tools: {
        prevMonth: {
          align: 'start',
          cls: 'b-icon b-icon-angle-left',
          handler: 'gotoPrevMonth'
        },
        nextMonth: {
          align: 'end',
          cls: 'b-icon b-icon-angle-right',
          handler: 'gotoNextMonth'
        }
      },

      header: {
        title: '\xa0',
        titleAlign: 'center'
      },

      /**
       * The minimum selectable date. Selection of and navigtion to dates prior
       * to this date will not be possible.
       * @config {Date}
       */
      minDate: null,

      /**
       * The maximum selectable date. Selection of and navigtion to dates after
       * this date will not be possible.
       * @config {Date}
       */
      maxDate: null,

      /**
       * The class name to add to the calendar cell whose date which is outside of the
       * {@link #config-minDate}/{@link #config-maxDate} range.
       * @config {String}
       * @private
       */
      outOfRangeCls: 'b-out-of-range',

      /**
       * The class name to add to the currently focused calendar cell.
       * @config {String}
       * @private
       */
      activeCls: 'b-active-date',

      /**
       * The class name to add to selected calendar cells.
       * @config {String}
       * @private
       */
      selectedCls: 'b-selected-date',

      /**
       * By default, disabled dates cannot be navigated to, and they are skipped over
       * during keyboard navigation. Configure this as `true` to enable navigation to
       * disabled dates.
       * @config {Boolean}
       * @default
       */
      focusDisabledDates: null,

      /**
       * Configure as `true` to enable selecting a single date range by selecting a
       * start and end date.
       * @config {Boolean}
       * @default
       */
      multiSelect: false
    };
  }

  /**
   * Fires when a date is selected. If {@link #config-multiSelect} is specified, this
   * will fire upon deselection and selection of dates.
   * @event selectionChange
   * @param {Date[]} selection The selected date. If {@link #config-multiSelect} is specified
   * this may be a two element array specifying start and end dates.
   */

  construct(config) {
    const me = this;

    me.selection = [];
    me.refresh = me.createOnFrame(me.refresh);
    super.construct(config);
    me.element.setAttribute('aria-activedescendant', `${me.id}-active-day`);

    EventHelper.on({
      element: me.element,
      mousedown: 'onPickerMousedown',
      click: {
        delegate: `.${me.cellCls}:not(.${me.disabledCls}):not(.${me.outOfRangeCls})`,
        handler: 'onCellClick'
      },
      keydown: 'onPickerKeyDown',
      thisObj: me
    });
  }

  get focusElement() {
    return this.element;
  }

  refresh() {
    super.refresh();
    this.title = DateHelper.format(this.month.date, 'MMMM YYYY');
  }

  cellRenderer(cell, cellDate) {
    const me = this,
      { activeCls, selectedCls } = me,
      cellClassList = cell.classList;

    cell.innerHTML = cellDate.getDate();
    cell.setAttribute('aria-label', DateHelper.format(cellDate, 'MMMM D, YYYY'));

    if (me.isActiveDate(cellDate)) {
      cellClassList.add(activeCls);
      cell.id = `${me.id}-active-day`;
    }
    if (me.isSelectedDate(cellDate)) {
      cellClassList.add(selectedCls);
    }
    if (me.minDate && cellDate < me.minDate) {
      cellClassList.add(me.outOfRangeCls);
    } else if (me.maxDate && cellDate > me.maxDate) {
      cellClassList.add(me.outOfRangeCls);
    }
  }

  onPickerMousedown(event) {
    event.preventDefault();
  }

  onCellClick(event) {
    this.onDateActivate(DateHelper.parse(event.target.dataset.date, 'YYYY-MM-DD'), event);
  }

  onDateActivate(date, event) {
    const me = this,
      { lastClickedDate, selection } = me;

    me.activeDate = date;
    me.lastClickedDate = date;

    // Handle multi selecting.
    // * single contiguous date range, eg: an event start and end
    // * multiple discontiguous ranges
    if (me.multiSelect) {
      if (me.multiRange);
      else if (!lastClickedDate || date.getTime() !== lastClickedDate.getTime()) {
        if (lastClickedDate && event.shiftKey) {
          selection[1] = date;
          selection.sort();
        } else {
          selection.length = 0;
          selection[0] = date;
        }

        me.trigger('selectionChange', {
          selection
        });
      }
    } else {
      if (!me.value || me.value.getTime() !== date.getTime()) {
        me.value = date;
      } else {
        me.hide();
      }
    }
  }

  onPickerKeyDown(keyEvent) {
    const me = this,
      keyName = keyEvent.key.trim() || keyEvent.code,
      activeDate = me.activeDate;

    let newDate = new Date(activeDate);

    if (activeDate) {
      do {
        switch (keyName) {
          case 'Escape':
            me.hide();
            break;
          case 'ArrowLeft':
            if (keyEvent.ctrlKey) {
              // Disable browser use of this key
              keyEvent.preventDefault();
              newDate.setMonth(newDate.getMonth() - 1);
            } else {
              newDate.setDate(newDate.getDate() - 1);
            }
            break;
          case 'ArrowUp':
            newDate.setDate(newDate.getDate() - 7);
            break;
          case 'ArrowRight':
            if (keyEvent.ctrlKey) {
              // Disable browser use of this key
              keyEvent.preventDefault();
              newDate.setMonth(newDate.getMonth() + 1);
            } else {
              newDate.setDate(newDate.getDate() + 1);
            }
            break;
          case 'ArrowDown':
            newDate.setDate(newDate.getDate() + 7);
            break;
          case 'Enter':
            me.onDateActivate(activeDate, keyEvent);
            break;
        }
      } while (me.isDisabledDate(newDate) && !me.focusDisabledDates);

      // Don't allow navigation to outside of date bounds.
      if (me.minDate && newDate < me.minDate) {
        return;
      }
      if (me.maxDate && newDate > me.maxDate) {
        return;
      }
      me.activeDate = newDate;
    }
  }

  set minDate(minDate) {
    this._minDate = minDate ? this.ingestDate(minDate) : null;
    this.refresh();
  }

  get minDate() {
    return this._minDate;
  }

  set maxDate(maxDate) {
    this._maxDate = maxDate ? this.ingestDate(maxDate) : null;
    this.refresh();
  }

  get maxDate() {
    return this._maxDate;
  }

  set activeDate(activeDate) {
    const me = this;

    if (activeDate) {
      me._activeDate = me.ingestDate(activeDate);
    } else {
      me._activeDate = DateHelper.clearTime(new Date());
    }

    // New active date is in another month
    if (me.month.month !== me._activeDate.getMonth()) {
      me.month.date = me._activeDate;
    }
    me.refresh();
  }

  get activeDate() {
    return this._activeDate;
  }

  set value(date) {
    const me = this,
      { selection } = me;

    let changed;

    if (date) {
      date = me.ingestDate(date);
      if (!me.value || date.getTime() !== me.value.getTime()) {
        selection.length = 0;
        selection[0] = date;
        me.date = date;
        changed = true;
      }
    } else {
      changed = selection.length;
      selection.length = 0;

      // Clearing the value - go to today's calendar
      me.date = new Date();
    }

    if (changed) {
      me.trigger('selectionChange', {
        selection
      });
    }
  }

  get value() {
    return this.selection[this.selection.length - 1];
  }

  gotoPrevMonth() {
    const date = this.date;

    date.setMonth(date.getMonth() - 1);
    this.date = date;
  }

  gotoNextMonth() {
    const date = this.date;

    date.setMonth(date.getMonth() + 1);
    this.date = date;
  }

  isActiveDate(date) {
    return this.activeDate && this.ingestDate(date).getTime() === this.activeDate.getTime();
  }

  isSelectedDate(date) {
    return this.selection.some((d) => d.getTime() === date.getTime());
  }
}

DatePicker._$name = 'DatePicker';
BryntumWidgetAdapterRegister.register('datepicker', DatePicker);

//TODO: picker icon (calendar) should show day number

/**
 * @module Common/widget/DateField
 */

/**
 * Date field widget (text field + date picker).
 *
 * @extends Common/widget/PickerField
 *
 * @example
 * // minimal DateField config with date format specified
 * let dateField = new DateField({
 *   format: 'YYMMDD'
 * });
 *
 * @classType datefield
 * @externalexample widget/DateField.js
 */
class DateField extends PickerField {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Format for date displayed in field. Defaults to using long date format, as defined by current locale (`L`)
       * @config {String}
       * @default
       */
      format: 'L',

      fallbackFormat: 'YYYY-MM-DD', // same for all languages

      /**
       * Format for date in picker. Uses localized format per default
       * @config {String}
       */
      pickerFormat: null,

      triggers: {
        expand: {
          cls: 'b-icon-calendar',
          handler: 'onTriggerClick',
          weight: 200
        }
      },

      stepTriggers: {
        back: {
          cls: 'b-icon-angle-left b-step-trigger',
          handler: 'onBackClick',
          align: 'start',
          weight: 100
        },

        forward: {
          cls: 'b-icon-angle-right b-step-trigger',
          handler: 'onForwardClick',
          align: 'end',
          weight: 100
        }
      },

      // An optional extra CSS class to add to the picker container element
      calendarContainerCls: '',

      /**
       * Min value
       * @config {String|Date}
       */
      min: null,

      /**
       * Max value
       * @config {String|Date}
       */
      max: null,

      /**
       * Time increment duration value. If specified, `forward` and `back` triggers are displayed.
       * The value is taken to be a string consisting of the numeric magnitude and the units.
       * The units may be a recognised unit abbreviation of this locale or the full local unit name.
       * For example `'1d'` or `'1w'` or `'1 week'`. This may be specified as an object containing
       * two properties: `magnitude`, a Number, and `unit`, a String
       * @config {String|Number|Object}
       */
      step: null,

      /**
       * A config object used to configure the {@link Common.widget.DatePicker datePicker}.
       * ```javascript
       * dateField = new DateField({
       *      picker    : {
       *          multiSelect : true
       *      }
       *  });
       * ```
       * @config {Object}
       */
      picker: null
    };
  }

  //endregion

  //region Init & destroy

  inputTemplate() {
    const me = this;
    return TemplateHelper.tpl`<input type="${me.inputType || 'text'}"
            reference="input"
            class="${me.inputCls || ''}"
            min="${me.min}"
            max="${me.max}"
            placeholder="${me.placeholder}"
            name="${me.name || me.id}"
            id="${me.id + '_input'}"/>`;
  }

  get picker() {
    if (!this._picker) {
      this.picker = true;
    }
    return this._picker;
  }

  set picker(picker) {
    const me = this;

    if (me._picker) {
      me._picker.destroy();
    }

    me._picker = picker = new DatePicker(
      Object.assign(
        {
          owner: me,
          forElement: me[me.pickerAlignElement],
          floating: true,
          scrollAction: 'realign',
          align: {
            align: 't0-b0',
            axisLock: true,
            anchor: me.overlayAnchor,
            target: me[me.pickerAlignElement]
          },
          value: me.value,
          minDate: me.min,
          maxDate: me.max,

          onSelectionChange: ({ selection }) => {
            // We only care about what DatePicker does if it has been opened
            if (picker.isVisible) {
              me._isUserAction = true;
              me.value = selection[0];
              me._isUserAction = false;
              picker.hide();
            }
          }
        },
        picker
      )
    );

    if (me.calendarContainerCls) {
      picker.element.classList.add(me.calendarContainerCls);
    }
  }

  //endregion

  set triggers(triggers) {
    super.triggers = ObjectHelper.assign(triggers, this.stepTriggers);
  }

  get triggers() {
    return super.triggers;
  }

  //region Click listeners

  onBackClick() {
    const me = this,
      { min } = me;

    if (!me.readOnly && me.value) {
      const newValue = DateHelper.add(me.value, -1 * me._step.magnitude, me._step.unit);
      if (!min || min.getTime() <= newValue) {
        me.value = newValue;
      }
    }
  }

  onForwardClick() {
    const me = this,
      { max } = me;

    if (!me.readOnly && me.value) {
      const newValue = DateHelper.add(me.value, me._step.magnitude, me._step.unit);
      if (!max || max.getTime() >= newValue) {
        me.value = newValue;
      }
    }
  }

  //endregion

  //region Toggle picker

  showPicker(focusPicker) {
    this.picker.value = this.picker.activeDate = this.value;
    super.showPicker(focusPicker);
  }

  focusPicker() {
    this.picker.focus();
  }

  //endregion

  // region Validation

  get isValid() {
    const me = this,
      min = me.min,
      max = me.max;

    me.clearError('minimumValueViolation', true);
    me.clearError('maximumValueViolation', true);

    let value = me.value;

    if (value) {
      value = value.getTime();
      if (min && min.getTime() > value) {
        me.setError('minimumValueViolation', true);
        return false;
      }

      if (max && max.getTime() < value) {
        me.setError('maximumValueViolation', true);
        return false;
      }
    }

    return super.isValid;
  }

  //endregion

  //region Getters/setters
  transformDateValue(value) {
    if (value != null) {
      if (!(value.constructor.name === 'Date')) {
        if (typeof value === 'string') {
          // If date cannot be parsed with set format, try fallback - the more general one
          value = DateHelper.parse(value, this.format) || DateHelper.parse(value, this.fallbackFormat);
        } else {
          value = new Date(value);
        }
      }

      // We insist on a *valid* Date as the value.
      // An invalid Date object returns NaN as its valueof().
      if (value && value.constructor.name === 'Date' && !isNaN(value.valueOf())) {
        return DateHelper.clearTime(value);
      }
    }
    return null;
  }

  /**
   * Get/set min value, which can be a Date or a string. If a string is specified, it will be converted using the
   * specified {@link #config-format}
   * @property {Date|String}
   */
  set min(value) {
    const me = this;
    me._min = me.transformDateValue(value);
    me.input && (me.input.min = me._min);

    if (me._picker) {
      me._picker.minDate = me._min;
    }
    me.updateInvalid();
  }

  get min() {
    return this._min;
  }

  /**
   * Get/set max value, which can be a Date or a string. If a string is specified, it will be converted using the
   * specified {@link #config-format}
   * @property {Date|String}
   */
  set max(value) {
    const me = this;
    me._max = me.transformDateValue(value);
    me.input && (me.input.max = me._max);

    if (me._picker) {
      me._picker.maxDate = me._max;
    }
    me.updateInvalid();
  }
  get max() {
    return this._max;
  }

  set value(value) {
    const me = this,
      oldValue = me.value,
      picker = me._picker,
      newValue = me.transformDateValue(value);

    // A value we could not parse
    if (value && !newValue) {
      // setError uses localization
      me.setError('invalidDate');
      return;
    }
    me.clearError('invalidDate');

    // Reject non-change
    if (!me.hasChanged(oldValue, newValue)) {
      return;
    }

    if (picker && !me.inputting) {
      picker.value = newValue;
    }
    super.value = newValue;
  }

  get value() {
    return super.value;
  }

  /**
   *  The `step` property may be set in Object form specifying two properties,
   * `magnitude`, a Number, and `unit`, a String.
   *
   * If a Number is passed, the steps's current unit is used (or `day` if no current step set)
   * and just the magnitude is changed.
   *
   * If a String is passed, it is parsed in accordance with (see {@link Common.helper.DateHelper#function-format-static}.
   * The string is taken to be the numeric magnitude then an abbreviation, or name of the unit.
   *
   * Upon read, the value is always returned in object form containing `magnitude` and `unit`.
   * @property {String|Number|Object}
   * */
  set step(value) {
    const me = this;

    // If a step is configured, show the steppers
    me.element.classList[value ? 'add' : 'remove']('b-show-steppers');

    if (typeof value === 'number') {
      value = {
        magnitude: value,
        unit: me._step ? me._step.unit : 'day'
      };
    } else if (typeof value !== 'object') {
      value = DateHelper.parseDuration(value);
    }

    if (value && value.magnitude && value.unit) {
      value.magnitude = Math.abs(value.magnitude);
      me._step = value;
      me.updateInvalid();
    }
  }

  get step() {
    return this._step;
  }

  hasChanged(oldValue, newValue) {
    if (oldValue && oldValue.getTime && newValue && newValue.getTime) {
      return oldValue.getTime() !== newValue.getTime();
    }

    return super.hasChanged(oldValue, newValue);
  }

  get inputValue() {
    // Do not use the _value property. If called during configuration, this
    // will import the configured value from the config object.
    let date = this.value;

    return date ? DateHelper.format(date, this.format) : '';
  }

  /**
   * Get/Set format for date displayed in field (see {@link Common.helper.DateHelper#function-format-static} for formatting options)
   * @property {String}
   */
  set format(value) {
    const me = this;
    me._format = value;
    me.syncInputFieldValue();
  }

  get format() {
    return this._format;
  }

  //endregion

  //region Localization

  updateLocalization() {
    super.updateLocalization();
    this.syncInputFieldValue();
  }

  //endregion

  //region Other

  internalOnKeyPress(event) {
    super.internalOnKeyPress(event);

    if (event.key === 'Enter' && this.isValid) {
      this.picker.hide();
    }
  }

  //endregion
}

DateField._$name = 'DateField';
BryntumWidgetAdapterRegister.register('datefield', DateField);
BryntumWidgetAdapterRegister.register('date', DateField);

/**
 * @module Common/widget/NumberField
 */

/**
 * Number field widget. Wraps native `<input type="number">`
 *
 * @extends Common/widget/Field
 *
 * @example
 * let number = new NumberField({
 *   min: 1,
 *   max: 5,
 *   value: 3
 * });
 *
 * @classType numberfield
 * @externalexample widget/NumberField.js
 */
class NumberField extends Field {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Min value
       * @config {Number}
       */
      min: null,

      /**
       * Max value
       * @config {Number}
       */
      max: null,

      /**
       * Step size. Use a decimal value to allow decimal input
       * @config {Number}
       */
      step: 1,

      /**
       * Initial value
       * @config {Number}
       */
      value: 0,

      triggers: {
        spin: {
          type: 'spintrigger'
        }
      }
    };
  }

  internalOnKeyPress(e) {
    if (BrowserHelper.isEdge && e.type === 'keydown') {
      if (e.key === 'ArrowUp') {
        this.doSpinUp();
        e.preventDefault();
      } else if (e.key === 'ArrowDown') {
        this.doSpinDown();
        e.preventDefault();
      }
    }
    super.internalOnKeyPress(e);
  }

  //endregion

  inputTemplate() {
    const me = this,
      style =
        'inputWidth' in me ? `style="width:${me.inputWidth}${typeof me.inputWidth === 'number' ? 'px' : ''}"` : '';

    return TemplateHelper.tpl`
            <input type="number"
                reference="input"
                min="${me.min}"
                max="${me.max}"
                step="any"
                value="${me._value}"
                autocomplete="${me.autoComplete}"
                placeholder="${me.placeholder}"
                name="${me.name || me.id}"
                id="${me.id}_input"
                ${style}/>
            `;
  }

  set step(step) {
    this.element.classList[step ? 'remove' : 'add']('b-hide-spinner');
    this._step = step;
  }

  get step() {
    return this._step;
  }

  /**
   * Min value
   * @property {Number}
   */
  set min(min) {
    this._min = min;

    if (this.input) {
      this.input.min = min;
    }
  }

  get min() {
    return this._min;
  }

  /**
   * Max value
   * @property {Number}
   */
  set max(max) {
    this._max = max;

    if (this.input) {
      this.input.max = max;
    }
  }

  get max() {
    return this._max;
  }

  doSpinUp() {
    let newValue = (this.value || 0) + this.step,
      { min, max } = this;

    if (!isNaN(min) && newValue < min) {
      newValue = min;
    }
    if (isNaN(max) || newValue <= max) {
      this._isUserAction = true;
      this.value = newValue;
      this._isUserAction = false;
    }
  }

  doSpinDown() {
    let newValue = (this.value || 0) - this.step,
      { min, max } = this;

    if (!isNaN(max) && newValue > max) {
      newValue = max;
    }
    if (isNaN(min) || newValue >= min) {
      this._isUserAction = true;
      this.value = newValue;
      this._isUserAction = false;
    }
  }

  get value() {
    return super.value;
  }

  set value(value) {
    if (value || value === 0) {
      // We insist on a number as the value
      if (typeof value !== 'number') {
        value = typeof value === 'string' ? parseFloat(value) : Number(value);

        if (isNaN(value)) {
          value = '';
        }
      }
    } else {
      value = this.clearable ? undefined : 0;
    }

    // Reject non-changes & not interested in non-number values
    if (this.value !== value) {
      super.value = value;
    }
  }
}

NumberField._$name = 'NumberField';
BryntumWidgetAdapterRegister.register('numberfield', NumberField);
BryntumWidgetAdapterRegister.register('number', NumberField);

/**
 * @module Common/widget/Slider
 */

/**
 * Wraps native &lt;input type="range"&gt;
 *
 * @extends Common/widget/Widget
 *
 * @example
 * let slider = new Slider({
 *   text: 'Choose value'
 * });
 *
 * @classType slider
 * @externalexample widget/Slider.js
 */
class Slider extends Widget {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Slider label text
       * @config {String}
       */
      text: '',

      /**
       * Show value in label (appends in () if text is set)
       * @config {Boolean}
       * @default
       */
      showValue: true,

      /**
       * Show value in tooltip
       * @config {Boolean}
       * @default
       */
      showTooltip: false,

      /**
       * Minimum value
       * @config {Number}
       * @default
       */
      min: 0,

      /**
       * Maximum value
       * @config {Number}
       * @default
       */
      max: 100,

      /**
       * Step size
       * @config {Number}
       * @default
       */
      step: 1,

      /**
       * Initial value
       * @config {Number}
       */
      value: null,

      // The value is set in the Light theme. The Material theme will have different value.
      thumbSize: 20,

      localizableProperties: ['text']
    };
  }

  //endregion

  //region Init

  construct(config) {
    const me = this;

    super.construct(config);

    me.updateLabel();

    if (me.showTooltip) {
      me.tip = new Tooltip({
        forElement: me.input,
        anchor: false, // No anchor displayed since thumbSize is different for different themes
        align: 'b-t',
        axisLock: true
      });
    }

    me.input.addEventListener('input', me.onInternalInput.bind(me));
    me.input.addEventListener('change', me.onInternalChange.bind(me));
    me.input.addEventListener('mouseover', me.onInternalMouseOver.bind(me));
    me.input.addEventListener('mouseout', me.onInternalMouseOut.bind(me));
  }

  template(widget) {
    return TemplateHelper.tpl`
            <div class="${widget.text ? 'b-text b-has-label' : ''}">
                <input type="range"
                   reference="input"
                   id="${widget.id}_input"
                   min="${widget.min}"
                   max="${widget.max}"
                   step="${widget.step}"
                   value="${widget.value}">
                <label reference="label" for="${widget.id}_input">${widget.text}</label>
            </div>
        `;
  }

  get focusElement() {
    return this.input;
  }

  //endregion

  //region Events

  onInternalInput(event) {
    const me = this;

    me._value = parseInt(me.input.value);

    me.updateUI();
    me.trigger('input', { value: me.value });
  }

  onInternalChange(event) {
    const me = this;
    me.updateUI();
    me.triggerChange(true);
    me.trigger('action', { value: me.value });
  }

  onInternalMouseOver(event) {
    const me = this;

    me.updateLabel();

    if (me.tip) {
      me.tip.showBy({
        target: me.calcThumbPosition(),
        offset: 5
      });
    }
  }

  onInternalMouseOut(event) {
    if (this.tip) {
      this.tip.hide();
    }
  }

  triggerChange(userAction) {
    this.trigger('change', {
      value: this.value,
      userAction
    });
  }

  //endregion

  //region Getters/setters

  /**
   * Get/Set text. Appends value if Slider.showValue is true
   * @property {String}
   */
  get text() {
    return this._text;
  }

  set text(text) {
    const me = this;

    me._text = text;

    if (me.label) {
      if (me.showValue) {
        text = text ? `${text} (${me.value})` : me.value;
      }

      me.label.innerHTML = text;
    }

    if (me.tip) {
      me.tip.html = me.value;
    }
  }

  /**
   * Get/set value
   * @property {Number}
   */
  get value() {
    return this.input ? parseInt(this.input.value) : this._value;
  }

  set value(value) {
    const me = this;

    if (me._value !== value) {
      if (me.input) {
        me.input.value = value;
        me.updateUI();
        me.triggerChange(false);
      }
      me._value = value;
    }
  }

  /**
   * Get/set min value
   * @property {Number}
   */
  get min() {
    return this.input ? this.input.min : this._min;
  }

  set min(min) {
    const me = this;

    if (me.input) {
      me.input.min = min;
      if (me._value < min) {
        me.value = min;
        me.trigger('input', { value: me.value });
      }
    }

    me._min = min;
  }

  /**
   * Get/set max value
   * @property {Number}
   */
  get max() {
    return this.input ? this.input.max : this._max;
  }

  set max(max) {
    const me = this;

    if (me.input) {
      me.input.max = max;
      if (me._value > max) {
        me.value = max;
        me.trigger('input', { value: me.value });
      }
    }

    me._max = max;
  }

  /**
   * Get/set step size
   * @property {Number}
   */
  get step() {
    return this.input ? this.input.step : this._step;
  }

  set step(step) {
    if (this.input) this.input.step = step;
    this._step = step;
  }

  //endregion

  //region Util

  /**
   * Refresh label text
   * @private
   */
  updateLabel() {
    this.text = this._text;
  }

  /**
   * Refresh tooltip position
   * @private
   */
  updateTooltipPosition() {
    if (this.tip) {
      this.tip.alignTo({
        target: this.calcThumbPosition(),
        offset: 5
      });
    }
  }

  /**
   * Refresh slider UI
   * @private
   */
  updateUI() {
    this.updateLabel();
    this.updateTooltipPosition();
  }

  calcThumbPosition() {
    const me = this,
      inputRect = Rectangle.from(me.input),
      offset = ((inputRect.width - me.thumbSize) * me.calcPercentProgress()) / 100;

    return new Rectangle(
      inputRect.x + offset,
      inputRect.y + inputRect.height / 2 - me.thumbSize / 2,
      me.thumbSize,
      me.thumbSize
    );
  }

  calcPercentProgress() {
    return ((this.value - this.min) / (this.max - this.min)) * 100;
  }

  //endregion
}

Slider._$name = 'Slider';
BryntumWidgetAdapterRegister.register('slider', Slider);

/**
 * @module Common/widget/layout/Card
 */

const animationClasses = ['b-slide-out-left', 'b-slide-out-right', 'b-slide-in-left', 'b-slide-in-right'];

/**
 * A helper class for containers which must manage multiple child widgets, of which only one may be visible at once such
 * as a {@link Common.widget.TabPanel}. This class offers an active widget switching API, and optional slide-in,
 * slide-out animations from child to child.
 */
class Card extends Layout {
  static get defaultConfig() {
    return {
      containerCls: 'b-card-container',

      itemCls: 'b-card-item',

      /**
       * Specifies whether to slide tabs in and out of visibility.
       * @config {Boolean}
       * @default
       */
      animateCardChange: true
    };
  }

  /**
   * Get/set active item, using index or the Widget to activate
   * @param {Common.widget.Widget|Number} activeItem
   * @returns {Object} An object describing the card change containing the following properties:
   *
   *  - `prevActiveIndex` The previously active index.
   *  - `prevActiveItem ` The previously active child item.
   *  - `activeIndex    ` The newly active index.
   *  - `activeItem     ` The newly active child item.
   *  - `promise        ` A promise which completes when the slide-in animation finishes and the child item contains
   * focus if it is focusable.
   */
  setActiveItem(activeIndex) {
    const me = this,
      { owner } = me,
      { contentElement, items } = owner,
      widgetPassed = activeIndex instanceof Widget,
      prevActiveIndex = parseInt(contentElement.dataset.activeIndex),
      prevActiveItem = items[prevActiveIndex],
      newActiveItem =
        owner.items[(activeIndex = widgetPassed ? (activeIndex = items.indexOf(activeIndex)) : parseInt(activeIndex))],
      event = {
        prevActiveIndex,
        prevActiveItem
      };

    // There's a child widget at that index to activate
    if (newActiveItem && newActiveItem !== prevActiveItem) {
      const prevItemElement = prevActiveItem.element,
        newActiveElement = newActiveItem && newActiveItem.element;

      event.activeIndex = activeIndex;
      event.activeItem = newActiveItem;

      // A previous card change is in progress, abort it and clean the items it was operating upon
      if (me.animateDetacher) {
        const abortedEvent = me.animateDetacher.event;
        me.animateDetacher();
        abortedEvent.prevActiveItem.element.classList.remove(animationClasses);
        abortedEvent.activeItem.element.classList.remove('b-active', ...animationClasses);
        me.animateDetacher = null;
      }

      event.promise = new Promise((resolve, reject) => {
        // If there's something to slide out, slide it out, and slide the new item in
        if (prevItemElement && me.animateCardChange) {
          prevItemElement.classList.add(activeIndex > prevActiveIndex ? 'b-slide-out-left' : 'b-slide-out-right');
          newActiveElement.classList.add(
            'b-active',
            activeIndex < prevActiveIndex ? 'b-slide-in-left' : 'b-slide-in-right'
          );

          // Paint early, to have contents in place when sliding in
          newActiveItem.triggerPaint();

          // When the new widget is in place, clean up
          me.animateDetacher = EventHelper.on({
            element: newActiveElement,
            animationend: () => {
              me.animateDetacher = null;

              // Clean incoming widget's animation classes
              newActiveElement.classList.remove(...animationClasses);

              // If there's an outgoing item, clean its animation classes and hide it
              if (prevItemElement) {
                prevItemElement.classList.remove('b-active', ...animationClasses);
              }
              contentElement.dataset.activeIndex = activeIndex;

              // Note that we have to call focus *after* the element is in its new position
              // because focus({preventScroll:true}) is not supported everywhere
              // and crazy browser scrolling behaviour on focus breaks the animation.
              newActiveItem.focus();
              resolve(event);
            },
            once: true
          });
          me.animateDetacher.reject = reject;
          me.animateDetacher.event = event;
        }
        // Nothing to slide out or we are not animating.
        else {
          if (prevItemElement) {
            prevItemElement.classList.remove('b-active');
          }
          newActiveElement.classList.add('b-active');
          contentElement.dataset.activeIndex = activeIndex;
          newActiveItem.focus();
          newActiveItem.triggerPaint();
          resolve(event);
        }
      });
    }

    return event;
  }

  renderChildren() {
    const { owner } = this,
      activeIndex = owner.activeIndex;

    // The usual; not working on IE11
    if (BrowserHelper.isIE11) {
      this.animateCardChange = false;
    }

    // Ensure activeIndex of the owning Container at render time is honoured.
    if (owner.items && activeIndex != null && owner.items[activeIndex]) {
      owner.contentElement.dataset.activeIndex = activeIndex;
      owner.items[activeIndex].element.classList.add('b-active');
    }
    super.renderChildren();
  }

  /**
   * The active child index. Setting must be done through {@link #function-setActiveItem}
   * @property {Number}
   * @readonly
   */
  get activeIndex() {
    return parseInt(this.owner.contentElement.dataset.activeIndex);
  }

  /**
   * The active child item. Setting must be done through {@link #function-setActiveItem}
   * @property {Common.widget.Widget}
   * @readonly
   */
  get activeItem() {
    return this.owner.items[parseInt(this.owner.contentElement.dataset.activeIndex)];
  }
}

// Layouts must register themselves so that the static layout instantiation
// in Layout knows what to do with layout type names
Card._$name = 'Card';
Layout.registerLayout(Card);

/**
 * @module Common/widget/TabPanel
 */

/**
 * Tab panel widget, displays a collection of tabs which each can contain other widgets. Layout is handled using css
 *
 * @extends Common/widget/Widget
 * @example
 * let tabPanel = new TabPanel({
 *  items: [
 *      {
 *          title: 'First',
 *          items: [
 *              { type: 'textfield', label: 'Name' },
 *              ...
 *          ]
 *      }, {
 *          title: 'Last',
 *          items: [
 *              ...
 *          ]
 *      }
 *  ]
 * });
 *
 * @classType tabpanel
 * @externalexample widget/TabPanel.js
 */
class TabPanel extends Container {
  //region Config

  static get defaultConfig() {
    return {
      template: (me) => TemplateHelper.tpl`
                <div>
                    <div class="b-tabpanel-tabs" reference="tabStrip">
                        ${me.items.map(
                          (tab, i) => `
                        <div tabindex="-1" data-index="${i}" class="b-tabpanel-tab ${
                            i === me.activeIndex ? 'b-active' : ''
                          } ${tab.cls || ''}" style="${
                            me.tabMinWidth ? 'min-width:' + DomHelper.setLength(me.tabMinWidth) + ';' : ''
                          } ${me.tabMaxWidth ? 'max-width:' + DomHelper.setLength(me.tabMaxWidth) + ';' : ''}" >
                            <span class="b-tabpanel-tab-title">${tab.title}</span>
                        </div>
                        `
                        )}
                    </div>
                    <div class="b-tabpanel-body" reference="tabPanelBody" data-activeIndex="${me.activeIndex}">
                    </div>
                </div>
            `,

      itemCls: 'b-tabpanel-item',

      defaultType: 'container',

      /**
       * The index of the initially active tab.
       * @config {Number}
       * @default
       */
      activeTab: 0,

      /**
       * Min width of a tab title. 0 means no minimum width. This is default.
       * @config {Number}
       * @default
       */
      tabMinWidth: null,

      /**
       * Max width of a tab title. 0 means no maximum width. This is default.
       * @config {Number}
       * @default
       */
      tabMaxWidth: null,

      /**
       * Specifies whether to slide tabs in and out of visibility.
       * @config {Boolean}
       * @default
       */
      animateTabChange: true,

      layout: 'card',

      // Prevent child panels from displaying a header unless explicitly configured with one
      suppressChildHeaders: true
    };
  }

  //endregion

  //region Init

  construct(config) {
    const me = this;

    super.construct(config);

    // assign elements to titleElement, so they can get updated automatically when title is changed
    me.items.forEach((tab, i) => {
      tab.titleElement = me.element.querySelector(`div.b-tabpanel-tab[data-index="${i}"] span`);
    });

    EventHelper.on({
      element: me.tabStrip,
      delegate: '.b-tabpanel-tab',
      click: 'onTabElementClick',
      thisObj: me
    });
  }

  //endregion

  set tabMinWidth(width) {
    this._tabMinWidth = width;

    this.element &&
      DomHelper.forEachSelector(this.element, '.b-tabpanel-tab', (tab) => {
        DomHelper.setLength(tab, 'minWidth', width || null);
      });
  }

  get tabMinWidth() {
    return this._tabMinWidth;
  }

  set tabMaxWidth(width) {
    this._tabMaxWidth = width;

    this.element &&
      DomHelper.forEachSelector(this.element, '.b-tabpanel-tab', (tab) => {
        DomHelper.setLength(tab, 'maxWidth', width || null);
      });
  }

  get tabMaxWidth() {
    return this._tabMaxWidth;
  }

  set layout(layout) {
    super.layout = layout;
    this.layout.animateCardChange = this.animateTabChange;
  }

  get layout() {
    return super.layout;
  }

  //region Tabs

  get contentElement() {
    return this.tabPanelBody;
  }

  get focusElement() {
    const activeTab = this.items[this.activeTab || 0],
      tabFocusElement = activeTab && activeTab.focusElement;

    return tabFocusElement || this.tabStrip.children[this.activeTab];
  }

  /**
   * Get/set active tab, using index or the Widget to activate.
   * @property {Common.widget.Widget|Number}
   */
  set activeTab(index) {
    const me = this;

    if (me.isConfiguring) {
      me._activeTab = index;
    } else {
      const tabchangeEvent = me.layout.setActiveItem(index),
        { promise, activeIndex, activeItem } = tabchangeEvent;

      // If the layout successfully activated a new item...
      if (activeItem) {
        const { tabStrip } = me,
          prevTabElement = tabStrip.children[me._activeTab];

        // Our UI changes immediately, our state must be accurate
        me._activeTab = activeIndex;

        // Deactivate previous active tab
        if (prevTabElement) {
          prevTabElement.classList.remove('b-active');
        }

        // Activate the new tab
        tabStrip.children[activeIndex].classList.add('b-active');

        promise.then(() => {
          /**
           * The active tab has changed.
           * @event tabchange
           * @param {Common.widget.Widget} prevActiveItem - The previous active child widget.
           * @param {Number} prevActiveIndex - The previous active index.
           * @param {Common.widget.Widget} activeItem - The new active child widget.
           * @param {Number} activeIndex - The new active index.
           */
          me.trigger('tabchange', tabchangeEvent);
        });
      }
    }
  }

  /**
   * The active tab index. Setting must be done through {@link #property-activeTab}
   * @property {Number}
   * @readonly
   */
  get activeIndex() {
    return this.activeTab;
  }

  get activeTab() {
    return this._activeTab;
  }

  /**
   * The active child widget. Setting must be done through {@link #property-activeTab}
   * @property {Common.widget.Widget}
   * @readonly
   */
  get activeItem() {
    return this.layout.activeItem;
  }

  //endregion

  //region Events

  onTabElementClick(event) {
    this.activeTab = event.currentTarget.dataset.index;
  }

  //endregion
}

TabPanel._$name = 'TabPanel';
BryntumWidgetAdapterRegister.register('tabpanel', TabPanel);
BryntumWidgetAdapterRegister.register('tabs', TabPanel);

/**
 * @module Common/widget/TextAreaField
 */

/**
 * TextAreaField widget. Wraps native &lt;input type="text"&gt;
 *
 * @extends Common/widget/Field
 *
 * @example
 * let textAreaField = new TextAreaField({
 *   placeholder: 'Enter some text'
 * });
 *
 * @classType textareafield
 */
class TextAreaField extends PickerField {
  static get defaultConfig() {
    return {
      triggers: null, // Override PickerField. We don't have a trigger by default

      /**
       * Configure as `false` to have the field render as a non-editable picker field which
       * shows a `<textarea>` input when expanded.
       * @config {Boolean}
       * @default
       */
      inline: true,

      /**
       * The resize style to apply to the `<textarea>` element.
       * @config {String}
       * @default
       */
      resize: 'none'
    };
  }

  startConfigure(config) {
    // Read the inline config which will force evaluation of triggers.
    this._thisIsAUsedExpression(this.inline);
    super.startConfigure(config);
  }

  inputTemplate() {
    const me = this;

    if (me.inline) {
      return TemplateHelper.tpl`<textarea
                reference="input"
                class="${me.inputCls || ''}"
                placeholder="${me.placeholder}"
                name="${me.name || me.id}"
                style="resize:${me.resize}"
                id="${me.id + '_input'}"></textarea>`;
    } else {
      return TemplateHelper.tpl`<input type="text"
                readOnly="readonly"
                reference="displayElement"
                placeholder="${me.placeholder}"/>`;
    }
  }

  get focusElement() {
    return this.inline || (this._picker && this._picker.isVisible) ? this.input : this.displayElement;
  }

  showPicker() {
    const me = this,
      picker = me.picker;

    picker.width = me.pickerWidth || me[me.pickerAlignElement].offsetWidth;

    // Always focus the picker.
    super.showPicker(true);
  }

  focusPicker() {
    this.input.focus();
  }

  onPickerKeyDown(keyEvent) {
    const me = this,
      realInput = me.input;

    switch (keyEvent.key.trim() || keyEvent.code) {
      case 'Escape':
        // TODO: revert value?
        me.picker.hide();
        return;
      case 'Enter':
        if (keyEvent.ctrlKey) {
          me.syncInputFieldValue();
          me.picker.hide();
        }
        break;
    }

    // Super's onPickerKeyDown fires through this.input, so avoid infinite recursion
    // by redirecting it through the displayElement.
    me.input = me.displayElement;
    const result = super.onPickerKeyDown(keyEvent);
    me.input = realInput;

    return result;
  }

  syncInputFieldValue() {
    if (this.displayElement) {
      this.displayElement.value = this.inputValue;
    }
    super.syncInputFieldValue();
  }

  set value(value) {
    super.value = value == null ? '' : value;
  }

  get value() {
    return super.value;
  }

  set inline(inline) {
    this._inline = inline;
    if (!inline && !this.triggers) {
      this.triggers = {};
    }
  }

  set triggers(triggers) {
    if (!this.inline) {
      (triggers || (triggers = {})).expand = {
        cls: 'b-icon-picker',
        handler: 'onTriggerClick'
      };
    }
    super.triggers = triggers;
  }

  get triggers() {
    return super.triggers;
  }

  get inline() {
    return this._inline;
  }

  get picker() {
    if (!this._picker) {
      this.picker = true;
    }
    return this._picker;
  }

  set picker(picker) {
    const me = this;

    if (me._picker) {
      me._picker.destroy();
    }

    // Allow configuring pickerWidth in one go. Setting `picker = { width : 300 }` will otherwise be overridden by
    // pickerWidth or fields width.
    if (picker.width) {
      me.pickerWidth = picker.width;
    }

    me._picker = new Widget(
      ObjectHelper.merge(
        {
          cls: 'b-textareafield-picker',
          owner: me,
          floating: true,
          scrollAction: 'realign',
          forElement: me[me.pickerAlignElement],
          align: {
            align: 't-b',
            axisLock: true,
            anchor: me.overlayAnchor,
            target: me[me.pickerAlignElement]
          },
          html: `<textarea id="${me.id + '_input'}" style="resize:${me.resize}">${me.value}</textarea>`,
          autoShow: false
        },
        picker
      )
    );

    const input = (me.input = me.picker.element.querySelector(`#${me.id}_input`));

    me.inputListenerRemover = EventHelper.on({
      element: input,
      thisObj: me,
      focus: 'internalOnInputFocus',
      change: 'internalOnChange',
      input: 'internalOnInput',
      keydown: 'internalOnKeyPress',
      keypress: 'internalOnKeyPress',
      keyup: 'internalOnKeyPress'
    });
  }
}

TextAreaField._$name = 'TextAreaField';
BryntumWidgetAdapterRegister.register('textareafield', TextAreaField);
BryntumWidgetAdapterRegister.register('textarea', TextAreaField);

/**
 * @module Common/widget/TimePicker
 */

/**
 * A Popup which displays hour and minute number fields and AM/PM switcher buttons for 12 hour time format.
 * Fires timeChange event upon user changes time.
 *
 * This class is not intended for use in applications. It is used internally by the
 * {@link Common.widget.TimeField} class.
 *
 * @classType timepicker
 * @private
 */
class TimePicker extends Popup {
  //region Config

  static get defaultConfig() {
    return {
      items: [
        {
          type: 'number',
          ref: 'fieldHours',
          min: 0,
          max: 23
        },
        { html: '<label>:</label>' },
        {
          type: 'number',
          ref: 'fieldMinutes',
          min: 0,
          max: 59
        },
        {
          type: 'button',
          text: 'AM',
          toggleGroup: 'am-pm',
          ref: 'buttonAM',
          cls: 'b-blue'
        },
        {
          type: 'button',
          text: 'PM',
          toggleGroup: 'am-pm',
          ref: 'buttonPM',
          cls: 'b-blue'
        }
      ],

      float: '1',

      autoShow: false,

      trapFocus: true,

      /**
       * Default time value
       * @config {Date}
       */
      value: DateHelper.getTime(0),

      /**
       * Time format. Used to set appropriate 12/24 hour format to display.
       * See Common.helper.DateHelper#format for formatting options.
       * @config {String}
       */
      format: null
    };
  }

  //endregion

  //region Init

  /**
   * Fires when a time is changed.
   * @event timeChange
   * @param {Date} time The selected time.
   */
  construct(config) {
    const me = this;
    super.construct(config);

    me._pm = false;
    me.fieldHours.on('change', me.onFieldChange, me);
    me.fieldMinutes.on('change', me.onFieldChange, me);
    me.buttonAM.on('click', me.onButtonAMClick, me);
    me.buttonPM.on('click', me.onButtonPMClick, me);

    EventHelper.on({
      element: me.element,
      keydown: 'onPickerKeyDown',
      thisObj: me
    });

    EventHelper.on({
      element: me.fieldHours.element,
      keydown: 'onPickerKeyDown',
      thisObj: me
    });

    EventHelper.on({
      element: me.fieldMinutes.element,
      keydown: 'onPickerKeyDown',
      thisObj: me
    });

    me.refresh();
  }

  //endregion

  //region Event listeners

  onFieldChange() {
    const me = this;
    if (me._time) {
      me.value = me.pickerToTime();
    }
  }

  onButtonAMClick() {
    const me = this;
    me._pm = false;
    if (me._time) {
      me.value = me.pickerToTime();
    }
  }

  onButtonPMClick() {
    const me = this;
    me._pm = true;
    if (me._time) {
      me.value = me.pickerToTime();
    }
  }

  onPickerKeyDown(keyEvent) {
    const me = this,
      keyName = (keyEvent.key && keyEvent.key.trim()) || keyEvent.code;

    switch (keyName) {
      case 'Escape':
        // Support for undefined initial time
        me.triggerTimeChange(me._initialValue);
        me.hide();
        keyEvent.preventDefault();
        break;
      case 'Enter':
        me.value = me.pickerToTime();
        me.hide();
        keyEvent.preventDefault();
        break;
    }
  }

  //endregion

  //region Internal functions

  pickerToTime() {
    const me = this,
      pm = me._pm;
    let hours = me.fieldHours.value,
      newValue = new Date(me._time);

    if (!me._is24Hour) {
      if (pm && hours < 12) hours = hours + 12;
      if (!pm && hours === 12) hours = 0;
    }

    newValue.setHours(hours);
    newValue.setMinutes(me.fieldMinutes.value);

    if (me._min) {
      newValue = DateHelper.max(me._min, newValue);
    }
    if (me._max) {
      newValue = DateHelper.min(me._max, newValue);
    }

    return newValue;
  }

  triggerTimeChange(time) {
    this.trigger('timeChange', { time });
  }

  //endregion

  //region Getters / Setters

  /**
   * Get/set value, which can be a Date or a string. If a string is specified, it will be converted using the
   * specified {@link #config-format}
   * @property {Date|String}
   */
  set value(newTime) {
    const me = this;
    let changed = false;

    if (!newTime || !me._time) {
      me._time = TimePicker.defaultConfig.value;
      changed = true;
    } else if (newTime.getTime() !== me._time.getTime()) {
      me._time = newTime;
      changed = true;
    }

    if (changed) {
      if (me.isVisible) {
        me.triggerTimeChange(me.value);
      }
      me.refresh();
    }
  }

  get value() {
    return this._time;
  }

  /**
   * Get/Set format for time displayed in field (see Common.helper.DateHelper#format for formatting options)
   * @property {String}
   */
  set format(value) {
    const me = this;
    me._format = value;
    me._is24Hour = DateHelper.is24HourFormat(me._format);
    me.refresh();
  }

  get format() {
    return this._format;
  }

  /**
   * Get/set max value, which can be a Date or a string. If a string is specified, it will be converted using the
   * specified {@link #config-format}
   * @property {Date|String}
   */
  set min(value) {
    this._min = value;
  }

  get min() {
    return this._min;
  }

  /**
   * Get/set min value, which can be a Date or a string. If a string is specified, it will be converted using the
   * specified {@link #config-format}
   * @property {Date|String}
   */
  set max(value) {
    this._max = value;
  }

  get max() {
    return this._max;
  }

  /**
   * Get/set initial value and value, which can be a Date or a string. If a string is specified,
   * it will be converted using the specified {@link #config-format}. Initial value is restored on Escape click
   * @property {Date|String}
   */
  set initialValue(value) {
    this.value = value;
    this._initialValue = value;
  }

  get initialValue() {
    return this._initialValue;
  }

  //endregion

  //region Internal widgets getters

  get buttonAM() {
    return this.widgetMap.buttonAM;
  }

  get buttonPM() {
    return this.widgetMap.buttonPM;
  }

  get fieldHours() {
    return this.widgetMap.fieldHours;
  }

  get fieldMinutes() {
    return this.widgetMap.fieldMinutes;
  }

  //endregion

  //region Display

  refresh() {
    const me = this;
    if (!me.isConfiguring) {
      const time = me._time,
        is24 = me._is24Hour,
        hours = time.getHours(),
        pm = (me._pm = hours >= 12),
        fieldHours = me.fieldHours;

      me.width = is24 ? '12.8em' : '20em';
      fieldHours.min = is24 ? 0 : 1;
      fieldHours.max = is24 ? 23 : 12;
      fieldHours.value = is24 ? hours : hours % 12 || 12;
      me.fieldMinutes.value = time.getMinutes();
      me.buttonAM.pressed = !pm;
      me.buttonPM.pressed = pm;
      me.buttonAM.hidden = me.buttonPM.hidden = is24;
    }
  }

  //endregion
}

TimePicker._$name = 'TimePicker';
BryntumWidgetAdapterRegister.register('timepicker', TimePicker);

//TODO: picker icon (clock) should be clock that shows actual time

/**
 * @module Common/widget/TimeField
 */

/**
 * Time field widget (text field + time picker).
 *
 * @extends Common/widget/PickerField
 *
 * @example
 * let field = new TimeField({
 *   format: 'HH'
 * });
 *
 * @classType timefield
 * @externalexample widget/TimeField.js
 */
class TimeField extends PickerField {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Format for date displayed in field (see Common.helper.DateHelper#function-format-static for formatting options)
       * @config {String}
       * @default
       */
      format: 'LT',

      triggers: {
        back: {
          cls: 'b-icon b-icon-angle-left',
          handler: 'onBackClick',
          align: 'start'
        },
        expand: {
          template: () => `<div class="b-align-${this.align || 'end'}"><div class="b-icon-clock-live"></div></div>`,
          handler: 'onTriggerClick',
          align: 'end'
        },
        forward: {
          cls: 'b-icon b-icon-angle-right',
          handler: 'onForwardClick',
          align: 'end'
        }
      },

      /**
       * Min time value
       * @config {String|Date}
       */
      min: null,

      /**
       * Max time value
       * @config {String|Date}
       */
      max: null,

      /**
             * Time increment duration value. Defaults to 5 minutes.
             * The value is taken to be a string consisting of the numeric magnitude and the units.
             * The units may be a recognised unit abbreviation of this locale or the full local unit name.
             * For example `"10m"` or `"5min"` or `"2 hours"`

             * @config {String}
             */
      step: '5m'
    };
  }

  //endregion

  //region Init & destroy

  get picker() {
    if (!this._picker) {
      this.picker = true;
    }
    return this._picker;
  }

  set picker(picker) {
    const me = this;

    if (me._picker) {
      me._picker.destroy();
    }

    me._picker = new TimePicker(
      Object.assign(
        {
          owner: me,
          floating: true,
          forElement: me[me.pickerAlignElement],
          align: {
            align: 't0-b0',
            axisLock: true,
            anchor: me.overlayAnchor,
            target: me[me.pickerAlignElement]
          },
          value: me.value,
          format: me.format,
          onTimeChange({ time }) {
            me._isUserAction = true;
            me.value = time;
            me._isUserAction = false;
          }
        },
        picker
      )
    );
  }

  //endregion

  //region Click listeners

  onBackClick() {
    const me = this,
      { min } = me;

    if (!me.readOnly && me.value) {
      const newValue = DateHelper.add(me.value, -1 * me._step.magnitude, me._step.unit);
      if (!min || min.getTime() <= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }

  onForwardClick() {
    const me = this,
      { max } = me;

    if (!me.readOnly && me.value) {
      const newValue = DateHelper.add(me.value, me._step.magnitude, me._step.unit);
      if (!max || max.getTime() >= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }

  //endregion

  // region Validation

  get isValid() {
    const me = this;

    me.clearError('minimumValueViolation', true);
    me.clearError('maximumValueViolation', true);

    let value = me.value;
    if (value) {
      value = value.getTime();
      if (me._min && me._min.getTime() > value) {
        me.setError('minimumValueViolation', true);
        return false;
      }

      if (me._max && me._max.getTime() < value) {
        me.setError('maximumValueViolation', true);
        return false;
      }
    }

    return super.isValid;
  }

  hasChanged(oldValue, newValue) {
    if (oldValue && oldValue.getTime && newValue && newValue.getTime) {
      return oldValue.getTime() !== newValue.getTime();
    }

    return super.hasChanged(oldValue, newValue);
  }

  //endregion

  //region Toggle picker

  /**
   * Show picker
   */
  showPicker(focusPicker) {
    const me = this,
      picker = me.picker;

    picker.initialValue = me.value;
    picker.format = me.format;
    picker.maxTime = me.max;
    picker.minTime = me.min;

    // Show valid time from picker while editor has undefined value
    me.value = picker.value;

    super.showPicker(focusPicker);
  }

  onPickerShow() {
    const me = this;
    super.onPickerShow();
    // Remove PickerField key listener
    me.pickerKeyDownRemover && me.pickerKeyDownRemover();
  }

  /**
   * Focus time picker
   */
  focusPicker() {
    this.picker.focus();
  }

  //endregion

  //region Getters/setters

  transformTimeValue(value) {
    if (value != null) {
      if (!(value.constructor.name === 'Date')) {
        if (typeof value === 'string') {
          value = DateHelper.parse(value, this.format);
        } else {
          value = new Date(value);
        }
      }

      // We insist on a *valid* Time as the value.
      // An invalid Date object returns NaN as its valueof().
      if (value && value.constructor.name === 'Date' && !isNaN(value.valueOf())) {
        // Clear date part back to zero so that all we have is the time part of the epoch.
        value = DateHelper.clone(value);
        value.setFullYear(1970, 0, 1);
        return value;
      }
    }
    return null;
  }

  /**
   * Get/set min value, which can be a Date or a string. If a string is specified, it will be converted using the
   * specified {@link #config-format}
   * @property {Date|String}
   */
  set min(value) {
    const me = this;
    me._min = me.transformTimeValue(value);
    me.input && (me.input.min = me._min);
    me.updateInvalid();
  }

  get min() {
    return this._min;
  }

  /**
   * Get/set max value, which can be a Date or a string. If a string is specified, it will be converted using the
   * specified {@link #config-format}
   * @property {Date|String}
   */
  set max(value) {
    const me = this;
    me._max = me.transformTimeValue(value);
    me.input && (me.input.max = me._max);
    me.updateInvalid();
  }

  get max() {
    return this._max;
  }

  /**
   * Get/set value, which can be a Date or a string. If a string is specified, it will be converted using the
   * specified {@link #config-format}
   * @property {Date|String}
   */
  set value(value) {
    const me = this,
      oldValue = me.value,
      newValue = me.transformTimeValue(value);

    // A value we could not parse
    if (value && !newValue) {
      // setError uses localization
      me.setError('invalidTime');
      return;
    }
    me.clearError('invalidTime');

    // Reject non-change
    if (!me.hasChanged(oldValue, newValue)) {
      return;
    }

    // This makes to clock icon show correct time
    if (me.triggers.expand && newValue) {
      me.triggers.expand.element.firstElementChild.style.animationDelay =
        -((newValue.getHours() * 60 + newValue.getMinutes()) / 10) + 's';
    }

    super.value = newValue;
  }

  get value() {
    return super.value;
  }

  /**
   *  The `step` property may be set in Object form specifying two properties,
   * `magnitude`, a Number, and `unit`, a String.
   *
   * If a Number is passed, the steps's current unit is used and just the magnitude is changed.
   *
   * If a String is passed, it is parsed in accordance with (see {@link Common.helper.DateHelper#function-format-static}.
   * The string is taken to be the numeric magnitude then an abbreviation, or name of the unit.
   *
   * Upon read, the value is always returned in object form containing `magnitude` and `unit`.
   * @property {String|Number|Object}
   * */
  set step(value) {
    const me = this;

    if (typeof value === 'number') {
      value = {
        magnitude: value,
        unit: me._step.unit
      };
    } else if (typeof value !== 'object') {
      value = DateHelper.parseDuration(value);
    }

    if (value && value.magnitude && value.unit) {
      value.magnitude = Math.abs(value.magnitude);
      me._step = value;
      me.updateInvalid();
    }
  }

  get step() {
    return this._step;
  }

  /**
   * Get/Set format for time displayed in field (see {@link Common.helper.DateHelper#function-format-static} for formatting options)
   * @property {String}
   */
  set format(value) {
    const me = this;
    me._format = value;
    me.syncInputFieldValue();
  }

  get format() {
    return this._format;
  }

  get inputValue() {
    return DateHelper.format(this.value, this.format);
  }

  //endregion

  //region Localization

  updateLocalization() {
    super.updateLocalization();
    this.syncInputFieldValue();
  }

  //endregion
}

TimeField._$name = 'TimeField';
BryntumWidgetAdapterRegister.register('timefield', TimeField);
BryntumWidgetAdapterRegister.register('time', TimeField);

/**
 * @module Common/adapter/widget/BryntumWidgetAdapter
 */

/**
 * Adapter that allows {@link Common.helper.WidgetHelper} to use Bryntums widgets.
 * Not to be called directly.
 * @example
 * WidgetHelper.adapter = BryntumWidgetAdapter;
 */
class BryntumWidgetAdapter {
  // region Create, insert, append
  createWidget(config) {
    return BryntumWidgetAdapterRegister.createWidget(config.type, config);
  }

  getClass(type) {
    return BryntumWidgetAdapterRegister.getClass(type);
  }

  appendWidget(config) {
    return this.createWidget(config);
  }

  appendWidgets(configArray, config) {
    // Prototype chained objects may be passed, so use ObjectHelper.
    return configArray.map((item) => this.appendWidget(ObjectHelper.assign({}, config || {}, item)));
  }

  //endregion

  //region Window & popup

  openPopup(element, config) {
    // Prototype chained objects may be passed, so use ObjectHelper.
    return new Popup(
      ObjectHelper.assign(
        {
          forElement: element
        },
        typeof config === 'string'
          ? {
              html: config
            }
          : config
      )
    );
  }

  //endregion

  //region Menu

  showContextMenu(element, config) {
    const me = this;

    if (me.currentContextMenu) {
      me.currentContextMenu.destroy();
    }

    if (element instanceof HTMLElement) {
      config.forElement = element;
    } else if (Array.isArray(element)) {
      config.forElement = {
        target: new Point(...element)
      };
    } else if (element instanceof Point) {
      config.forElement = {
        target: element
      };
    }

    me.currentContextMenu = new Menu(config);

    me.currentContextMenu.on('destroy', () => {
      me.currentContextMenu = null;
    });

    return me.currentContextMenu;
  }

  //endregion

  //region Tooltip

  attachTooltip(element, configOrText) {
    if (typeof configOrText === 'string') configOrText = { html: configOrText };

    // TODO: refactor this
    // eslint-disable-next-line no-new
    new Tooltip(
      Object.assign(
        {
          forElement: element
        },
        configOrText
      )
    );

    return element;
  }

  hasTooltipAttached(element) {
    return Tooltip.hasTooltipAttached(element);
  }

  destroyTooltipAttached(element) {
    return Tooltip.destroyTooltipAttached(element);
  }

  //endregion

  //region Mask

  mask(config, text = 'Loading') {
    if (config) {
      // Config object normalization
      if (config instanceof HTMLElement) {
        config = {
          element: config,
          text
        };
      }

      return Mask.mask(config, config.element);
    }
  }

  unmask(element, close = true) {
    if (element.mask) {
      if (close) {
        element.mask.close();
      } else {
        element.mask.hide();
      }
    }
  }

  //endregion

  //region Toast

  toast(msg) {
    return Toast.show(msg);
  }

  //endregion

  //region Style

  // moved from WidgetHelper to avoid circular reference

  set defaultStyle(style) {
    this._defaultStyle = style;
  }

  get defaultStyle() {
    return this._defaultStyle;
  }

  //endregion
}

if (!WidgetHelper._adapter) WidgetHelper.adapter = BryntumWidgetAdapter;
BryntumWidgetAdapter._$name = 'BryntumWidgetAdapter';

/**
 * @module Common/data/AjaxStore
 */

const processParamEntry = (paramArray, entry) => {
    if (Array.isArray(entry[1])) {
      entry[1].forEach((value) => paramArray.push(entry[0] + '=' + value));
    } else {
      paramArray.push(entry[0] + '=' + entry[1]);
    }
    return paramArray;
  },
  immediatePromise$2 = new Promise((resolve) => resolve());

/**
 * Store that does CRUD using Ajax.
 *
 * <h3>Create</h3>
 * Posts array of JSON data for newly added records to {@link #config-createUrl}, expects response containing an array of JSON objects
 * in same order with id set (uses Model#idField as id).
 *
 * <h3>Read</h3>
 * Reads array of JSON data from the data packet returned from the {@link #config-readUrl}. Unique id for each row is required.
 * By default looks in field 'id' but can be configured by setting {@link Common.data.Model#property-idField-static}.
 *
 * <h3>Update</h3>
 * Posts array of JSON data for newly modified records to {@link #config-updateUrl}.
 *
 * <h3>Destroy</h3>
 * Posts to {@link #config-deleteUrl} with removed records ids (for example id=1,4,7).
 *
 * @example
 * new AjaxStore({
 *   createUrl  : 'php/create',
 *   readUrl    : 'php/read',
 *   updateUrl  : 'php/update',
 *   deleteUrl  : 'php/delete',
 *   modelClass : Customer
 * });
 *
 * @extends Common/data/Store
 */
class AjaxStore extends Store {
  // region Events

  /**
   * Fired when a remote request fails, either at the network level, or the server returns a failure, or an invalid response.
   *
   * Note that when a {@link #function-commit} fails, more than one exception event will be triggered. The individual operation,
   * `create`, `update` or `delete` will trigger their own `exception` event, but the encapsulating commit operation will also
   * trigger an `exception` event when all the operations have finished, so if exceptions are going to be handled gracefully,
   * the event's `action` property must be examined, and the constituent operations of the event must be examined.
   * @event exception
   * @param {Common.data.Store} source This Store
   * @param {Boolean} exception `true`
   * @param {String} action Action that failed, `'create'`, `'read'`, `'update'` or `'delete'`. May also be fired
   * with '`commit'` to indicate the failure of an aggregated `create`, `update` and `delete` operation. In this case,
   * the event will contain a property for each operation of the commit named `'create'`, `'update'` and `'delete'`,
   * each containing the individual `exception` events.
   * @param {String} exceptionType The type of failure, `'network'` or `'server'`
   * @param {Response} response the `Response` object
   * @param {Object} json The decoded response object *if the exceptionType is `'server'`*
   */

  /**
   * Fired after committing added records
   * @event commitAdded
   * @param {Common.data.Store} source This Store
   */

  /**
   * Fired after committing modified records
   * @event commitModified
   * @param {Common.data.Store} source This Store
   */

  /**
   * Fired on successful load
   * @event load
   * @param {Common.data.Store} source This Store
   * @param {Object[]} data Data loaded
   * @param {Response} response the `Response` object
   * @param {Object} json The decoded response object.
   */

  /**
   * Fired on successful load of remote child nodes for a tree node.
   * @event loadChildren
   * @param {Common.data.Store} source This Store
   * @param {Object[]} data Data loaded
   * @param {Object} json The decoded response object.
   */

  /**
   * Fired after committing removed records
   * @event commitRemoved
   * @param {Common.data.Store} source This Store
   */

  /**
   * Fired before loading starts. Allows altering parameters and is cancelable
   * @event beforeLoad
   * @param {Common.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax requet.
   */

  /**
   * Fired before loading of remote child nodes of a tree node starts. Allows altering parameters and is cancelable
   * @event beforeLoadChildren
   * @param {Common.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax requet.
   */

  /**
   * Fired when loading is beginning. This is not cancelable. Parameters in the event may still be
   * mutated at this stage.
   * @event loadStart
   * @param {Common.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax requet.
   */

  /**
   * Fired when loading of remote child nodes into a tree node is beginning. This is not cancelable. Parameters in the event may still be
   * mutated at this stage.
   * @event loadChildrenStart
   * @param {Common.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax requet.
   */

  /**
   * Fired before any remote request is initiated.
   * @event beforeRequest
   * @param {Common.data.Store} source This Store
   * @param {String} action Action that is making the request, `'create'`, `'read'`, `'update'` or `'delete'`
   */

  /**
   * Fired after any remote request has finished whether successfully or unsuccessfully.
   * @event afterRequest
   * @param {Boolean} exception `true`. *Only present if the request triggered an exception.*
   * @param {String} action Action that has finished, `'create'`, `'read'`, `'update'` or `'delete'`
   * @param {String} exceptionType The type of failure, `'network'` or `'server'`. *Only present if the request triggered an exception.*
   * @param {Response} response The `Response` object
   * @param {Object} json The decoded response object if there was no `'network'` exception.
   */

  // endregion

  //region Config

  static get defaultConfig() {
    return {
      /**
       * An object containing the HTTP headers to add to each server request issued by this Store.
       * @config {Object}
       * @default
       */
      headers: null,

      /**
       * An object containing the Fetch options to pass to each server request issued by this Store. Use this to control if credentials are sent
       * and other options, read more at [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).
       * @config {Object}
       * @default
       */
      fetchOptions: null,

      /**
       * Specify `true` to send payloads as form data, `false` to send as regular JSON.
       * @config {Boolean}
       * @default
       */
      sendAsFormData: false,

      /**
       * Specify `true` to send all model fields when committing modified records (as opposed to just the modified fields)
       * @config {Boolean}
       * @default
       */
      writeAllFields: false,

      /**
       * The name of the HTTP parameter passed to this Store's {@link #config-readUrl} to indicate the node `id` to
       * load when loading child nodes on demand if the node being expanded was created with data containing `children: true`.
       * @config {String}
       * @default
       */
      parentIdParamName: 'id',

      /**
       * The property name in JSON responses from the server that contains the data for the records
       * ```
       * {
       *   "success" : true,
       *   // The property name used here should match that of 'reponseDataProperty'
       *   "data" : [
       *     ...
       *   ]
       * }
       * ```
       * @config {String}
       * @default
       */
      responseDataProperty: 'data'
    };
  }

  /**
   * Url to post newly created records to.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * Just the array of data may be returned, however that precludes the
   * orderly handling of errors encountered at the server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler
   * in the `response` property of the event.
   *
   * The `success` property may be ommitted, it defaults to `true`.
   *
   * @config {String} createUrl
   * @category CRUD
   */

  /**
   * Url to read data from.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * Just the array of data may be returned, however that precludes the
   * orderly handling of errors encountered at the server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler
   * in the `response` property of the event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @config {String} readUrl
   * @category CRUD
   */

  /**
   * Url to post record modifications to.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * Just the array of data may be returned, however that precludes the
   * orderly handling of errors encountered at the server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler
   * in the `response` property of the event.
   *
   * The `success` property may be ommitted, it defaults to `true`.
   *
   * @config {String} updateUrl
   * @category CRUD
   */

  /**
   * Url for destroying records.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true
   *     }
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler
   * in the `response` property of the event.
   *
   * The `success` property may be ommitted, it defaults to `true`.
   *
   * @config {String} deleteUrl
   * @category CRUD
   */

  /**
   * True to initiate a load when the store is instantiated
   * @config {Boolean} autoLoad
   * @category Common
   */

  //endregion

  afterConstruct(config) {
    super.afterConstruct(config);

    if (this.autoLoad) {
      this.load().catch((e) => {});
    }
  }

  /**
   * Returns true if the Store is currently loading
   * @property {Boolean}
   * @readonly
   * @category CRUD
   */
  get isLoading() {
    return this._isLoading;
  }

  /**
   * Returns true if the Store is currently committing
   * @property {Boolean}
   * @readonly
   * @category CRUD
   */
  get isCommitting() {
    return Boolean(this.commitPromise);
  }

  buildQueryString(...paramObjects) {
    const queryString = Object.entries(Object.assign({}, ...paramObjects))
      .reduce(processParamEntry, [])
      .join('&');

    return queryString ? '?' + queryString : '';
  }

  internalLoad(params, eventName, successFn) {
    const me = this,
      allParams = Object.assign({}, me.params, params),
      event = { action: 'read' + eventName, params: allParams },
      result = me.readUrl
        ? new Promise((resolve, reject) => {
            if (me.trigger('beforeLoad' + eventName, event) === false) {
              return reject(false); // eslint-disable-line
            }

            me._isLoading = true;

            // This may look redundant, but it allows for two levels of event listening.
            // Granular, where the observer observes only the events of interest, and
            // catch-all, where the observer is interested in all requests.
            me.trigger(`load${eventName}Start`, event);
            me.trigger('beforeRequest', event);

            AjaxHelper.get(
              me.readUrl + me.buildQueryString(allParams),
              Object.assign({ headers: me.headers, parseJson: true }, me.fetchOptions)
            )
              .then((response) => {
                const data = response.parsedJson,
                  isArray = Array.isArray(data),
                  success = isArray || (data && data.success !== false);

                me._isLoading = false;
                event.response = response;
                event.json = data;

                if (success) {
                  event.data = isArray ? data : data[me.responseDataProperty];
                  successFn(event);
                  me.trigger('load' + eventName, event);
                  resolve(event);
                } else {
                  event.exception = true;

                  event.exceptionType = 'server';
                  me.trigger('exception', event);
                  reject(event);
                }

                // finally
                me.trigger('afterRequest', event);
              })
              .catch((responseOrError) => {
                me._isLoading = false;

                event.exception = true;

                if (responseOrError instanceof Response) {
                  event.exceptionType = responseOrError.ok ? 'server' : 'network';
                  event.response = responseOrError;
                  event.error = responseOrError.error;
                } else {
                  event.exceptionType = 'server';
                  event.error = responseOrError;
                }

                me.trigger('exception', event);
                reject(event);

                // finally
                me.trigger('afterRequest', event);
              });
          })
        : null;

    return result;
  }

  /**
   * Load data from the {@link #config-readUrl}.
   * @param {Object} params A hash of parameters to append to querystring (will also append Store#params)
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoad} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoad} handler.
   * @fires beforeLoad
   * @fires loadStart
   * @fires beforeRequest
   * @fires load
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  load(params) {
    const me = this;

    return me.internalLoad(params, '', (event) => {
      // The set Data setter will trigger the refresh event with { action: 'dataset' }
      me.data = event.data;
    });
  }

  /**
   * Loads children into specified parent record. Parent records id is sent as a param (param name configured with
   * {@link #config-parentIdParamName}.
   * @param {Common.data.Model} parentRecord Parent record
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoadChildren} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoadChildren} handler.
   * @fires beforeLoadChildren
   * @fires loadChildrenStart
   * @fires beforeRequest
   * @fires loadChildren
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  async loadChildren(parentRecord) {
    const me = this;

    return me.internalLoad({ [me.parentIdParamName]: parentRecord.id }, 'Children', (event) => {
      event.parentRecord = parentRecord;
      // Append received children
      parentRecord.data[parentRecord.constructor.childrenField] = event.data;
      parentRecord.processChildren(parentRecord.stores);
    });
  }

  /**
   * Commits all changes (added, modified and removed) using corresponding urls ({@link #config-createUrl},
   * {@link #config-updateUrl} and {@link #config-deleteUrl})
   * @fires beforeCommit
   * @returns {Promise} A Promise which is resolved only if all pending changes (Create, Update and Delete) successfully resolve.
   * Both the resolve and reject functions are passed a `commitState` object which is stored the {@link #event-afterRequest}
   * event for each request. Each event contains the `exception`, `request` and `response` properties eg:
   *
   *     {
   *          success: true,                  // If *all* commits succeeded
   *          changes: {
   *              added: [records...],
   *              modified: [records...],
   *              removed: [records...],
   *          },
   *          added: {
   *              source: theStore,
   *              exception: true,            // Only if the add request triggered an exception
   *              exceptionType: 'server'/'network', // Only if the add request triggered an exception
   *              response: Response,
   *              json: parsedResponseObject
   *          },
   *          modified: {},                   // Same format as added
   *          removed: {}                     // Same format as added
   *     }
   *
   * If there were no pending changes, the resolve and reject functions are passed no parameters.
   *
   * Returns `false` if a commit operation is already in progress.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * @category CRUD
   */
  commit() {
    const me = this,
      changes = me.changes,
      allPromises = [];

    // not allowing additional commits while in progress
    // TODO: should queue
    if (me.commitPromise) return false;

    // No outstanding changes, return a Promise that resolves immediately.
    if (!changes) {
      return immediatePromise$2;
    }

    // Flag all affected records as being committed
    [...changes.added, ...changes.modified, ...changes.removed].forEach((record) => (record.meta.committing = true));

    // TODO: do we need a general way of disabling plugins?
    if (!me.disabled && me.trigger('beforeCommit', { changes }) !== false) {
      let commitState = {
          action: 'commit',
          exception: false,
          changes
        },
        p = me.commitRemoved(commitState);

      if (p) {
        allPromises.push(p);
      }
      p = me.commitAdded(commitState);
      if (p) {
        allPromises.push(p);
      }
      p = me.commitModified(commitState);
      if (p) {
        allPromises.push(p);
      }

      // If there were no urls configured, behave as a local store
      if (!allPromises.length) {
        me.modified.forEach((r) => r.clearChanges(false));
        me.modified.clear();

        me.added.forEach((r) => r.clearChanges(false));
        me.added.clear();

        me.removed.clear();
        me.trigger('commit', { changes });
        return immediatePromise$2;
      }

      // The Promises from the commit methods all resolve whether the request
      // succeeded or not. They each contribute their afterrequest event to the
      // commitState which can be used to detect overall success or failure
      // and granular inspection of which operations succeeded or failed.
      // If there's only one operation, wait for it.
      // If there's more than one operation, we have to wait for allPromises to resolve.
      p = allPromises.length === 1 ? allPromises[0] : Promise.all(allPromises);

      return (me.commitPromise = new Promise((resolve, reject) => {
        p.then(() => {
          me.commitPromise = null;
          if (commitState.exception) {
            me.trigger('exception', commitState);
            reject(commitState);
          } else {
            me.trigger('commit', { changes });
            resolve(commitState);
          }
        }).catch(() => {
          me.commitPromise = null;
          reject(commitState);
        });
      }));
    }
  }

  // TODO: need a way to abort commits

  /**
   * Commits added records by posting to {@link #config-createUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was succesful.
   * @param {Object} commitState An object into which is added a `delete` property being the {@link #event-afterRequest} event.
   * @returns {Promise} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `add` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @private
   * @fires beforeRequest
   * @fires commitAdded
   * @fires refresh
   * @fires exception
   * @fires afterRequest
   */
  commitAdded(commitState) {
    const me = this,
      added = me.added,
      event = { action: 'create', params: me.params },
      result =
        added.count && me.createUrl
          ? new Promise((resolve) => {
              const toAdd = added.values.map((r) => r.persistableData);
              commitState.create = event;
              me.trigger('beforeRequest', event);

              let dataToSend = { data: toAdd };

              if (me.sendAsFormData) {
                const formData = new FormData();

                formData.append('data', JSON.stringify(toAdd));
                dataToSend = formData;
              }

              AjaxHelper.post(
                me.createUrl + me.buildQueryString(me.params),
                dataToSend,
                Object.assign({ headers: me.headers, parseJson: true }, me.fetchOptions)
              )
                .then((response) => {
                  const data = response.parsedJson,
                    isArray = Array.isArray(data),
                    success = isArray || (data && data.success !== false);

                  event.json = data;
                  event.response = response;

                  if (success) {
                    // Copy updated fields and updated ID back into records
                    me.processReturnedData(added.values, isArray ? data : data[me.responseDataProperty]);

                    me.added.forEach((r) => r.clearChanges(false));
                    added.clear();

                    me.trigger('commitAdded');

                    // We must signal a full refresh because any number of records could have recieved any number of field updates
                    // back from the server, so a refresh is more efficient than picking through the received updates.
                    me.trigger('refresh', event);

                    resolve(commitState);
                  } else {
                    // Clear committing flag
                    added.forEach((r) => (r.meta.committing = false));

                    commitState.exception = event.exception = true;

                    commitState.exceptionType = event.exceptionType = 'server';

                    me.trigger('exception', event);
                    resolve(commitState);
                  }

                  // finally
                  me.trigger('afterRequest', event);
                })
                .catch((responseOrError) => {
                  // Clear committing flag
                  added.forEach((r) => (r.meta.committing = false));

                  commitState.exception = event.exception = true;

                  if (responseOrError instanceof Response) {
                    event.exceptionType = responseOrError.ok ? 'server' : 'network';
                    event.response = responseOrError;
                    event.error = responseOrError.error;
                  } else {
                    event.exceptionType = 'server';
                    event.error = responseOrError;
                  }

                  me.trigger('exception', event);
                  resolve(commitState);

                  // finally
                  me.trigger('afterRequest', event);
                });
            })
          : null;

    return result;
  }

  /**
   * Commits modified records by posting to {@link #config-updateUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was succesful.
   * @param {Object} commitState An object into which is added a `delete` property being the {@link #event-afterRequest} event.
   * @returns {Promise} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `update` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @private
   * @fires beforeRequest
   * @fires commitModified
   * @fires refresh
   * @fires exception
   * @fires afterRequest
   */
  commitModified(commitState) {
    let me = this,
      modified = me.modified,
      event = { action: 'update', params: me.params },
      result =
        modified.count && me.updateUrl
          ? new Promise((resolve) => {
              const modifications = modified.map((r) => (me.writeAllFields ? r.persistableData : r.modifications));

              commitState.update = event;
              me.trigger('beforeRequest', event);

              let dataToSend = { data: modifications };

              if (me.sendAsFormData) {
                const formData = new FormData();

                formData.append('data', JSON.stringify(modifications));
                dataToSend = formData;
              }

              AjaxHelper.post(
                me.updateUrl + me.buildQueryString(me.params),
                dataToSend,
                Object.assign({ headers: me.headers, parseJson: true }, me.fetchOptions)
              )
                .then((response) => {
                  const data = response.parsedJson,
                    isArray = Array.isArray(data),
                    success = isArray || (data && data.success !== false);

                  event.json = data;
                  event.response = response;

                  if (success) {
                    // Copy updated fields and updated ID back into records
                    me.processReturnedData(me.modified.values, isArray ? data : data[me.responseDataProperty], true);

                    // Clear down modified fields cache
                    modified.forEach((r) => r.clearChanges(false));
                    modified.clear();

                    me.trigger('commitModified');

                    // We must signal a full refresh because any number of records could have recieved any number of field updates
                    // back from the server, so a refresh is more efficient than picking through the received updates.
                    me.trigger('refresh', event);

                    resolve(commitState);
                  } else {
                    // Clear committing flag
                    modified.forEach((r) => (r.meta.committing = false));

                    commitState.exception = event.exception = true;
                    event.exceptionType = 'server';
                    me.trigger('exception', event);
                    resolve(commitState);
                  }

                  // finally
                  me.trigger('afterRequest', event);
                })
                .catch((responseOrError) => {
                  // Clear committing flag
                  modified.forEach((r) => (r.meta.committing = false));

                  commitState.exception = event.exception = true;

                  if (responseOrError instanceof Response) {
                    event.exceptionType = responseOrError.ok ? 'server' : 'network';
                    event.response = responseOrError;
                    event.error = responseOrError.error;
                  } else {
                    event.exceptionType = 'server';
                    event.error = responseOrError;
                  }

                  me.trigger('exception', event);
                  resolve(commitState);

                  // finally
                  me.trigger('afterRequest', event);
                });
            })
          : null;

    return result;
  }

  processReturnedData(localRecords, returnedData, isUpdating = false) {
    const me = this,
      Model = me.modelClass,
      idDataSource = Model.fieldMap.id.dataSource;

    returnedData.forEach((recData, i) => {
      // Using syncId to update record's id with no flagging the property as modified.
      localRecords[i].syncId(recData[idDataSource]);

      // When updating, only want to apply the actual changes and not reapply defaults. When adding, also
      // apply the defaults
      Object.assign(localRecords[i].data, Model.processData(recData, isUpdating));
    });
  }

  /**
   * Commits removed records by posting to {@link #config-deleteUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was succesful.
   * @param {Object} commitState An object into which is added a `delete` property being the {@link #event-afterRequest} event.
   * @returns {Promise} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `delete` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @private
   * @fires beforerequest
   * @fires commitremoved
   * @fires refresh
   * @fires exception
   * @fires afterrequest
   */
  commitRemoved(commitState) {
    const me = this,
      removed = me.removed,
      event = { action: 'delete', params: me.params },
      result =
        removed.count && me.deleteUrl
          ? new Promise((resolve) => {
              commitState.delete = event;
              me.trigger('beforeRequest', event);

              let dataToSend = { ids: removed.map((r) => r.id) };

              if (me.sendAsFormData) {
                const formData = new FormData();

                formData.append('id', JSON.stringify(dataToSend.ids));
                dataToSend = formData;
              }

              AjaxHelper.post(
                me.deleteUrl + me.buildQueryString(me.params),
                dataToSend,
                Object.assign({ headers: me.headers, parseJson: true }, me.fetchOptions)
              )
                .then((response) => {
                  const data = response.parsedJson,
                    isArray = Array.isArray(data),
                    success = isArray || (data && data.success !== false);

                  event.json = data;
                  event.response = response;

                  if (success) {
                    removed.forEach((record) => (record.meta.committing = false)); // In case used by other store etc.
                    removed.clear();

                    me.trigger('commitRemoved');
                    me.trigger('refresh', event);

                    resolve(commitState);
                  } else {
                    // Clear committing flag
                    removed.forEach((r) => (r.meta.committing = false));

                    commitState.exception = event.exception = true;

                    event.exceptionType = 'server';
                    me.trigger('exception', event);
                    resolve(commitState);
                  }

                  // finally
                  me.trigger('afterRequest', event);
                })
                .catch((responseOrError) => {
                  // Clear committing flag
                  removed.forEach((r) => (r.meta.committing = false));

                  commitState.exception = event.exception = true;

                  if (responseOrError instanceof Response) {
                    event.exceptionType = responseOrError.ok ? 'server' : 'network';
                    event.response = responseOrError;
                    event.error = responseOrError.error;
                  } else {
                    event.exceptionType = 'server';
                    event.error = responseOrError;
                  }

                  me.trigger('exception', event);
                  resolve(commitState);

                  // finally
                  me.trigger('afterRequest', event);
                });
            })
          : null;

    return result;
  }
}
AjaxStore._$name = 'AjaxStore';

/**
 * @module Common/data/stm/state/StateBase
 */

const throwAbstractMethodCall = () => {
  throw new Error('Abstract method call!');
};

const throwInvalidMethodCall = () => {
  throw new Error('Method cannot be called at this state!');
};

/**
 * Abstract class for STM states
 *
 * Every on* method should return a state for the STM which it should switch to
 * or throw an exception that this call at this state is illegal.
 *
 * Interface of this class mirrors interface of {@link Common.data.stm.StateTrackingManager}.
 *
 * @abstract
 */
class StateBase extends Base {
  canUndo(stm) {
    throwAbstractMethodCall();
  }

  canRedo(stm) {
    throwAbstractMethodCall();
  }

  onUndo(stm) {
    throwAbstractMethodCall();
  }

  onRedo(stm) {
    throwAbstractMethodCall();
  }

  onStartTransaction(stm) {
    throwAbstractMethodCall();
  }

  onStopTransaction(stm) {
    throwAbstractMethodCall();
  }

  onStopTransactionDelayed(stm) {
    throwAbstractMethodCall();
  }

  onRejectTransaction(stm) {
    throwAbstractMethodCall();
  }

  onEnable(stm) {
    throwAbstractMethodCall();
  }

  onDisable(stm) {
    throwAbstractMethodCall();
  }

  onAutoRecordOn(stm) {
    throwAbstractMethodCall();
  }

  onAutoRecordOff(stm) {
    throwAbstractMethodCall();
  }

  onResetQueue(stm) {
    throwAbstractMethodCall();
  }

  onModelUpdate(stm) {
    throwAbstractMethodCall();
  }

  onStoreModelAdd(stm) {
    throwAbstractMethodCall();
  }

  onStoreModelInsert(stm) {
    throwAbstractMethodCall();
  }

  onStoreModelRemove(stm) {
    throwAbstractMethodCall();
  }

  onStoreModelRemoveAll(stm) {
    throwAbstractMethodCall();
  }

  onModelInsertChild(stm) {
    throwAbstractMethodCall();
  }

  onModelRemoveChild(stm) {
    throwAbstractMethodCall();
  }
}
StateBase._$name = 'StateBase';

/**
 * @module Common/data/stm/Props.js
 * @internal
 */

const STATE_PROP = Symbol('STATE_PROP');
const STORES_PROP = Symbol('STORES_PROP');
const QUEUE_PROP = Symbol('QUEUE_PROP');
const POS_PROP = Symbol('POS_PROP');
const TRANSACTION_PROP = Symbol('TRANSACTION_PROP');
const TRANSACTION_TIMER_PROP = Symbol('TRANSACTION_TIMER_PROP');
const AUTO_RECORD_PROP = Symbol('AUTO_RECORD_PROP');
const PROPS = Object.freeze([
  STATE_PROP,
  STORES_PROP,
  QUEUE_PROP,
  POS_PROP,
  TRANSACTION_PROP,
  TRANSACTION_TIMER_PROP,
  AUTO_RECORD_PROP
]);

/**
 * @module Common/data/stm/state/Registry
 *
 * Provides map of registered STM states.
 *
 * Needed to remove states circular dependency.
 *
 * @internal
 */
const registry = new Map();

/**
 * Registers STM state class with the given name.
 *
 * @private
 *
 * @param {string} name
 * @param {Common.data.stm.state.StateBase} state
 */
const registerStmState = (name, state) => {
  registry.set(name, state);
};

/**
 * Resolves STM state class with the given name.
 *
 * @private
 *
 * @param {string} name
 * @return {Common.data.stm.state.StateBase} state
 */
const resolveStmState = (state) => {
  if (typeof state === 'string') {
    state = registry.get(state);
  }

  return state;
};

// UMD/module compatible export
// NOTE: the most compatible way of exporting is:
//       import registry from './Registry.js';
//       { registerStmState, resolveStmState } = registry;
//          or
//       registry.registerStmState(...);
var Registry = {
  registerStmState,
  resolveStmState
};

const resetQueue = (stm, options) => {
  const { undo, redo } = options;

  let newProps;

  if (undo && !redo) {
    newProps = {
      [QUEUE_PROP]: stm[QUEUE_PROP].slice(stm.position),
      [POS_PROP]: 0
    };
  } else if (redo && !undo) {
    newProps = {
      [QUEUE_PROP]: stm[QUEUE_PROP].slice(0, stm.position)
    };
  } else {
    newProps = {
      [QUEUE_PROP]: [],
      [POS_PROP]: 0
    };
  }
  return [
    newProps,
    () => {
      stm.notifyStoresAboutQueueReset(options);
    }
  ];
};

/**
 * @module Common/data/stm/state/DisabledState
 */

/**
 * STM disabled state class.
 *
 * @internal
 */
class DisabledStateClass extends StateBase {
  canUndo() {
    return false;
  }

  canRedo() {
    return false;
  }

  onUndo() {
    throwInvalidMethodCall();
  }

  onRedo() {
    throwInvalidMethodCall();
  }

  onEnable(stm) {
    return stm.autoRecord ? 'autoreadystate' : 'readystate';
  }

  onDisable() {
    throwInvalidMethodCall();
  }

  onAutoRecordOn() {
    return {
      [AUTO_RECORD_PROP]: true
    };
  }

  onAutoRecordOff() {
    return {
      [AUTO_RECORD_PROP]: false
    };
  }

  onStartTransaction() {
    throwInvalidMethodCall();
  }

  onStopTransaction() {
    throwInvalidMethodCall();
  }

  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }

  onRejectTransaction() {
    throwInvalidMethodCall();
  }

  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }

  onModelUpdate() {}
  onModelInsertChild() {}
  onModelRemoveChild() {}
  onStoreModelAdd() {}
  onStoreModelInsert() {}
  onStoreModelRemove() {}
  onStoreRemoveAll() {}
}

/**
 * STM disabled state.
 *
 * @internal
 */
const DisabledState = new DisabledStateClass();

Registry.registerStmState('disabledstate', DisabledState);

/**
 * @module Common/data/stm/Transaction
 */

const ACTION_QUEUE_PROP = Symbol('ACTION_QUEUE_PROP');

/**
 * STM transaction class, holds list of actions constituting a transaction.
 *
 * A transaction can be undone and redone. Upon undo all the actions being held
 * are undone in reverse order. Upon redo all the actions being held are redone
 * in forward order.
 */
class Transaction extends Base {
  get defaultConfig() {
    return {
      /**
       * Transaction title
       *
       * @config {String}
       * @default
       */
      title: null
    };
  }

  construct(...args) {
    this[ACTION_QUEUE_PROP] = [];

    super.construct(...args);
  }

  /**
   * Gets transaction's actions queue
   *
   * @property {Common.data.stm.action.ActionBase[]}
   */
  get queue() {
    return this[ACTION_QUEUE_PROP].slice(0);
  }

  /**
   * Gets transaction's actions queue length
   *
   * @property {Number}
   */
  get length() {
    return this[ACTION_QUEUE_PROP].length;
  }

  /**
   * Adds an action to the transaction.
   *
   * @param {Common.data.stm.action.ActionBase|Object} action
   */
  addAction(action) {
    this[ACTION_QUEUE_PROP].push(action);
  }

  /**
   * Undoes actions held
   */
  undo() {
    const queue = this[ACTION_QUEUE_PROP];

    for (let i = queue.length - 1; i >= 0; --i) {
      queue[i].undo();
    }
  }

  /**
   * Redoes actions held
   */
  redo() {
    const queue = this[ACTION_QUEUE_PROP];

    for (let i = 0, len = queue.length; i < len; ++i) {
      queue[i].redo();
    }
  }
}
Transaction._$name = 'Transaction';

/**
 * @module Common/data/stm/state/ReadyState
 */

/**
 * STM ready state class.
 *
 * @internal
 */
class ReadyStateClass extends StateBase {
  canUndo(stm) {
    //      v
    // |*|*|
    return 0 < stm.position && stm.position <= stm.length;
  }

  canRedo(stm) {
    //  v
    // |*|*|
    return 0 <= stm.position && stm.position < stm.length;
  }

  onUndo(stm, steps) {
    const queue = stm[QUEUE_PROP];

    let curPos = stm.position,
      newPos = Math.max(0, curPos - steps);

    const next = () => {
      stm.notifyStoresAboutStateRestoringStart();

      while (curPos != newPos) {
        queue[--curPos].undo();
      }

      return [
        stm.autoRecord ? 'autoreadystate' : 'readystate',
        () => {
          stm.notifyStoresAboutStateRestoringStop();
        }
      ];
    };

    return [
      {
        [STATE_PROP]: 'restoringstate',
        [POS_PROP]: newPos
      },
      next
    ];
  }

  onRedo(stm, steps) {
    const queue = stm[QUEUE_PROP];

    let curPos = stm.position,
      newPos = Math.min(queue.length, curPos + steps);

    const next = () => {
      stm.notifyStoresAboutStateRestoringStart();

      do {
        queue[curPos++].redo();
      } while (curPos != newPos);

      return [
        stm.autoRecord ? 'autoreadystate' : 'readystate',
        () => {
          stm.notifyStoresAboutStateRestoringStop();
        }
      ];
    };

    return [
      {
        [STATE_PROP]: 'restoringstate',
        [POS_PROP]: newPos
      },
      next
    ];
  }

  onEnable() {
    throwInvalidMethodCall();
  }

  onDisable() {
    return 'disabledstate';
  }

  onAutoRecordOn() {
    return {
      [STATE_PROP]: 'autoreadystate',
      [AUTO_RECORD_PROP]: true
    };
  }

  onAutoRecordOff() {
    throwInvalidMethodCall();
  }

  onStartTransaction(stm, title) {
    const transaction = new Transaction({ title: title });

    return [
      {
        [STATE_PROP]: 'recordingstate',
        [TRANSACTION_PROP]: transaction
      },
      () => {
        stm.notifyStoresAboutStateRecordingStart(transaction);
      }
    ];
  }

  onStopTransaction() {
    throwInvalidMethodCall();
  }

  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }

  onRejectTransaction() {
    throwInvalidMethodCall();
  }

  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }

  onModelUpdate() {}
  onModelInsertChild() {}
  onModelRemoveChild() {}
  onStoreModelAdd() {}
  onStoreModelInsert() {}
  onStoreModelRemove() {}
  onStoreRemoveAll() {}
}

/**
 * STM ready state.
 *
 * @internal
 */
let ReadyState = new ReadyStateClass();

Registry.registerStmState('readystate', ReadyState);

/**
 * @module Common/data/stm/state/RecordingState
 */

/**
 * STM recording state class.
 *
 * @internal
 */
class RecordingStateClass extends StateBase {
  canUndo() {
    return false;
  }

  canRedo() {
    return false;
  }

  onEnable() {}

  onDisable(stm) {
    const transaction = stm[TRANSACTION_PROP];

    stm.notifyStoresAboutStateRecordingStop(transaction, { disabled: true });

    return {
      [STATE_PROP]: 'disabledstate',
      [TRANSACTION_PROP]: null
    };
  }

  onAutoRecordOn(stm) {
    return [
      {
        [STATE_PROP]: 'autorecordingstate',
        [AUTO_RECORD_PROP]: true
      },
      () => {
        stm[STATE_PROP].onStopTransactionDelayed(stm);
      }
    ];
  }

  onAutoRecordOff() {
    throwInvalidMethodCall();
  }

  onStartTransaction() {
    throwInvalidMethodCall();
  }

  onStopTransaction(stm, title) {
    const transaction = stm[TRANSACTION_PROP];
    let position = stm[POS_PROP];
    let queue = stm[QUEUE_PROP];

    if (transaction.length) {
      if (!transaction.title && !title && stm.getTransactionTitle) {
        transaction.title = stm.getTransactionTitle(transaction);
      } else if (title) {
        transaction.title = title;
      }

      queue[position] = transaction;
      queue.length = ++position;
    }

    return [
      {
        [STATE_PROP]: 'readystate',
        [POS_PROP]: position,
        [TRANSACTION_PROP]: null
      },
      () => {
        stm.notifyStoresAboutStateRecordingStop(transaction, { stop: true });
      }
    ];
  }

  onRejectTransaction(stm) {
    const transaction = stm[TRANSACTION_PROP];

    return [
      {
        [STATE_PROP]: 'restoringstate',
        [TRANSACTION_PROP]: null
      },
      () => {
        if (transaction.length) {
          transaction.undo();
        }

        return [
          'readystate',
          () => {
            stm.notifyStoresAboutStateRecordingStop(transaction, { rejected: true });
          }
        ];
      }
    ];
  }

  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }

  onQueueReset() {
    throwInvalidMethodCall();
  }

  onModelUpdate(stm, model, newData, oldData) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelUpdateAction(model, newData, oldData));
  }

  onModelInsertChild(stm, parentModel, index, childModel, previousParent, previousIndex) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(
      stm.makeModelInsertChildAction(parentModel, index, childModel, previousParent, previousIndex)
    );
  }

  onModelRemoveChild(stm, parentModel, childModels, context) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelRemoveChildAction(parentModel, childModels, context));
  }

  onStoreModelAdd(stm, store, models, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelAddAction(store, models, silent));
  }

  onStoreModelInsert(stm, store, index, models, context, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelInsertAction(store, index, models, context, silent));
  }

  onStoreModelRemove(stm, store, models, context, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelRemoveAction(store, models, context, silent));
  }

  onStoreRemoveAll(stm, store, allRecords, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreRemoveAllAction(store, allRecords, silent));
  }
}

/**
 * STM recording state.
 *
 * @internal
 */
const RecordingState = new RecordingStateClass();

Registry.registerStmState('recordingstate', RecordingState);

/**
 * @module Common/data/stm/state/RestoringState
 */

/**
 * STM restoring state class.
 *
 * @internal
 */
class RestoringStateClass extends StateBase {
  canUndo() {
    return false;
  }

  canRedo() {
    return false;
  }

  onUndo() {
    throwInvalidMethodCall();
  }

  onRedo() {
    throwInvalidMethodCall();
  }

  onEnable() {
    throwInvalidMethodCall();
  }

  onDisable() {
    throwInvalidMethodCall();
  }

  onAutoRecordOn() {
    return {
      [AUTO_RECORD_PROP]: true
    };
  }

  onAutoRecordOff() {
    return {
      [AUTO_RECORD_PROP]: false
    };
  }

  onStartTransaction() {
    throwInvalidMethodCall();
  }

  onStopTransaction() {
    throwInvalidMethodCall();
  }

  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }

  onRejectTransaction() {
    throwInvalidMethodCall();
  }

  onQueueReset() {
    throwInvalidMethodCall();
  }

  onModelUpdate() {}
  onModelInsertChild() {}
  onModelRemoveChild() {}
  onStoreModelAdd() {}
  onStoreModelInsert() {}
  onStoreModelRemove() {}
  onStoreRemoveAll() {}
}

/**
 * STM restoring state.
 *
 * @internal
 */
const RestoringState = new RestoringStateClass();

Registry.registerStmState('restoringstate', RestoringState);

/**
 * @module Common/data/stm/state/AutoReadyState
 */

/**
 * STM transaction autostart ready state class.
 *
 * @internal
 */
class AutoReadyStateClass extends ReadyStateClass {
  onAutoRecordOn() {
    throwInvalidMethodCall();
  }

  onAutoRecordOff() {
    return {
      [STATE_PROP]: 'readystate',
      [AUTO_RECORD_PROP]: false
    };
  }

  onStartTransaction(stm, title) {
    const transaction = new Transaction({ title: title });

    return [
      {
        [STATE_PROP]: 'autorecordingstate',
        [TRANSACTION_PROP]: transaction
      },
      () => {
        stm.notifyStoresAboutStateRecordingStart(transaction);
        stm.stopTransactionDelayed();
      }
    ];
  }

  onModelUpdate(stm, model, newData, oldData) {
    stm.startTransaction();
    stm.onModelUpdate(model, newData, oldData);
  }

  onModelInsertChild(stm, parentModel, index, childModels, context) {
    stm.startTransaction();
    stm.onModelInsertChild(parentModel, index, childModels, context);
  }

  onModelRemoveChild(stm, parentModel, childModels, context) {
    stm.startTransaction();
    stm.onModelRemoveChild(parentModel, childModels, context);
  }

  onStoreModelAdd(stm, store, models, silent) {
    stm.startTransaction();
    stm.onStoreModelAdd(store, models, silent);
  }

  onStoreModelInsert(stm, store, index, models, context, silent) {
    stm.startTransaction();
    stm.onStoreModelInsert(store, index, models, silent);
  }

  onStoreModelRemove(stm, store, models, context, silent) {
    stm.startTransaction();
    stm.onStoreModelRemove(store, models, context, silent);
  }

  onStoreRemoveAll(stm, store, allRecords, silent) {
    stm.startTransaction();
    stm.onStoreRemoveAll(store, allRecords, silent);
  }
}

/**
 * STM transaction autostart ready state.
 *
 * @internal
 */
const AutoReadyState = new AutoReadyStateClass();

Registry.registerStmState('autoreadystate', AutoReadyState);

/**
 * @module Common/data/stm/state/AutoRecordingState
 */

/**
 * STM recording state class.
 *
 * @internal
 */
class AutoRecordingStateClass extends Delayable(RecordingStateClass) {
  onDisable(stm) {
    const transaction = stm[TRANSACTION_PROP];
    const timer = stm[TRANSACTION_TIMER_PROP];

    if (timer) {
      this.clearTimeout(timer);
    }

    stm.notifyStoresAboutStateRecordingStop(transaction, { disabled: true });

    return {
      [STATE_PROP]: 'disabledstate',
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    };
  }

  onAutoRecordOn(stm) {
    throwInvalidMethodCall();
  }

  onAutoRecordOff(stm) {
    const timer = stm[TRANSACTION_TIMER_PROP];

    if (timer) {
      this.clearTimeout(timer);
    }

    return {
      [STATE_PROP]: 'recordingstate',
      [AUTO_RECORD_PROP]: false,
      [TRANSACTION_TIMER_PROP]: null
    };
  }

  onStopTransaction(stm, title) {
    const transaction = stm[TRANSACTION_PROP];
    const timer = stm[TRANSACTION_TIMER_PROP];
    let position = stm[POS_PROP];
    let queue = stm[QUEUE_PROP];

    if (timer) {
      this.clearTimeout(timer);
    }

    if (transaction.length) {
      if (!transaction.title && !title && stm.getTransactionTitle) {
        transaction.title = stm.getTransactionTitle(transaction);
      } else if (title) {
        transaction.title = title;
      }

      queue[position] = transaction;
      queue.length = ++position;
    }

    return [
      {
        [STATE_PROP]: 'autoreadystate',
        [POS_PROP]: position,
        [TRANSACTION_PROP]: null,
        [TRANSACTION_TIMER_PROP]: null
      },
      () => {
        stm.notifyStoresAboutStateRecordingStop(transaction, { stop: true });
      }
    ];
  }

  onStopTransactionDelayed(stm) {
    let timer = stm[TRANSACTION_TIMER_PROP];

    if (timer) {
      this.clearTimeout(timer);
    }

    timer = this.setTimeout(() => {
      stm.stopTransaction();
    }, stm.autoRecordTransactionStopTimeout);

    return {
      [STATE_PROP]: AutoRecordingState,
      [TRANSACTION_TIMER_PROP]: timer
    };
  }

  onRejectTransaction(stm) {
    const transaction = stm[TRANSACTION_PROP],
      timer = stm[TRANSACTION_TIMER_PROP];

    if (timer) {
      this.clearTimeout(timer);
    }

    return [
      {
        [STATE_PROP]: 'restoringstate',
        [TRANSACTION_PROP]: null,
        [TRANSACTION_TIMER_PROP]: null
      },
      () => {
        if (transaction.length) {
          transaction.undo();
        }

        return [
          'autoreadystate',
          () => {
            stm.notifyStoresAboutStateRecordingStop(transaction, { rejected: true });
          }
        ];
      }
    ];
  }

  onModelUpdate(stm, ...rest) {
    super.onModelUpdate(stm, ...rest);
    stm.stopTransactionDelayed();
  }

  onModelInsertChild(stm, ...rest) {
    super.onModelInsertChild(stm, ...rest);
    stm.stopTransactionDelayed();
  }

  onModelRemoveChild(stm, ...rest) {
    super.onModelRemoveChild(stm, ...rest);
    stm.stopTransactionDelayed();
  }

  onStoreModelAdd(stm, ...rest) {
    super.onStoreModelAdd(stm, ...rest);
    stm.stopTransactionDelayed();
  }

  onStoreModelInsert(stm, ...rest) {
    super.onStoreModelInsert(stm, ...rest);
    stm.stopTransactionDelayed();
  }

  onStoreModelRemove(stm, ...rest) {
    super.onStoreModelRemove(stm, ...rest);
    stm.stopTransactionDelayed();
  }

  onStoreRemoveAll(stm, ...rest) {
    super.onStoreRemoveAll(stm, ...rest);
    stm.stopTransactionDelayed();
  }
}

/**
 * STM recording state.
 *
 * @internal
 */
const AutoRecordingState = new AutoRecordingStateClass();

Registry.registerStmState('autorecordingstate', AutoRecordingState);

/**
 * @module Common/data/stm/action/ActionBase
 */

const throwAbstractMethodCall$1 = () => {
  throw new Error('Abstract method call!');
};

/**
 * Base class for STM actions.
 *
 * @abstract
 */
class ActionBase extends Base {
  /**
   * Gets the type of the action (stringified class name).
   *
   * @return {String}
   */
  get type() {
    return this.constructor.name;
  }

  /**
   * Undoes an action
   */
  undo() {
    throwAbstractMethodCall$1();
  }

  /**
   * Redoes an action
   */
  redo() {
    throwAbstractMethodCall$1();
  }
}
ActionBase._$name = 'ActionBase';

/**
 * @module Common/data/stm/action/UpdateAction
 */

const MODEL_PROP = Symbol('MODEL_PROP');
const NEW_DATA_PROP = Symbol('NEW_DATA_PROP');
const OLD_DATA_PROP = Symbol('OLD_DATA_PROP');

/**
 * Action to record the fact that a model has been updated.
 */
class UpdateAction extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a model which has been updated.
       *
       * @config {Common.data.Model}
       * @default
       */
      model: undefined,

      /**
       * Map of updated properties with new values.
       *
       * @config {Object}
       * @default
       */
      newData: undefined,

      /**
       * Map of updated properties with old values.
       *
       * @config {Object}
       * @default
       */
      oldData: undefined
    };
  }

  get type() {
    return 'UpdateAction';
  }

  get model() {
    return this[MODEL_PROP];
  }

  set model(value) {
    this[MODEL_PROP] = value;
  }

  get newData() {
    return this[NEW_DATA_PROP];
  }

  set newData(value) {
    this[NEW_DATA_PROP] = Object.assign({}, value);
  }

  get oldData() {
    return this[OLD_DATA_PROP];
  }

  set oldData(value) {
    this[OLD_DATA_PROP] = Object.assign({}, value);
  }

  undo() {
    this.model.set(this.oldData);
  }

  redo() {
    this.model.set(this.newData);
  }
}
UpdateAction._$name = 'UpdateAction';

/**
 * @module Common/data/stm/action/InsertChildAction
 */

const PARENT_MODEL_PROP = Symbol('PARENT_MODEL_PROP');
const CHILD_MODELS_PROP = Symbol('CHILD_MODELS_PROP');
const INSERT_INDEX_PROP = Symbol('INSERT_INDEX_PROP');
const CONTEXT_PROP = Symbol('CONTEXT_PROP');

/**
 * Action to record the fact of adding a children models into a parent model.
 */
class InsertChildAction extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a parent model a child model has been added to.
       *
       * @config {Common.data.Model}
       * @default
       */
      parentModel: undefined,

      /**
       * Children models inserted.
       *
       * @config {Common.data.Model[]}
       * @default
       */
      childModels: undefined,

      /**
       * Index a children models are inserted at
       *
       * @config {Number}
       * @default
       */
      insertIndex: undefined,

      /**
       * Map having children models as keys and values containing previous parent
       * of each model and index at the previous parent.
       *
       * @config {Object}
       * @default
       */
      context: undefined
    };
  }

  get type() {
    return 'InsertChildAction';
  }

  get parentModel() {
    return this[PARENT_MODEL_PROP];
  }

  set parentModel(model) {
    this[PARENT_MODEL_PROP] = model;
  }

  get childModels() {
    return this[CHILD_MODELS_PROP];
  }

  set childModels(models) {
    this[CHILD_MODELS_PROP] = models.slice(0);
  }

  get insertIndex() {
    return this[INSERT_INDEX_PROP];
  }

  set insertIndex(index) {
    this[INSERT_INDEX_PROP] = index;
  }

  get context() {
    return this[CONTEXT_PROP];
  }

  set context(ctx) {
    this[CONTEXT_PROP] = ctx;
  }

  undo() {
    const { parentModel, context, childModels } = this;

    // Let's sort models by parent index such that models with lesser index
    // were inserted back first, thus making valid parent index of models following.
    childModels.sort((lhs, rhs) => {
      const { lhsParent, lhsIndex } = context.get(lhs) || {},
        { rhsParent, rhsIndex } = context.get(rhs) || {};

      return lhsParent && lhsParent === rhsParent ? lhsIndex - rhsIndex : 0;
    });

    // Now let's re-insert records back to where they were or remove them
    // if they weren't anywhere
    childModels.forEach((m) => {
      const { parent, index } = context.get(m) || {};

      if (parent) {
        // If we move within same parent then index must be adjusted
        if (parent === parentModel) {
          parent.insertChild(m, parent.children[index + 1]);
        } else {
          // Insert at previous index
          parent.insertChild(m, parent.children[index]);
        }
      } else {
        // Just remove
        parentModel.removeChild(m);
      }
    });
  }

  redo() {
    const me = this;
    me.parentModel.insertChild(me.insertIndex, me.childModels);
  }
}
InsertChildAction._$name = 'InsertChildAction';

const PARENT_MODEL_PROP$1 = Symbol('PARENT_MODEL_PROP');
const CHILD_MODELS_PROP$1 = Symbol('CHILD_MODELS_PROP');
const CONTEXT_PROP$1 = Symbol('CONTEXT_PROP');

class RemoveChildAction extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a parent model a child model has been removed to.
       *
       * @config {Common.data.Model}
       * @default
       */
      parentModel: undefined,

      /**
       * Children models removed.
       *
       * @config {Common.data.Model[]}
       * @default
       */
      childModels: undefined,

      /**
       * Map having children models as keys and values containing previous parent
       * index at the parent.
       *
       * @config {Object}
       * @default
       */
      context: undefined
    };
  }

  get type() {
    return 'RemoveChildAction';
  }

  get parentModel() {
    return this[PARENT_MODEL_PROP$1];
  }

  set parentModel(model) {
    this[PARENT_MODEL_PROP$1] = model;
  }

  get childModels() {
    return this[CHILD_MODELS_PROP$1];
  }

  set childModels(models) {
    this[CHILD_MODELS_PROP$1] = models.slice(0);
  }

  get context() {
    return this[CONTEXT_PROP$1];
  }

  set context(ctx) {
    this[CONTEXT_PROP$1] = ctx;
  }

  undo() {
    const { parentModel, context, childModels } = this;

    // Let's sort models by parent index such that models with lesser index
    // were inserted back first, thus making valid parent index of models following.

    childModels.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs),
        rhsIndex = context.get(rhs);

      return lhsIndex - rhsIndex;
    });

    // Now let's re-insert records back to where they were
    childModels.forEach((m) => {
      parentModel.insertChild(context.get(m), m);
    });
  }

  redo() {
    this.parentModel.removeChild(this.childModels);
  }
}
RemoveChildAction._$name = 'RemoveChildAction';

/**
 * @module Common/data/stm/action/AddAction
 */
const STORE_PROP = Symbol('STORE_PROP');
const MODEL_LIST_PROP = Symbol('MODEL_LIST_PROP');

/**
 * Action to record the fact of models adding to a store.
 */
class AddAction extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a store models have been added into.
       *
       * @config {Common.data.Store}
       * @default
       */
      store: undefined,

      /**
       * List of models added into the store.
       *
       * @config {Common.data.Model[]}
       * @default
       */
      modelList: undefined,

      /**
       * Flag showing if undo/redo should be done silently i.e. with events suppressed
       *
       * @config {Boolean}
       * @default
       */
      silent: false
    };
  }

  get type() {
    return 'AddAction';
  }

  get store() {
    return this[STORE_PROP];
  }

  set store(store) {
    this[STORE_PROP] = store;
  }

  get modelList() {
    return this[MODEL_LIST_PROP];
  }

  set modelList(list) {
    this[MODEL_LIST_PROP] = list.slice(0);
  }

  undo() {
    const me = this;
    me.store.remove(me.modelList, me.silent);
  }

  redo() {
    const me = this;
    me.store.add(me.modelList, me.silent);
  }
}
AddAction._$name = 'AddAction';

/**
 * @module Common/data/stm/action/InsertAction
 */

const STORE_PROP$1 = Symbol('STORE_PROP');
const MODEL_LIST_PROP$1 = Symbol('MODEL_LIST_PROP');
const INSERT_INDEX_PROP$1 = Symbol('INSERT_INDEX_PROP');
const CONTEXT_PROP$2 = Symbol('CONTEXT_PROP');

/**
 * Action to record the fact of models inserting into a store.
 */
class InsertAction extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a store models have been inserted into.
       *
       * @config {Common.data.Store}
       * @default
       */
      store: undefined,

      /**
       * List of models inserted into the store.
       *
       * @config {Common.data.Model[]}
       * @default
       */
      modelList: undefined,

      /**
       * Index the models have been inserted at.
       *
       * @config {Number}
       * @default
       */
      insertIndex: undefined,

      /**
       * Models move context (if models has been moved), if any.
       * Map this {@link Common/data/Model} instances as keys and their
       * previous index as values
       *
       * @config {Map}
       * @default
       */
      context: undefined,

      /**
       * Flag showing if undo/redo should be done silently i.e. with events suppressed
       *
       * @config {Boolean}
       * @default
       */
      silent: false
    };
  }

  get type() {
    return 'InsertAction';
  }

  get store() {
    return this[STORE_PROP$1];
  }

  set store(store) {
    this[STORE_PROP$1] = store;
  }

  get modelList() {
    return this[MODEL_LIST_PROP$1];
  }

  set modelList(list) {
    this[MODEL_LIST_PROP$1] = list.slice(0);
  }

  get insertIndex() {
    return this[INSERT_INDEX_PROP$1];
  }

  set insertIndex(index) {
    this[INSERT_INDEX_PROP$1] = index;
  }

  get context() {
    return this[CONTEXT_PROP$2];
  }

  set context(context) {
    this[CONTEXT_PROP$2] = context;
  }

  undo() {
    const { store, modelList, context, silent } = this;

    // Let's sort models by index such that models with lesser index
    // were inserted back first, thus making valid index of models following.

    modelList.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs),
        rhsIndex = context.get(rhs);

      return lhsIndex !== undefined && rhsIndex !== undefined ? lhsIndex - rhsIndex : 0;
    });

    modelList.forEach((m) => {
      const index = context.get(m);

      if (index !== undefined) {
        // Insert at previous index
        store.insert(index, m, silent);
      } else {
        // Just remove
        store.remove(m, silent);
      }
    });
  }

  redo() {
    const me = this;
    me.store.insert(me.insertIndex, me.modelList, me.silent);
  }
}
InsertAction._$name = 'InsertAction';

/**
 * @module Common/data/stm/action/RemoveAction
 */

const STORE_PROP$2 = Symbol('STORE_PROP');
const MODEL_LIST_PROP$2 = Symbol('MODEL_LIST_PROP');
const CONTEXT_PROP$3 = Symbol('CONTEXT_PROP');

/**
 * Action to record the fact of models removed from a store.
 */
class RemoveAction extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a store models have been removed from.
       *
       * @config {Common.data.Store}
       * @default
       */
      store: undefined,

      /**
       * List of models removed from the store.
       *
       * @config {Common.data.Model[]}
       * @default
       */
      modelList: undefined,

      /**
       * Models removing context.
       *
       * @config {Object}
       * @default
       */
      context: undefined,

      /**
       * Flag showing if undo/redo should be done silently i.e. with events suppressed
       *
       * @config {Boolean}
       * @default
       */
      silent: false
    };
  }

  get type() {
    return 'RemoveAction';
  }

  get store() {
    return this[STORE_PROP$2];
  }

  set store(store) {
    this[STORE_PROP$2] = store;
  }

  get modelList() {
    return this[MODEL_LIST_PROP$2];
  }

  set modelList(list) {
    this[MODEL_LIST_PROP$2] = list.slice(0);
  }

  get context() {
    return this[CONTEXT_PROP$3];
  }

  set context(context) {
    this[CONTEXT_PROP$3] = context;
  }

  undo() {
    const { store, context, modelList, silent } = this;

    // Let's sort models by index such that models with lesser index
    // were inserted back first, thus making valid index of models following.
    modelList.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs),
        rhsIndex = context.get(rhs);

      // Here, in contrast to InsertAction, index is always present
      return lhsIndex - rhsIndex;
    });

    modelList.forEach((m) => {
      const index = context.get(m);

      // Insert at previous index
      store.insert(index, m, silent);
    });
  }

  redo() {
    const me = this;
    me.store.remove(me.modelList, me.silent);
  }
}
RemoveAction._$name = 'RemoveAction';

/**
 * @module Common/data/stm/action/RemoveAllAction
 */

const STORE_PROP$3 = Symbol('STORE_PROP');
const ALL_RECORDS_PROP = Symbol('ALL_RECORDS_PROP');

/**
 * Action to record store remove all operation.
 */
class RemoveAllAction extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a store cleared.
       *
       * @config {Common.data.Store}
       * @default
       */
      store: undefined,

      /**
       * All store records removed
       *
       * @config {Common.data.Model[]}
       * @default
       */
      allRecords: undefined,

      /**
       * Flag showing if undo/redo should be done silently i.e. with events suppressed
       *
       * @config {Boolean}
       * @default
       */
      silent: false
    };
  }

  get type() {
    return 'RemoveAllAction';
  }

  get store() {
    return this[STORE_PROP$3];
  }

  set store(store) {
    this[STORE_PROP$3] = store;
  }

  get allRecords() {
    return this[ALL_RECORDS_PROP];
  }

  set allRecords(records) {
    this[ALL_RECORDS_PROP] = records.slice(0);
  }

  undo() {
    const { store, allRecords, silent } = this;
    store.add(allRecords, silent);
  }

  redo() {
    const me = this;
    me.store.removeAll(me.silent);
  }
}
RemoveAllAction._$name = 'RemoveAllAction';

/**
 * @module Common/data/stm/StateTrackingManager
 */

const makeModelUpdateAction = (model, newData, oldData) => {
  return new UpdateAction({
    model,
    newData,
    oldData
  });
};

const makeModelInsertChildAction = (parentModel, insertIndex, childModels, context) => {
  return new InsertChildAction({
    parentModel,
    childModels,
    insertIndex,
    context
  });
};

const makeModelRemoveChildAction = (parentModel, childModels, context) => {
  return new RemoveChildAction({
    parentModel,
    childModels,
    context
  });
};

const makeStoreModelAddAction = (store, modelList, silent) => {
  return new AddAction({
    store,
    modelList,
    silent
  });
};

const makeStoreModelInsertAction = (store, insertIndex, modelList, context, silent) => {
  return new InsertAction({
    store,
    insertIndex,
    modelList,
    context,
    silent
  });
};

const makeStoreModelRemoveAction = (store, modelList, context, silent) => {
  return new RemoveAction({
    store,
    modelList,
    context,
    silent
  });
};

const makeStoreRemoveAllAction = (store, allRecords, silent) => {
  return new RemoveAllAction({
    store,
    allRecords,
    silent
  });
};

const stateTransition = (stm, event, ...args) => {
  const newState = event.call(stm[STATE_PROP], stm, ...args);

  if (typeof newState === 'string') {
    stm[STATE_PROP] = Registry.resolveStmState(newState);
  } else if (newState instanceof StateBase) {
    stm[STATE_PROP] = newState;
  } else if (Array.isArray(newState)) {
    const [state, next] = newState;

    if (typeof state === 'string') {
      stm[STATE_PROP] = Registry.resolveStmState(state);
    } else if (state instanceof StateBase) {
      stm[STATE_PROP] = state;
    } else if (state && typeof state === 'object') {
      stm = Object.assign(stm, state);
      stm[STATE_PROP] = Registry.resolveStmState(stm[STATE_PROP]);
    }

    if (typeof next === 'function') {
      stateTransition(stm, next, ...args);
    }
  } else if (newState && typeof newState === 'object') {
    stm = Object.assign(stm, newState);
    stm[STATE_PROP] = Registry.resolveStmState(stm[STATE_PROP]);
  }
};

/**
 * State Tracking Manager.
 *
 * When enabled tracks state of every store registered via {@link #function-addStore}.
 * Use {@link #function-undo} / {@link #function-redo} method calls to restore state to a particular
 * point in time
 *
 * @example
 *
 * stm = new StateTrackingManager({
 *     autoRecord : true,
 *     listeners  : {
 *        'recordingstop' : () => {
 *            // your custom code to update undo/redo GUI controls
 *            updateUndoRedoControls();
 *        },
 *        'restoringstop' : ({ stm }) => {
 *            // your custom code to update undo/redo GUI controls
 *            updateUndoRedoControls();
 *        }
 *    },
 *    getTransactionTitle : (transaction) => {
 *        // your custom code to analyze the transaction and return custom transaction title
 *        const lastAction = transaction.queue[transaction.queue.length - 1];
 *
 *        if (lastAction instanceof AddAction) {
 *            let title = 'Add new record';
 *        }
 *
 *        return title;
 *    }
 * });
 *
 * stm.addStore(userStore);
 * stm.addStore(companyStore);
 * stm.addStore(otherStore);
 *
 * stm.enable();
 */
class StateTrackingManager extends Events(Base) {
  static get defaultConfig() {
    return {
      /**
       * Default manager disabled state
       *
       * @config {Boolean}
       * @default
       */
      disabled: true,

      /**
       * Whether to start transaction recording automatically in case the Manager is enabled.
       *
       * In the auto recording mode, the manager waits for the first change in any store being managed and starts a transaction, i.e.
       * records any changes in its monitored stores. The transaction lasts for {@link #config-autoRecordTransactionStopTimeout} and
       * afterwards creates one undo/redo step, including all changes in the stores during that period of time.
       *
       * In non auto recording mode you have to call {@link #function-startTransaction} / {@link #function-stopTransaction} to start and end
       * a transaction.
       *
       * @config {Boolean}
       * @default
       */
      autoRecord: false,

      /**
       * The transaction duration (in ms) for the auto recording mode {@link #config-autoRecord}
       *
       * @config {Number}
       * @default
       */
      autoRecordTransactionStopTimeout: 100,

      /**
       * Store model update action factory
       *
       * @config {Function}
       * @default
       * @private
       */
      makeModelUpdateAction: makeModelUpdateAction,

      /**
       * Store insert child model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeModelInsertChildAction: makeModelInsertChildAction,

      /**
       * Store remove child model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeModelRemoveChildAction: makeModelRemoveChildAction,

      /**
       * Store add model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeStoreModelAddAction: makeStoreModelAddAction,

      /**
       * Store insert model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeStoreModelInsertAction: makeStoreModelInsertAction,

      /**
       * Store remove model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeStoreModelRemoveAction: makeStoreModelRemoveAction,

      /**
       * Store remove all models action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeStoreRemoveAllAction: makeStoreRemoveAllAction,

      /**
       * Function to create a transaction title if none is provided.
       *
       * The function receives a transaction and should return a title.
       *
       * @config {Function}
       * @default
       */
      getTransactionTitle: null
    };
  }

  construct(...args) {
    const me = this;

    Object.assign(me, {
      [STATE_PROP]: ReadyState,
      [STORES_PROP]: [],
      [QUEUE_PROP]: [],
      [POS_PROP]: 0,
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null,
      [AUTO_RECORD_PROP]: false
    });

    super.construct(...args);
  }

  doDestroy() {
    super.doDestroy();
    this.destroyProperties(STATE_PROP);
  }

  /**
   * Gets current state of the manager
   *
   * @return {Common.data.stm.state.StateBase}
   */
  get state() {
    return this[STATE_PROP];
  }

  /**
   * Gets current undo/redo queue position
   *
   * @return {Number}
   */
  get position() {
    return this[POS_PROP];
  }

  /**
   * Gets current undo/redo queue length
   *
   * @return {Number}
   */
  get length() {
    return this[QUEUE_PROP].length;
  }

  /**
   * Gets all the stores registered in STM
   *
   * @return {Common.data.Store[]}
   */
  get stores() {
    return Array.from(this[STORES_PROP]);
  }

  /**
   * Checks if a store has been added to the manager
   *
   * @param  {Common.data.Store} store
   * @return {Boolean}
   */
  hasStore(store) {
    return this[STORES_PROP].includes(store);
  }

  /**
   * Adds a store to the manager
   *
   * @param {Common.data.Store} store
   */
  addStore(store) {
    if (!this.hasStore(store)) {
      this[STORES_PROP].push(store);

      store.stm = this;
    }
  }

  /**
   * Removes a store from the manager
   *
   * @param {Common.data.Store} store
   */
  removeStore(store) {
    if (this.hasStore(store)) {
      this[STORES_PROP] = this[STORES_PROP].filter((s) => s !== store);
      store.stm = null;
    }
  }

  /**
   * Returns previously added store by it's id or undefined if store with the given id isn't added.
   *
   * @param  {String|Number} id
   * @return {Common.data.Store}
   * @deprecated 2.1
   */
  getStoreById(id) {
    return this[STORES_PROP].find((s) => s.id === id);
  }

  /**
   * Calls `fn` for each store registered in STM.
   *
   * @param {Function} fn (store, id) => ...
   */
  forEachStore(fn) {
    this[STORES_PROP].forEach((s) => fn(s, s.id));
  }

  /**
   * Get/set manager disabled state
   *
   * @property {Boolean}
   */
  get disabled() {
    return this.state === DisabledState;
  }

  set disabled(val) {
    const me = this;

    if (me.disabled != val) {
      if (val) {
        stateTransition(me, me.state.onDisable, me);
      } else {
        stateTransition(me, me.state.onEnable, me);
      }
    }
  }

  /**
   * Enables manager
   */
  enable() {
    this.disabled = false;
  }

  /**
   * Disables manager
   */
  disable() {
    this.disabled = true;
  }

  /**
   * Checks manager ready state
   *
   * @return {Boolean}
   */
  get isReady() {
    return this.state === ReadyState || this.state === AutoReadyState;
  }

  /**
   * Checks manager recording state
   *
   * @return {Boolean}
   */
  get isRecording() {
    return this.state === RecordingState || this.state === AutoRecordingState;
  }

  /**
   * Gets/sets manager auto record option
   *
   * @property {Boolean}
   */
  get autoRecord() {
    return this[AUTO_RECORD_PROP];
  }

  set autoRecord(value) {
    const me = this;

    if (me.autoRecord != value) {
      if (value) {
        stateTransition(me, me.state.onAutoRecordOn, me);
      } else {
        stateTransition(me, me.state.onAutoRecordOff, me);
      }
    }
  }

  /**
   * Starts undo/redo recording transaction.
   *
   * @param {String} [title=nul]
   */
  startTransaction(title = null) {
    stateTransition(this, this.state.onStartTransaction, title);
  }

  /**
   * Stops undo/redo recording transaction
   *
   * @param {String} [title=null]
   */
  stopTransaction(title = null) {
    stateTransition(this, this.state.onStopTransaction, title);
  }

  /**
   * Stops undo/redo recording transaction after {@link #config-autoRecordTransactionStopTimeout} delay.
   *
   * @private
   */
  stopTransactionDelayed() {
    stateTransition(this, this.state.onStopTransactionDelayed);
  }

  /**
   * Rejects currently recorded transaction.
   */
  rejectTransaction() {
    stateTransition(this, this.state.onRejectTransaction);
  }

  /**
   * Gets currently recording STM transaction.
   *
   * @return {Common.data.stm.Transaction}
   */
  get transaction() {
    return this[TRANSACTION_PROP];
  }

  /**
   * Gets titles of all recorded undo/redo transactions
   *
   * @return {String[]}
   */
  get queue() {
    return this[QUEUE_PROP].map((t) => t.title);
  }

  /**
   * Gets manager restoring state.
   *
   * @return {Boolean}
   */
  get isRestoring() {
    return this.state === RestoringState;
  }

  /**
   * Checks if the manager can undo.
   *
   * @return {Boolean}
   */
  get canUndo() {
    return this.state.canUndo(this);
  }

  /**
   * Checks if the manager can redo.
   *
   * @return {Boolean}
   */
  get canRedo() {
    return this.state.canRedo(this);
  }

  /**
   * Undoes current undo/redo transaction.
   *
   * @param {Number} [steps=1]
   */
  undo(steps = 1) {
    stateTransition(this, this.state.onUndo, steps);
  }

  /**
   * Undoes all transactions.
   */
  undoAll() {
    this.undo(this.length);
  }

  /**
   * Redoes current undo/redo transaction.
   *
   * @param {Number} [steps=1]
   */
  redo(steps = 1) {
    stateTransition(this, this.state.onRedo, steps);
  }

  /**
   * Redoes all transactions.
   */
  redoAll() {
    this.redo(this.length);
  }

  /**
   * Resets undo/redo queue.
   */
  resetQueue(/* private */ options = { undo: true, redo: true }) {
    stateTransition(this, this.state.onResetQueue, options);
  }

  /**
   * Resets undo queue.
   */
  resetUndoQueue() {
    this.resetQueue({ undo: true });
  }

  /**
   * Resets redo queue.
   */
  resetRedoQueue() {
    this.resetQueue({ redo: true });
  }

  notifyStoresAboutStateRecordingStart(transaction) {
    this.forEachStore((store) => {
      store.onStmRecordingStart && store.onStmRecordingStart(this, transaction);
    });
    /**
     * Fired upon state recording operation starts.
     *
     * @event recordingStart
     * @param {Common.data.stm.StateTrackingManager} stm
     * @param {Common.data.stm.Transaction} transaction
     */
    this.trigger('recordingStart', { stm: this, transaction });
  }

  notifyStoresAboutStateRecordingStop(transaction, reason) {
    this.forEachStore((store) => {
      store.onStmRecordingStop && store.onStmRecordingStop(this, transaction, reason);
    });
    /**
     * Fired upon state recording operation stops.
     *
     * @event recordingStop
     * @param {Common.data.stm.StateTrackingManager} stm
     * @param {Common.data.stm.Transaction} transaction
     * @param {Object} reason Transaction stop reason
     * @param {Boolean} reason.stop Transaction recording has been stopped in a normal way.
     * @param {Boolean} reason.disabled Transaction recording has been stopped due to STM has been disabled.
     * @param {Boolean} reason.rejected Transaction recording has been stopped due to transaction has been rejected.
     */
    this.trigger('recordingStop', { stm: this, transaction, reason });
  }

  notifyStoresAboutStateRestoringStart() {
    this.forEachStore((store) => {
      store.onStmRestoringStart && store.onStmRestoringStart(this);
    });
    /**
     * Fired upon state restoration operation starts.
     *
     * @event restoringStart
     * @param {Common.data.stm.StateTrackingManager} stm
     */
    this.trigger('restoringStart', { stm: this });
  }

  notifyStoresAboutStateRestoringStop() {
    this.forEachStore((store) => {
      store.onStmRestoringStop && store.onStmRestoringStop(this);
    });
    /**
     * Fired upon state restoration operation stops.
     *
     * @event restoringStop
     * @param {Common.data.stm.StateTrackingManager} stm
     */
    this.trigger('restoringStop', { stm: this });
  }

  notifyStoresAboutQueueReset(options) {
    this.forEachStore((store) => {
      store.onStmQueueReset && store.onStmQueueReset(this, options);
    });
    /**
     * Fired upon state undo/redo queue reset.
     *
     * @event queueReset
     * @param {Common.data.stm.StateTrackingManager} stm
     */
    this.trigger('queueReset', { stm: this, options });
  }

  /**
   * Method to call from model STM mixin upon model update
   *
   * @param {Common.data.Model} model
   * @param {Object} newData
   * @param {Object} oldData
   *
   * @private
   */
  onModelUpdate(model, newData, oldData) {
    stateTransition(this, this.state.onModelUpdate, model, newData, oldData);
  }

  /**
   * Method to call from model STM mixin upon tree model child insertion
   *
   * @param {Common.data.Model} parentModel Parent model
   * @param {Number} index Insertion index
   * @param {Common.data.Model[]} childModels Array of models inserted
   * @param {Map} context Map with inserted models as keys and objects with previous parent,
   *                      and index at previous parent.
   *
   * @private
   */
  onModelInsertChild(parentModel, index, childModels, context) {
    stateTransition(this, this.state.onModelInsertChild, parentModel, index, childModels, context);
  }

  /**
   * Method to call from model STM mixin upon tree model child removal
   *
   * @param {Common.data.Model} parentModel
   * @param {Common.data.Model[]} childModels
   * @param {Map} context
   *
   * @private
   */
  onModelRemoveChild(parentModel, childModels, context) {
    stateTransition(this, this.state.onModelRemoveChild, parentModel, childModels, context);
  }

  /**
   * Method to call from store STM mixin upon store models adding
   *
   * @param {Common.data.Store} store
   * @param {Common.data.Model[]} models
   * @param {Boolean} silent
   *
   * @private
   */
  onStoreModelAdd(store, models, silent) {
    stateTransition(this, this.state.onStoreModelAdd, store, models, silent);
  }

  /**
   * Method to call from store STM mixin upon store models insertion
   *
   * @param {Common.data.Store} store
   * @param {Number} index
   * @param {Common.data.Model[]} models
   * @param {Map} context
   * @param {Boolean} silent
   *
   * @private
   */
  onStoreModelInsert(store, index, models, context, silent) {
    stateTransition(this, this.state.onStoreModelInsert, store, index, models, context, silent);
  }

  /**
   * Method to call from store STM mixin upon store models removal
   *
   * @param {Common.data.Store} store
   * @param {Common.data.Model[]} models
   * @param {Object} context
   * @param {Boolean} silent
   *
   * @private
   */
  onStoreModelRemove(store, models, context, silent) {
    stateTransition(this, this.state.onStoreModelRemove, store, models, context, silent);
  }

  /**
   * Method to call from store STM mixin upon store clear
   *
   * @param {Common.data.Store} store
   * @param {Common.data.Model[]} allRecords
   * @param {Boolean} silent
   *
   * @private
   */
  onStoreRemoveAll(store, allRecords, silent) {
    stateTransition(this, this.state.onStoreRemoveAll, store, allRecords, silent);
  }
}
StateTrackingManager._$name = 'StateTrackingManager';

/**
 * @module Common/helper/CSSHelper
 */

/**
 * Provides methods to add and manipulate CSS style rules.
 *
 * Note that this class is incompatible with [CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)
 *
 * ```
 * this.criticalRule = CSSHelper.insertRule(`#${this.id} .b-sch-event.critical {background-color:${this.criticalColor}}`);
 * ```
 */
class CSSHelper {
  /**
   * Inserts a CSS style rule based upon the passed text
   * @param {String} cssText The text of the rule including selector and rule body just as it would
   * be specified in a CSS file.
   * @returns {CSSRule} The resulting CSS Rule object if the add was successful.
   */
  static insertRule(cssText) {
    const { styleSheet } = this,
      oldCount = styleSheet.cssRules.length;

    styleSheet.insertRule(cssText, 0);

    // Only return element zero if the add was successful.
    if (styleSheet.cssRules.length > oldCount) {
      return styleSheet.cssRules[0];
    }
  }

  /**
   * Looks up the first rule which matched the passed selector.
   * @param {String/Function} selector Either the selector string to exactly match or a function which
   * when passed a required selector, returns `true`.
   * @returns {CSSRule} The first matching CSS Rule object if any found.
   */
  static findRule(selector) {
    let result,
      isFn = typeof selector === 'function';

    // Array#find will stop when the function returns true, stop when the inner
    // find call yields a value from the search string.
    // Array#find better: to http://www.andygup.net/fastest-way-to-find-an-item-in-a-javascript-array/
    Array.prototype.find.call(document.head.querySelectorAll('link[rel=stylesheet],style[type*=css]'), (element) => {
      result = Array.prototype.find.call(element.sheet.rules || element.sheet.cssRules, (r) => {
        return isFn ? selector(r) : r.selectorText === selector;
      });
      if (result) {
        return true;
      }
    });

    return result;
  }

  static get styleSheet() {
    if (!this._stylesheet) {
      this._stylesheet = DomHelper.createElement({
        tag: 'style',
        id: 'bryntum-private-styles',
        type: 'text/css',
        parent: document.head
      }).sheet;
    }
    return this._stylesheet;
  }
}
CSSHelper._$name = 'CSSHelper';

// TODO: Use mousedown pos and not center too reposition

/**
 * @module Common/helper/mixin/DragHelperContainer
 */

/**
 * Mixin for DragHelper that handles dragging elements between containers (or rearranging within)
 *
 * @private
 * @mixin
 */
var DragHelperContainer = (Target) =>
  class DragHelperContainer extends (Target || Base) {
    //region Init

    /**
     * Initialize container drag mode.
     * @private
     */
    initContainerDrag() {
      const me = this;
      //use container drag as default mode
      if (!me.mode) me.mode = 'container';
      if (me.mode === 'container' && !me.containers) throw new Error('Container drag mode must specify containers');
    }

    //endregion

    //region Grab, update, finish

    /**
     * Grab an element which can be dragged between containers.
     * @private
     * @param event
     * @returns {Boolean}
     */
    grabContainerDrag(event) {
      const me = this;

      // allow specified selectors to prevent drag
      if (!me.ignoreSelector || !DomHelper.up(event.target, me.ignoreSelector)) {
        // go up from "handle" to draggable element
        const element = DomHelper.getAncestor(event.target, me.containers, me.outerElement);

        if (element) {
          const box = element.getBoundingClientRect();

          me.context = {
            element,
            valid: true,
            action: 'container',
            offsetX: event.pageX - box.left,
            offsetY: event.pageY - box.top,
            originalPosition: {
              parent: element.parentElement,
              prev: element.previousElementSibling,
              next: element.nextElementSibling
            }
          };
        }

        return true;
      }

      return false;
    }

    /**
     * Starts dragging, called when mouse moves first time after grabbing
     * @private
     * @param event
     */
    startContainerDrag(event) {
      const { context } = this,
        { element: dragElement } = context,
        div = dragElement.cloneNode(true),
        box = dragElement.getBoundingClientRect();

      // init drag proxy
      div.classList.add(this.dragProxyCls);
      div.classList.add(this.draggingCls);
      document.body.appendChild(div);
      context.dragProxy = div;

      // Always set the proxy element width manually, drag target could be sized with flex or % width
      div.style.width = box.width + 'px';
      div.style.height = box.height + 'px';
      DomHelper.setTranslateXY(context.dragProxy, box.left, box.top);

      // style dragged element
      context.dragging = dragElement;
      dragElement.classList.add(this.dropPlaceholderCls);
    }

    /**
     * Move the placeholder element into its new position on valid drag.
     * @private
     * @param event
     */
    updateContainerDrag(event) {
      const me = this,
        context = me.context;

      if (!context.started || !context.targetElement) return;

      const containerElement = DomHelper.getAncestor(context.targetElement, me.containers, 'b-grid'),
        willLoseFocus = context.dragging && context.dragging.contains(document.activeElement);

      if (containerElement && DomHelper.isDescendant(context.element, containerElement)) {
        // dragging over part of self, do nothing
        return;
      }

      // The dragging element contains focus, and moving it within the DOM
      // will cause focus loss which might affect an encapsulating autoClose Popup.
      // Prevent focus loss handling during the DOM move.
      if (willLoseFocus) {
        GlobalEvents.suspendFocusEvents();
      }
      if (containerElement && context.valid) {
        me.moveNextTo(containerElement, event);
      } else {
        // dragged outside of containers, revert position
        me.revertPosition();
      }
      if (willLoseFocus) {
        GlobalEvents.resumeFocusEvents();
      }

      event.preventDefault();
    }

    /**
     * Finalize drag, fire drop.
     * @private
     * @param event
     * @fires drop
     */
    finishContainerDrag(event) {
      const me = this,
        context = me.context,
        // extracting variables to make code more readable
        { dragging, dragProxy, valid, draggedTo, insertBefore, originalPosition } = context;

      if (dragging) {
        // needs to have a valid target
        context.valid =
          valid &&
          draggedTo &&
          // no drop on self or parent
          (dragging !== insertBefore || originalPosition.parent !== draggedTo);

        context.finalize = (valid = context.valid) => {
          // revert if invalid (and context still exists, might have been aborted from outside)
          if (!valid && this.context) {
            me.revertPosition();
          }

          dragging.classList.remove(me.dropPlaceholderCls);
          dragProxy.remove();

          me.reset();
        };

        // allow async finalization by setting async to true on context in drop handler,
        // requires implementer to call context.finalize later to finish the drop
        context.async = false;

        me.trigger('drop', { context, event });

        if (!context.async) {
          // finalize immediately
          context.finalize();
        } else {
          context.awaitingFinalization = true;
        }
      }
    }

    /**
     * Aborts a drag operation.
     * @private
     * @param {Boolean} [invalid]
     * @param {Object} [event]
     * @param {Boolean} [silent]
     */
    abortContainerDrag(invalid = false, event = null, silent = false) {
      const me = this,
        context = me.context;

      if (context.dragging) {
        context.dragging.classList.remove(me.dropPlaceholderCls);
        context.dragProxy.remove();

        me.context = {};
      }

      if (!silent) {
        me.trigger(invalid ? 'drop' : 'abort', { context, event });
      }
    }

    //endregion

    //region Helpers

    /**
     * Starts a drag operation by creating a proxy and storing which element is being dragged.
     * @private
     */
    // startDrag() {
    //     const context = this.context,
    //           div      = context.element.cloneNode(true);
    //
    //     // init drag proxy
    //     div.classList.add('b-drag-proxy');
    //     document.body.appendChild(div);
    //     context.dragProxy = div;
    //
    //     // style dragged element
    //     context.dragging = context.element;
    //     context.dragging.classList.add('myClass');
    // }

    /**
     * Updates the drag proxy position.
     * @private
     * @param event
     */
    updateContainerProxy(event) {
      const me = this,
        context = me.context,
        proxy = context.dragProxy;

      let newX = event.pageX - context.offsetX,
        newY = event.pageY - context.offsetY;

      if (typeof me.minX === 'number') {
        newX = Math.max(me.minX, newX);
      }

      if (typeof me.maxX === 'number') {
        newX = Math.min(me.maxX - proxy.offsetWidth, newX);
      }

      if (typeof me.minY === 'number') {
        newY = Math.max(me.minY, newY);
      }

      if (typeof me.maxY === 'number') {
        newY = Math.min(me.maxY - proxy.offsetHeight, newY);
      }

      if (me.lockX) {
        DomHelper.setTranslateY(proxy, newY);
      } else if (me.lockY) {
        DomHelper.setTranslateX(proxy, newX);
      } else {
        DomHelper.setTranslateXY(proxy, newX, newY);
      }

      let targetElement;

      if (event.type === 'touchmove') {
        let touch = event.changedTouches[0];
        targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
      } else {
        targetElement = event.target;
      }

      context.targetElement = targetElement;
    }

    /**
     * Positions element being dragged in relation to targetElement.
     * @private
     * @param targetElement
     * @param event
     */
    moveNextTo(targetElement, event) {
      const context = this.context,
        dragElement = context.dragging,
        parent = targetElement.parentElement;

      if (targetElement !== dragElement) {
        // dragged over a container and not over self, calculate where to insert

        const centerX = targetElement.getBoundingClientRect().left + targetElement.offsetWidth / 2;

        if (event.pageX < centerX) {
          // dragged left of target center, insert before
          parent.insertBefore(dragElement, targetElement);
          context.insertBefore = targetElement;
        } else {
          // dragged right of target center, insert after
          if (targetElement.nextElementSibling) {
            // check that not dragged to the immediate left of self. in such case, position should not change
            if (targetElement.nextElementSibling !== dragElement) {
              context.insertBefore = targetElement.nextElementSibling;
              parent.insertBefore(dragElement, targetElement.nextElementSibling);
            } else if (!context.insertBefore && dragElement.parentElement.lastElementChild !== dragElement) {
              // dragged left initially, should stay in place (checked in finishContainerDrag)
              // TODO: or flag as invalid drag? since no change...
              context.insertBefore = targetElement.nextElementSibling;
            }
          } else {
            parent.appendChild(dragElement);
            context.insertBefore = null;
          }
        }

        context.draggedTo = parent;
      }
    }

    /**
     * Moves element being dragged back to its original position.
     * @private
     */
    revertPosition() {
      const context = this.context,
        original = context.originalPosition;

      // revert to correct location
      if (original.next) {
        const isNoop =
          (original.next && original.next.previousSibling === context.dragging) ||
          (!original.next && context.dragging === original.parent.lastChild);

        if (!isNoop) {
          original.parent.insertBefore(context.dragging, original.next);
        }
      } else {
        original.parent.appendChild(context.dragging);
      }

      // no target container
      context.draggedTo = null;
    }

    //endregion
  };

/**
 * @module Common/helper/mixin/DragHelperTranslate
 */

const noScroll = { pageXOffset: 0, pageYOffset: 0 };

/**
 * Mixin for DragHelper that handles repositioning (translating) an element within its container
 *
 * @private
 * @mixin
 */
var DragHelperTranslate = (Target) =>
  class DragHelperTranslate extends Delayable(Target || Base) {
    //region Init

    /**
     * Initialize translation drag mode.
     * @private
     */
    initTranslateDrag() {
      const me = this;
      if (!me.isElementDraggable && me.targetSelector) {
        me.isElementDraggable = (element) => DomHelper.up(element, me.targetSelector);
      }
    }

    //endregion

    //region Grab, update, finish

    /**
     * Grab an element which can be moved using translation.
     * @private
     * @param event
     * @returns {Boolean}
     */
    grabTranslateDrag(event) {
      const me = this,
        element = me.getTarget(event);

      if (element) {
        me.context = {
          valid: true,
          action: me.mode, // translateX or translateXY...
          element,

          startPageX: event.pageX,
          startPageY: event.pageY,
          startClientX: event.clientX,
          startClientY: event.clientY
        };

        return true;
      }

      return false;
    }

    getTarget(event) {
      return DomHelper.up(event.target, this.targetSelector);
    }

    /**
     * Start translating, called on first mouse move after dragging
     * @private
     * @param event
     */
    startTranslateDrag(event) {
      const me = this,
        context = me.context,
        { relatedElements } = context;

      let element = context.dragProxy || context.element;

      if (element && !context.started) {
        const grabbed = element,
          grabbedParent = element.parentElement,
          // When cloning an element to be dragged, we place it in BODY by default
          dragWithin = (me.dragWithin = me.dragWithin || (me.cloneTarget && document.body)),
          outerElement = me.outerElement;

        if (me.cloneTarget) {
          const offsetX = DomHelper.getOffsetX(element, dragWithin),
            offsetY = DomHelper.getOffsetY(element, dragWithin),
            offsetWidth = element.offsetWidth,
            offsetheight = element.offsetHeight;

          element = this.createProxy(element);

          // Match the grabbed element's size and position.
          DomHelper.setTranslateXY(element, offsetX, offsetY);
          element.style.width = `${offsetWidth}px`;
          element.style.height = `${offsetheight}px`;

          element.classList.add(me.dragProxyCls);
          dragWithin.appendChild(element);

          grabbed.classList.add('b-drag-original');

          if (me.hideOriginalElement) {
            grabbed.classList.add('b-hidden');
          }
        }

        Object.assign(me.context, {
          // The element which we're moving, could be a cloned version of grabbed, or the grabbed element itself
          element,

          // The original element upon which the mousedown event triggered a drag operation
          grabbed,

          // The parent of the original element where the pointerdown was detected - to be able to restore after an invalid drop
          grabbedParent,

          // The next sibling of the original element where the pointerdown was detected - to be able to restore after an invalid drop
          grabbedNextSibling: element.nextElementSibling,

          // elements position within parent element
          elementStartX: DomHelper.getTranslateX(element),
          elementStartY: DomHelper.getTranslateY(element),
          elementX: DomHelper.getOffsetX(element, dragWithin || outerElement),
          elementY: DomHelper.getOffsetY(element, dragWithin || outerElement),

          scrollX: 0,
          scrollY: 0,

          scrollManagerElementContainsDragProxy: !me.cloneTarget || dragWithin === outerElement
        });

        element.classList.add(me.draggingCls);

        if (dragWithin) {
          context.parentElement = element.parentElement;

          if (dragWithin !== element.parentElement) {
            dragWithin.appendChild(element);
          }
          me.updateTranslateProxy(event);
        }

        if (relatedElements) {
          relatedElements.forEach((r) => {
            r.classList.add(me.draggingCls);
          });
        }
      }
    }

    /**
     * Limit translation to outer bounds and specified constraints
     * @private
     * @param element
     * @param x
     * @param y
     * @returns {{constrainedX: *, constrainedY: *}}
     */
    applyConstraints(element, x, y) {
      const me = this,
        dragWithin = me.dragWithin,
        { pageXOffset, pageYOffset } = dragWithin === document.body ? window : noScroll;

      // limit to outer elements edges
      if (dragWithin && me.constrain) {
        if (x < 0) x = 0;
        if (x + element.offsetWidth > dragWithin.scrollWidth) x = dragWithin.scrollWidth - element.offsetWidth;

        if (y < 0) y = 0;
        if (y + element.offsetHeight > dragWithin.scrollHeight) y = dragWithin.scrollHeight - element.offsetHeight;
      }

      // limit horizontally
      if (typeof me.minX === 'number') {
        x = Math.max(me.minX + pageXOffset, x);
      }
      if (typeof me.maxX === 'number') {
        x = Math.min(me.maxX + pageXOffset, x);
      }

      // limit vertically
      if (typeof me.minY === 'number') {
        y = Math.max(me.minY + pageYOffset, y);
      }
      if (typeof me.maxY === 'number') {
        y = Math.min(me.maxY + pageYOffset, y);
      }

      return { constrainedX: x, constrainedY: y };
    }

    /**
     * Update elements translation on mouse move.
     * @private
     * @param event
     */
    updateTranslateProxy(event, scrollManagerConfig) {
      const me = this,
        { mode, lockX, lockY } = me,
        context = me.context,
        element = context.dragProxy || context.element,
        { relatedElements, relatedElDragFromPos } = context;

      // If we are cloning the dragged element outside of the element(s) monitored by the ScrollManager, then no need to take the scrollManager scroll values into account
      // since it is only relevant when dragProxy is inside the Grid (where scroll manager operates).
      if (context.scrollManagerElementContainsDragProxy && scrollManagerConfig) {
        context.scrollX = scrollManagerConfig.scrollRelativeLeft;
        context.scrollY = scrollManagerConfig.scrollRelativeTop;
      }

      context.pageX = event.pageX;
      context.pageY = event.pageY;
      context.clientX = event.clientX;
      context.clientY = event.clientY;

      const newX = context.elementStartX + event.pageX - context.startPageX + context.scrollX,
        newY = context.elementStartY + event.pageY - context.startPageY + context.scrollY,
        { constrainedX, constrainedY } = me.applyConstraints(element, newX, newY);

      if (mode === 'translateXY' && !(lockX || lockY)) {
        DomHelper.setTranslateXY(element, constrainedX, constrainedY);
      } else if (mode === 'translateX' || lockY) {
        DomHelper.setTranslateX(element, constrainedX);
      } else if (mode === 'translateY' || lockX) {
        DomHelper.setTranslateY(element, constrainedY);
      }

      if (relatedElements) {
        const deltaX = !lockX && mode !== 'translateY' ? constrainedX - context.elementStartX : 0,
          deltaY = !lockY && mode !== 'translateX' ? constrainedY - context.elementStartY : 0;

        relatedElements.forEach((r, i) => {
          const [x, y] = relatedElDragFromPos[i];

          DomHelper.setTranslateXY(r, x + deltaX, y + deltaY);
        });
      }

      context.newX = constrainedX;
      context.newY = constrainedY;
    }

    /**
     * Finalize drag, fire drop.
     * @private
     * @param event
     * @fires drop
     */
    finishTranslateDrag(event) {
      const me = this,
        context = me.context,
        xChanged = context.newX !== context.elementStartX,
        yChanged = context.newY !== context.elementStartY,
        element = context.dragProxy || context.element,
        { relatedElements } = context;

      function cleanUp() {
        element.classList.remove(me.invalidCls);
        element.classList.remove(me.draggingCls);

        if (relatedElements) {
          relatedElements.forEach((r) => {
            r.classList.remove(me.invalidCls);
            r.classList.remove(me.draggingCls);
          });
        }
        // If we're currently aborting, the b-hidden CSS class will be removed after animation is complete
        if (!element.classList.contains('b-aborting')) {
          if (me.hideOriginalElement) {
            context.grabbed.classList.remove('b-hidden');
          }
          context.grabbed.classList.remove('b-drag-original');
        }
      }

      if (
        !me.ignoreSamePositionDrop ||
        (me.mode !== 'translateY' && xChanged) ||
        (me.mode !== 'translateX' && yChanged)
      ) {
        if (context.valid === false) {
          me.abortTranslateDrag(true, event);
        } else {
          const targetRect = Rectangle.from(me.dragWithin || me.outerElement);

          if (
            (!me.minX && event.pageX < targetRect.left) ||
            (!me.maxX && event.pageX > targetRect.right) ||
            (!me.minY && event.pageY < targetRect.top) ||
            (!me.maxY && event.pageY > targetRect.bottom)
          ) {
            // revert location when dropped outside allowed element
            context.valid = false;
            me.abortTranslateDrag(true, event);
          } else {
            context.finalize = (valid = context.valid) => {
              if (context.asyncCleanup) {
                cleanUp();
              }

              // abort if invalid (and context still exists, might have been aborted from outside)
              if (!valid && me.context) {
                // abort if flagged as invalid, without triggering abort or drop again
                me.abortTranslateDrag(true, null, true);
              } else if (me.cloneTarget || context.dragProxy) {
                element.remove();
              }

              me.reset();
            };

            // allow async finalization by setting async to true on context in drop handler,
            // requires implementer to call context.finalize later to finish the drop
            context.async = false;

            me.trigger('drop', { context, event });

            if (!context.async) {
              // finalize immediately
              context.finalize();
            } else {
              context.awaitingFinalization = true;
            }
          }
        }

        if (!context.asyncCleanup) {
          cleanUp();
        }
      } else {
        // no change, abort but not as invalid
        me.abortTranslateDrag(false, event);
      }
    }

    /**
     * Abort translation
     * @private
     * @param invalid
     * @fires abort
     */
    abortTranslateDrag(invalid = false, event = null, silent = false) {
      const me = this,
        context = me.context,
        { relatedElements, relatedElStartPos, grabbed } = context,
        element = context.dragProxy || context.element,
        resetEl = me.cloneTarget && me.hideOriginalElement ? grabbed : element;

      let { elementStartX, elementStartY } = context;

      if (element && context.started) {
        // Put the dragged element back where it was
        if (!me.cloneTarget && me.dragWithin && me.dragWithin !== context.grabbedParent) {
          context.grabbedParent.insertBefore(element, context.grabbedNextSibling);
        }

        grabbed.classList.remove('b-hidden');

        // Align the now visible grabbed element with the clone, so that it looks like it's
        // sliding back into place when the clone is removed
        if (me.cloneTarget) {
          if (me.hideOriginalElement) {
            [elementStartX, elementStartY] = DomHelper.getTranslateXY(grabbed);
            DomHelper.alignTo(grabbed, element);

            // The getBoundingClientRect is important. The aligning above must be processed
            // by a forced synchronous layout *before* the b-aborting class is added below.
            resetEl.getBoundingClientRect();
          }

          element.remove();
        }

        // animated restore of position.
        resetEl.classList.add('b-aborting');

        // Move the elements back to their original positions.
        if (me.mode === 'translateXY' && !(me.lockX || me.lockY)) {
          DomHelper.setTranslateXY(resetEl, elementStartX, elementStartY);
          relatedElements &&
            relatedElements.forEach((element, i) => {
              element.classList.add('b-aborting');
              DomHelper.setTranslateXY(element, relatedElStartPos[i][0], relatedElStartPos[i][1]);
            });
        }
        if (me.mode === 'translateX' || me.lockY) {
          DomHelper.setTranslateX(resetEl, elementStartX);
          relatedElements &&
            relatedElements.forEach((element, i) => {
              element.classList.add('b-aborting');
              DomHelper.setTranslateX(element, relatedElStartPos[i][0]);
            });
        }
        if (me.mode === 'translateY' || me.lockX) {
          DomHelper.setTranslateY(resetEl, elementStartY);
          relatedElements &&
            relatedElements.forEach((element, i) => {
              element.classList.add('b-aborting');
              DomHelper.setTranslateY(element, relatedElStartPos[i][1]);
            });
        }

        me.setTimeout(
          () => {
            resetEl.classList.remove('b-aborting');

            grabbed.classList.remove('b-dragging');
            grabbed.classList.remove('b-drag-original');

            if (!me.cloneTarget) {
              relatedElements &&
                relatedElements.forEach((element, i) => {
                  element.classList.remove('b-aborting');
                });
              element.classList.remove('b-aborting');
              element.classList.remove(me.draggingCls);
              element.classList.remove(me.invalidCls);
            }
          },
          300,
          undefined,
          true
        );

        if (!silent) {
          me.trigger(invalid ? 'drop' : 'abort', { context, event });
        }
      }

      me.reset();
    }

    //endregion
  };

//TODO: add touch support
//TODO: add pointer events support

/**
 * @module Common/helper/DragHelper
 */

const documentListeners = {
  down: 'onMouseDown',
  move: 'onMouseMove',
  up: 'onMouseUp',
  docclick: 'onDocumentClick',
  touchstart: 'onTouchStart',
  touchmove: 'onTouchMove',
  touchend: 'onTouchEnd',
  keydown: 'onKeyDown'
};

/**
 * Helps with drag and drop. Supports two modes of dragging:
 * * `container` - moving/rearranging elements within and between specified containers
 * * `translateXY` - repositioning an element withing its container
 *
 * Usage examples:
 * ```
 * // dragging element between containers
 * let dragHelper = new DragHelper({
 *   mode       : 'container',
 *   containers : [ container1, container2 ]
 * });
 *
 * // dragging element within container
 * let dragHelper = new DragHelper({
 *   mode    : 'translateXY',
 *   targetSelector: 'div.moveable'
 * });
 * ```
 * In the various Drag event handlers, you will have access to the raw DOM event and some useful `context` of the drag operation:
 *
 * ```
 *  myDrag.on({
 *      drag : ({event , context}) {
 *            // The element which we're moving, could be a cloned version of grabbed, or the grabbed element itself
 *           const element = context.element;
 *
 *           // The original mousedown element upon which triggered the drag operation
 *           const grabbed = context.grabbed;
 *
 *           // The target under the current mouse / pointer / touch position
 *           const target = context.target;
 *       }
 *  });
 * ```
 *
 * Simple drag drop with a drop target specified:
 * ```
 * export default class MyDrag extends DragHelper {
        static get defaultConfig() {
            return {
                // Don't drag the actual cell element, clone it
                cloneTarget        : true,
                mode               : 'translateXY',
                // Only allow drops on DOM elements with 'yourDropTarget' CSS class specified
                dropTargetSelector : '.yourDropTarget',

                // Only allow dragging elements with the 'draggable' CSS class
                targetSelector : '.draggable'
            };
        }

        construct(config) {
            const me = this;

            super.construct(config);

            me.on({
                dragstart : me.onDragStart
            });
        }

        onDragStart({ event, context }) {
            const target = context.target;

            // Here you identify what you are dragging (an image of a user, grid row in an order table etc) and map it to something in your
            // data model. You can store your data on the context object which is available to you in all drag-related events
            context.userId = target.dataset.userId;
        }

        onEquipmentDrop({ context, event }) {
            const me = this;

            if (context.valid) {
                const userId   = context.userId,
                      droppedOnTarget = context.target;

                console.log(`You dropped user ${userStore.getById(userId).name} on ${droppedOnTarget}`, droppedOnTarget);

                // Dropped on a scheduled event, display toast
                WidgetHelper.toast(`You dropped user ${userStore.getById(userId).name} on ${droppedOnTarget}`);

                // tell the drag helper the operation is finished
                me.context.finalize();
            }
        }
    };
 * ```
 * @mixes Common/helper/mixin/DragHelperContainer
 * @mixes Common/helper/mixin/DragHelperTranslate
 * @mixes Common/mixin/Events
 * @extends Common/Base
 */
class DragHelper extends base(Base).mixes(Events, DragHelperContainer, DragHelperTranslate) {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Drag proxy CSS class
       * @config {String}
       * @default
       * @private
       */
      dragProxyCls: 'b-drag-proxy',

      /**
       * CSS class added when drag is invalid
       * @config {String}
       * @default
       */
      invalidCls: 'b-drag-invalid',

      /**
       * CSS class added to the source element in Container drag
       * @config {String}
       * @default
       * @private
       */
      draggingCls: 'b-dragging',

      /**
       * CSS class added to the source element in Container drag
       * @config {String}
       * @default
       * @private
       */
      dropPlaceholderCls: 'b-drop-placeholder',

      /**
       * CSS class added when resizing
       * @config {String}
       * @default
       * @private
       */
      resizingCls: 'b-resizing',

      /**
       * The amount of pixels to move mouse before it counts as a drag operation
       * @config {Number}
       * @default
       */
      dragThreshold: 5,

      /**
       * Resizing handle size
       * @config {Number}
       * @default
       */
      handleSize: 10,

      /**
       * Resizing handle size on touch devices
       * @config {Number}
       * @default
       */
      touchHandleSize: 30,

      /**
       * Minimum width when resizing
       * @config {Number}
       * @default
       */
      minWidth: 1,

      /**
       * The outer element where the drag helper will operate (attach events to it and use as outer limit when looking for ancestors)
       * @config {HTMLElement}
       * @default
       */
      outerElement: document.body,

      /**
       * Outer element that limits where element can be dragged
       * @config {HTMLElement}
       * @default
       */
      dragWithin: null,

      /**
       * Constrain translate drag to dragWithin elements bounds (set to false to allow it to "overlap" edges)
       * @config {Boolean}
       * @default
       */
      constrain: true,

      /**
       * Smallest allowed x when dragging horizontally.
       * @config {Number}
       * @default
       */
      minX: null,

      /**
       * Largest allowed x when dragging horizontally.
       * @config {Number}
       * @default
       */
      maxX: null,

      /**
       * Smallest allowed y when dragging horizontally.
       * @config {Number}
       * @default
       */
      minY: null,

      /**
       * Largest allowed y when dragging horizontally.
       * @config {Number}
       * @default
       */
      maxY: null,

      /**
       * Enabled dragging, specify mode:
       * <table>
       * <tr><td>container<td>Allows reordering elements within one and/or between multiple containers
       * <tr><td>translateXY<td>Allows dragging within a parent container
       * </table>
       * @config {String}
       * @default
       * @private
       */
      mode: null,

      /**
       * A function that determines if dragging an element is allowed. Gets called with the element as argument,
       * return true to allow dragging or false to prevent.
       * @config {Function}
       * @default
       */
      isElementDraggable: null,

      /**
       * A CSS selector used to determine if dragging an element is allowed.
       * @config {String}
       * @default
       */
      targetSelector: null,

      /**
       * A CSS selector used to determine if a drop is allowed at the current position.
       * @config {String}
       * @default
       */
      dropTargetSelector: null,

      /**
       * Set to true to clone the dragged target, and not move the actual target DOM node.
       * @config {Boolean}
       * @default
       */
      cloneTarget: false,

      /**
       * Set to true to hide the original element while dragging (applicable when `cloneTarget` is true).
       * @config {Boolean}
       * @default
       */
      hideOriginalElement: false,

      /**
       * Containers whose elements can be rearranged (and moved between the containers). Used when
       * mode is set to "container".
       * @config {HTMLElement[]}
       * @default
       */
      containers: null,

      /**
       * A CSS selector used to exclude elements when using container mode
       * @config {String}
       * @default
       */
      ignoreSelector: null,

      /**
       * A CSS selector used to determine where handles should be "displayed" when resizing. Defaults to
       * targetSelector if unspecified
       * @config {String}
       * @default
       */
      handleSelector: null,

      startEvent: null,

      /**
       * Configure as `true` to disallow dragging in the `X` axis. The dragged element will only move vertically.
       * @config {Boolean}
       * @default
       */
      lockX: false,

      /**
       * Configure as `true` to disallow dragging in the `Y` axis. The dragged element will only move horizontally.
       * @config {Boolean}
       * @default
       */
      lockY: false,

      touchStartDelay: 300,

      ignoreSamePositionDrop: true
    };
  }

  //endregion

  //region Events

  /**
   * Fired before dragging starts, return false to prevent the drag operation.
   * @preventable
   * @event beforeDragStart
   * @param {DragHelper} source
   * @param {Object} context
   * @param {MouseEvent|TouchEvent} event
   */

  /**
   * Fired when dragging starts.
   * @event dragStart
   * @param {DragHelper} source
   * @param {Object} context
   * @param {MouseEvent|TouchEvent} event
   */

  /**
   * Fired while dragging, you can signal that the drop is valid or invalid by setting `context.valid = false;`
   * @event drag
   * @param {DragHelper} source
   * @param {Object} context
   * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid.
   * @param {MouseEvent} event
   */

  //endregion

  //region Init

  /**
   * Initializes a new DragHelper.
   * @param {Object} config Configuration object, accepts options specified under Configs above
   * @example
   * new DragHelper({
   *   containers: [div1, div2],
   *   isElementDraggable: element => element.className.contains('handle'),
   *   outerElement: topParent,
   *   listeners: {
   *     drop: onDrop,
   *     thisObj: this
   *   }
   * });
   * @function constructor
   */
  construct(config) {
    const me = this;

    super.construct(config);

    me.initListeners();

    if (BrowserHelper.isTouchDevice) {
      me.handleSize = me.touchHandleSize;
    }

    if (me.mode === 'container') {
      me.initContainerDrag();
    } else if (me.mode.startsWith('translate')) {
      if (me.lockY) {
        me.mode = 'translateX';
      } else if (me.lockX) {
        me.mode = 'translateY';
      }
      me.initTranslateDrag();
    }
  }

  doDestroy() {
    // Abort dragging
    this.abort(true);
    super.doDestroy();
  }

  /**
   * Initialize listener
   * @private
   */
  initListeners() {
    const dragStartListeners = {
      element: this.outerElement,
      mousedown: documentListeners.down,
      thisObj: this
    };

    if (BrowserHelper.isTouchDevice) {
      dragStartListeners.touchstart = documentListeners.touchstart;
    }

    // These will be autoDetached upon destroy
    EventHelper.on(dragStartListeners);
  }

  //endregion

  //region Events

  /**
   * Fires after drop. For valid drops, it exposes `context.async` which you can set to true to signal that additional
   * processing is needed before finalizing the drop (such as showing some dialog). When that operation is done, call
   * `context.finalize(true/false)` with a boolean that determines the outcome of the drop.
   * @event drop
   * @param {DragHelper} dragHelper
   * @param {Object} context
   */

  onPointerDown(event) {
    let me = this,
      handled = false,
      isTouch = 'touches' in event;

    // If a drag is ongoing already, finalize it and don't proceed with new drag (happens if user does mouseup
    // outside browser window). Also handles the edge case of trying to start a new drag while previous is awaiting
    // finalization, in which case it just bails out.
    if (me.context) {
      if (!me.context.awaitingFinalization) {
        me.onMouseUp(event);
        me.reset();
      }
      return;
    }

    me.startEvent = event;

    if (me.isElementDraggable && !me.isElementDraggable(event.target, event)) return;

    if (me.mode) {
      if (!handled && me.mode === 'container') handled = me.grabContainerDrag(event);
      if (!handled && me.mode.startsWith('translate')) handled = me.grabTranslateDrag(event);
    }

    if (handled) {
      const dragListeners = {
        element: document,
        thisObj: me,
        keydown: documentListeners.keydown
      };

      if (isTouch) {
        dragListeners.touchmove = {
          handler: documentListeners.touchmove,
          passive: false // We need to be able to preventDefault on the touchmove
        };
        // Touch desktops don't fire touchend event when touch has ended, instead pointerup is fired
        // iOS do fire touchend
        dragListeners.touchend = dragListeners.pointerup = documentListeners.touchend;
      } else {
        dragListeners.mousemove = documentListeners.move;
        dragListeners.mouseup = documentListeners.up;
      }

      // A listener detacher is returned;
      me.removeListeners = EventHelper.on(dragListeners);

      if (me.dragWithin && me.dragWithin !== me.outerElement) {
        const box = me.dragWithin.getBoundingClientRect();

        me.minY = box.top;
        me.maxY = box.bottom;

        me.minX = box.left;
        me.maxX = box.right;
      }
    }
  }

  /**
   * @param event
   * @private
   */
  onTouchStart(event) {
    const me = this;
    // only allowing one finger for now...
    if (event.touches.length === 1) {
      me.touchStartTimer = me.setTimeout(() => {
        me.touchStartTimer = null;
      }, me.touchStartDelay);

      me.onPointerDown(event);
    }
  }

  /**
   * Grab draggable element on mouse down.
   * @private
   * @param event
   */
  onMouseDown(event) {
    // only dragging with left mouse button
    if (event.button === 0) {
      this.onPointerDown(event);
    }
  }

  internalMove(event) {
    const me = this,
      context = me.context,
      distance = EventHelper.getDistanceBetween(me.startEvent, event),
      abortTouchDrag = me.touchStartTimer && distance > me.dragThreshold;

    if (abortTouchDrag) {
      me.abort(true);
      return;
    }

    if (
      !me.touchStartTimer &&
      context &&
      context.element &&
      // Only target Elements, not text nodes
      event.target.nodeType === Node.ELEMENT_NODE &&
      (context.started || distance >= me.dragThreshold)
    ) {
      if (!context.started) {
        // triggers beforeDragStart, dragStart. returning false from beforeDragStart aborts drag
        if (
          me.callPreventable('dragStart', { context, event }, () => {
            const direction = me.lockX ? 'vertical' : me.lockY ? 'horizontal' : 'both';

            if (context.action.startsWith('translate')) {
              me.startTranslateDrag(event);
            } else if (context.action === 'container') {
              me.startContainerDrag(event);
            }

            context.started = true;

            // Now that the drag drop is confirmed to be starting, activate the configured scrollManager if present
            if (me.scrollManager) {
              me.scrollManager.startMonitoring({
                direction: direction,
                element: me.dragWithin || me.outerElement,
                callback: (config) => {
                  if (me.context.element && me.lastMouseMoveEvent) {
                    // Indicate that this is a 'fake' mousemove event as a result of the scrolling
                    me.lastMouseMoveEvent.isScroll = true;

                    me.update(me.lastMouseMoveEvent, config);
                  }
                },
                thisObj: me
              });
            }

            // Global informatoinal class for when DragHelper is dragging
            document.body.classList.add('b-draghelper-active');
          }) === false
        ) {
          return me.abort();
        }
      }

      // to prevent view drag (scroll) on ipad
      if (event.type === 'touchmove') {
        event.preventDefault();
        event.stopImmediatePropagation();
      }

      me.update(event);
    }
  }

  onTouchMove(event) {
    this.internalMove(event);
  }

  /**
   * Move drag element with mouse.
   * @param event
   * @fires beforeDragStart
   * @fires dragStart
   * @private
   */
  onMouseMove(event) {
    this.internalMove(event);
  }

  /**
   * Updates drag, called when an element is grabbed and mouse moves
   * @private
   * @fires drag
   */
  update(event, scrollManagerConfig) {
    const me = this,
      context = me.context,
      draggingElement = context.dragProxy || context.element; // two different modes used

    let target = event.target,
      scrollingPageElement = document.scrollingElement || document.body;

    // "pointer-events:none" touchmove has no effect for the touchmove event target, meaning we cannot know
    // what's under the cursor as easily in touch devices
    if (event.type === 'touchmove') {
      const touch = event.changedTouches[0];

      target = DomHelper.elementFromPoint(
        touch.clientX + scrollingPageElement.scrollLeft,
        touch.clientY + scrollingPageElement.scrollTop
      );
    }

    context.target = target;

    if (me.dropTargetSelector) {
      context.valid = Boolean(target.closest(me.dropTargetSelector));
    } else {
      // assume valid drop location
      context.valid = true;
    }

    // Move the drag proxy or dragged element before triggering the drag event
    if (context.action) {
      if (context.action === 'container') {
        me.updateContainerProxy(event, scrollManagerConfig);
      }
      if (context.action.startsWith('translate')) {
        me.updateTranslateProxy(event, scrollManagerConfig);
      }
    }

    // Allow external code to validate the context before updating a container drag
    me.trigger('drag', { context, event });

    // Move the placeholder element into its new place.
    // This will see the new state of context if mutated by a drag listener.
    if (context.action === 'container') {
      me.updateContainerDrag(event, scrollManagerConfig);
    }

    // change to toggle with force when not supporting IE11 any longer
    draggingElement.classList[context.valid ? 'remove' : 'add'](me.invalidCls);

    if (event) me.lastMouseMoveEvent = event;
  }

  /**
   * Abort dragging
   * @fires abort
   */
  abort(silent = false) {
    const me = this,
      context = me.context;

    me.scrollManager && me.scrollManager.stopMonitoring(me.dragWithin || me.outerElement);

    if (context) {
      // Force a synchronous layout so that transitions from this point will work.
      context.element.getBoundingClientRect();

      // Aborted drag not considered valid
      context.valid = false;

      if (context.action === 'container') {
        me.abortContainerDrag(undefined, undefined, silent);
      } else {
        me.abortTranslateDrag(undefined, undefined, silent);
      }
    }

    me.reset();
  }

  // Empty class implementation. If listeners *are* added, the detacher is added
  // as an instance property. So this is always callable.
  removeListeners() {}

  // Called when a drag operation is completed, aborted, or when drag doesn't start (simple click)
  // Removes DOM listeners and resets context
  reset() {
    document.body.classList.remove('b-draghelper-active');
    this.removeListeners();
    /**
     * Fired when a drag operation is completed, aborted, or when drag doesn't start (simple click)
     * @event reset
     * @private
     * @param {DragHelper} dragHelper
     */
    this.trigger('reset');
    this.context = this.lastMouseMoveEvent = null;
  }

  onTouchEnd(event) {
    this.onMouseUp(event);
  }

  /**
   * This is a capture listener, only added during drag, which prevents a click gesture
   * propagating from the terminating mouseup geature
   * @param {MouseEvent} event
   * @private
   */
  onDocumentClick(event) {
    event.stopPropagation();
  }

  /**
   * Drop on mouse up (if dropped on valid target).
   * @param event
   * @private
   */
  onMouseUp(event) {
    const me = this,
      context = me.context;

    me.removeListeners();

    if (context) {
      me.scrollManager && me.scrollManager.stopMonitoring(me.dragWithin || me.outerElement);

      if (context.action === 'container') {
        me.finishContainerDrag(event);
      } else if (context.started && context.action.startsWith('translate')) {
        me.finishTranslateDrag(event);
      }

      if (context.started) {
        // Prevent the impending document click from the mouseup event from propagating
        // into a click on our element.
        const clickPreventer = EventHelper.on({
          element: document,
          thisObj: me,
          click: documentListeners.docclick,
          capture: true,
          once: true
        });
        // In case a click did not ensue, remove the listener
        me.setTimeout(clickPreventer, 50);
      } else {
        me.reset();
      }
    }
  }

  /**
   * Cancel on ESC key
   * @param event
   * @private
   */
  onKeyDown(event) {
    if (event.key === 'Escape') this.abort();
  }

  /**
   * Creates the proxy element to be dragged, when using {@link #config-cloneTarget}. Clones the original element by default
   */
  createProxy(element) {
    const clone = element.cloneNode(true);
    clone.removeAttribute('id');

    return clone;
  }
  //endregion
}
DragHelper._$name = 'DragHelper';

/**
 * @module Common/helper/util/DomClassList
 */

/**
 * This class encapsulates a list of CSS classes which can be set as the `className`
 * on an `HTMLElement`.
 *
 * Properties names set on this class equate to *adding* a class if the property's value
 * is _truthy_, or removing a class if the value is _falsy_.
 *
 * ```javascript
 * const myClassList = new DomClassList('b-test-button');
 *
 * myClassList.add('test-class');
 * myClassList.important = 1;
 *
 * myHtmlElement.className = myClassList; // Sets it to "b-test-button test-class important"
 * ```
 */
class DomClassList {
  constructor(...classes) {
    if (typeof classes[0] === 'object') {
      Object.assign(this, classes[0]);
    } else {
      this.process(1, classes);
    }

    // String value needs recalculating
    this[dirtySymbol] = true;
  }

  /**
   * Returns a clone of this DomClassList with all the same keys set.
   * @returns {Common.helper.util.DomClassList} A clone of this DomClassList.
   */
  clone() {
    return new DomClassList(this);
  }

  // An instance of this class may be assigned directly to an element's className
  // it will be coerced to a string value using this method.
  toString() {
    // Adding space at the end if there is content to make concatenation code simpler in renderers.
    return this.length ? `${this.value} ` : '';
  }

  /**
   * Analogous to string.trim, returns the string value of this `DomClassList` with no trailing space.
   * @returns {String} A concatenated string value of all the class names in this `DomClassList`
   * separated by spaces.
   */
  trim() {
    return this.value;
  }

  /**
   * Compares this ClassList to another ClassList (or class name string of space separated classes).
   * If the *same class names, regardless of order* are present, the two are considered equal.
   *
   * So `new DomClassList('foo bar bletch').isEqual('bletch bar foo')` would return `true`
   * @param {Common.helper.util.DomClassList|String} other The `DomClassList` or string of classes to compare to.
   * @returns {Boolean} `true` if the two contain the same class names.
   */
  isEqual(other) {
    if (typeof other === 'string') {
      testClassList.value = other;
      other = testClassList;
    }

    if (this.length === other.length) {
      const otherClasses = ObjectHelper.getTruthyKeys(other);

      for (let i = 0, len = otherClasses.length; i < len; i++) {
        if (!this[otherClasses[i]]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  get value() {
    const me = this;

    if (me[dirtySymbol]) {
      const keys = ObjectHelper.getTruthyKeys(me);
      me[lengthSymbol] = keys.length;
      me[valueSymbol] = keys.join(' ');
      me[dirtySymbol] = false;
    }
    return me[valueSymbol];
  }

  set value(value) {
    const me = this,
      keys = Object.keys(me),
      len = keys.length;

    for (let i = 0; i < len; i++) {
      delete me[keys[i]];
    }

    if (value) {
      me.process(1, [value]);
    } else {
      // String value needs recalculating
      me[dirtySymbol] = true;
    }
  }

  get length() {
    // Maintainer: We MUST access the value getter to force
    // the value to be calculated if it's currently dirty.
    return this.value ? this[lengthSymbol] : 0;
  }

  process(value, classes) {
    const len = classes.length;
    for (let i = 0; i < len; i++) {
      if (classes[i]) {
        const cls = classes[i],
          splitClasses = cls.values ? Array.from(cls.values()) : cls.item ? Array.from(cls) : cls.split(whiteSpaceRe$2),
          len = splitClasses.length;
        for (let i = 0; i < len; i++) {
          if (splitClasses[i]) {
            this[splitClasses[i]] = value;
          }
        }
      }
    }

    // String value needs recalculating
    this[dirtySymbol] = true;
  }

  /**
   * Add CSS class(es)
   * ```
   * myClassList.add('bold', 'small');
   * ```
   * @param {String} classes CSS classes to add
   */
  add(...classes) {
    this.process(1, classes);
  }

  /**
   * Remove CSS class(es)
   * ```
   * myClassList.remove('bold', 'small');
   * ```
   * @param {String} classes CSS classes to remove
   */
  remove(...classes) {
    this.process(0, classes);
  }

  /**
   * Analogous to the `String#split` method, but with no delimiter
   * parameter. This method returns an array containing the individual
   * CSS class names set.
   * @returns {String[]} The individual class names in this `DomClassList`
   */
  split() {
    return ObjectHelper.getTruthyKeys(this);
  }

  forEach(fn) {
    return ObjectHelper.getTruthyKeys(this).forEach(fn);
  }

  // To gain some speed in DomHelper.sync(), faster than instanceof etc
  get isDomClassList() {
    return true;
  }
}
const whiteSpaceRe$2 = /\s+/,
  valueSymbol = Symbol('value'),
  lengthSymbol = Symbol('length'),
  dirtySymbol = Symbol('dirty'),
  testClassList = new DomClassList();
DomClassList._$name = 'DomClassList';

//TODO: add pointer events support

const documentListeners$1 = {
  down: 'onMouseDown',
  move: 'onMouseMove',
  up: 'onMouseUp',
  docclick: 'onDocumentClick',
  touchstart: 'onTouchStart',
  touchmove: 'onTouchMove',
  touchend: 'onTouchEnd',
  keydown: 'onKeyDown'
};

/**
 * @module Common/helper/ResizeHelper
 */

/**
 * Handles resizing of elements using handles. Handles can be actual elements or virtual handles specified as a border
 * area on elements left and right edges.
 *
 * ```
 * // enable resizing all elements with class 'resizable'
 * let resizer = new ResizeHelper({
 *   targetSelector: '.resizable'
 * });
 * ```
 *
 * @mixes Common/mixin/Events
 * @internal
 */
class ResizeHelper extends Events(Base) {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * CSS class added when resizing
       * @config {String}
       * @default
       */
      resizingCls: 'b-resizing',

      /**
       * The amount of pixels to move mouse before it counts as a drag operation
       * @config {Number}
       * @default
       */
      dragThreshold: 5,

      /**
       * Resizing handle size
       * @config {Number}
       * @default
       */
      handleSize: 10,

      /**
       * Resizing handle size on touch devices
       * @config {Number}
       * @default
       */
      touchHandleSize: 30,

      /**
       * Minimum width when resizing
       * @config {Number}
       * @default
       */
      minWidth: 1,

      /**
       * Max width when resizing.
       * @config {Number}
       * @default
       */
      maxWidth: 0,

      /**
       * Minimum height when resizing
       * @config {Number}
       * @default
       */
      minHeight: 1,

      /**
       * Max height when resizing
       * @config {Number}
       * @default
       */
      maxHeight: 0,

      // outerElement, attach events to it and use as outer limit when looking for ancestors
      outerElement: document.body,

      /**
       * Optional scroller used to read scroll position. If unspecified, the outer element will be used.
       * @config {Common.helper.util.Scroller}
       */
      scroller: null,

      /**
       * Assign a function to determine if a hovered element can be resized or not
       * @config {Function}
       * @default
       */
      allowResize: null,

      /**
       * Outer element that limits where element can be dragged
       * @config {HTMLElement}
       * @default
       */
      dragWithin: null,

      /**
       * A function that determines if dragging an element is allowed. Gets called with the element as argument,
       * return true to allow dragging or false to prevent.
       * @config {Function}
       * @default
       */
      isElementResizable: null,

      /**
       * A CSS selector used to determine if resizing an element is allowed.
       * @config {String}
       * @default
       */
      targetSelector: null,

      /**
       * Use left handle when resizing. Only applies when `direction` is 'horizontal'
       * @config {Boolean}
       * @default
       */

      leftHandle: true,

      /**
       * Use right handle when resizing. Only applies when `direction` is 'horizontal'
       * @config {Boolean}
       * @default
       */
      rightHandle: true,

      /**
       * Use top handle when resizing. Only applies when `direction` is 'vertical'
       * @config {Boolean}
       * @default
       */

      topHandle: true,

      /**
       * Use bottom handle when resizing. Only applies when `direction` is 'vertical'
       * @config {Boolean}
       * @default
       */
      bottomHandle: true,

      /**
       * A CSS selector used to determine where handles should be "displayed" when resizing. Defaults to
       * targetSelector if unspecified
       * @config {String}
       * @default
       */
      handleSelector: null,

      /**
       * A CSS selector used to determine which inner element contains handles.
       * @config {String}
       * @default
       */
      handleContainerSelector: null,

      startEvent: null,

      /*
       * Optional config object, used by EventResize feature: it appends proxy and has to start resizing immediately
       * @config {Object}
       * @private
       */
      grab: null,

      /**
       * CSS class added when the resize state is invalid
       * @config {String}
       * @default
       */
      invalidCls: 'b-resize-invalid',

      // A number that controls whether or not the element is wide enough for it to make sense to show resize handles
      // e.g. handle width is 10px, so doesn't make sense to show them unless handles on both sides fit
      handleVisibilityThreshold: null,

      // Private config that disables translation when resizing left edge. Useful for example in cases when element
      // being resized is part of a flex layout
      skipTranslate: false,

      /**
       * Direction to resize in, either 'horizontal' or 'vertical'
       * @config {String}
       * @default
       */
      direction: 'horizontal'
    };
  }

  //endregion

  //region Events

  /**
   * Fires after resize
   * @event resize
   * @param {Common.helper.ResizeHelper} source
   * @param {Object} context Resize context
   */

  /**
   * Fires when a resize is canceled (width is unchanged)
   * @event cancel
   * @param {Common.helper.ResizeHelper} source
   * @param {Object} context Resize context
   * @param {MouseEvent|TouchEvent} event Browser event
   */

  /**
   * Fired while dragging
   * @event resizing
   * @param {Common.helper.ResizeHelper} source
   * @param {Object} context Resize context
   * @param {MouseEvent} event Browser event
   */

  /**
   * Fired when dragging starts.
   * @event resizeStart
   * @param {Common.helper.ResizeHelper} source
   * @param {Object} context Resize context
   * @param {MouseEvent|TouchEvent} event Browser event
   */

  //endregion

  //region Init

  construct(config) {
    const me = this;

    super.construct(config);

    // Larger grabbable zones on touch devices
    if (!me.handleSelector && BrowserHelper.isTouchDevice) {
      me.handleSize = me.touchHandleSize;
    }

    me.handleVisibilityThreshold = me.handleVisibilityThreshold || 2 * me.handleSize;

    me.initListeners();

    me.initResize();
  }

  doDestroy() {
    this.abort(true);
    super.doDestroy();
  }

  /**
   * Initializes resizing
   * @private
   */
  initResize() {
    const me = this;

    if (!me.isElementResizable && me.targetSelector) {
      me.isElementResizable = (element) => DomHelper.up(element, me.targetSelector);
    }

    if (me.grab) {
      const { edge, element, event } = me.grab;

      me.startEvent = event;

      // emulates mousedown & grabResize
      me.context = {
        element,
        edge,
        valid: true,
        async: false,
        elementStartX: DomHelper.getTranslateX(element) || element.offsetLeft, // extract x from translate
        elementStartY: DomHelper.getTranslateY(element) || element.offsetTop, // extract x from translate
        newX: DomHelper.getTranslateX(element) || element.offsetLeft, // No change yet on start, but info must be present
        newY: DomHelper.getTranslateY(element) || element.offsetTop, // No change yet on start, but info must be present
        elementWidth: element.offsetWidth,
        elementHeight: element.offsetHeight,
        startX: event.clientX + me.scrollLeft,
        startY: event.clientY + me.scrollTop,
        started: true,
        finalize: () => me.reset && me.reset()
      };
      element.classList.add(me.resizingCls);

      me.internalStartResize(me.isTouch);
    }
  }

  /**
   * Initialize listeners
   * @private
   */
  initListeners() {
    const me = this,
      dragStartListeners = {
        element: me.outerElement,
        mousedown: documentListeners$1.down,
        thisObj: me
      };

    if (BrowserHelper.isTouchDevice) {
      dragStartListeners.touchstart = documentListeners$1.touchstart;
    } else if (!me.handleSelector) {
      dragStartListeners.mousemove = {
        handler: documentListeners$1.move,

        // Filter events for checkResizeHandles so we only get called if the mouse
        // is over one of our targets.
        delegate: me.targetSelector
      };

      // We need to clean up when we exit one of our targets
      dragStartListeners.mouseleave = {
        handler: 'onMouseLeaveTarget',
        delegate: me.targetSelector,
        capture: true
      };
    }

    // These will be autoDetached upon destroy
    me.removeListeners = EventHelper.on(dragStartListeners);
  }

  removeListeners() {}

  //endregion

  //region Scroll helpers

  get scrollLeft() {
    if (this.scroller) {
      return this.scroller.x;
    }

    return this.outerElement.scrollLeft;
  }

  get scrollTop() {
    if (this.scroller) {
      return this.scroller.y;
    }

    return this.outerElement.scrollTop;
  }

  //endregion

  //region Events

  internalStartResize(isTouch) {
    const me = this,
      dragListeners = {
        element: document,
        keydown: documentListeners$1.keydown,
        thisObj: me
      };

    if (isTouch) {
      dragListeners.touchmove = documentListeners$1.touchmove;
      // Touch desktops don't fire touchend event when touch has ended, instead pointerup is fired
      // iOS do fire touchend
      dragListeners.touchend = dragListeners.pointerup = documentListeners$1.touchend;
    } else {
      dragListeners.mousemove = documentListeners$1.move;
      dragListeners.mouseup = documentListeners$1.up;
    }

    // A listener detacher is returned;
    me.removeDragListeners = EventHelper.on(dragListeners);

    me.scrollManager &&
      me.scrollManager.startMonitoring({
        direction: me.direction, // TODO Update this then when we add support for vertical resizing too
        element: me.dragWithin || me.outerElement,
        callback: (config) =>
          me.context && me.context.element && me.lastMouseMoveEvent && me.update(me.lastMouseMoveEvent, config),
        thisObj: me
      });
  }

  // Empty class implementation. If listeners *are* added, the detacher is added
  // as an instance property. So this is always callable.
  removeDragListeners() {}

  reset() {
    this.removeDragListeners();
    this.context = null;
  }

  onPointerDown(isTouch, event) {
    const me = this;

    me.startEvent = event;

    if (!me.isElementResizable || me.isElementResizable(event.target, event)) {
      if (me.grabResizeHandle(isTouch, event)) {
        // Stop event if resize handle was grabbed (resize started)
        event.stopImmediatePropagation();
        me.internalStartResize(isTouch);
      }
    }
  }

  onTouchStart(event) {
    // only allowing one finger for now...
    if (event.touches.length > 1) {
      return;
    }

    this.onPointerDown(true, event);
  }

  /**
   * Grab draggable element on mouse down.
   * @private
   * @param event
   */
  onMouseDown(event) {
    // only dragging with left mouse button
    if (event.button !== 0) {
      return;
    }

    this.onPointerDown(false, event);
  }

  internalMove(isTouch, event) {
    const me = this,
      context = me.context;

    if (
      context &&
      context.element &&
      (context.started || EventHelper.getDistanceBetween(me.startEvent, event) >= me.dragThreshold)
    ) {
      if (!context.started) {
        me.trigger('resizeStart', { context, event });

        context.started = true;
      }

      me.update(event);
    }
    // If a mousemove, and we are using zones, and not handles, we have to
    // programatically check whether we are over a handle, and add/remove
    // classes to change the mouse cursor to resize.
    // If we are using handles, their CSS will set the mouse cursor.
    else if (!isTouch && !me.handleSelector) {
      me.checkResizeHandles(event);
    }
  }

  onTouchMove(event) {
    this.internalMove(true, event);
  }

  /**
   * Move grabbed element with mouse.
   * @param event
   * @fires resizestart
   * @private
   */
  onMouseMove(event) {
    this.internalMove(false, event);
  }

  internalEnd(isTouch, event) {
    const me = this,
      context = me.context;

    me.removeDragListeners();

    if (context) {
      me.scrollManager && me.scrollManager.stopMonitoring(me.dragWithin || me.outerElement);

      me.finishResize(event);

      // Resize could have not been finalized
      if (me.context) {
        // Prevent the impending document click from the mouseup event from propagating
        // into a click on our element.
        EventHelper.on({
          element: document,
          thisObj: me,
          click: documentListeners$1.docclick,
          capture: true,
          once: true
        });
      }
    }
  }

  onTouchEnd(event) {
    this.internalEnd(true, event);
  }

  /**
   * Drop on mouse up (if dropped on valid target).
   * @param event
   * @private
   */
  onMouseUp(event) {
    this.internalEnd(false, event);
  }

  /**
   * This is a capture listener, only added during drag, which prevents a click gesture
   * propagating from the terminating mouseup geature
   * @param {MouseEvent} event
   * @private
   */
  onDocumentClick(event) {
    event.stopPropagation();
  }

  /**
   * Cancel on ESC key
   * @param event
   * @private
   */
  onKeyDown(event) {
    if (event.key === 'Escape') {
      this.abort();
    }
  }

  //endregion

  //region Grab, update, finish

  /**
   * Updates resize, called when an element is grabbed and mouse moves
   * @private
   * @fires resizing
   */
  update(event) {
    const me = this,
      context = me.context,
      parentRectangle = Rectangle.from(me.outerElement.parentElement);

    // Calculate the current pointer X. Do not allow overflowing either edge
    context.currentX = Math.max(Math.min(event.clientX, parentRectangle.right - 1), parentRectangle.x) + me.scrollLeft;
    context.currentY = Math.max(Math.min(event.clientY, parentRectangle.bottom - 1), parentRectangle.y) + me.scrollTop;

    me.updateResize(event);

    me.trigger('resizing', { context, event });

    context.element.classList[context.valid === false ? 'add' : 'remove'](me.invalidCls);
    // When IE11 support is dropped
    // context.grabbed.classList.toggle(me.invalidCls, context.valid === false);

    if (event) {
      me.lastMouseMoveEvent = event;
    }
  }

  /**
   * Abort dragging
   */
  abort(silent = false) {
    const me = this;

    me.scrollManager && me.scrollManager.stopMonitoring(me.dragWithin || me.outerElement);

    if (me.context) {
      me.abortResize(null, silent);
    }
  }

  /**
   * Starts resizing, updates ResizeHelper#context with relevant info.
   * @private
   * @param {Boolean} isTouch
   * @param {MouseEvent} event
   * @returns {Boolean} True if handled, false if not
   */
  grabResizeHandle(isTouch, event) {
    const me = this;

    if (me.allowResize && !me.allowResize(event.target, event)) {
      return false;
    }

    const handleSelector = me.handleSelector,
      coordsFrom = event.type === 'touchstart' ? event.changedTouches[0] : event,
      clientX = coordsFrom.clientX,
      clientY = coordsFrom.clientY,
      // go up from "handle" to resizable element
      element = me.targetSelector ? DomHelper.up(event.target, me.targetSelector) : event.target;

    if (element) {
      let edge;

      // Calculate which edge to resize
      // If there's a handle selector, see if it's anchored on the left or the right
      if (handleSelector) {
        if (event.target.matches(handleSelector)) {
          if (me.direction === 'horizontal') {
            if (event.pageX < DomHelper.getPageX(element) + element.offsetWidth / 2) {
              edge = 'left';
            } else {
              edge = 'right';
            }
          } else {
            if (event.pageY < DomHelper.getPageY(element) + element.offsetHeight / 2) {
              edge = 'top';
            } else {
              edge = 'bottom';
            }
          }
        } else {
          return false;
        }
      }
      // If we're not using handles, but just active zones
      // then test whether the event position is in an active resize zone.
      else {
        if (me.direction === 'horizontal') {
          if (me.overLeftHandle(event, element)) {
            edge = 'left';
          } else if (me.overRightHandle(event, element)) {
            edge = 'right';
          }
        } else {
          if (me.overTopHandle(event, element)) {
            edge = 'top';
          } else if (me.overBottomHandle(event, element)) {
            edge = 'bottom';
          }
        }

        if (!edge) {
          me.context = null;
          // not over an edge, abort
          return false;
        }
      }

      // If resizing is initiated by a touch, we must preventDefault on the touchstart
      // so that scrolling is not invoked when dragging. This is in lieu of a functioning
      // touch-action style on iOS Safari. When that's fixed, this will not be needed.
      if (event.type === 'touchstart') {
        event.preventDefault();
      }

      if (me.trigger('beforeResizeStart', { element, event }) !== false) {
        // store initial size
        me.context = {
          element,
          edge,
          valid: true,
          async: false,
          direction: me.direction,
          isTouch: isTouch,
          elementStartX: DomHelper.getTranslateX(element) || element.offsetLeft, // extract x from translate
          elementStartY: DomHelper.getTranslateY(element) || element.offsetTop, // extract y from translate
          newX: DomHelper.getTranslateX(element) || element.offsetLeft, // No change yet on start, but info must be present
          newY: DomHelper.getTranslateY(element) || element.offsetTop, // No change yet on start, but info must be present
          elementWidth: element.offsetWidth,
          elementHeight: element.offsetHeight,
          startX: clientX + me.scrollLeft,
          startY: clientY + me.scrollTop,
          finalize: () => me.reset && me.reset()
        };

        element.classList.add(me.resizingCls);

        return true;
      }
    }

    return false;
  }

  /**
   * Check if mouse is over a resize handle (virtual). If so, highlight.
   * @private
   * @param event
   */
  checkResizeHandles(event) {
    const me = this,
      target = me.targetSelector ? DomHelper.up(event.target, me.targetSelector) : event.target;

    // mouse over a target element and allowed to resize?
    if (target && (!me.allowResize || me.allowResize(event.target, event))) {
      me.currentElement = me.handleContainerSelector
        ? DomHelper.up(event.target, me.handleContainerSelector)
        : event.target;

      if (me.currentElement) {
        let over = false;

        if (me.direction === 'horizontal') {
          over = me.overLeftHandle(event, target) || me.overRightHandle(event, target);
        } else {
          over = me.overTopHandle(event, target) || me.overBottomHandle(event, target);
        }

        if (over) {
          me.highlightHandle(); // over handle
        } else {
          me.unHighlightHandle(); // not over handle
        }
      }
    } else if (me.currentElement) {
      me.unHighlightHandle(); // outside element
    }
  }

  onMouseLeaveTarget(event) {
    const me = this;

    me.currentElement = me.handleContainerSelector
      ? DomHelper.up(event.target, me.handleContainerSelector)
      : event.target;

    if (me.currentElement) {
      me.unHighlightHandle();
    }
  }

  /**
   * Updates size of target (on mouse move).
   * @private
   * @param event
   */
  updateResize(event) {
    const me = this,
      context = me.context;

    // flip which edge is being dragged depending on whether we're to the right or left of the mousedown
    if (me.allowEdgeSwitch) {
      if (me.direction === 'horizontal') {
        context.edge = context.currentX > context.startX ? 'right' : 'left';
      } else {
        context.edge = context.currentY > context.startY ? 'bottom' : 'top';
      }
    }

    let // limit to outerElement if set
      deltaX = context.currentX - context.startX,
      deltaY = context.currentY - context.startY,
      minWidth = DomHelper.getExtremalSizePX(context.element, 'minWidth') || me.minWidth,
      maxWidth = DomHelper.getExtremalSizePX(context.element, 'maxWidth') || me.maxWidth,
      minHeight = DomHelper.getExtremalSizePX(context.element, 'minHeight') || me.minHeight,
      maxHeight = DomHelper.getExtremalSizePX(context.element, 'maxHeight') || me.maxHeight,
      // dragging right edge right increases width, dragging left edge right decreases width
      sign = context.edge === 'right' || context.edge === 'bottom' ? 1 : -1,
      // new width, not allowed to go below minWidth
      newWidth = context.elementWidth + deltaX * sign,
      width = Math.max(minWidth, newWidth),
      newHeight = context.elementHeight + deltaY * sign,
      height = Math.max(minHeight, newHeight);

    if (maxWidth > 0) {
      width = Math.min(width, maxWidth);
    }

    if (maxHeight > 0) {
      height = Math.min(height, maxHeight);
    }

    // remove flex when resizing
    if (context.element.style.flex) {
      context.element.style.flex = '';
    }

    if (me.direction === 'horizontal') {
      context.element.style.width = Math.abs(width) + 'px';
      context.newWidth = width;

      // when dragging left edge, also update position (so that right edge remains in place)
      if (context.edge === 'left' || width < 0) {
        context.newX = Math.max(
          Math.min(context.elementStartX + context.elementWidth - me.minWidth, context.elementStartX + deltaX),
          0
        );
        if (!me.skipTranslate) {
          DomHelper.setTranslateX(context.element, context.newX);
        }
      }
      // When dragging the right edge and we're allowed to flip the drag from left to right
      // through the start point (eg drag event creation) the element must be at its initial X position
      else if (context.edge === 'right' && me.allowEdgeSwitch && !me.skipTranslate) {
        DomHelper.setTranslateX(context.element, context.elementStartX);
      }
    } else {
      context.element.style.height = Math.abs(height) + 'px';
      context.newHeight = height;

      // when dragging top edge, also update position (so that bottom edge remains in place)
      if (context.edge === 'top' || height < 0) {
        context.newY = Math.max(
          Math.min(context.elementStartY + context.elementHeight - me.minHeight, context.elementStartY + deltaY),
          0
        );
        if (!me.skipTranslate) {
          DomHelper.setTranslateY(context.element, context.newY);
        }
      }
      // When dragging the bottom edge and we're allowed to flip the drag from top to bottom
      // through the start point (eg drag event creation) the element must be at its initial Y position
      else if (context.edge === 'bottom' && me.allowEdgeSwitch && !me.skipTranslate) {
        DomHelper.setTranslateY(context.element, context.elementStartY);
      }
    }
  }

  /**
   * Finalizes resize, fires drop.
   * @private
   * @param event
   * @fires resize
   * @fires cancel
   */
  finishResize(event) {
    const me = this,
      context = me.context,
      eventObject = { context, event };

    context.element.classList.remove(me.resizingCls);

    let changed = false;

    if (me.direction === 'horizontal') {
      changed = context.newWidth && context.newWidth !== context.elementWidth;
    } else {
      changed = context.newHeight && context.newHeight !== context.elementHeight;
    }

    me.trigger(changed ? 'resize' : 'cancel', eventObject);

    if (!context.async) {
      context.finalize();
    }
  }

  /**
   * Abort resizing
   * @private
   * @fires cancel
   */
  abortResize(event = null, silent = false) {
    const me = this,
      context = me.context;

    context.element.classList.remove(me.resizingCls);
    if (me.direction === 'horizontal') {
      DomHelper.setTranslateX(context.element, context.elementStartX);
      context.element.style.width = context.elementWidth + 'px';
    } else {
      DomHelper.setTranslateY(context.element, context.elementStartY);
      context.element.style.height = context.elementHeight + 'px';
    }

    !silent && me.trigger('cancel', { context, event });

    if (!me.isDestroyed) {
      me.reset();
    }
  }

  //endregion

  //region Handles

  // /**
  //  * Constrain resize to outerElements bounds
  //  * @private
  //  * @param x
  //  * @returns {*}
  //  */
  // constrainResize(x) {
  //     const me = this;
  //
  //     if (me.outerElement) {
  //         const box = me.outerElement.getBoundingClientRect();
  //         if (x < box.left) x = box.left;
  //         if (x > box.right) x = box.right;
  //     }
  //
  //     return x;
  // }

  /**
   * Highlights handles (applies css that changes cursor).
   * @private
   */
  highlightHandle() {
    const me = this,
      target = me.targetSelector ? DomHelper.up(me.currentElement, me.targetSelector) : me.currentElement;

    // over a handle, add cls to change cursor
    me.currentElement.classList.add('b-resize-handle');
    target.classList.add('b-over-resize-handle');
  }

  /**
   * Unhighlight handles (removes css).
   * @private
   */
  unHighlightHandle() {
    const me = this,
      target = me.targetSelector ? DomHelper.up(me.currentElement, me.targetSelector) : me.currentElement;

    target && target.classList.remove('b-over-resize-handle');
    me.currentElement.classList.remove('b-resize-handle');
    me.currentElement = null;
  }

  overAnyHandle(event, target) {
    return this.overStartHandle(event, target) || this.overEndHandle(event, target);
  }

  overStartHandle(event, target) {
    return this.direction === 'horizontal' ? this.overLeftHandle(event, target) : this.overTopHandle(event, target);
  }

  overEndHandle(event, target) {
    return this.direction === 'horizontal' ? this.overRightHandle(event, target) : this.overBottomHandle(event, target);
  }

  /**
   * Check if over left handle (virtual).
   * @private
   * @param {MouseEvent} event MouseEvent
   * @param {HTMLElement} target The current target element
   * @returns {Boolean} Returns true if mouse is over left handle, otherwise false
   */
  overLeftHandle(event, target) {
    if (this.leftHandle && target.offsetWidth >= this.handleVisibilityThreshold) {
      const leftHandle = Rectangle.from(target);

      leftHandle.width = this.handleSize;
      return leftHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }

  /**
   * Check if over right handle (virtual).
   * @private
   * @param {MouseEvent} event MouseEvent
   * @param {HTMLElement} target The current target element
   * @returns {Boolean} Returns true if mouse is over left handle, otherwise false
   */
  overRightHandle(event, target) {
    if (this.rightHandle && target.offsetWidth >= this.handleVisibilityThreshold) {
      const rightHandle = Rectangle.from(target);

      rightHandle.x = rightHandle.right - this.handleSize;
      return rightHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }

  /**
   * Check if over top handle (virtual).
   * @private
   * @param {MouseEvent} event MouseEvent
   * @param {HTMLElement} target The current target element
   * @returns {Boolean} Returns true if mouse is over top handle, otherwise false
   */
  overTopHandle(event, target) {
    if (this.topHandle && target.offsetHeight >= this.handleVisibilityThreshold) {
      const topHandle = Rectangle.from(target);

      topHandle.height = this.handleSize;
      return topHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }

  /**
   * Check if over bottom handle (virtual).
   * @private
   * @param {MouseEvent} event MouseEvent
   * @param {HTMLElement} target The current target element
   * @returns {Boolean} Returns true if mouse is over bottom handle, otherwise false
   */
  overBottomHandle(event, target) {
    if (this.bottomHandle && target.offsetHeight >= this.handleVisibilityThreshold) {
      const bottomHandle = Rectangle.from(target);

      bottomHandle.y = bottomHandle.bottom - this.handleSize;
      return bottomHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }

  //endregion
}
ResizeHelper._$name = 'ResizeHelper';

/**
 * @module Common/helper/VersionHelper
 */

/**
 * Helper for version handling
 * @private
 * @example
 *
 * VersionHelper.setVersion('grid', '1.5');
 *
 * if (VersionHelper.getVersion('grid').isNewerThan('1.0')) {
 *   ...
 * }
 */
class VersionHelper {
  /**
   * Set version for specified product
   * @private
   * @param {String} product
   * @param {String} version
   */
  static setVersion(product, version) {
    product = product.toLowerCase();

    this[product] = {
      version,
      isNewerThan(otherVersion) {
        return otherVersion < version;
      },
      isOlderThan(otherVersion) {
        return otherVersion > version;
      }
    };

    if (!window.bryntum) {
      window.bryntum = {};
    }

    let bundleFor = '';

    // Var productName is only defined in bundles, it is internal to bundle so not available on window. Used to
    // tell importing combinations of grid/scheduler/gantt bundles apart from loading same bundle twice
    try {
      // eslint-disable-next-line no-undef
      bundleFor = productName;
    } catch (e) {}

    // Set "global" flag to detect bundle being loaded twice
    const globalKey = `${bundleFor}.${product}${version.replace(/\./g, '-')}`;

    if (window.bryntum[globalKey] === true) {
      if (window.parent.Siesta) {
        window.BUNDLE_EXCEPTION = true;
      } else {
        throw new Error('Bundle included twice, check cache-busters and file types (.js)');
      }
    } else {
      window.bryntum[globalKey] = true;
    }
  }

  /**
   * Get (previously set) version for specified product
   * @private
   * @param {String} product
   */
  static getVersion(product) {
    product = product.toLowerCase();

    if (!this[product]) {
      throw new Error('No version specified');
    }

    return this[product].version;
  }
}
VersionHelper._$name = 'VersionHelper';

/**
 * @module Common/helper/util/RandomGenerator
 */

/**
 * Generates pseudo random numbers from predefined sequence of 100 numbers
 */
class RandomGenerator {
  constructor() {
    this.random100 = [
      46,
      2,
      36,
      46,
      54,
      59,
      18,
      20,
      71,
      55,
      88,
      98,
      13,
      61,
      61,
      40,
      2,
      15,
      3,
      32,
      51,
      45,
      64,
      25,
      81,
      85,
      54,
      13,
      57,
      49,
      64,
      22,
      81,
      94,
      0,
      62,
      17,
      7,
      11,
      2,
      33,
      99,
      85,
      26,
      83,
      83,
      96,
      26,
      20,
      89,
      91,
      38,
      26,
      13,
      11,
      79,
      32,
      30,
      5,
      51,
      70,
      7,
      5,
      56,
      58,
      77,
      37,
      89,
      40,
      80,
      78,
      59,
      26,
      36,
      8,
      51,
      60,
      23,
      86,
      5,
      11,
      96,
      64,
      94,
      87,
      64,
      4,
      78,
      17,
      85,
      35,
      0,
      90,
      86,
      23,
      55,
      53,
      9,
      35,
      59,
      29,
      2,
      64,
      42,
      8,
      49,
      43,
      73,
      6,
      53,
      38,
      9,
      39,
      31,
      32,
      40,
      49,
      13,
      78,
      68,
      20,
      99,
      24,
      78,
      35,
      91,
      73,
      46,
      67,
      76,
      89,
      69,
      30,
      69,
      25,
      3,
      4,
      55,
      1,
      65,
      66,
      76,
      83,
      19,
      67,
      1,
      95,
      24,
      54,
      45,
      56,
      40,
      67,
      92,
      72,
      4,
      69,
      8,
      47,
      50,
      27,
      2,
      38,
      9,
      14,
      83,
      12,
      14,
      62,
      95,
      22,
      47,
      35,
      18,
      38,
      14,
      86,
      64,
      68,
      61,
      52,
      69,
      39,
      93,
      20,
      73,
      32,
      52,
      74,
      6,
      56,
      68,
      99,
      29,
      24,
      92,
      40,
      67,
      6,
      72,
      31,
      41,
      91,
      53,
      80,
      55,
      33,
      97,
      97,
      99,
      18,
      20,
      5,
      27,
      82,
      84,
      61,
      78,
      27,
      67,
      7,
      42,
      75,
      95,
      91,
      25,
      63,
      21,
      70,
      36,
      46,
      0,
      1,
      45,
      84,
      6,
      86,
      15,
      10,
      62,
      96,
      94,
      10,
      23,
      93,
      83,
      94,
      47,
      5,
      29,
      29,
      52,
      51,
      37,
      77,
      96,
      43,
      72,
      43,
      14,
      54,
      14,
      72,
      52,
      4,
      39,
      15,
      26,
      68,
      28,
      25,
      76,
      60,
      50,
      22,
      40,
      72,
      74,
      68,
      58,
      8,
      48,
      40,
      62,
      52,
      24,
      9,
      26,
      47,
      44,
      49,
      96,
      7,
      77,
      90,
      45,
      76,
      47,
      5,
      86,
      1,
      36,
      18,
      42,
      19,
      90,
      34,
      23,
      70,
      32,
      69,
      79,
      0,
      99,
      57,
      80,
      72,
      21,
      19,
      72,
      85,
      68,
      4,
      40,
      86,
      62,
      0,
      63,
      4,
      11,
      69,
      31,
      78,
      31,
      21,
      78,
      29,
      84,
      13,
      53,
      57,
      10,
      26,
      50,
      24,
      30,
      90,
      42,
      51,
      96,
      93,
      21,
      99,
      23,
      81,
      0,
      89,
      43,
      86,
      63,
      93,
      19,
      54,
      71,
      92,
      36,
      4,
      95,
      37,
      99,
      60,
      29,
      23,
      50,
      68,
      95,
      57,
      95,
      77,
      53,
      99,
      78,
      75,
      12,
      92,
      47,
      23,
      14,
      0,
      41,
      98,
      11,
      34,
      64,
      26,
      90,
      50,
      23,
      38,
      31,
      74,
      76,
      16,
      76,
      66,
      23,
      22,
      72,
      48,
      50,
      20,
      36,
      37,
      58,
      5,
      43,
      49,
      64,
      81,
      30,
      8,
      21,
      98,
      75,
      60,
      17,
      50,
      42,
      27,
      38,
      90,
      74,
      45,
      68,
      67,
      27,
      31,
      15,
      58,
      76,
      41,
      99,
      23,
      98,
      53,
      98,
      56,
      19,
      79,
      2,
      4,
      38,
      96,
      24,
      65,
      51,
      43,
      42,
      41,
      60,
      46,
      7,
      90,
      65,
      3,
      27,
      63,
      99,
      51,
      44,
      86,
      1,
      54,
      40,
      15,
      74,
      3,
      81,
      51,
      63,
      87,
      79,
      84,
      72,
      22,
      38,
      96,
      95,
      33,
      41,
      21,
      99,
      21,
      69,
      7,
      49,
      40,
      52,
      41,
      6,
      91,
      19,
      76,
      40,
      54,
      17,
      33,
      11,
      11,
      0,
      1,
      32,
      94,
      33,
      13,
      18,
      45,
      7,
      85,
      61,
      42,
      54,
      45,
      72,
      78,
      96,
      17,
      9,
      80,
      87,
      41,
      96,
      66,
      0,
      8,
      59,
      18,
      21,
      2,
      28,
      64,
      75,
      97,
      32,
      80,
      86,
      97,
      97,
      55,
      2,
      73,
      75,
      11,
      89,
      67,
      58,
      70,
      76,
      12,
      46,
      64,
      17,
      22,
      97,
      25,
      35,
      93,
      57,
      82,
      46,
      57,
      61,
      31,
      74,
      27,
      4,
      32,
      85,
      53,
      86,
      53,
      53,
      42,
      5,
      28,
      50,
      65,
      63,
      70,
      61,
      73,
      37,
      13,
      80,
      7,
      34,
      22,
      3,
      26,
      6,
      62,
      78,
      12,
      56,
      87,
      41,
      58,
      64,
      31,
      27,
      45,
      35,
      18,
      66,
      62,
      43,
      89,
      69,
      94,
      93,
      33,
      74,
      2,
      43,
      85,
      37,
      82,
      41,
      74,
      9,
      15,
      44,
      33,
      42,
      65,
      19,
      1,
      49,
      78,
      12,
      29,
      9,
      78,
      7,
      55,
      12,
      45,
      40,
      33,
      16,
      86,
      14,
      52,
      16,
      73,
      76,
      0,
      98,
      75,
      91,
      78,
      46,
      99,
      95,
      90,
      69,
      78,
      45,
      62,
      55,
      37,
      88,
      49,
      77,
      27,
      83,
      38,
      73,
      39,
      1,
      75,
      40,
      65,
      83,
      54,
      95,
      7,
      73,
      4,
      30,
      26,
      36,
      89,
      21,
      5,
      95,
      11,
      14,
      87,
      45,
      36,
      21,
      77,
      55,
      5,
      66,
      51,
      98,
      48,
      62,
      74,
      58,
      23,
      82,
      30,
      28,
      19,
      53,
      89,
      76,
      98,
      8,
      34,
      70,
      28,
      54,
      16,
      52,
      35,
      93,
      54,
      54,
      72,
      49,
      18,
      93,
      72,
      90,
      71,
      73,
      15,
      60,
      38,
      80,
      76,
      53,
      70,
      39,
      69,
      25,
      5,
      31,
      61,
      46,
      6,
      54,
      34,
      31,
      52,
      33,
      36,
      79,
      76,
      44,
      29,
      28,
      38,
      1,
      66,
      2,
      90,
      91,
      1,
      76,
      78,
      31,
      55,
      37,
      71,
      2,
      3,
      38,
      85,
      0,
      95,
      42,
      2,
      39,
      57,
      87,
      61,
      77,
      98,
      2,
      24,
      80,
      48,
      27,
      47,
      71,
      15,
      7,
      49,
      60,
      86,
      3,
      2,
      29,
      38,
      54,
      36,
      59,
      83,
      27,
      47,
      9,
      36,
      42,
      8,
      73,
      85,
      9,
      16,
      73,
      60,
      39,
      12,
      43,
      25,
      23,
      29,
      28,
      47,
      40,
      77,
      20,
      89,
      22,
      30,
      41,
      59,
      96,
      19,
      56,
      20,
      76,
      73,
      39,
      46,
      72,
      40,
      47,
      37,
      52,
      29,
      79,
      37,
      39,
      50,
      41,
      87,
      66,
      17,
      75,
      31,
      45,
      26,
      88,
      70,
      11,
      90,
      40,
      74,
      9,
      32,
      65,
      72,
      61,
      6,
      93,
      54,
      15,
      84,
      22,
      99,
      47,
      10,
      96,
      4,
      84,
      19,
      85,
      73,
      45,
      25,
      16,
      8,
      94,
      99,
      39,
      28,
      26,
      68,
      87,
      48,
      1,
      65,
      86,
      46,
      86,
      7,
      60,
      82,
      45,
      75,
      38,
      56,
      41,
      35,
      30,
      86,
      91,
      97,
      85,
      45,
      5,
      14,
      69,
      85,
      96,
      37,
      18,
      26,
      16,
      38,
      16,
      1,
      44,
      94,
      85,
      58,
      60,
      20,
      5,
      47,
      52,
      41,
      50,
      71,
      43,
      42,
      67,
      64,
      38,
      65,
      83,
      99,
      78,
      96,
      33,
      20,
      98,
      24,
      6,
      2,
      25,
      16,
      16,
      44,
      63,
      24,
      68,
      56,
      49,
      91,
      15,
      59,
      99,
      27,
      43,
      34,
      28,
      36,
      45,
      1,
      10,
      19,
      54,
      26,
      75,
      17,
      88,
      96,
      63,
      24,
      71,
      93,
      72,
      97,
      66,
      87,
      18,
      86
    ];
    this.randomCache = {};
    this.rndIndex = 0;
  }

  /**
   * Returns next pseudo random integer number from sequence between 0 and max parameter value (99 is maximum value)
   * @param max max value
   * @returns {number}
   */
  nextRandom(max) {
    let randomCache = this.randomCache,
      randomNumbers;

    if (randomCache[max]) {
      randomNumbers = randomCache[max];
    } else {
      randomNumbers = this.random100.filter((num) => num < max);
      randomCache[max] = randomNumbers;
    }

    return randomNumbers[this.rndIndex++ % randomNumbers.length];
  }

  /**
   * Resets sequence to initial number
   */
  reset() {
    this.rndIndex = 0;
  }

  /**
   * Returns pseudo random array element
   * @param array input array
   * @returns {*}
   */
  fromArray(array) {
    return array[this.nextRandom(array.length)];
  }
}
RandomGenerator._$name = 'RandomGenerator';

class DataGenerator {
  //region Random

  static reset() {
    this.rnd.reset();
    this.rndTime.reset();
  }

  //endregion

  //region Generate data

  static *generate(count, randomHeight = false, initialId = 1) {
    const me = this,
      rnd = me.rnd,
      rndTime = me.rndTime,
      firstNames = me.firstNames,
      surNames = me.surNames,
      teams = me.teams,
      foods = me.foods,
      colors = me.colors,
      cities = me.cities;

    for (let i = 0; i < count; i++) {
      const firstName = rnd.fromArray(firstNames),
        surName = rnd.fromArray(surNames),
        name = `${firstName} ${String.fromCharCode(65 + (i % 25))} ${surName}`,
        startDay = rnd.nextRandom(60) + 1,
        start = new Date(2019, 0, startDay),
        finish = new Date(2019, 0, startDay + rnd.nextRandom(30) + 2), //DateHelper.add(start, rnd.nextRandom(30) + 2, 'days'),
        row = {
          id: i + initialId,
          title: 'Row ' + i,
          name: name,
          firstName: firstName,
          surName: surName,
          city: rnd.fromArray(cities),
          team: rnd.fromArray(cities) + ' ' + rnd.fromArray(teams),
          age: 10 + rnd.nextRandom(80),
          food: rnd.fromArray(foods),
          color: rnd.fromArray(colors),
          score: rnd.nextRandom(100) * 10,
          rank: rnd.nextRandom(100) + 1,
          start: start,
          finish: finish,
          time: DateHelper.getTime(rndTime.nextRandom(24), rndTime.nextRandom(12) * 5),
          percent: rnd.nextRandom(100),
          done: rnd.nextRandom(100) < 50,
          rating: Math.round(Math.random() * 5),
          relatedTo: Math.min(count - 1, i + initialId + rnd.nextRandom(10))
        };

      if (randomHeight) {
        row.rowHeight = rnd.nextRandom(randomHeight === true ? 20 : randomHeight) * 5 + 20;
      }

      yield row;
    }
  }

  // Param reset defaults to true to ensure we get the same dataset on consecutive calls. Without it, code editor
  // reloading modules yields different data each time
  static generateData(count, randomHeight = false, initialId = 1, reset = true) {
    if (reset) this.reset();

    const rows = [],
      number = DataGenerator.overrideRowCount ? DataGenerator.overrideRowCount : count,
      generator = this.generate(number, randomHeight, initialId);

    for (let i = 0; i < number; i++) {
      rows.push(generator.next().value);
    }
    return rows;
  }

  //endregion
}

Object.assign(DataGenerator, {
  rnd: new RandomGenerator(),
  rndTime: new RandomGenerator(),
  rating: 0,
  cities: ['Stockholm', 'Barcelona', 'Paris', 'Dubai', 'New York', 'San Francisco', 'Washington', 'Moscow'],
  firstNames: [
    'Mike',
    'Linda',
    'Don',
    'Karen',
    'Doug',
    'Jenny',
    'Daniel',
    'Melissa',
    'John',
    'Jane',
    'Theo',
    'Lisa',
    'Adam',
    'Mary',
    'Barbara',
    'James',
    'David'
  ],
  surNames: [
    'McGregor',
    'Ewans',
    'Scott',
    'Smith',
    'Johnson',
    'Adams',
    'Williams',
    'Brown',
    'Jones',
    'Miller',
    'Davis',
    'More',
    'Wilson',
    'Taylor',
    'Anderson',
    'Thomas',
    'Jackson'
  ],
  teams: [
    'Lions',
    'Eagles',
    'Tigers',
    'Horses',
    'Dogs',
    'Cats',
    'Panthers',
    'Rats',
    'Ducks',
    'Cougars',
    'Hens',
    'Roosters'
  ],
  foods: ['Pancake', 'Burger', 'Fish n chips', 'Carbonara', 'Taco', 'Salad', 'Bolognese', 'Mac n cheese', 'Waffles'],
  colors: ['Blue', 'Green', 'Red', 'Yellow', 'Pink', 'Purple', 'Orange', 'Teal', 'Black']
});
DataGenerator._$name = 'DataGenerator';

const knownProps = ['action', 'target', 'to', 'deltaX', 'deltaY', 'x', 'y', 'text'];

class DemoBot extends Events(Delayable()) {
  static get defaultConfig() {
    return {
      repeat: true,
      outerElement: document.body,
      callOnFunctions: true
    };
  }

  // expects an outer element (grid.element/scheduler.element) and an array of steps similar to chain steps in siesta
  construct(config) {
    super.construct(config);

    const me = this;

    if (me.widget) {
      me.outerElement = me.widget.element;
      me.widget.playingDemo = true;
    }

    EventHelper.playingDemo = true;

    Object.assign(me, {
      prevTarget: null,
      currentStep: 0,
      mouse: DomHelper.createElement({
        parent: me.outerElement,
        tag: 'div',
        className: 'simulated-mouse'
      }),
      timeoutId: null,
      innerIntervalId: null,
      mouseOutElements: []
    });

    me.intervalId = me.setInterval(me.nextStep.bind(me), 1000);

    me.outerElement.classList.add('b-playing-demo');

    me.outerElement.addEventListener('click', (event) => {
      if (event.isTrusted) {
        me.abort();
      }
    });
  }

  doDestroy() {
    this.abort();
  }

  // stops the bot
  abort(atEnd = false) {
    const me = this;

    me.mouse.style.top = '-100px';
    me.clearInterval(me.intervalId);
    me.timeoutId && me.clearTimeout(me.timeoutId);
    me.innerIntervalId && me.clearInterval(me.innerIntervalId);

    me.outerElement.classList.remove('b-playing-demo');
    if (me.widget) {
      me.widget.playingDemo = false;
    }

    EventHelper.playingDemo = false;

    me.trigger(atEnd ? 'done' : 'abort');
  }

  // triggers a synthetic event
  triggerEvent(element, type, data) {
    if (!element) return null;

    let event;

    if (type.startsWith('mouse')) {
      const box = this.mouse.getBoundingClientRect();

      event = new MouseEvent(
        type,
        Object.assign(
          {
            view: window,
            bubbles: true,
            cancelable: true,
            clientX: box.left,
            clientY: box.top
          },
          data || {}
        )
      );
    } else {
      event = document.createEvent('Event');
      event.initEvent(type, true, false);
    }

    element.dispatchEvent(event);

    return event;
  }

  // moves mouse to target in 10 steps, with animated transition between steps
  handleMouseMove(step, target) {
    const me = this,
      mouse = me.mouse;

    mouse.classList.add('quick');
    if (me.mouseDown) mouse.classList.add('drag');

    let mouseBox = Rectangle.from(mouse, me.outerElement),
      x = mouseBox.x,
      y = mouseBox.y,
      deltaX = 0,
      deltaY = 0;

    if (step.to) {
      if (typeof step.to === 'string') {
        const toElement = me.outerElement.querySelector(step.to);
        if (toElement) {
          const rect = Rectangle.from(toElement, me.outerElement),
            toX = rect.x + rect.width / 2,
            toY = rect.y + rect.height / 2;
          deltaX = (toX - x) / 10;
          deltaY = (toY - y) / 10;
        }
      } else if (step.to.x) {
        deltaX = (step.to.x - x) / 10;
      } else {
        deltaX = step.to[0] / 10;
        deltaY = step.to[1] / 10;
      }
    } else if (step.deltaX) {
      deltaX = step.deltaX / 10;
    } else if (step.x) {
      deltaX = (step.x - x) / 10;
    }

    if (step.deltaY) {
      deltaY = step.deltaY / 10;
    }

    let i = 0;

    me.innerIntervalId = me.setInterval(() => {
      // Only move mouse if in view and not scrolling
      if (me.shouldPause) {
        return;
      }

      if (i++ === 9) {
        clearInterval(me.innerIntervalId);
        if (step.then) {
          step.then();
        }
      }

      const mouseX = x + deltaX * i,
        mouseY = y + deltaY * i;

      // Move mouse there also
      mouse.style.left = mouseX + 'px';
      mouse.style.top = mouseY + 'px';

      const mouseBounds = mouse.getBoundingClientRect(),
        clientX = mouseBounds.left,
        clientY = mouseBounds.top,
        eventTarget = document.elementFromPoint(clientX, clientY);

      if (eventTarget !== me.prevTarget) {
        if (me.prevTarget) {
          me.mouseOutElements.push(me.prevTarget);
          if (!DomHelper.isDescendant(me.mouseOutElements[0], eventTarget)) {
            me.mouseOutElements.forEach((element) => me.triggerEvent(element, 'mouseout'));
            me.mouseOutElements.length = 0;
          }
        }
        me.prevTarget = eventTarget;
        me.triggerEvent(eventTarget, 'mouseover');
      }

      me.triggerEvent(eventTarget, step.action, {
        clientX,
        clientY
      });
    }, 50);
  }

  // target can be a string selector, a function or blank to use last target or outerElement if first time
  getTarget(step) {
    const me = this,
      target = step.target;

    if (!target) {
      return me.prevTarget || me.outerElement;
    }

    if (typeof target === 'function') {
      return target(step);
    }

    return document.querySelector(target);
  }

  // action can be a function, a string or extracted from a property by scanning for unknown names
  normalizeStep(step) {
    if (step.action) {
      if (typeof step.action === 'function') {
        return step.action(step);
      }
      return step;
    }

    if (typeof step === 'function') {
      step();
      return step;
    }

    // try to find action among properties
    for (let prop in step) {
      if (step.hasOwnProperty(prop) && !knownProps.includes(prop)) {
        step.action = prop.toLowerCase();
        step.to = step[prop];
      }
    }

    if (!step.target && (typeof step.to === 'string' || typeof step.to === 'function')) step.target = step.to;

    return step;
  }

  get isScrolling() {
    const me = this,
      box = me.outerElement.getBoundingClientRect(),
      scrolled = me.lastTop && box.top !== me.lastTop;

    me.lastTop = box.top;

    return scrolled;
  }

  get isInView() {
    const box = this.outerElement.getBoundingClientRect();
    return box.top < window.innerHeight && box.bottom > 0;
  }

  get shouldPause() {
    return !this.isInView || this.isScrolling || document.hidden || !document.hasFocus();
  }

  // process the next step
  nextStep() {
    const me = this;

    // Only perform step if in view and not scrolling
    if (me.shouldPause) {
      return;
    }

    if (me.currentStep === me.steps.length) {
      if (me.repeat) {
        me.currentStep = 0;
      } else {
        return me.abort(true);
      }
    }

    // First step, signal to let demo initialize stuff
    if (me.currentStep === 0) {
      me.trigger('initialize');
    }

    const mouse = me.mouse,
      step = me.normalizeStep(me.steps[me.currentStep++]),
      target = me.getTarget(step),
      action = step.action;

    if (target && action) {
      mouse.className = 'simulated-mouse';

      if (action === 'mousemove') {
        me.handleMouseMove(step, target);
      } else {
        // First move mouse into position
        if (target !== me.prevTarget) {
          const rect = Rectangle.from(target, me.outerElement);
          mouse.style.left = rect.x + rect.width / 2 + 'px';
          mouse.style.top = rect.y + rect.height / 2 + 'px';
        }

        if (action === 'mousedown') {
          me.mouseDown = true;
        }

        if (action === 'mouseup') {
          me.mouseDown = false;
        }

        // Then trigger action
        me.timeoutId = me.setTimeout(
          () => {
            me.prevTarget = target;

            // Animate click etc.
            mouse.classList.add(action);

            if (action === 'type') {
              const field = IdHelper.fromElement(target),
                parts = step.text.split('|');

              field.value = parts[parts.length === 1 || field.value != parts[0] ? 0 : 1];
            } else {
              me.triggerEvent(target, action);
            }
          },
          action === 'type' ? 100 : 550
        );
      }
    }
  }
}
DemoBot._$name = 'DemoBot';

/**
 * @module Common/helper/util/Fullscreen
 */

/**
 * Encapsulates the functionality related to switching cross-browser to full screen view and back.
 */
class Fullscreen {
  static init() {
    const fnNames = ['fullscreenEnabled', 'requestFullscreen', 'exitFullscreen', 'fullscreenElement'],
      // turns fnNames into function calls to prefixed functions, fullscreenEnabled -> document.mozFullscreenEnabled
      prefixFn = (prefix) =>
        fnNames.map((fn) => {
          let result = prefix + StringHelper.capitalizeFirstLetter(fn);

          // fullscreenEnabled in Firefox is called fullScreenEnabled
          if (prefix === 'moz') {
            result = result.replace('screen', 'Screen');

            // #6555 - Crash when clicking full screen button twice
            // firefox doesn't support exitFullScreen method
            if ('mozCancelFullScreen' in document && fn === 'exitFullscreen') {
              result = 'mozCancelFullScreen';
            }
          }

          return result;
        });

    this.functions =
      ('fullscreenEnabled' in document && fnNames) ||
      ('webkitFullscreenEnabled' in document && prefixFn('webkit')) ||
      ('mozFullScreenEnabled' in document && prefixFn('moz')) ||
      ('msFullscreenEnabled' in document && prefixFn('ms')) ||
      [];

    const eventNames = ['fullscreenchange', 'fullscreenerror'],
      msEventNames = ['MSFullscreenChange', 'MSFullscreenError'],
      prefixEvt = (prefix) => eventNames.map((eventName) => prefix + StringHelper.capitalizeFirstLetter(eventName));

    this.events =
      ('fullscreenEnabled' in document && eventNames) ||
      ('webkitFullscreenEnabled' in document && prefixEvt('webkit')) ||
      ('mozFullscreenEnabled' in document && prefixEvt('moz')) ||
      ('msFullscreenEnabled' in document && msEventNames) ||
      [];
  }

  /**
   * True if the fullscreen mode is supported and enabled, false otherwise
   * @property {Boolean}
   */
  static get enabled() {
    return document[this.functions[0]];
  }

  /**
   * Request entering the fullscreen mode.
   * @param {HTMLElement} element Element to be displayed fullscreen
   */
  static request(element) {
    return element[this.functions[1]](element);
  }

  /**
   * Exit the previously entered fullscreen mode.
   */
  static exit() {
    return document[this.functions[2]]();
  }

  /**
   * True if fullscreen mode is currently active, false otherwise
   * @return {Boolean}
   */
  static get isFullscreen() {
    return !!document[this.functions[3]];
  }

  /**
   * Installs the passed listener to fullscreenchange event
   * @param {Function} fn The listener to install
   */
  static onFullscreenChange(fn) {
    document.addEventListener(this.events[0], fn);
  }

  /**
   * Uninstalls the passed listener from fullscreenchange event
   * @param {Function} fn
   */
  static unFullscreenChange(fn) {
    document.removeEventListener(this.events[0], fn);
  }
}

Fullscreen.init();
Fullscreen._$name = 'Fullscreen';

/**
 * @module Common/mixin/Override
 */

const excludedPropNames = {
  constructor: 1,
  prototype: 1,
  name: 1,
  length: 1,
  arguments: 1,
  caller: 1,
  callee: 1,
  __proto__: 1
};

/**
 * Simplifies overriding class methods by allowing methods from another class to be used as overrides.
 * Overrides are defined as own classes. They must at a minimum contain a static getter named targetClass, which
 * should return the class to override. Apply the override by calling {@link #function-apply-static apply()}.
 *
 * @example
 * class TemplateColumnOverride {
 *   static get target() {
 *     return {
 *             class: TemplateColumn,
 *             product: 'grid',
 *             minVersion: '1.0',
 *             maxVersion: '1.5'
 *     }
 *   }
 *
 *   renderer(renderData) {
 *       // call overridden function (optional)
 *       const value = this._overridden.renderer.call(this, renderData);
 *
 *       return 'HELLO' + value;
 *   }
 * }
 * Override.apply(TemplateColumnOverride);
 */
class Override {
  /**
   * Apply override. We strongly suggest that you at least specify a maxVersion for your overrides.
   * ```
   * class OriginalOverride {
   *     static get target() {
   *         return {
   *             class: Original,
   *             product: 'grid',
   *             minVersion: '1.0',
   *             maxVersion: '1.5'
   *         }
   *     }
   * }
   * ```
   * @param override An override class definition
   */
  static apply(override) {
    if (!override.target) throw new Error('Override must specify what it overrides, using static getter target');
    if (!override.target.class) throw new Error('Override must specify which class it overrides, using target.class');

    if (!this.shouldApplyOverride(override)) return false;

    const staticKeys = Object.getOwnPropertyNames(override),
      instanceKeys = Object.getOwnPropertyNames(override.prototype);

    staticKeys.splice(staticKeys.indexOf('target'), 1);

    this.internalOverrideAll(override.target.class, staticKeys, override);
    this.internalOverrideAll(override.target.class.prototype, instanceKeys, override.prototype);

    return true;
  }

  static internalOverrideAll(targetClass, properties, overrideDefinition) {
    Reflect.ownKeys(overrideDefinition).forEach((key) => {
      if (properties.includes(key) && !excludedPropNames[key]) {
        const desc = Object.getOwnPropertyDescriptor(overrideDefinition, key);
        let currentTargetClass = targetClass;

        let targetProperty = null;

        // Walk up the prototype chain to find fn, needed for mixin overrides applied to class that has them
        // mixed in
        while (!targetProperty && currentTargetClass) {
          targetProperty = Object.getOwnPropertyDescriptor(currentTargetClass, key);
          if (!targetProperty) {
            currentTargetClass = Object.getPrototypeOf(currentTargetClass);
          }
        }

        if (targetProperty) {
          this.internalOverride(currentTargetClass, key, desc, targetProperty);
        }
      }
    });
  }

  static internalOverride(target, key, desc, targetDesc) {
    const overrides = (target._overridden = target._overridden || {});

    overrides[key] = target[key];

    if (targetDesc.get) {
      Object.defineProperty(target, key, {
        enumerable: false,
        configurable: true,
        get: desc.get
      });
    } else {
      target[key] = desc.value;
    }
  }

  /**
   * Checks versions if an override should be applied. Specify version in your overrides target config
   * @param override
   * @returns {Boolean}
   * @example
   * class OriginalOverride {
   *     static get target() {
   *         return {
   *             class: Original,
   *             product: 'grid',
   *             minVersion: '1.0',
   *             maxVersion: '1.5'
   *         }
   *     }
   * }
   * @private
   */
  static shouldApplyOverride(override) {
    const config = override.target;
    // not using versioning, allow override
    if (!config.maxVersion && !config.minVersion) return true;

    // must specify product to be able to lookup versions
    if (!config.product) throw new Error('Override must specify product when using versioning');

    // override is for older version, disallow
    if (config.maxVersion && VersionHelper[config.product].isNewerThan(config.maxVersion)) {
      return false;
    }

    // override is for newer version, disallow
    if (config.minVersion && VersionHelper[config.product].isOlderThan(config.minVersion)) {
      return false;
    }

    // override is for current version, allow
    return true;
  }
}
Override._$name = 'Override';

/**
 * Boolean combo, a combo box with two options corresponding to true or false
 *
 * @classType booleancombo
 * @extends Common/widget/Combo
 */
class BooleanCombo extends Localizable(Combo) {
  static get type() {
    return 'booleancombo';
  }

  //region Config
  static get defaultConfig() {
    return {
      /**
       * Positive option value
       *
       * @config {*}
       */
      positiveValue: true,
      /**
       * Positive option display value
       *
       * @config {String}
       */
      positiveText: null,
      /**
       * Negative option value
       *
       * @config {*}
       */
      negativeValue: false,
      /**
       * False option display value
       *
       * @config {String}
       */
      negativeText: null,
      /**
       * Default value
       *
       * @config {*}
       */
      value: false
    };
  }
  //endregion

  get store() {
    if (!this._store) {
      this.store = new Store({
        data: [
          {
            id: this.positiveValue,
            text: this.positiveText || this.L('Yes')
          },
          {
            id: this.negativeValue,
            text: this.negativeText || this.L('No')
          }
        ]
      });
    }

    return this._store;
  }

  set store(store) {
    super.store = store;
  }
}

BooleanCombo._$name = 'BooleanCombo';
BryntumWidgetAdapterRegister.register(BooleanCombo.type, BooleanCombo);

/**
 * @module Common/widget/FileField
 */

/**
 * Filefield widget. Wraps native &lt;input type="file"&gt;.
 *
 * There is a nicer styled wrapper for this field, see {@link Common/widget/FilePicker}
 *
 * @extends Common/widget/Field
 * @example
 *
 * let fileField = new FileField({
 *   multiple : true,
 *   accept   : "image/*"
 * });
 *
 * @classType filefield
 * @externalexample widget/FileField.js
 */
class FileField extends Field {
  static get defaultConfig() {
    return {
      /**
       * Set to true to allow picking multiple files
       * @config {Boolean}
       * @default
       */
      multiple: false,

      /**
       * Comma-separated list of file extensions or MIME type to to accept. E.g.
       * ".jpg,.png,.doc" or "image/*". Null by default, allowing all files.
       * @config {String}
       */
      accept: null
    };
  }

  inputTemplate() {
    const me = this;

    // Not using reference="input" here intentionally.
    // In IE11/Edge when you pick file first time, field.value reports empty string while field.files.length is
    // non zero. Trying to fix this and embed file field to common field behavior is very tricky because cannot
    // be covered with siesta tests (it looks like).
    // Also we don't need much from this field - only `change` event.
    return TemplateHelper.tpl`
            <input
             type="file"
             id="${me.id}_input"
             class="${me.inputCls || ''}"
             ${me.multiple ? 'multiple' : ''}
             accept="${me.accept || ''}"
            />
        `;
  }

  construct(config) {
    const me = this;

    super.construct(config);

    me.input = me.element.querySelector('input');

    EventHelper.on({
      element: me.input,
      change: me.onFileInputChange,
      thisObj: me
    });
  }

  get oldValue() {
    return this._oldValue;
  }

  set oldValue(value) {
    this._oldValue = value;
  }

  /**
   * Returns list of selected files
   * @returns {FileList}
   * @readonly
   */
  get files() {
    return this.input.files;
  }

  /**
   * Opens browser file picker
   * @internal
   */
  pickFile() {
    this.input.click();
  }

  /**
   * Clears field value
   */
  clear() {
    this.input.value = null;
  }

  onFileInputChange() {
    const me = this,
      value = me.input.value,
      oldValue = me.oldValue;

    this.trigger('change', { value, oldValue, userAction: true, valid: true });

    me.oldValue = value;
  }
}

FileField._$name = 'FileField';
BryntumWidgetAdapterRegister.register('filefield', FileField);

/**
 * @module Common/widget/FilePicker
 */

/**
 * File input field wrapped into {@link Common/widget/Button button}. Clicking button opens browser file picker window.
 * When files are chosen, badge appears showing amount of files. Hovering the button shows tip with file names.
 *
 * By default only single file allowed.
 *
 * @extends Common/widget/Container
 * @example
 *
 * let fileField = new FilePicker({
 *   fileFieldConfig : {
 *      multiple : true,
 *      accept   : "image/*"
 *   },
 *   buttonConfig : {
 *       text : 'Pick file...'
 *   }
 * });
 *
 * @classType filepicker
 * @externalexample widget/FilePicker.js
 */
class FilePicker extends Container {
  static get defaultConfig() {
    return {
      /**
       * Fires after user closes file picker dialog.
       * @event change
       * @param {FileList} files List of picked files
       */

      /**
       * Fires when field is cleared with {@link #function-clear} method
       * @event clear
       */

      /**
       * Wrapper button config object. See {@link Common/widget/Button} for list of available configs.
       * @config {Object}
       */
      buttonConfig: null,

      /**
       * Underlying field config object. See {@link Common/widget/FileField} for list of available configs.
       * @config {Object}
       */
      fileFieldConfig: null
    };
  }

  construct(config = {}) {
    const me = this;

    config.items = [
      Object.assign(
        {
          type: 'button',
          ref: 'fileButton',
          text: 'File'
        },
        config.buttonConfig
      ),
      Object.assign(
        {
          type: 'filefield',
          ref: 'fileField',
          style: 'display: none'
        },
        config.fileFieldConfig
      )
    ].concat(config.items || []);

    super.construct(config);

    me.button.on({
      click: me.onButtonClick,
      thisObj: me
    });

    me.fileField.on({
      change: me.onFileFieldChange,
      thisObj: me
    });

    me._thisIsAUsedExpression(me.fileTip);
  }

  get button() {
    return this.widgetMap.fileButton;
  }

  get fileField() {
    return this.widgetMap.fileField;
  }

  /**
   * List of selected files
   * @returns {FileList}
   * @readonly
   */
  get files() {
    return this.fileField.files;
  }

  get fileTip() {
    const me = this;

    return (
      me._fileTip ||
      (me._fileTip = new Tooltip({
        cls: 'b-file-tip',
        forElement: me.button.element,
        showOnHover: true,
        align: 'b-t',
        scrollAction: 'realign',
        listeners: {
          beforeshow() {
            const tip = this,
              files = me.files;

            if (files && files.length) {
              tip.html = `${Array.from(files)
                .map((file) => file.name)
                .join('<br>')}`;
              return true;
            }

            // Veto show
            return false;
          }
        }
      }))
    );
  }

  /**
   * Clears field
   */
  clear() {
    const me = this;

    me.fileField.clear();
    me.button.badge = '';

    me.trigger('clear');
  }

  onButtonClick({ event }) {
    const me = this;

    // forward click to the file input to open browser file picker
    // me.fileField.input.click();
    me.fileField.pickFile();

    event.preventDefault();
  }

  onFileFieldChange() {
    const me = this;

    me.button.badge = me.files.length || '';

    me.trigger('change', { files: me.files });
  }
}

FilePicker._$name = 'FilePicker';
BryntumWidgetAdapterRegister.register('filepicker', FilePicker);

/**
 * @module Common/widget/FlagField
 */

/**
 * Flag field is a checkbox which is driven by its boolean value and vice-versa.
 * When value is `true` then checkbox is checked, when it's `false` then checkbox
 * is unchecked.
 */
class FlagField extends Checkbox {
  static get type() {
    return 'flagfield';
  }

  static get defaultConfig() {
    return {
      value: ''
    };
  }

  get value() {
    return this.checked;
  }

  set value(v) {
    v = Boolean(v);
    super.value = v;

    if (!this.inputting) {
      this.checked = v;
    }
  }
}

FlagField._$name = 'FlagField';
BryntumWidgetAdapterRegister.register(FlagField.type, FlagField);

/**
 * @module Common/widget/DisplayField
 */

/**
 * DisplayField widget used to show a read only value
 *
 * @extends Common/widget/Field
 *
 * @example
 * let displayField = new DisplayField({
 *   label: 'name',
 *   value : 'John Doe'
 * });
 *
 * @classType DisplayField
 * @externalexample widget/DisplayField.js
 */
class DisplayField extends TextField {
  static get defaultConfig() {
    return {
      readOnly: true,
      editable: false,
      cls: 'b-display-field'
    };
  }

  get focusElement() {
    // we're not focusable.
  }

  set readOnly(value) {
    // empty, to not allow changing readOnly status
  }

  get readOnly() {
    return true;
  }
}

DisplayField._$name = 'DisplayField';
BryntumWidgetAdapterRegister.register('display', DisplayField);

/**
 * @module Common/widget/DurationField
 */

/**
 * A specialized field allowing a user to also specify duration unit when editing the duration value.
 *
 * @extends Common/widget/TextField
 *
 * @classType durationfield
 */
class DurationField extends TextField {
  static get defaultConfig() {
    return {
      /**
       * The `value` config may be set in Object form specifying two properties,
       * `magnitude`, a Number, and `unit`, a String.
       *
       * If a String is passed, it is parsed in accordance with current locale rules.
       * The string is taken to be the numeric magnitude, followed by whitespace, then an abbreviation, or name of the unit.
       * @config {Object|String}
       */
      value: null,

      step: 1,

      /**
       * The duration unit to use with the current magnitude value.
       * @config {String}
       */
      unit: null,

      /**
       * When set to `true` the field will use short names of unit durations
       * (as returned by {@link Common.helper.DateHelper#function-getShortNameOfUnit-static}) when creating the
       * input field's display value.
       * @config {Boolean}
       */
      useAbbreviation: false,

      /**
       * Set to `true` to allow negative duration
       * @config {Boolean}
       */
      allowNegative: false,

      triggers: {
        spin: {
          type: 'spintrigger'
        }
      }
    };
  }

  get inputValue() {
    // Do not use the _value property. If called during configuration, this
    // will import the configured value from the config object.
    const value = this.value;

    return value == null ? '' : this.valueToVisible(value.magnitude, value.unit);
  }

  set unit(unit) {
    this.value = {
      magnitude: super.value,
      unit
    };
  }

  get unit() {
    return this._unit;
  }

  valueToVisible(magnitude, unit) {
    if (!isNaN(magnitude)) {
      const valueInt = parseInt(magnitude, 10);

      // could happen if magnitude is null
      if (!isNaN(valueInt)) {
        const valueFixed = ObjectHelper.toFixed(magnitude, this.decimalPrecision);

        return (
          String(valueInt == valueFixed ? valueInt : valueFixed) +
          ' ' +
          DateHelper[this.useAbbreviation ? 'getShortNameOfUnit' : 'getLocalizedNameOfUnit'](
            unit || this.unit,
            magnitude !== 1
          )
        );
      }
    }

    return '';
  }

  parseDuration(value) {
    if (value == null) {
      return null;
    }

    const duration = DateHelper.parseDuration(value, this.allowDecimals, this.unit);

    if (!duration) {
      return null;
    }

    duration.unit = duration.unit || this.unit;

    return duration;
  }

  get isValid() {
    const me = this;
    return (
      (me.value == null && me.clearable && !me.required) ||
      (me.value != null && (me.allowNegative || me.value.magnitude >= 0))
    );
  }

  internalOnChange(event) {
    const me = this,
      value = me.value,
      oldVal = me._lastValue;

    if (me.hasChanged(oldVal, value)) {
      me._lastValue = value;
      me.trigger('change', { value, event, userAction: true, valid: me.isValid });
    }
  }

  onFocusOut(e) {
    this.syncInputFieldValue();

    return super.onFocusOut(e);
  }

  /**
   * The `value` property may be set in Object form specifying two properties,
   * `magnitude`, a Number, and `unit`, a String.
   *
   * If a Number is passed, the field's current unit is used and just the magnitude is changed.
   *
   * If a String is passed, it is parsed in accordance with current locale rules.
   * The string is taken to be the numeric magnitude, followed by whitespace, then an abbreviation, or name of the unit.
   *
   * Upon read, the value is always returned in object form containing `magnitude` and `unit`.
   * @property {String|Number|Object}
   */
  set value(value) {
    const me = this;

    // A number means maintain the unit type
    if (typeof value === 'number') {
      value = {
        magnitude: value,
        unit: me._unit
      };
    }
    // Not an object, parse as a string
    else if (typeof value !== 'object') {
      value = me.parseDuration(value);
    }

    if (me.value !== value) {
      // Only change the value if the input is valid
      if (value) {
        me._unit = value.unit;
        super.value = value;
      } else {
        me._unit = me.clearable ? null : 0;
        super.value = me.clearable ? null : 0;
      }
    }
  }

  get value() {
    return super.value;
  }

  hasChanged(oldValue, newValue) {
    return (
      (newValue && !oldValue) ||
      (!newValue && oldValue) ||
      (newValue && oldValue && (newValue.magnitude != oldValue.magnitude || newValue.unit != oldValue.unit))
    );
  }

  /**
   * The `milliseconds` property is a read only property which returns the
   * number of milliseconds in this field's value
   * @property {Number}
   */
  get milliseconds() {
    const v = this.value;

    return DateHelper.asMilliseconds(v.magnitude, v.unit);
  }

  onInternalKeyDown(keyEvent) {
    if (keyEvent.key === 'ArrowUp') {
      this.doSpinUp();
    } else if (keyEvent.key === 'ArrowDown') {
      this.doSpinDown();
    }
  }

  doSpinUp() {
    const me = this,
      value = me.value;

    me._isUserAction = true;
    me.value = {
      unit: value.unit,
      // null magnitude will result NaN
      magnitude: (value.magnitude || 0) + me.step
    };
    me._isUserAction = false;
  }

  doSpinDown() {
    const me = this,
      value = me.value;

    if (me.allowNegative || value.magnitude > 0) {
      me._isUserAction = true;
      me.value = {
        unit: value.unit,
        // null magnitude will result NaN
        magnitude: (value.magnitude || 0) - me.step
      };
      me._isUserAction = false;
    }
  }
}

DurationField._$name = 'DurationField';
BryntumWidgetAdapterRegister.register('durationfield', DurationField);
BryntumWidgetAdapterRegister.register('duration', DurationField);

/**
 * @module Grid/column/Column
 */

/**
 * Base class for other column types, used if no type is specified on a column.
 *
 * ```
 * const grid = new Grid({
 *   columns : [
 *      { field : 'name', text : 'Name' }, // Will use Column
 *      { type : 'number', field : 'age', text : 'Age' } // Will use NumberColumn
 *   ]
 * });
 * ```
 *
 * @extends Common/data/Model
 * @classType column
 * @mixes Common/mixin/Events
 * @mixes Common/localization/Localizable
 */
class Column extends Events(Localizable(Model)) {
  //region Config

  static get fields() {
    return [
      //region Common

      /**
       * Get/set header text
       * @member {String} text
       */

      /**
       * Text to display in the header
       * @config {String} text
       * @category Common
       */
      'text',

      /**
       * The {@link Common.data.Model Model} field name to read data from
       * @config {String} field
       * @category Common
       */
      'field',

      /**
       * Renderer function, used to format and style the content displayed in the cell. Return the cell text you want to display.
       * Can also affect other aspects of the cell, such as styling.
       * @param {HTMLElement} cellElement Cell element, for adding CSS classes, styling etc
       * @param {*} value Value to be displayed in the cell
       * @param {Common.data.Model} record Record for the row
       * @param {Grid.column.Column} column This column
       * @param {Grid.view.Grid} grid This grid
       * @param {Grid.row.Row} row Row object
       * @param {Object} size Set `size.height` to specify the desired row height for the current row. Largest specified height will be used, including the configured {@link Grid/view/Grid#config-rowHeight}
       * @config {Function} renderer
       * @category Common
       */
      'renderer',

      /**
       * Column width. If value is Number then width is in pixels
       * @config {Number|String} width
       * @category Common
       */
      'width',

      /**
       * Gets or sets the column flex weight
       * @member {String} flex
       */

      /**
       * Column width as a flex weight. All columns with flex specified divide the available space (after
       * subtracting fixed widths) between them according to the flex value. Columns that have flex 2 will be
       * twice as wide as those with flex 1 (and so on)
       * @config {Number} flex
       * @category Common
       */
      'flex',

      //endregion

      //region Interaction

      /**
       * Specifies if this column should be editable, and define which editor to use for editing cells in the
       * column (if {@link Grid/feature/CellEdit CellEdit} feature is enabled). Editor refers to {@link #config-field} for a data source. If
       * record has method set + capitalized field, method will be called, e.g. if record has method named
       * `setFoobar` and this config is `foobar`, then instead of `record.foobar = value`,
       * `record.setFoobar(value)` will be called.
       * @config {String|Object|Boolean} editor
       * @category Interaction
       */
      { name: 'editor', defaultValue: {} },

      /**
       * Allow sorting of data in the column. You can pass true/false to enable/disable sorting, or provide a
       * custom sorting function, or a config object for a {@link Common.util.CollectionSorter}
       *
       * ```javascript
       * const grid = new Grid({
       *     columns : [
       *          {
       *              // Disable sorting for this column
       *              sortable : false
       *          },
       *          {
       *              // Custom sorting for this column
       *              sortable : function(user1, user2) {
       *                  return user1.name < user2.name ? -1 : 1;
       *              }
       *          },
       *          {
       *              // A config object for a Common.util.CollectionSorter
       *              sortable : {
       *                  property         : 'someField',
       *                  direction        : 'DESC',
       *                  useLocaleCompare : 'sv-SE'
       *              }
       *          }
       *     ]
       * });
       * ```
       *
       * @config {Boolean/Function/Object} sortable
       * @default true
       * @category Interaction
       */
      { name: 'sortable', defaultValue: true },

      /**
       * Allow searching in the column (respected by QuickFind and Search features)
       * @config {Boolean} searchable
       * @default true
       * @category Interaction
       */
      { name: 'searchable', defaultValue: true },

      /**
       * Allow filtering data in the column (if Filter or FilterBar feature is enabled). Also allows passing a
       * custom filtering function that will be called for each record with a single argument of format
       * { value, record, [operator] }. Returning `true` from the function includes the record in the filtered set.
       *
       * ```
       * const grid = new Grid({
       *     columns : [
       *          {
       *              field : 'name',
       *              // Disable filtering for this column
       *              filterable : false
       *          },
       *          {
       *              field : 'age',
       *              // Custom filtering for this column
       *              filterable: ({ value, record }) => Math.abs(record.age - value) < 10
       *          }
       *     ]
       * });
       * ```
       *
       * @config {Boolean/Function} filterable
       * @default true
       * @category Interaction
       */
      { name: 'filterable', defaultValue: true },

      /**
       * Allow column visibility to be toggled through UI
       * @config {Boolean} hideable
       * @default true
       * @category Interaction
       */
      { name: 'hideable', defaultValue: true },

      /**
       * Set to false to prevent this column header from being dragged
       * @config {Boolean} draggable
       * @category Interaction
       */
      { name: 'draggable', defaultValue: true },

      /**
       * Set to false to prevent grouping by this column
       * @config {Boolean} groupable
       * @category Interaction
       */
      { name: 'groupable', defaultValue: true },

      /**
       * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.
       * @config {Boolean} resizable
       * @default true
       * @category Interaction
       */
      { name: 'resizable', defaultValue: true },

      //endregion

      //region Rendering

      /**
       * Renderer function for group headers (when using Group feature).
       * @param {HTMLElement} cellElement Cell element, for adding CSS classes, styling etc.
       * @param {*} groupRowFor Current group value
       * @param {Common.data.Model} record Record for the row
       * @param {Grid.column.Column} groupColumn Column that the grid is grouped by
       * @config {Function} groupRenderer
       * @returns {String} The header grouping text
       * @category Rendering
       */
      'groupRenderer',

      /**
       * Renderer function for the column header.
       * @param {Object} renderData
       * @param {Grid.column.Column} renderData.column This column
       * @param {HTMLElement} renderData.headerElement The header element
       * @config {Function} headerRenderer
       * @category Rendering
       */
      'headerRenderer',

      /**
       * Renderer function for cell tooltips header (used with CellTooltip feature). Specify false to prevent
       * tooltip for that column.
       * @param {HTMLElement} cellElement Cell element
       * @param {Common.data.Model} record Record for cell row
       * @param {Grid.column.Column} column Cell column
       * @param {CellTooltip} cellTooltip Feature instance, used to set tooltip content async
       * @param {MouseEvent} event The event that triggered the tooltip
       * @config {Function} tooltipRenderer
       * @category Rendering
       */
      'tooltipRenderer',

      /**
       * CSS class added to each cell in this column
       * @config {String} cellCls
       * @category Rendering
       */
      'cellCls',

      /**
       * CSS class added to the header of this column
       * @config {String} cls
       * @category Rendering
       */
      'cls',

      /**
       * Get/set header icon class
       * @member {String} icon
       */

      /**
       * Icon to display in header. Specifying an icon will render a `<i>` element with the icon as value for the
       * class attribute
       * @config {String} icon
       * @category Rendering
       */
      'icon',

      //endregion

      //region Layout

      /**
       * Text align (left, center, right)
       * @config {String} align
       * @category Layout
       */
      'align',

      /**
       * Column minimal width. If value is Number then minimal width is in pixels
       * @config {Number|String} minWidth
       * @default 60
       * @category Layout
       */
      { name: 'minWidth', defaultValue: 60 },

      /**
       * Get/set columns hidden state. Specify `true` to hide the column, `false` to show it.
       * @member {Boolean} hidden
       */

      /**
       * Hide the column from start
       * @config {Boolean} hidden
       * @category Layout
       */
      { name: 'hidden', defaultValue: false },

      /**
       * Convenient way of putting a column in the "locked" region. Same effect as specifying region: 'locked'.
       * If you have defined your own regions (using {@link Grid.view.Grid#config-subGridConfigs}) you should use
       * {@link #config-region} instead of this one.
       * @config {Boolean} locked
       * @default false
       * @category Layout
       */
      { name: 'locked' },

      /**
       * Region (part of the grid, it can be configured with multiple) where to display the column. Defaults to
       * {@link Grid.view.Grid#config-defaultRegion}.
       * @config {String} region
       * @category Layout
       */
      { name: 'region' },

      //endregion

      // region Menu

      /**
       * Show column picker for the column
       * @config {Boolean} showColumnPicker
       * @default true
       * @category Menu
       */
      { name: 'showColumnPicker', defaultValue: true },

      /**
       * false to prevent showing a context menu on the column header element
       * @config {Boolean} enableHeaderContextMenu
       * @default true
       * @category Menu
       */
      { name: 'enableHeaderContextMenu', defaultValue: true },

      /**
       * false to prevent showing a context menu on the cell elements in this column
       * @config {Boolean} enableCellContextMenu
       * @default true
       * @category Menu
       */
      { name: 'enableCellContextMenu', defaultValue: true },

      /**
       * Extra items to show in the header context menu for this column
       * @config {Object[]} headerMenuItems
       * @category Menu
       */
      'headerMenuItems',

      /**
       * Extra items to show in the cell context menu for this column
       * @config {Object[]} cellMenuItems
       * @category Menu
       */
      'cellMenuItems',

      //endregion

      //region Summary

      /**
       * Summary type (when using Summary feature). Valid types are:
       * <dl class="wide">
       * <dt>sum <dd>Sum of all values in the column
       * <dt>add <dd>Alias for sum
       * <dt>count <dd>Number of rows
       * <dt>countNotEmpty <dd>Number of rows containing a value
       * <dt>average <dd>Average of all values in the column
       * <dt>function <dd>A custom function, used with store.reduce. Should take arguments (sum, record)
       * </dl>
       * @config {String} sum
       * @category Summary
       */
      'sum',

      /**
       * Summary configs, use if you need multiple summaries per column. Replaces {@link #config-sum} and
       * {@link #config-summaryRenderer} configs. Accepts an array of objects with the following fields:
       * * sum - Matching {@link #config-sum}
       * * renderer - Matching {@link #config-summaryRenderer}
       * * seed - Initial value when using a function as `sum`
       * @config {Object[]} summaries
       * @category Summary
       */
      'summaries',

      /**
       * Renderer function for summary (when using Summary feature). The renderer is called with the calculated
       * summary as only argument.
       * @config {Function} summaryRenderer
       * @category Summary
       */
      'summaryRenderer',

      //region Misc

      /**
       * Column settings at different responsive levels, see responsive demo under examples/
       * @config {Object} responsiveLevels
       * @category Misc
       */
      'responsiveLevels',

      /**
       * Tags, may be used by ColumnPicker feature for grouping columns by tag in the menu
       * @config {String[]} tags
       * @category Misc
       */
      'tags',

      /**
       * Column config to apply to normal config if viewed on a touch device
       * @config {Object} touchConfig
       * @category Misc
       */
      'touchConfig',

      /**
       * When using the tree feature, exactly one column should specify { tree: true }
       * @config {Boolean} tree
       * @category Misc
       */
      'tree',

      /**
       * Determines which type of filtering to use for the column. Usually determined by the column type used,
       * but may be overridden by setting this field.
       * @config {String} filterType
       * @category Misc
       */
      'filterType',

      /**
       * By default, any rendered column text content is HTML-encoded. Set this flag to `false` disable this and allow rendering html elements
       * @config {Boolean} htmlEncode
       * @default true
       * @category Misc
       */
      { name: 'htmlEncode', defaultValue: true },

      /**
       * Set to `true`to automatically call DomHelper.sync for html returned from a renderer. Should in most cases
       * be more performant than replacing entire innerHTML of cell and also allows CSS transitions to work. Has
       * no effect unless `htmlEncode` is enabled. Returned html must contain a single root element (that can have
       * multiple children). See PercentColumn for example usage.
       * @config {Boolean} autoSyncHtml
       * @default false
       * @category Misc
       */
      { name: 'autoSyncHtml', defaultValue: false },

      'type',

      /**
       * Set to `true` to have the {@link Grid.feature.CellEdit CellEdit} feature update the record being
       * edited live upon field edit instead of when editing is finished by using `TAB` or `ENTER`
       */
      { name: 'instantUpdate', defaultValue: false },

      { name: 'repaintOnResize', defaultValue: false },

      /**
       * An optional query selector to select a sub element within the cell being
       * edited to align a cell editor's `X` position and `width` to.
       * @config {String} editTargetSelector
       */
      'editTargetSelector'

      //endregion
    ];
  }

  // prevent undefined fields from being exposed, to simplify spotting errors
  static get autoExposeFields() {
    return false;
  }

  //endregion

  //region Init

  construct(data, store) {
    const me = this;

    me.masterStore = store;

    // Store might be an array
    if (store) {
      me._grid = Array.isArray(store) ? store[0].grid : store.grid;
    }

    me.localizableProperties = data.localizableProperties || ['text'];

    if (data.localeClass) {
      me.localeClass = data.localeClass;
    }

    super.construct(data, store, null, false);

    me.processConfiguredListeners(data.listeners);

    // Default value for region is assigned by the ColumnStore in createRecord(), same for `locked`

    // Allow field : null if the column does not rely on a record field.
    // For example the CheckColumn when used by GridSelection.
    if (!('field' in me.data)) {
      me.field = '_' + (me.type || '') + ++Column.emptyCount;
    }

    // If our field is a dot separated path, we must use ObjectHelper.getPath to extract our value
    me.hasComplexMapping = me.field && me.field.includes('.');

    if (!me.width && !me.flex && !me.children) {
      // Set the width silently because we're in construction.
      me.set(
        {
          width: Column.defaultWidth,
          flex: null
        },
        null,
        true
      );
    }
  }

  /**
   * Extracts the value from the record specified by this Column's {@link #config-field} specification.
   *
   * This will work if the field is a dot-separated path to access fields in associated records, eg
   *
   * ```javascript
   *  field : 'resource.calendar.name'
   * ```
   *
   * **Note:** This is the raw field value, not the value returned by the {@link #config-renderer}.
   * @param {Common.data.Model} record The record from which to extract the field value.
   * @returns {*} The value of the referenced field if any.
   */
  getRawValue(record) {
    const me = this;

    if (me.hasComplexMapping) {
      return ObjectHelper.getPath(record, me.field);
    }
    return record[me.field] || record.get(me.field);
  }

  get nextVisibleSibling() {
    let next = this.nextSibling;
    while (next && next.hidden) {
      next = next.nextSibling;
    }
    return next;
  }

  get isLast() {
    return !this.nextVisibleSibling && (!this.parent || this.parent.isLast);
  }

  get isLastInSubGrid() {
    return (
      (!this.nextVisibleSibling || this.nextVisibleSibling.region !== this.region) &&
      (!this.parent || this.parent.isLastInSubGrid)
    );
  }

  /**
   * The header element for this Column. *Only available after the grid has been rendered*.
   *
   * **Note that column headers are rerendered upon mutation of Column values, so this
   * value is volatile and should not be cached, but should be read whenever needed.**
   * @property {HTMLElement}
   * @readonly
   */
  get element() {
    return this.grid.getHeaderElement(this);
  }

  /**
   * The text wrapping element for this Column. *Only available after the grid has been rendered*.
   *
   * This is the full-width element which *contains* the text-bearing element and any icons.
   *
   * **Note that column headers are rerendered upon mutation of Column values, so this
   * value is volatile and should not be cached, but should be read whenever needed.**
   * @property {HTMLElement}
   * @readonly
   */
  get textWrapper() {
    return DomHelper.getChild(this.element, '.b-grid-header-text');
  }

  /**
   * The text containing element for this Column. *Only available after the grid has been rendered*.
   *
   * **Note that column headers are rerendered upon mutation of Column values, so this
   * value is volatile and should not be cached, but should be read whenever needed.**
   * @property {HTMLElement}
   * @readonly
   */
  get textElement() {
    return DomHelper.down(this.element, '.b-grid-header-text-content');
  }

  /**
   * The child element into which content should be placed. This means where any
   * contained widgets such as filter input fields should be rendered. *Only available after the grid has been rendered*.
   *
   * **Note that column headers are rerendered upon mutation of Column values, so this
   * value is volatile and should not be cached, but should be read whenever needed.**
   * @property {HTMLElement}
   * @readonly
   */
  get contentElement() {
    return DomHelper.down(this.element, '.b-grid-header-children');
  }

  /**
   * The Field to use as editor for this column
   * @private
   * @readonly
   */
  get editor() {
    let editor = this.data.editor;

    if (editor && !(editor instanceof Widget)) {
      if (typeof editor === 'string') {
        editor = {
          type: editor
        };
      }
      editor = this.data.editor = WidgetHelper.createWidget(Object.assign(this.defaultEditor, editor));
    }
    return editor;
  }

  set editor(editor) {
    this.data.editor = editor;
  }

  /**
   * A config object specifying the editor to use to edit this column.
   * @private
   * @readonly
   */
  get defaultEditor() {
    return {
      type: 'textfield',
      name: this.field
    };
  }

  /**
   * Default settings for the column, applied in constructor. None by default, override in subclass.
   * @member {Object} defaults
   * @returns {Object}
   * @readonly
   */
  //get defaults() {
  //    return {};
  //}
  //endregion

  //region Properties

  static get type() {
    return 'column';
  }

  static get text() {
    return this.defaultValues.text;
  }

  get grid() {
    return this._grid || (this.parent && this.parent.grid);
  }

  get locked() {
    return this.data.region === 'locked';
  }

  set locked(locked) {
    this.region = locked ? 'locked' : 'normal';
  }

  // parent headers cannot be sorted by
  get sortable() {
    return this.isLeaf && this.data.sortable;
  }

  set sortable(sortable) {
    this.set('sortable', sortable);
  }

  // parent headers cannot be grouped by
  get groupable() {
    return this.isLeaf && this.data.groupable;
  }

  set groupable(groupable) {
    this.set('groupable', groupable);
  }

  //endregion

  //region Show/hide

  /**
   * Hides this column.
   */
  hide(silent = false) {
    const me = this,
      parent = me.parent;

    // Reject non-change
    if (!me.hidden) {
      me.hidden = true;

      if (parent && !parent.isRoot) {
        // check if all sub columns are hidden, if so hide parent
        const anyVisible = parent.children.some((child) => child.hidden !== true);
        if (!anyVisible && !parent.hidden) {
          silent = true; // hiding parent will trigger event
          parent.hide();
        }
      }

      if (me.children) {
        me.children.forEach((child) => child.hide(true));
      }

      if (!silent) {
        me.stores.forEach((store) => store.trigger('hideColumn'));
      }
    }
  }

  /**
   * Shows this column.
   */
  show(silent = false) {
    const me = this,
      parent = me.parent;

    // Reject non-change
    if (me.hidden) {
      me.hidden = false;

      if (parent && parent.hidden) {
        parent.show();
      }

      if (me.children) {
        me.children.forEach((child) => child.show(true));
      }

      // event is triggered on chained stores
      if (!silent) {
        me.stores.forEach((store) => store.trigger('showColumn'));
      }
    }
  }

  /**
   * Toggles the column visibility.
   * @param {Boolean} force Set to true (visible) or false (hidden) to force a certain state
   */
  toggle(force = null) {
    if ((this.hidden && force === undefined) || force === true) return this.show();
    if ((!this.hidden && force === undefined) || force === false) return this.hide();
  }

  //endregion

  //region Index & id

  /**
   * Generates an id for the column when none is set. Generated ids are 'col1', 'col2' and so on. If a field is
   * specified (as it should be in most cases) the field name is used instead: 'name1', 'age2' ...
   * @private
   * @returns {String}
   */
  generateId() {
    if (!Column.generatedIdIndex) Column.generatedIdIndex = 0;

    return (this.field ? this.field.replace(/\./g, '-') : 'col') + ++Column.generatedIdIndex;
  }

  /**
   * Index among all flattened columns
   * @property {Number}
   * @readOnly
   * @internal
   */
  get allIndex() {
    return this.masterStore.indexOf(this);
  }

  //endregion

  //region Width

  /**
   * Get/set columns width in px. If column uses flex, width will be undefined.
   * Setting a width on a flex column cancels out flex.
   *
   * **NOTE:** Grid might be configured to always stretch the last column, in which case the columns actual width
   * might deviate from the configured width.
   *
   * ```javascript
   * let grid = new Grid({
   *     appendTo : 'container',
   *     height   : 200,
   *     width    : 400,
   *     columns  : [{
   *         text  : 'First column',
   *         width : 100
   *     }, {
   *         text  : 'Last column',
   *         width : 100 // last column in the grid is always stretched to fill the free space
   *     }]
   * });
   *
   * grid.columns.last.element.offsetWidth; // 300 -> this points to the real element width
   * ```
   * @property {Number|String}
   */
  get width() {
    return this.data.width;
  }

  set width(width) {
    const data = { width };
    if (width) {
      data.flex = null; // remove flex when setting width to enable resizing flex columns
    }
    this.set(data);
  }

  //Returns subGrid for the column
  get subGrid() {
    return this.grid ? this.grid.getSubGridFromColumn(this) : undefined;
  }

  // Returns size in pixels for measured value
  measureSize(value) {
    return DomHelper.measureSize(value, this.subGrid ? this.subGrid.element : undefined);
  }

  // This method is used to calculate minimum row width for edge and safari
  // It calculates minimum width of the row taking column hierarchy into account
  calculateMinWidth() {
    const me = this,
      width = me.measureSize(me.width),
      minWidth = me.measureSize(me.minWidth);

    let minChildWidth = 0;

    if (me.children) {
      minChildWidth = me.children.reduce((result, column) => {
        return result + column.calculateMinWidth();
      }, 0);
    }

    return Math.max(width, minWidth, minChildWidth);
  }

  /**
   * Resizes the column to match the widest string in it. By default it also measures the column header, this
   * behaviour can be configured by setting {@link Grid.view.Grid#config-resizeToFitIncludesHeader}.
   *
   * Called internally when you double click the edge between
   * column headers, but can also be called programmatically. For performance reasons it is limited to checking 1000
   * rows surrounding the current viewport.
   */
  resizeToFitContent() {
    const me = this,
      { grid, renderer, defaultRenderer, element } = me,
      rowManager = grid.rowManager,
      store = grid.store,
      count = store.count,
      useRenderer = renderer || defaultRenderer;

    if (count <= 0) return;

    const cellElement = grid.element.querySelector(`.b-grid-cell[data-column-id=${me.id}]`),
      originalStyle = cellElement.cssText, // Renderer might overwrite
      originalClassName = cellElement.className; // Renderer might overwrite

    let maxWidth = 0,
      start,
      end,
      i,
      record,
      value;

    // Measure header unless configured not to
    if (grid.resizeToFitIncludesHeader) {
      const style = window.getComputedStyle(element);
      // Header always in view, use its element
      maxWidth =
        DomHelper.measureText(element.innerText, element, false, element.parentElement) + parseInt(style.paddingLeft); // Seems to miss the padding, have not found why

      // Remove measuring element, it messes some styling rules up if left in DOM
      element.parentElement.offScreenDiv.parentElement.remove();
    }

    // If it's a very large dataset, measure the maxWidth of the field in the 1000 rows
    // surrounding the rendered block.
    if (count > 1000) {
      start = Math.max(Math.min(rowManager.topIndex + rowManager.rowCount / 2 - 500, count - 1000), 0);
      end = start + 1000;
    } else {
      start = 0;
      end = count;
    }

    for (i = start; i < end; i++) {
      record = store.getAt(i);
      value = me.getRawValue(record);

      if (useRenderer) {
        value = useRenderer.call(me, {
          cellElement,
          rowElement: cellElement.parentNode,
          value,
          record,
          column: me,
          size: { height: record.rowHeight || 0 },
          grid,
          row: {},
          updatingSingleRow: false
        });

        // Cell renderer is allowed to direction manipulate the cell element, if so it wont return a value
        value = value == null ? cellElement.innerHTML : String(value);
      }

      if (value) {
        // Measure withing the SubGrid, allows more css rules to apply. Not measuring inside rows sine that might get to costly performance wise
        maxWidth = Math.max(
          maxWidth,
          DomHelper.measureText(value, cellElement, !(me.htmlEncode && !me.disableHtmlEncode), me.subGrid.element)
        );
      }
    }

    // Restore top cell which may be mutated by the repeated call of the renderer.
    cellElement.className = originalClassName;
    cellElement.cssText = originalStyle;

    return (me.width = maxWidth);
  }

  //endregion

  //region State

  /**
   * Get column state, used by State mixin
   * @private
   */
  getState() {
    // TODO: exclude those with value = default?
    const me = this,
      state = {
        [me.flex ? 'flex' : 'width']: me.flex ? me.flex : me.width,
        id: me.id,
        hidden: me.hidden,
        index: me.allIndex,
        region: me.region,
        filterable: me.filterable,
        text: me.text,
        locked: me.locked
      };

    if (me.children) state.children = me.children.map((child) => child.getState());

    return state;
  }

  /**
   * Apply state to column, used by State mixin
   * @private
   */
  applyState(state) {
    const me = this;

    me.beginBatch();

    if ('locked' in state) {
      me.locked = state.locked;
    }

    if ('minWidth' in state) {
      me.minWidth = state.minWidth;
    }

    if ('width' in state) {
      me.width = state.width;
    }

    if ('flex' in state) {
      me.flex = state.flex;
    }

    if ('width' in state && me.flex) {
      me.flex = undefined;
    } else if ('flex' in state && me.width) {
      me.width = undefined;
    }

    if ('text' in state) {
      me.text = state.text;
    }

    if ('region' in state) {
      me.region = state.region;
    }

    if ('renderer' in state) {
      me.renderer = state.renderer;
    }

    if ('filterable' in state) {
      me.filterable = state.filterable;
    }

    me.endBatch();

    if ('hidden' in state) {
      me.toggle(state.hidden !== true);
    }
  }

  //endregion

  //region Other

  /**
   * Clear cell contents. Base implementation which just sets innerHTML to blank string.
   * Should be overridden in subclasses to clean up for examples widgets.
   * @param {HTMLElement} cellElement
   * @internal
   */
  clearCell(cellElement) {
    cellElement.innerHTML = '';
  }

  /**
   * Override in subclasses to allow/prevent editing of certain rows.
   * @param {Common.data.Model} record
   * @internal
   */
  canEdit(record) {
    return true;
  }

  //endregion
}
// Registered in ColumnStore as we can't have this in Column due to circular dependencies
// ColumnStore.registerColumnType(Column);

Column.emptyCount = 0;
Column.defaultWidth = 100;
Column.exposeProperties();
Column._$name = 'Column';

/**
 * @module Grid/data/ColumnStore
 */

/**
 * A store specialized in handling columns. Used by the Grid to hold its columns and used as a chained store by each SubGrid
 * to hold theirs. Should not be instanced directly, instead access it through `grid.columns` or `subGrid.columns`
 *
 * ```
 * // resize first column
 * grid.columns.first.width = 200;
 *
 * // remove city column
 * grid.columns.get('city').remove();
 *
 * // add new column
 * grid.columns.add({text : 'New column'});
 *
 * // add new column to specific region (SubGrid)
 * grid.columns.add({text : 'New column', region : 'locked'});
 *
 * // add new column to 'locked' region (SubGrid)
 * grid.columns.add({text : 'New column', locked : true});
 * ```
 *
 * @extends Common/data/Store
 */
class ColumnStore extends Localizable(Store) {
  static get defaultConfig() {
    return {
      modelClass: Column,
      tree: true
    };
  }

  construct(config) {
    const me = this;

    // Consequences of ColumnStore construction can cause reading of grid.columns
    // so set the property early.
    if (config.grid) {
      config.grid._columnStore = me;
      me.id = `${config.grid.id}-columns`;
    }
    super.construct(config);

    // So that we can invalidate cached collections which take computing so that we compute them
    // only when necessary. For example when asking for the visible leaf columns, we do not want
    // to compute that each time.
    me.on({
      change: me.clearCaches,
      scope: me,
      prio: 1
    });
  }

  doDestroy() {
    const allColumns = [];

    this.traverse((column) => allColumns.push(column));

    super.doDestroy();

    // Store's destroy unjoins all records. Destroy all columns *after* that.
    allColumns.forEach((column) => column.destroy());
  }

  // Overridden because the flat collection only contains top level columns,
  // not leaves - group columns are *not* expanded.
  getById(id) {
    return super.getById(id) || this.idRegister[id];
  }

  forEach(fn, thisObj = this) {
    // Override to omit root
    if (this.tree) {
      this.rootNode.traverseWhile((n, i) => fn.call(thisObj, n, i), true);
    }
    // stores on subgrids are chained and are not trees
    else {
      super.forEach(fn, thisObj);
    }
  }

  get totalFixedWidth() {
    let result = 0;
    for (let col of this) {
      if (!col.hidden) {
        if (col.flex) {
          result += col.measureSize(Column.defaultWidth);
        } else {
          result += Math.max(col.measureSize(col.width), col.measureSize(col.minWidth));
        }
      }
    }
    return result;
  }

  /**
   * Returns the visible leaf headers which drive the rows' cell content.
   * @property {Grid.column.Column[]}
   * @readonly
   */
  get visibleColumns() {
    const me = this;

    if (!me._visibleColumns) {
      me._visibleColumns = me.leaves.filter((column) => !column.hidden);
    }

    return me._visibleColumns;
  }

  clearCaches() {
    this._visibleColumns = null;
  }

  onMasterDataChanged(event) {
    super.onMasterDataChanged(event);

    // If master store has changes we also need to clear cached columns, in case a column was hidden
    this.clearCaches();
  }

  getAdjacentVisibleLeafColumn(columnOrId, next = true, wrap = false) {
    let columns = this.visibleColumns,
      column = columnOrId instanceof Column ? columnOrId : this.getById(columnOrId),
      idx = columns.indexOf(column) + (next ? 1 : -1);

    // If we walked off either end, wrap if directed to do so,
    // otherwise, return null;
    if (!columns[idx]) {
      if (wrap) {
        idx = next ? 0 : columns.length - 1;
      } else {
        return null;
      }
    }

    return columns[idx];
  }

  /**
   * Bottom columns are the ones displayed in the bottom row of a grouped header, or all columns if not using a grouped
   * header. They are the columns that actually display any data.
   * @returns {Grid.column.Column[]}
   * @readonly
   */
  get bottomColumns() {
    return this.leaves;
  }

  /**
   * Get column by field. To be sure that you are getting exactly the intended column, use {@link Common.data.Store#function-getById Store#getById()} with the
   * columns id instead.
   * @param {String} field Field name
   * @returns {Grid.column.Column}
   */
  get(field) {
    return this.findRecord('field', field, true);
  }

  /**
   * Used internally to create a new record in the store. Creates a column of the correct type by looking up the
   * specified type among registered columns.
   * @private
   */
  createRecord(data) {
    let columnClass = this.modelClass;

    if (data.type) {
      columnClass = ColumnStore.getColumnClass(data.type);
      if (!columnClass) throw new Error(this.L('columnTypeNotFound', data));
    }

    if (data.locked) {
      data.region = 'locked';
      delete data.locked;
    }

    const column = new columnClass(data, this);

    // Doing this after construction, in case the columnClass has a default value for region (Schedulers
    // TimeAxisColumn has)
    if (!column.data.region) {
      column.data.region = this.grid ? this.grid.defaultRegion : 'normal'; // Some ColumnStore tests lacks Grid
    }

    return column;
  }

  /**
   * indexOf extended to also accept a columns field, for backward compatibility.
   * ```
   * grid.columns.indexOf('name');
   * ```
   * @param recordOrId
   * @returns {Number}
   */
  indexOf(recordOrId) {
    // TODO: build the need for field away
    let index = super.indexOf(recordOrId);
    if (index > -1) return index;
    // no record found by id, find by field since old code relies on that instead of id
    // TODO: replace such cases with columns id
    return this.records.findIndex((r) => r.field === recordOrId);
  }

  //region Column types

  /**
   * Call from custom column to register it with ColumnStore. Required to be able to specify type in column config.
   * @param columnClass The class
   * @example
   * // create and register custom column
   * class CustomColumn {
   *  static get type() {
   *      return 'custom';
   *  }
   * }
   * ColumnStore.registerColumnType(CustomColumn);
   * // now possible to specify in column config
   * let grid = new Grid({
   *   columns: [
   *     { type: 'custom', field: 'id' }
   *   ]
   * });
   */
  static registerColumnType(columnClass) {
    if (!ColumnStore.columnTypes) ColumnStore.columnTypes = {};
    ColumnStore.columnTypes[columnClass.type] = columnClass;
  }

  /**
   * Returns registered column class for specified type.
   * @param type Type name
   * @returns {Grid.column.Column}
   * @internal
   */
  static getColumnClass(type) {
    return ColumnStore.columnTypes && ColumnStore.columnTypes[type];
  }

  //endregion
}

/**
 * Custom {@link Grid.data.ColumnStore} event which triggers when a column is resized, i.e. its width has been changed
 *
 * @param {Function} handler
 * @param {Object} [thisObj]
 */
const columnResizeEvent = (handler, thisObj) => ({
  update: ({ store, record, changes }) => {
    let result = true;

    if ('width' in changes || 'minWidth' in changes || 'flex' in changes) {
      result = handler.call(thisObj, { store, record, changes });
    }

    return result;
  }
});
// Can't have this in Column due to circular dependencies
ColumnStore.registerColumnType(Column);
ColumnStore._$name = 'ColumnStore';

//TODO: Currently widgets reuse elements already in cell, but performance would improve if entire widget was reused

/**
 * @module Grid/column/WidgetColumn
 */

/**
 * A column that displays widgets in the cells
 *
 * @extends Grid/column/Column
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *         { type: 'widget', text: 'Increase age', widget: { type: 'button', icon: 'add' }, data: 'age' }
 *     ]
 * });
 *
 * @classType widget
 * @externalexample column/WidgetColumn.js
 */
class WidgetColumn extends Column {
  //region Config

  static get type() {
    return 'widget';
  }

  static get fields() {
    return [
      /**
       * An array of widget config objects
       * @config {Object[]} widgets
       * @category Common
       */
      'widgets'
    ];
  }

  static get defaults() {
    return {
      filterable: false,
      sortable: false,
      editor: false,
      searchable: false
    };
  }

  //endregion

  //region Init / Destroy

  construct(config, store) {
    this.widgetMap = {};
    this.internalCellCls = 'b-widget-cell';

    super.construct(...arguments);
  }

  doDestroy() {
    // Destroy all the widgets we created.
    for (const widget of Object.values(this.widgetMap)) {
      widget.destroy && widget.destroy();
    }
    super.doDestroy();
  }

  //endregion

  //region Render

  /**
   * Renderer that displays a widget in the cell.
   * @param {Object} event Render event
   * @private
   */
  renderer(event) {
    const me = this,
      { cellElement, column, value, record } = event,
      widgets = column.widgets;

    if (widgets) {
      cellElement.widgets = widgets.map((widgetCfg, i) => {
        let widget, widgetNextSibling;

        // If cell element already has widgets, check if we need to destroy/remove one
        if (cellElement.widgets) {
          // Current widget
          widget = cellElement.widgets[i];

          // Store next element sibling to insert widget to correct position later
          widgetNextSibling = widget.element.nextElementSibling;

          // If we are not syncing content for present widget, remove it from cell and render again later
          if (widgetCfg.recreate && widget) {
            // destroy widget and remove reference to it
            delete me.widgetMap[widget.id];
            widget.destroy();
            cellElement.widgets[i] = null;
          }
        }

        // Ensure widget is created if first time through
        if (!widget) {
          me.onBeforeWidgetCreate(widgetCfg, event);
          widget = WidgetHelper.append(
            widgetCfg,
            widgetNextSibling ? { insertBefore: widgetNextSibling } : cellElement
          )[0];
          me.widgetMap[widget.id] = widget;
          me.onAfterWidgetCreate(widget, event);
        }

        widget.cellInfo = {
          cellElement,
          value,
          record,
          column
        };

        if (me.grid) {
          widget.readOnly = me.grid.readOnly;
        }

        if (me.onBeforeWidgetSetValue(widget, event) !== false) {
          if (!widgetCfg.noValueOnRender) {
            if (widgetCfg.valueProperty) {
              widget[widgetCfg.valueProperty] = value;
            } else if (widget.defaultBindProperty) {
              widget[widget.defaultBindProperty] = value;
            } else {
              widget.text = widget.value = value;
            }
          }
        }

        return widget;
      });
    }
  }

  //endregion

  //region Other

  /**
   * Called before widget is created on rendering
   * @param {Object} widgetCfg Widget config
   * @param {Object} event Render event
   * @private
   */
  onBeforeWidgetCreate(widgetCfg, event) {}

  /**
   * Called after widget is created on rendering
   * @param {Common.widget.Widget} widget Created widget
   * @param {Object} event Render event
   * @private
   */
  onAfterWidgetCreate(widget, event) {}

  /**
   * Called before widget gets value on rendering. Pass `false` to skip value setting while rendering
   * @param {Common.widget.Widget} widget Created widget
   * @param {Object} event Render event
   * @private
   */
  onBeforeWidgetSetValue(widget, renderEvent) {}

  // Overrides base implementation to cleanup widgets, for example when a cell is reused as part of group header
  clearCell(cellElement) {
    if (cellElement.widgets) {
      cellElement.widgets.forEach((widget) => {
        // destroy widget and remove reference to it
        delete this.widgetMap[widget.id];
        widget.destroy();
      });
      cellElement.widgets = null;
    }
  }

  // Null implementation because there is no way of ascertaining whether the widgets get their width from
  // the column, or the column shrinkwraps the Widget.
  // Remember that the widget could have a width from a CSS rule which we cannot read.
  // It might have width: 100%, or a flex which would mean it is sized by us, but we cannot read that -
  // getComputedStyle would return the numeric width.
  resizeToFitContent() {}
  //endregion
}

ColumnStore.registerColumnType(WidgetColumn);
WidgetColumn.exposeProperties();
WidgetColumn._$name = 'WidgetColumn';

//TODO: Reuse checkbox instead of creating a new one

/**
 * @module Grid/column/CheckColumn
 */

/**
 * A column that displays a checkbox in the cell. The value of the backing field is toggled by the checkbox.
 *
 * @extends Grid/column/WidgetColumn
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *         { type: 'check', field: 'allow' }
 *     ]
 * });
 *
 * @classType check
 * @externalexample column/CheckColumn.js
 */
class CheckColumn extends WidgetColumn {
  //region Config

  static get type() {
    return 'check';
  }

  static get fields() {
    return ['checkCls'];
  }

  static get defaults() {
    return {
      align: 'center',

      /**
       * CSS class name to add to checkbox
       * @config {String}
       * @category Rendering
       */
      checkCls: null,

      widgets: [
        {
          type: 'checkbox',
          valueProperty: 'checked'
        }
      ]
    };
  }

  constructor(config, store) {
    super(...arguments);

    this.internalCellCls = 'b-check-cell';
  }
  //endregion

  //region Widget rendering

  onBeforeWidgetCreate(widgetCfg, event) {
    widgetCfg.cls = this.checkCls;
  }

  onAfterWidgetCreate(widget, event) {
    event.cellElement.widget = widget;
    widget.on({
      beforeChange: 'onBeforeCheckboxChange',
      change: 'onCheckboxChange',
      thisObj: this
    });
  }

  onBeforeWidgetSetValue(widget) {
    widget.record = widget.cellInfo.record;
  }

  //endregion

  //region Events

  onBeforeCheckboxChange({ source, checked }) {
    /**
     * Fired when a cell is clicked to toggle its checked status. Returning `false` will prevent status change.
     * @event beforeToggle
     * @param {Grid.column.Column} source This Column
     * @param {Common.data.Model} record The record for the row containing the cell.
     * @param {Boolean} checked The new checked status of the cell.
     */
    return this.trigger('beforeToggle', { record: source.cellInfo.record, checked });
  }

  onCheckboxChange({ source, checked }) {
    const record = source.cellInfo.record,
      field = this.field;

    if (field) {
      const setterName = `set${StringHelper.capitalizeFirstLetter(field)}`;
      if (record[setterName]) {
        record[setterName](checked);
      } else {
        record.set(field, checked);
      }
    }

    /**
     * Fired when a cell is clicked to toggle its checked status.
     * @event toggle
     * @param {Grid.column.Column} source This Column
     * @param {Common.data.Model} record The record for the row containing the cell.
     * @param {Boolean} checked The new checked status of the cell.
     */
    this.trigger('toggle', { record, checked });
  }

  //endregion
}

ColumnStore.registerColumnType(CheckColumn);
CheckColumn._$name = 'CheckColumn';

/**
 * @module Grid/column/DateColumn
 */

/**
 * A column that displays a date in the specified format (see {@link Common.helper.DateHelper#function-format-static} for formatting options),
 * with a date picker as default editor.
 *
 * @extends Grid/column/Column
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *          { type: 'date', text: 'Start date', format: 'YYYY-MM-DD', data: 'start' }
 *     ]
 * });
 *
 * @classType date
 * @externalexample column/DateColumn.js
 */
class DateColumn extends Column {
  //region Config

  static get type() {
    return 'date';
  }

  static get fields() {
    return ['format', 'pickerFormat', 'step'];
  }

  static get defaults() {
    return {
      /**
       * Date format
       * @config {String}
       * @category Common
       */
      format: 'L',

      /**
       * Date format used for date picker
       * @config {String}
       * @category Common
       */
      pickerFormat: null,

      /**
       * Time increment duration value. See {@link Common.widget.DateField#config-step} for more information
       * @config {String|Number|Object}
       * @category Common
       */
      step: 1,

      minWidth: 85,

      filterType: 'date'
    };
  }

  //endregion

  //region Init

  constructor(config, store) {
    super(...arguments);

    this.internalCellCls = 'b-date-cell';
  }

  //endregion

  //region Display

  /**
   * Renderer that displays the date with the specified format. Also adds cls 'date-cell' to the cell.
   * @private
   */
  defaultRenderer({ value }) {
    return value ? this.formatValue(value) : '';
  }

  /**
   * Group renderer that displays the date with the specified format.
   * @private
   */
  groupRenderer({ cellElement, groupRowFor }) {
    cellElement.innerHTML = this.formatValue(groupRowFor);
  }

  //endregion

  //region Formatter

  /**
   * Used by both renderer and groupRenderer to do the actual formatting of the date
   * @private
   * @param value
   * @returns {String}
   */
  formatValue(value) {
    // Ideally we should be served a date, but if not make it easier for the user by parsing
    if (typeof value === 'string') {
      value = DateHelper.parse(value, this.format);
    }
    return DateHelper.format(value, this.format);
  }

  //endregion

  //region Getters/setters

  /**
   * Get/Set format for date displayed in cell and editor (see {@link Common.helper.DateHelper#function-format-static} for formatting options)
   * @property {String}
   */
  set format(value) {
    const me = this,
      editor = me.editor;
    me.set('format', value);
    if (editor) {
      editor.format = me.format;
    }
  }

  get format() {
    return this.get('format');
  }

  get defaultEditor() {
    const me = this;

    return {
      name: me.field,
      type: 'date',
      calendarContainerCls: 'b-grid-cell-editor-related',
      format: me.format,
      pickerFormat: me.pickerFormat || me.format,
      step: me.step
    };
  }

  //endregion
}

ColumnStore.registerColumnType(DateColumn);
DateColumn.exposeProperties();
DateColumn._$name = 'DateColumn';

/**
 * @module Grid/column/PercentColumn
 */

/**
 * A column that display a basic progress bar
 *
 * @extends Grid/column/Column
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *         { type: 'percent', text: 'Progress', data: 'progress' }
 *     ]
 * });
 *
 * @classType percent
 * @externalexample column/PercentColumn.js
 */
class PercentColumn extends Column {
  static get type() {
    return 'percent';
  }

  static get fields() {
    return ['lowThreshold'];
  }

  static get defaults() {
    return {
      /**
       * PercentColumn uses a {@link Common.widget.NumberField} configured with an allowed interval 0 - 100 as
       * its default editor.
       * @config {Object|String}
       * @default Common.widget.NumberField
       * @category Misc
       */
      editor: {
        type: 'number',
        min: 0,
        max: 100
      },

      /**
       * When below this percentage the bar will have `b-low` CSS class added. By default it turns the bar red.
       * @config {Number}
       * @category Rendering
       */
      lowThreshold: 20,

      filterType: 'number',
      htmlEncode: false,
      searchable: false,
      summaryRenderer: (sum) => `${sum}%`
    };
  }

  constructor(config, store) {
    super(...arguments);

    this.internalCellCls = 'b-percent-bar-cell';
  }

  /**
   * Renderer that displays a progress bar in the cell.
   * @private
   */
  renderer({ value, cellElement }) {
    value = value || 0;

    if (!cellElement.percentBarElement) {
      cellElement.percentBarElement = DomHelper.createElement(
        {
          tag: 'div',
          className: 'b-percent-bar-outer',
          parent: cellElement,
          children: [
            {
              tag: 'div',
              className: 'b-percent-bar',
              html: '%'
            }
          ]
        },
        true
      )[1];
    }

    const { percentBarElement } = cellElement;

    percentBarElement.classList[value === 0 ? 'add' : 'remove']('b-zero');

    percentBarElement.classList[value < this.lowThreshold ? 'add' : 'remove']('b-low');

    percentBarElement.style.width = value + '%';
    percentBarElement.firstChild.data = value + '%';
  }

  // Overrides base implementation to cleanup the checkbox, for example when a cell is reused as part of group header
  clearCell(cellElement) {
    if (cellElement.percentBarElement) {
      cellElement.percentBarElement = null;
    }
    super.clearCell(cellElement);
  }

  // Null implementation because the column width drives the width of its content.
  // So the concept of sizing to content is invalid here.
  resizeToFitContent() {}
}

PercentColumn.sum = 'average';

ColumnStore.registerColumnType(PercentColumn);
PercentColumn._$name = 'PercentColumn';

/**
 * @module Grid/column/NumberColumn
 */

/**
 * A column for showing/editing numbers
 *
 * @extends Grid/column/Column
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *         { type: 'number', min: 0, max : 100, field: 'score' }
 *     ]
 * });
 *
 * @classType number
 * @externalexample column/NumberColumn.js
 */
class NumberColumn extends Column {
  //region Config
  static get type() {
    return 'number';
  }

  static get fields() {
    return [
      /**
       * The minimum value for the field used during editing.
       * @config {Number} min
       * @category Common
       */
      'min',

      /**
       * The maximum value for the field used during editing.
       * @config {Number} max
       * @category Common
       */
      'max',

      /**
       * Step size for the field used during editing. Specify a fractional step size to allow entering decimal
       * numbers.
       * @config {Number} step
       * @category Common
       */
      'step',

      /**
       * Unit to append to displayed value.
       * @config {String} unit
       * @category Common
       */
      'unit'
    ];
  }

  static get defaults() {
    return {
      filterType: 'number'
    };
  }

  constructor(config, store) {
    super(...arguments);

    this.internalCellCls = 'b-number-cell';
  }

  //endregion

  //region Init

  get defaultEditor() {
    return {
      name: this.field,
      type: 'numberfield',
      max: this.max,
      min: this.min,
      step: this.step
    };
  }

  /**
   * Renderer that displays value + optional unit in the cell
   * @private
   */
  defaultRenderer({ value = 0 }) {
    if (this.unit) {
      return `${value}${this.unit}`;
    }

    return value;
  }
}

ColumnStore.registerColumnType(NumberColumn);
NumberColumn.exposeProperties();
NumberColumn._$name = 'NumberColumn';

// TODO: resuse icon elements

/**
 * @module Grid/column/RatingColumn
 */

/**
 * A column that displays a star rating. Click a start to set a value, shift+click to unset a single start from the end.
 * Clicking the first and only star toggles it.
 *
 * @extends Grid/column/NumberColumn
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *         { type: 'rating', max : 10, field: 'rating' }
 *     ]
 * });
 *
 * @classType percent
 * @externalexample column/RatingColumn.js
 */
class RatingColumn extends NumberColumn {
  static get type() {
    return 'rating';
  }

  static get fields() {
    return ['emptyIcon', 'filledIcon', 'editable'];
  }

  static get defaults() {
    return {
      min: 0,
      max: 5,

      /**
       * The empty rating icon to show
       * @config {String}
       * @category Rendering
       */
      emptyIcon: 'b-icon b-icon-star',

      /**
       * The filled rating icon to show
       * @config {String}
       * @category Rendering
       */
      filledIcon: 'b-icon b-icon-star',

      /**
       * Allow user to click an icon to change the value
       * @config {Boolean}
       * @category Interaction
       */
      editable: true,

      filterType: 'number',
      searchable: false,
      width: '11.2em',
      htmlEncode: false,
      autoSyncHtml: true,
      minWidth: '11.2em',
      editor: false
    };
  }

  constructor(config, store) {
    super(...arguments);

    this.internalCellCls = 'b-rating-cell';
  }

  /**
   * Renderer that displays a number of stars in the cell. Also adds CSS class 'b-rating-cell' to the cell.
   * @private
   */
  renderer({ value }) {
    let html = `<div class="b-rating-cell-inner ${!this.editable ? 'b-not-editable' : ''}">`;

    for (let i = 0; i < this.max; i++) {
      let filled = i < value;
      html += `<i class="b-rating-icon ${filled ? 'b-filled ' + this.filledIcon : 'b-empty ' + this.emptyIcon}"></i>`;
    }

    html += '</div>';

    return html;
  }

  onCellClick({ grid, column, record, cellSelector, target, event }) {
    if (target.classList.contains('b-rating-icon') && !grid.readOnly && column.editable) {
      let starIndex = [].indexOf.call(target.parentNode.childNodes, target);

      if (target.classList.contains('b-filled') && (event.metaKey || event.shiftKey)) {
        starIndex = starIndex - 1;
      }

      // Clicking first star when it is only one removes it
      if (record.get(column.field) === 1 && starIndex === 0) {
        starIndex = -1;
      }

      record.set(column.field, starIndex + 1);
    }
  }
}

ColumnStore.registerColumnType(RatingColumn);
RatingColumn.exposeProperties();
RatingColumn._$name = 'RatingColumn';

/**
 * @module Grid/column/RowNumberColumn
 */

/**
 * A column that displays the row number in each cell
 *
 * @extends Grid/column/Column
 *
 * @example
 * let grid = new Grid({
    appendTo : targetElement,
    width    : 300,
    columns  : [
        { type : 'rownumber' }
    ]
});
 *
 * @classType rownumber
 * @externalexample column/RowNumberColumn.js
 */
class RowNumberColumn extends Column {
  static get defaults() {
    return {
      groupable: false,
      sortable: false,
      filterable: false,
      searchable: false,
      resizable: false,
      minWidth: 50,
      width: 50,
      align: 'right',
      text: '#',
      editor: false
    };
  }

  construct(config, store) {
    const me = this;

    super.construct(...arguments);

    // Update our width when the store mutates (tests test Columns in isolation with no grid, so we must handle that!)
    if (me.grid) {
      me.grid.store.on({
        change: me.resizeToFitContent,
        thisObj: me
      });
      if (me.grid.store.count) {
        me.grid.on({
          render: me.resizeToFitContent,
          thisObj: me,
          once: true
        });
      }
    }
    me.internalCellCls = 'b-row-number-cell';
  }

  static get type() {
    return 'rownumber';
  }

  /**
   * Renderer that displays the row number in the cell.
   * @private
   */
  renderer({ record, grid }) {
    return record.meta.specialRow ? '' : grid.store.indexOf(record, true) + 1;
  }

  /**
   * Resizes the column to match the widest string in it. Called when you double click the edge between column
   * headers
   */
  resizeToFitContent() {
    const grid = this.grid,
      store = grid.store,
      count = store.count;

    if (count && !this.hidden) {
      const cellElement = grid.element.querySelector(`.b-grid-cell[data-column-id=${this.id}]`);

      // cellElement might not exist, e.g. when trial is expired
      if (cellElement) {
        const cellStyle = window.getComputedStyle(cellElement),
          cellPadding = parseInt(cellStyle['padding-left']),
          maxWidth = DomHelper.measureText(count, cellElement);

        this.width = maxWidth + 2 * cellPadding;
      }
    }
  }

  set flex(f) {}
}

ColumnStore.registerColumnType(RowNumberColumn);
RowNumberColumn._$name = 'RowNumberColumn';

/**
 * @module Grid/column/TemplateColumn
 */

/**
 * A column that uses a template for cell content. Any function can be used as template, and the function is passed { value, record, field } properties.
 * It should return a string which will be rendered in the cell
 *
 * @extends Grid/column/Column
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *         { type: 'template', field: 'age', template: value => `${value} years old` }
 *     ]
 * });
 *
 * @classType template
 * @externalexample column/TemplateColumn.js
 */
class TemplateColumn extends Column {
  static get fields() {
    return [
      /**
       * Template function used to generate a value displayed in the cell. Called with arguments { value, record, field }
       * @config {Function} template
       * @category Common
       */
      'template'
    ];
  }

  static get defaults() {
    return {
      htmlEncode: false
    };
  }

  constructor(config, store) {
    super(...arguments);

    const me = this;

    if (!me.template) throw new Error(me.L('noTemplate'));
    if (typeof me.template !== 'function') throw new Error(me.L('noFunction'));
  }

  static get type() {
    return 'template';
  }

  /**
   * Renderer that uses a template for cell content.
   * @private
   */
  renderer(renderData) {
    // If it's a special row, such as a group row, we can't use the user's template
    if (!renderData.record.meta.specialRow) {
      return this.template({
        value: renderData.value,
        record: renderData.record,
        field: renderData.column.field
      });
    }
  }
}

ColumnStore.registerColumnType(TemplateColumn);
TemplateColumn.exposeProperties();
TemplateColumn._$name = 'TemplateColumn';

/**
 * @module Grid/column/TimeColumn
 */

/**
 * A column that displays a time in the specified format (see {@link Common.helper.DateHelper#function-format-static} for formatting options),
 * with a time picker as default editor.
 *
 * @extends Grid/column/Column
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *          { type: 'time', text: 'Start time', format: 'HH:mm:ss', data: 'start' }
 *     ]
 * });
 *
 * @classType time
 * @externalexample column/TimeColumn.js
 */
class TimeColumn extends Column {
  //region Config

  static get type() {
    return 'time';
  }

  static get fields() {
    return ['format'];
  }

  static get defaults() {
    return {
      /**
       * Time format
       * @config {String}
       * @category Common
       */
      format: 'LT',

      minWidth: 140,

      filterType: 'time'
    };
  }

  //endregion

  //region Init

  constructor(config, store) {
    super(...arguments);

    this.internalCellCls = 'b-time-cell';
  }

  //endregion

  //region Display

  /**
   * Renderer that displays the time with the specified format. Also adds cls 'b-time-cell' to the cell.
   * @private
   */
  defaultRenderer({ value }) {
    return value ? this.formatValue(value) : '';
  }

  /**
   * Group renderer that displays the time with the specified format.
   * @private
   */
  groupRenderer({ cellElement, groupRowFor }) {
    cellElement.innerHTML = this.formatValue(groupRowFor);
  }

  //endregion

  //region Formatter

  /**
   * Used by both renderer and groupRenderer to do the actual formatting of the time
   * @private
   * @param value
   * @returns {String}
   */
  formatValue(value) {
    const me = this;
    // Ideally we should be served a time, but if not make it easier for the user by parsing
    if (typeof value === 'string') {
      value = DateHelper.parse(value, me.format);
    }
    return DateHelper.format(value, me.format);
  }

  //endregion

  //region Getters/Setters
  /**
   * Get/Set format for time displayed in cell and editor (see {@link Common.helper.DateHelper#function-format-static} for formatting options)
   * @property {String}
   */
  set format(value) {
    const me = this,
      editor = me.editor;
    me.set('format', value);
    if (editor) {
      editor.format = me.format;
    }
  }

  get format() {
    return this.get('format');
  }

  get defaultEditor() {
    return {
      name: this.field,
      type: 'time',
      format: this.format
    };
  }

  //endregion
}

ColumnStore.registerColumnType(TimeColumn);
TimeColumn.exposeProperties();
TimeColumn._$name = 'TimeColumn';

/**
 * @module Grid/column/TreeColumn
 */

let currentParentHasIcon = false;

/**
 * A column that displays a tree structure when using the {@link Grid.feature.Tree tree} feature.
 *
 * When the TreeColumn renders its cells, it will look for two special fields {@link Grid.data.GridRowModel#field-href} and {@link Grid.data.GridRowModel#field-target}. Specifying `href` will produce a link for the TreeNode, and `target` will
 * have the same meaning as in an A tag:
 *
 * ```javascript
 * {
 *    id        : 1,
 *    name      : 'Some external link'
 *    href      : '//www.website.com",
 *    target    : '_blank"
 * }
 * ```
 *
 * @example
 * new TreeGrid({
 *     appendTo : document.body,
 *
 *     columns : [
 *          { type: 'tree', field: 'name' }
 *     ]
 * });
 *
 * @classType tree
 * @extends Grid/column/Column
 * @externalexample column/TreeColumn.js
 */
class TreeColumn extends Column {
  static get defaults() {
    return {
      tree: true,
      hideable: false,
      minWidth: 150
    };
  }

  static get fields() {
    return [
      /**
       * The icon to use for the collapse icon in collapsed state
       * @config {String} expandIconCls
       */
      { name: 'expandIconCls', defaultValue: 'b-icon b-icon-tree-expand' },

      /**
       * The icon to use for the collapse icon in expanded state
       * @config {String} collapseIconCls
       */
      { name: 'collapseIconCls', defaultValue: 'b-icon b-icon-tree-collapse' },

      /**
       * The icon to use for the collapse icon in expanded state
       * @config {String} collapsedFolderIconCls
       */
      //{ name : 'collapsedFolderIconCls', defaultValue : 'b-icon b-icon-tree-folder' },
      { name: 'collapsedFolderIconCls' },

      /**
       * The icon to use for the collapse icon in expanded state
       * @config {String} expandedFolderIconCls
       */
      //{ name : 'expandedFolderIconCls', defaultValue : 'b-icon b-icon-tree-folder-open' },
      { name: 'expandedFolderIconCls' },

      /**
       * The icon to use for the leaf nodes in the tree
       * @config {String} leafIconCls
       */
      { name: 'leafIconCls', defaultValue: 'b-icon b-icon-tree-leaf' },

      { name: 'editTargetSelector', defaultValue: '.b-tree-cell-value' }
    ];
  }

  static get type() {
    return 'tree';
  }

  constructor(config, store) {
    super(...arguments);

    const me = this;

    me.internalCellCls = 'b-tree-cell';

    // We handle htmlEncoding in this class rather than relying on the generic Row DOM manipulation
    // since this class requires quite a lot of DOM infrastructure around the actual rendered content
    me.shouldHtmlEncode = me.htmlEncode;
    me.tempDiv = document.createElement('div');
    me.setData('htmlEncode', false);

    // add tree renderer (which calls original renderer internally)
    if (me.renderer) {
      me.originalRenderer = me.renderer;
    }
    me.renderer = me.treeRenderer.bind(me);
  }

  /**
   * A column renderer that is automatically added to the column with { tree: true }. It adds padding and node icons
   * to the cell to make the grid appear to be a tree. The original renderer is called in the process.
   * @private
   */
  treeRenderer(renderData) {
    const me = this;

    let { cellElement, row, record, value } = renderData,
      html = '',
      gridMeta = record.instanceMeta(renderData.grid.store),
      cls = '',
      tag = record.href ? 'a' : 'div',
      iconCls;

    if (me.originalRenderer) {
      const rendererHtml = me.originalRenderer(renderData);
      value = rendererHtml === false ? cellElement.innerHTML : rendererHtml;
    }

    if (!record.isLeaf) {
      row.addCls && row.addCls('b-tree-parent-row');
      cellElement.classList.add('b-tree-parent-cell');

      // Spinner while loading children, added to row in Tree#toggleCollapse but needs to be readded if row is
      // rerendered during load
      if (gridMeta.isLoadingChildren) {
        row.addCls('b-loading-children');
      }

      // TODO remove IE 11 is no longer supported (doesnt support this)
      //cellElement.classList.toggle('b-tree-collapsed', record.meta.collapsed === true);

      html += `<div class="b-tree-expander ${
        gridMeta.collapsed ? me.expandIconCls + ' b-tree-collapsed' : me.collapseIconCls + ' b-tree-expanded'
      }"></div>`;

      // Allow user to customize tree icon or opt out entirely
      currentParentHasIcon = iconCls =
        renderData.iconCls ||
        record.iconCls ||
        (gridMeta.collapsed ? me.collapsedFolderIconCls : me.expandedFolderIconCls);
      if (iconCls) {
        html += `<div class="b-tree-icon ${iconCls}"></div>`;
      }
    } else {
      // TODO: Cleanup for reusing dom nodes should be done elsewhere, also cleanup selection
      cellElement.classList.add('b-tree-leaf-cell');

      // Allow user to customize tree icon or opt out entirely
      iconCls = renderData.iconCls || record.iconCls || me.leafIconCls;
      if (iconCls) {
        cls += iconCls;
      }
    }

    value = value != null ? value : '';

    if (me.shouldHtmlEncode) {
      me.tempDiv.innerText = value;
      value = me.tempDiv.innerHTML;
    }

    html += `<div class="b-tree-cell-value">${value}</div>`;

    // TODO: make size configurable
    const padding = record.childLevel * 1.7 + (record.isLeaf ? (currentParentHasIcon ? 1.8 : iconCls ? 0.4 : 0.3) : 0);

    return `<${tag} ${record.href ? `href="${record.href}"` : ''} ${
      tag === 'a' && record.target ? `target="${record.target}"` : ''
    } class="b-tree-cell-inner ${cls}" style="padding-left:${padding}em">${html}</${tag}>`;
  }
}

ColumnStore.registerColumnType(TreeColumn);
TreeColumn.exposeProperties();
TreeColumn._$name = 'TreeColumn';

/**
 * @module Grid/data/GridRowModel
 */

/**
 * Model extended with some fields related to grid rendering. Used as default model type in the grids store if nothing
 * else is specified.
 *
 * Using this model is optional. If you use a custom model instead and need the functionality of any of the fields
 * below, you just have to remember to add fields with the same name to your model.
 *
 * @extends Common/data/Model
 */
class GridRowModel extends Model {
  static get fields() {
    return [
      /**
       * Icon for row (used automatically in tree, feel free to use it in renderer in other cases)
       * @field {String} iconCls
       */
      'iconCls',

      /**
       * Start expanded or not (only valid for tree data)
       * @field {Boolean} expanded
       */
      'expanded',

      /**
       * CSS class (or several classes divided by space) to append to row elements
       * @field {String} cls
       */
      'cls',

      /**
       * Row height, set it to use another height then the default for a row
       * @field {Number} rowHeight
       */
      'rowHeight',

      /**
       * A link to use for this record when rendered into a {@link Grid.column.TreeColumn}.
       * @field {String} href
       */
      'href',

      /**
       * The target to use if this tree node provides a value for the {@link #field-href} field.
       * @field {String} target
       */
      'target'
    ];
  }
}

GridRowModel.exposeProperties();
GridRowModel._$name = 'GridRowModel';

/**
 * @module Grid/feature/GridFeatureManager
 */

const consumerToFeatureMap = new Map(),
  consumerToDefaultFeatureMap = new Map(),
  DEFAULT_FOR_TYPE = 'Grid';

/**
 * Static class intended to register and query grid features
 *
 * @class
 */
class GridFeatureManager {
  /**
   * Register a feature class with the Grid. Enables it to be created and configured using config Grid#features.
   * @param {Common.mixin.InstancePlugin} featureClass Feature to register
   * @param {Boolean} [onByDefault] Specify true to have the feature enabled per default
   * @param {String|String[]} [forType] Specify a type to let the class applying the feature to determine if it should use it
   */
  static registerFeature(featureClass, onByDefault = false, forType = null, as = null) {
    as = StringHelper.lowercaseFirstLetter(as || featureClass.$name);

    if (!Array.isArray(forType)) {
      forType = [forType || DEFAULT_FOR_TYPE];
    }

    forType.forEach((forType) => {
      const consumerFeaturesMap = consumerToFeatureMap.get(forType) || new Map(),
        consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(forType) || new Map();

      consumerFeaturesMap.set(as, featureClass);
      consumerDefaultFeaturesMap.set(featureClass, onByDefault);

      consumerToFeatureMap.set(forType, consumerFeaturesMap);
      consumerToDefaultFeatureMap.set(forType, consumerDefaultFeaturesMap);
    });
  }

  /**
   * Get all the features registered for the given type name in an object where keys are feature names and values are feature constructors.
   *
   * @param {String} [forType]
   * @return {Object}
   */
  static getTypeNameFeatures(forType = DEFAULT_FOR_TYPE) {
    const consumerFeaturesMap = consumerToFeatureMap.get(forType),
      features = {};

    if (consumerFeaturesMap) {
      consumerFeaturesMap.forEach((featureClass, as) => (features[as] = featureClass));
    }

    return features;
  }

  /**
   * Get all the default features registered for the given type name in an object where keys are feature names and values are feature constructors.
   *
   * @param {String} [forType]
   * @return {Object}
   */
  static getTypeNameDefaultFeatures(forType = DEFAULT_FOR_TYPE) {
    const consumerFeaturesMap = consumerToFeatureMap.get(forType),
      consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(forType);

    let features = {};

    if (consumerFeaturesMap && consumerDefaultFeaturesMap) {
      consumerFeaturesMap.forEach((featureClass, as) => {
        if (consumerDefaultFeaturesMap.get(featureClass)) {
          features[as] = featureClass;
        }
      });
    }

    return features;
  }

  /**
   * Gets all the features registered for the given instance type name chain. First builds the type name chain then quaries for features
   * for each type name and combines them into one object, see {@link #function-getTypeNameFeatures-static}() for returned object description.
   * If feature is registered for both parent and child type name then feature for child overrides feature for parent.
   *
   * @param {Object} instance
   * @return {Object}
   */
  static getInstanceFeatures(instance) {
    return instance
      .classNameHierarchy()
      .reduce((features, typeName) => Object.assign(features, this.getTypeNameFeatures(typeName)), {});
  }

  /**
   * Gets all the *defualt* features registered for the given instance type name chain. First builds the type name chain then quaries for features
   * for each type name and combines them into one object, see {@link #function-getTypeNameFeatures-static}() for returned object description.
   * If feature is registered for both parent and child type name then feature for child overrides feature for parent.
   *
   * @param {Object} instance
   * @return {Object}
   */
  static getInstanceDefaultFeatures(instance) {
    return instance.classNameHierarchy().reduce(
      (features, typeName) =>
        Object.entries(this.getTypeNameFeatures(typeName)).reduce((features, [as, featureClass]) => {
          if (this.isDefaultFeatureForTypeName(featureClass, typeName)) {
            features[as] = featureClass;
          } else {
            delete features[as];
          }
          return features;
        }, features),
      {}
    );
  }

  /**
   * Checks if the given feature class is default for the type name
   *
   * @param {Common.mixin.InstancePlugin} featureClass Feature to check
   * @param {String} [forType]
   * @return {Boolean}
   */
  static isDefaultFeatureForTypeName(featureClass, forType = DEFAULT_FOR_TYPE) {
    const consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(forType);
    return (consumerDefaultFeaturesMap && consumerDefaultFeaturesMap.get(featureClass)) || false;
  }

  /**
   * Checks if the given feature class is default for the given instance type name chain. If the feature is not default for the
   * parent type name but it is for the child type name, then the child setting overrides the parent one.
   *
   * @param {Common.mixin.InstancePlugin} featureClass Feature to check
   * @param {String} [forType]
   * @return {Boolean}
   */
  static isDefaultFeatureForInstance(featureClass, instance) {
    //const typeChain = ObjectHelper.getTypeNameChain(instance);
    const typeChain = instance.classNameHierarchy().reverse();

    let result = null;

    for (let i = 0, len = typeChain.length; i < len && result === null; ++i) {
      const consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(typeChain[i]);

      if (consumerDefaultFeaturesMap && consumerDefaultFeaturesMap.has(featureClass)) {
        result = consumerDefaultFeaturesMap.get(featureClass);
      }
    }

    return result || false;
  }

  /**
   * Resets feature registration date, used in tests to reset state after test
   *
   * @internal
   */
  static reset() {
    consumerToFeatureMap.clear();
    consumerToDefaultFeatureMap.clear();
  }
}
GridFeatureManager._$name = 'GridFeatureManager';

/**
 * @module Common/widget/layout/Fit
 */

/**
 * A helper class for containers which must manage a single child widget which must fit the container's
 * {@link Common.widget.Widget#property-contentElement contentElement}.
 */
class Fit extends Layout {
  static get defaultConfig() {
    return {
      containerCls: 'b-fit-container',

      itemCls: 'b-fit-item'
    };
  }
}

// Layouts must register themselves so that the static layout instantiation
// in Layout knows what to do with layout type names
Fit._$name = 'Fit';
Layout.registerLayout(Fit);

/**
 * @module Common/widget/Editor
 */

/**
 * Displays an input field, optionally editing a field of a record at a particular position.
 *
 * Offers events to signal edit completion upon `ENTER` or focus loss (if configured to do so),
 * or edit cancellation on `ESC`, or focus loss if configured that way.
 * @extends Common/widget/Container
 *
 * @classType Editor
 */
class Editor extends Container {
  //region Config

  static get defaultConfig() {
    return {
      positioned: true,

      hidden: true,

      layout: 'fit',

      /**
       * A config object, or the `type` string of the input field which this editor will encapsulate.
       * @config {Object|String}
       * @default
       */
      inputField: 'textfield',

      /**
       * What action should be taken when focus moves out of the editor, either by `TAB` or clicking outside.
       * May be `'complete'` or `'cancel`'. Any other value results in no action being taken upon focus leaving the editor
       * leaving the application to listen for the {@link Common.widget.Widget#event-focusout focusout} event.
       * @config {String}
       * @default
       */
      blurAction: 'complete',

      /**
       * The name of the `key` which completes the edit.
       *
       * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for key names.
       * @config {String}
       * @default
       */
      completeKey: 'Enter',

      /**
       * The name of the `key` which cancels the edit.
       *
       * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for key names.
       * @config {String}
       * @default
       */
      cancelKey: 'Escape',

      /**
       * Configure as `true` to allow editing to complete when the field is invalid. Editing may always be _canceled_.
       * @config {String}
       * @default
       */
      allowInvalid: false
    };
  }

  //endregion

  //region Events

  /**
   * Fired before the editor is shown to start an edit operation. Returning `false` from a handler vetoes the edit operation.
   * @event beforestart
   * @property {Object} value - The value to be edited.
   * @preventable
   */
  /**
   * Fired when an edit operation has begun.
   * @event start
   * @property {Object} value - The starting value of the field.
   * @property {Common.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fired when an edit completion has been requested, either by `ENTER`, or focus loss (if configured to complete on blur).
   * The completion may be vetoed, in which case, focus is moved back into the editor.
   * @event beforecomplete
   * @property {Object} oldValue - The original value.
   * @property {Object} value - The new value.
   * @property {Common.widget.Editor} source - The Editor that triggered the event.
   * @preventable
   */
  /**
   * Edit has been completed, and any associated record or element has been updated.
   * @event complete
   * @property {Object} oldValue - The original value.
   * @property {Object} value - The new value.
   * @property {Common.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fired when cancellation has been requested, either by `ESC`, or focus loss (if configured to cancel on blur).
   * The cancellation may be vetoed, in which case, focus is moved back into the editor.
   * @event beforecancel
   * @property {Object} oldValue - The original value.
   * @property {Object} value - The new value.
   * @property {Common.widget.Editor} source - The Editor that triggered the event.
   * @preventable
   */
  /**
   * Edit has been canceled without updating the associated record or element.
   * @event cancel
   * @property {Object} oldValue - The original value.
   * @property {Object} value - The value of the field.
   * @property {Common.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fire to relay a `keypress` event from the field.
   * @event keypress
   * @property {Event} event - The key event.
   */

  //endregion

  afterConfigure() {
    const me = this;
    super.afterConfigure();

    if (me.completeKey || me.cancelKey) {
      EventHelper.on({
        element: me.element,
        keydown: 'onKeyDown',
        thisObj: me
      });
    }

    LocaleManagerSingelton.on({
      locale: 'onLocaleChange',
      thisObj: me
    });
  }

  onLocaleChange() {
    const me = this;
    if (me.inputField) {
      me.inputField.syncInputFieldValue();
    }
  }

  /**
   * Start editing
   * @param {Object} editObject An object containing details about what to edit.
   * @param {HTMLElement/Common.helper.util.Rectangle} editObject.target the element or Rectangle to align to.
   * @param {String} [editObject.align=t0-t0] How to align to the target.
   * @param {Boolean} [editObject.matchSize=true] Match editor size to target size.
   * @param {Common.data.Model} [editObject.record] The record to edit.
   * @param {String} [editObject.field] The field name in the record to edit. This defaults to the `name` of the {@link #config-inputField}.
   * Also if record has method set + capitalized field, method will be called, e.g. if record has method named
   * `setFoobar` and this config is `foobar`, then instead of `record.foobar = value`, `record.setFoobar(value)` will be called.
   * @param {Object} [editObject.value] The value to edit.
   * @param {Boolean} [editObject.focus=true] Focus the field.
   */
  startEdit({ target, align = 't0-t0', matchSize = true, value, record, field = this.inputField.name, focus = true }) {
    const me = this,
      { inputField } = me,
      targetRect = target instanceof Rectangle ? target : Rectangle.inner(target);

    if (me.trigger('beforestart', { value }) !== false) {
      if (record && field && value === undefined) {
        me.record = record;
        me.dataField = field;
        value = record[field];
      }
      if (matchSize) {
        me.width = targetRect.width;
        me.height = targetRect.height;
      }
      inputField.value = value;
      me.showBy({
        target,
        align
      });
      if (focus && me.inputField.focus) {
        me.inputField.focus();
      }
      if (target.nodeType === 1) {
        target.classList.add('b-editing');
      }
      // Passed value may have been '10/06/2019', send the live field value to startedit
      me.trigger('start', { value: inputField.value });
      me.oldValue = inputField.value;

      // If the value from th value getter is an array, we must clone it because
      // if it's the same *instance*, the ObjectHelper.isEqual test in completeEdit
      // will find that there are no changes.
      if (Array.isArray(me.oldValue)) {
        me.oldValue = me.oldValue.slice();
      }
      return true;
    }
    return false;
  }

  refreshEdit() {
    if (this.isVisible) {
      const { record, dataField, inputField } = this;

      if (record && dataField) {
        const value = record[dataField];

        // Only update the field if the value has changed
        if (!ObjectHelper.isEqual(inputField.value, value)) {
          inputField.value = value;
        }
      }
    }
  }

  onKeyDown(event) {
    const me = this;

    switch (event.key) {
      case me.completeKey:
        me.completeEdit();
        event.stopImmediatePropagation();
        break;
      case me.cancelKey:
        me.cancelEdit();
        event.stopImmediatePropagation();
        break;
    }
    me.trigger('keydown', { event });
  }

  onFocusOut(event) {
    super.onFocusOut(event);

    if (!this.isFinishing) {
      const method = this[`${this.blurAction}Edit`];

      if (method) {
        method.call(this);
      }
    }
  }

  /**
   * Complete the edit, and, if associated with a record, update the record if possible.
   * If editing is completed, the editor is hidden.
   *
   * If the field is invalid, and this Editor is configured `{@link #config-allowInvalid}: false`
   * then editing is not completed.
   *
   * If a {@link #event-beforecomplete} handler returns `false` then editing is not completed.
   *
   * If the field's valus has not been changed, then editing is terminated through {@link #function-cancelEdit}.
   *
   * @returns `true` if editing ceased, `false` if the editor is still active.
   */
  completeEdit() {
    const me = this,
      { inputField, oldValue } = me,
      { value } = inputField;

    // If we're configured not to allow invalid values, refocus the field in case complete was triggered by focusout.
    if (!inputField.isValid && !(me.allowInvalid || inputField.allowInvalid)) {
      inputField.focus && inputField.focus();
      return false;
    }
    // No change means a cancel.
    else if (ObjectHelper.isEqual(value, oldValue)) {
      me.cancelEdit();
      return true;
    }
    // Allow veto of the completion
    else {
      const context = { value: value, oldValue };

      if (me.trigger('beforecomplete', context) === false) {
        inputField.focus && inputField.focus();
      }
      // EXPERIMENTAL: Allow async finalization of the editing, implementer may want to show a confirmation popup etc
      else if (context.async) {
        context.async.then((result) => {
          if (result === true) {
            me.onEditComplete();
          } else {
            inputField.setError(result || inputField.L('invalidValue'));
            if (!(me.allowInvalid || inputField.allowInvalid)) {
              inputField.focus && inputField.focus();
            }
          }
        });
        return false;
      }
      // Successful completion
      else {
        me.onEditComplete();
        return true;
      }
    }
    return false;
  }

  /**
   * Cancel the edit and hide the editor.
   */
  cancelEdit() {
    const me = this,
      { inputField, oldValue } = me,
      { value } = inputField;

    if (!me.isFinishing && me.trigger('beforecancel', { value: value, oldValue }) !== false) {
      // Hiding must not trigger our blurAction
      me.isFinishing = true;
      me.hide();
      me.trigger('cancel', { value, oldValue });
      me.isFinishing = false;
    }
  }

  // Handle updating what needs to be updated.
  onEditComplete() {
    const me = this,
      { record, dataField, inputField, oldValue, lastAlignSpec } = me,
      { target } = lastAlignSpec,
      { value } = inputField;

    if (!me.isFinishing) {
      // Hiding must not trigger our blurAction
      me.isFinishing = true;
      me.hide();

      if (record) {
        const setterName = `set${StringHelper.capitalizeFirstLetter(dataField)}`;
        if (record[setterName]) {
          record[setterName](value);
        } else {
          record[dataField] = value;
        }
      }
      me.trigger('complete', { value, oldValue });
      if (target.nodeType === 1) {
        target.classList.remove('b-editing');
      }

      me.isFinishing = false;
    }
  }

  doDestroy() {
    if (this.createdInputField) {
      this.inputField.destroy();
    }
    super.doDestroy();
  }

  set owner(owner) {
    this._owner = owner;
  }

  // This is a positioned widget appended to a Widget's contentElement. It has no owner link.
  // Grab the owner by finding what widget it is inside.
  get owner() {
    return this._owner || IdHelper.fromElement(this.element.parentNode);
  }

  get items() {
    return (this._items = [this.inputField]);
  }

  set inputField(inputField) {
    const me = this;

    if (me._inputField) {
      me._inputField.destroy();
    }
    if (typeof inputField === 'string') {
      inputField = {
        type: inputField
      };
    }
    if (inputField instanceof Widget) {
      me._inputField = inputField;
    } else {
      me._inputField = WidgetHelper.createWidget(inputField);
      me.createdInputField = true; // So we know we can destroy it
    }
    me._inputField.parent = me;
  }

  get inputField() {
    return this._inputField;
  }
}

Editor._$name = 'Editor';
BryntumWidgetAdapterRegister.register('editor', Editor);

//TODO: Maybe some more way to stop editing in touch mode (in case grid fills entire page...)

const validNonEditingKeys = {
  Enter: 1,
  F2: 1
};

const validEditingKeys = {
  ArrowUp: 1,
  ArrowDown: 1,
  ArrowLeft: 1,
  ArrowRight: 1
};

/**
 * @module Grid/feature/CellEdit
 */

/**
 * Adding this feature to the grid enables cell editing, usage instructions:
 * <h3>Start editing</h3>
 * * Double click on a cell
 * * Press [ENTER] or [F2] with a cell selected
 *
 * <h3>While editing</h3>
 * * [ENTER] <dd>Finish editing and start editing the same cell in next row
 * * [SHIFT] + [ENTER] <dd>Same as above put with previous row
 * * [F2] <dd>Finish editing
 * * [CMD/CTRL] + [ENTER] <dd>Finish editing
 * * [ESC] <dd>Cancel editing
 * * [TAB] <dd>Finish editing and start editing the next cell
 * * [SHIFT] + [TAB] <dd>Finish editing and start editing the previous cell
 *
 * Columns specify editor in their config, editor can
 * also by set by using a column type.
 *
 * <h3>Preventing editing of certain cells</h3>
 * You can prevent editing on a column by setting `editor` to false:
 *
 * ```javascript
 * new Grid({
 *    columns : [
 *       {
 *          type   : 'number',
 *          text   : 'Age',
 *          field  : 'age',
 *          editor : false
 *       }
 *    ]
 * ```
 * To prevent editing in a specific cell, listen to the {@link #event-beforeCellEditStart} and return false:
 *
 * ```javascript
 * grid.on('beforeCellEditStart', ({ editorContext }) => {
 *     return editorContext.column.field !== 'id';
 * });
 * ```
 *
 * This feature is <strong>enabled</strong> by default.
 *
 * @example
 * { data: 'name', text: 'Name', editor: 'text' }
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @demo celledit
 * @classtype cellEdit
 * @externalexample feature/CellEdit.js
 */
class CellEdit extends Delayable(InstancePlugin) {
  //region Config

  // Default configuration
  static get defaultConfig() {
    return {
      /**
       * Set to true to select the field text when editing starts
       * @config {Boolean}
       * @default
       */
      autoSelect: true,

      /**
       * What action should be taken when focus moves leaves the cell editor, for example when clicking outside.
       * May be `'complete'` or `'cancel`'.
       * @config {String}
       * @default
       */
      blurAction: 'complete',

      /**
       * Set to true to have TAB on the last cell in the data set create a new record
       * and begin editing it at its first editable cell.
       *
       * If this is configured as an object, it is used as the default data value set for each new record.
       * @config {Boolean/Object}
       * @default
       */
      addNewAtEnd: null,

      /**
       * Set to true to start editing when user starts typing text on a focused cell (as in Excel)
       * @config {Boolean}
       * @default
       */
      autoEdit: false,

      /**
       * Class to use as an editor. Default value: {@link Common.widget.Editor}
       * @config {Common.widget.Widget}
       * @internal
       */
      editorClass: Editor
    };
  }

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      assign: ['startEditing'],
      before: ['onElementKeyDown', 'onElementMouseDown'],
      chain: ['onElementClick']
    };
  }

  //endregion

  //region Init

  construct(grid, config) {
    const me = this;

    me.grid = grid;

    super.construct(grid, config);

    me.storeListenerDetacher = grid.store.on({
      update: 'onStoreUpdate',
      thisObj: me
    });
    me.listenerDetacher = grid.on({
      cellclick: 'onCellClick',
      celldblclick: 'onCellDblClick',
      beforerenderrows: 'onGridBeforeRenderRows',
      thisObj: me
    });
  }

  doDestroy() {
    this.cancelEditing(true);
    this.listenerDetacher();
    this.storeListenerDetacher();
    super.doDestroy();
  }

  //endregion

  //region Editing

  /**
   * Is any cell currently being edited?
   * @returns {boolean}
   */
  get isEditing() {
    return Boolean(this.editorContext);
  }

  /**
   * Internal function to create of get existing editor for specified cell.
   * @private
   * @param cellContext Cell to get or create editor for
   * @returns {{editor: (Element|*|null), field: *, widget: *}}
   * @category Internal
   */
  getEditorForCell({ column, selector }) {
    const me = this,
      grid = me.grid;

    // Reuse the editor by caching it on the column
    let editor = column._cellEditor;

    if (!editor) {
      column.editor.autoSelect = me.autoSelect;

      editor = column._cellEditor = new me.editorClass({
        cls: 'b-cell-editor',
        inputField: column.editor,
        blurAction: 'none',
        completeKey: false,
        cancelKey: false,
        owner: grid,
        listeners: me.getEditorListeners()
      });

      // Keep the record synced with the value
      if (column.instantUpdate) {
        ObjectHelper.wrapProperty(column.editor, 'value', null, (v) => {
          // Only tickle the record if the value has changed.
          if (me.editorContext && !ObjectHelper.isEqual(me.editorContext.record[me.editorContext.column.field], v)) {
            me.editorContext.record[me.editorContext.column.field] = v;
          }
        });
      }
    }
    const widgetWrapperData = editor.element.dataset;
    widgetWrapperData.rowId = selector.id;
    widgetWrapperData.columnId = selector.columnId;
    widgetWrapperData.field = column.field;

    return (me.editor = editor);
  }

  // Turned into function to allow overriding in Gantt, and make more configurable in general
  getEditorListeners() {
    return {
      focusout: 'onEditorFocusOut',
      focusin: 'onEditorFocusIn',
      start: 'onEditorStart',
      beforecomplete: 'onEditorBeforeComplete',
      complete: 'onEditorComplete',
      cancel: 'onEditorCancel',
      thisObj: this
    };
  }

  onEditorStart({ source: editor }) {
    const me = this,
      editorContext = (me.editorContext = editor.cellEditorContext);

    if (editorContext) {
      const { grid } = me,
        { cell, editor, column } = editorContext;

      // Match editorTarget size and position
      if (column.editTargetSelector) {
        const editorTarget = cell.querySelector(column.editTargetSelector);

        if (editorTarget) {
          editor.width -= editorTarget.offsetLeft;
          DomHelper.addTranslateX(editor.element, editorTarget.offsetLeft);
        }
      }

      cell.classList.add('b-editing');

      me.grid.on(
        {
          cellclick: 'onCellClickWhileEditing',
          viewportResize: 'onViewportResizeWhileEditing'
        },
        me
      );

      // Handle tapping outside of the grid element. Use GlobalEvents
      // because it uses a capture:true listener before any other handlers
      // might stop propagation.
      // Cannot use delegate here. A tapped cell will match :not(#body-container)
      me.removeEditingListeners = GlobalEvents.addListener({
        globaltap: 'onTapOut',
        thisObj: me
      });

      /**
       * Fires on the owning Grid when editing starts
       * @event startCellEdit
       * @param {Grid.view.Grid} grid **Deprecated** Use `source` instead
       * @param {Grid.view.Grid} source Owner grid
       * @param {Object} editorContext Editing context
       * @param {Common.widget.Editor} editorContext.editor The Editor being used.
       * Will contain an `inputField` property which is the field being used to perform the editing.
       * @param {Grid.column.Column} editorContext.column Target column
       * @param {Common.data.Model} editorContext.record Target record
       * @param {HTMLElement} editorContext.cell Target cell
       * @param {*} editorContext.value Cell value
       */
      grid.trigger('startCellEdit', { grid, editorContext });
    }
  }

  onEditorBeforeComplete(context) {
    const { grid } = this,
      editor = context.source,
      editorContext = editor.cellEditorContext;

    context.grid = grid;
    context.editorContext = editorContext;

    /**
     * Fires on the owning Grid before the cell editing is finished, return false to signal that the value is invalid and editing should not be finalized.
     * @event beforeFinishCellEdit
     * @param {Grid.view.Grid} grid Target grid
     * @param {Object} editorContext Editing context
     * @param {Common.widget.Editor} editorContext.editor The Editor being used.
     * Will contain an `inputField` property which is the field being used to perform the editing.
     * @param {Grid.column.Column} editorContext.column Target column
     * @param {Common.data.Model} editorContext.record Target record
     * @param {HTMLElement} editorContext.cell Target cell
     * @param {*} editorContext.value Cell value
     */
    return grid.trigger('beforeFinishCellEdit', context);
  }

  onEditorComplete({ source: editor }) {
    const { grid } = this,
      editorContext = editor.cellEditorContext;

    // Ensure the docs below are accurate!
    editorContext.value = editor.inputField.value;

    /**
     * Fires on the owning Grid when cell editing is finished
     * @event finishCellEdit
     * @param {Grid.view.Grid} grid Target grid
     * @param {Object} editorContext Editing context
     * @param {Common.widget.Editor} editorContext.editor The Editor being used.
     * Will contain an `inputField` property which is the field being used to perform the editing.
     * @param {Grid.column.Column} editorContext.column Target column
     * @param {Common.data.Model} editorContext.record Target record
     * @param {HTMLElement} editorContext.cell Target cell
     * @param {*} editorContext.value Cell value
     */
    grid.trigger('finishCellEdit', { grid, editorContext });
    this.cleanupAfterEdit(editorContext);
  }

  onEditorCancel() {
    const { editorContext, muteEvents, grid } = this;

    if (editorContext) {
      this.cleanupAfterEdit(editorContext);
    }
    if (!muteEvents) {
      /**
       * Fires on the owning Grid when editing is cancelled
       * @event cancelCellEdit
       * @param {Grid.view.Grid} grid **Deprecated** Use `source` instead
       * @param {Grid.view.Grid} source Owner grid
       */
      grid.trigger('cancelCellEdit', { grid });
    }
  }

  cleanupAfterEdit(editorContext) {
    const me = this,
      { editor } = editorContext;

    editorContext.cell.classList.remove('b-editing');
    editor.cellEditorContext = me.editorContext = null;
    me.grid.un(
      {
        cellclick: 'onCellClickWhileEditing',
        viewportResize: 'onViewportResizeWhileEditing'
      },
      me
    );
    me.removeEditingListeners();
    // MS Edge workaround.
    // At this moment active element is grid.element, but removing editor element still triggers focusout event
    // which is processed by the GlobalEvents, which decides that focus goes to body element. That, in turn, triggers
    // clearFocus on grid navigation, removing focused cell from cache etc, eventually focus actually goes to body.
    // Suspending listener to seamlessly remove element keeping focus where it belongs.
    // NOTE: not reproducible in IFrame, so our tests cannot catch this
    GlobalEvents.suspendFocusEvents();
    editor.element.remove();
    GlobalEvents.resumeFocusEvents();
  }

  /**
   * Find the next succeeding or preceding cell which is editable (column.editor != false)
   * @param {Object} cellInfo
   * @param {Boolean} isForward
   * @returns {Object}
   * @private
   * @category Internal
   */
  getAdjacentEditableCell(cellInfo, isForward) {
    let addNewAtEnd = this.addNewAtEnd,
      grid = this.grid,
      store = grid.store,
      rowManager = grid.rowManager,
      rowId = cellInfo.id,
      columnId = cellInfo.columnId,
      columns = grid.columns,
      column = columns.getAdjacentLeaf(columnId, isForward);

    while (rowId) {
      const record = store.getById(rowId);

      if (column) {
        columnId = column.id;

        if (!column.hidden && column.editor && column.canEdit(record)) {
          return { id: rowId, columnId: column.id };
        }

        column = columns.getAdjacentLeaf(columnId, isForward);
      } else {
        let editRec = store.getAdjacent(cellInfo.id, isForward, false, true);

        if (!editRec && isForward && addNewAtEnd) {
          editRec = store.add(typeof addNewAtEnd === 'object' ? ObjectHelper.clone(addNewAtEnd) : {})[0];

          // If the new record was not added due to it being off the end of the rendered block
          // ensure we force it to be there before we attempt to edit it.
          if (!rowManager.getRowFor(editRec)) {
            rowManager.displayRecordAtBottom();
          }
        }

        rowId = editRec && editRec.id;

        if (editRec) {
          column = isForward ? columns.first : columns.leaves[columns.leaves.length - 1];
        }
      }
    }

    return null;
  }

  /**
   * Creates an editing context object for the passed cell context (target cell must be in the DOM).
   *
   * If the referenced cell is editable, an object returned will
   * be returned containing the following properties:
   *
   *     - column
   *     - record
   *     - cell
   *     - value
   *     - selector
   *
   * If the references cell is _not_ editable, `false` will be returned.
   * @param {Object} cellContext an object which encapsulates a cell.
   * @param {String} cellContext.id The record id of the row to edit
   * @param {String} cellContext.columnId The column id of the column to edit
   * @private
   */
  getEditingContext(cellContext) {
    cellContext = this.grid.normalizeCellContext(cellContext);

    const me = this,
      { grid } = me,
      column = grid.columns.getById(cellContext.columnId),
      record = grid.store.getById(cellContext.id),
      cell = grid.getCell(cellContext);

    // Cell must be in the DOM to edit.
    // Cannot edit hidden columns and columns without an editor.
    // Cannot edit special rows (groups etc).
    if (
      cell &&
      column &&
      !column.hidden &&
      column.editor &&
      record &&
      !record.meta.specialRow &&
      column.canEdit(record)
    ) {
      const value = record && record[column.field];

      return {
        column,
        record,
        cell,
        value: value === undefined ? null : value,
        selector: cellContext
      };
    } else {
      return false;
    }
  }

  /**
   * Start editing specified cell. If no cellContext is given it starts with the first cell in the first row.
   * This function is exposed on Grid and can thus be called as `grid.startEditing(...)`
   * @param {Object} cellContext Cell specified in format { id: 'x', columnId/column/field: 'xxx' }. See {@link Grid.view.Grid#function-getCell} for details.
   * @fires startCellEdit
   * @returns {Boolean} editingStarted
   * @category Editing
   */
  startEditing(cellContext = {}) {
    const me = this;

    // If already editing, or grid is readonly, no can do.
    if (!(me.editorContext || me.disabled || me.grid.readOnly || me.grid.disabled)) {
      const { grid } = me,
        normalizedContext = grid.normalizeCellContext(cellContext);

      // First scroll record into view and register it as last focusedCell
      grid.focusCell(cellContext);

      const editorContext = me.getEditingContext(normalizedContext);

      /**
       * Fires on the owning Grid before editing starts, return `false` to prevent editing
       * @event beforeCellEditStart
       * @preventable
       * @param {Grid.view.Grid} source Owner grid
       * @param {Object} editorContext Editing context
       * @param {Grid.column.Column} editorContext.column Target column
       * @param {Common.data.Model} editorContext.record Target record
       * @param {HTMLElement} editorContext.cell Target cell
       * @param {*} editorContext.value Cell value
       */
      if (grid.trigger('beforeCellEditStart', { grid, editorContext }) === false) {
        return false;
      }

      // Cannot edit hidden columns and columns without an editor
      // Cannot edit special rows (groups etc).
      if (editorContext) {
        // Focus grid element to preserve focus inside once editing is started
        // https://app.assembla.com/spaces/bryntum/tickets/8155-grid-cell-not-properly-focused-in-advanced-demo
        DomHelper.focusWithoutScrolling(grid.element);

        const editor = (editorContext.editor = me.getEditorForCell(editorContext)),
          { cell, record, column } = editorContext;

        // Prevent highlight when setting the value in the editor
        editor.inputField.highlightExternalChange = false;

        editor.cellEditorContext = editorContext;
        editor.render(me.grid.getSubGridFromColumn(column).element);

        // Attempt to start edit.
        // We will set up our context in onEditorStart *if* the start was successful.
        editor.startEdit({
          target: cell,
          record
        });

        return true;
      }
    }

    return false;
  }

  /**
   * Cancel editing, destroys the editor
   * @param {Boolean} silent Pass true to prevent method from firing event
   * @fires cancelCellEdit
   * @category Editing
   */
  cancelEditing(silent = false) {
    const me = this,
      { editorContext, editor, grid } = me;

    if (editorContext) {
      // If cancel was not called from onEditorFocusOut, then refocus the grid.
      if (editor.containsFocus) {
        // Kill editorContext before we destroy the editor so that we know we are not editing
        // in ensuing focusout event handling
        me.editorContext = null;

        // Control focus reversion if we own focus
        if (editor.inputField.owns(DomHelper.activeElement)) {
          grid.focus();
        }
        me.editorContext = editorContext;
      }

      me.muteEvents = silent;
      editor.cancelEdit();
      me.muteEvents = false;
    }
  }

  /**
   * Finish editing, update the underlying record and destroy the editor
   * @fires finishCellEdit
   * @category Editing
   * @returns `false` if the edit could not be finished due to the value being invalid or the
   * Editor's `complete` event was vetoed.
   */
  finishEditing() {
    const { editorContext } = this;

    if (editorContext) {
      return editorContext.editor.completeEdit();
    }
    return false;
  }

  //endregion

  //region Context menu

  // /**
  //  * Populates the cell context menu with an 'Edit cell' item.
  //  * @private
  //  * @param column
  //  * @param {Common.data.Model} record
  //  * @param {Array} items
  //  * @returns {Array}
  //  * @category Internal
  //  */
  // getCellMenuItems(column, record, items) {
  //     const me = this;
  //
  //     if (column.editor !== false) {
  //         items.push({
  //             text   : this.L('editCell'),
  //             icon   : 'edit',
  //             id     : 'cellEdit',
  //             onItem : () => {
  //                 me.editorContext && me.finishEditing();
  //                 // selecting in context menu triggers cancel, which is fine in other cases...
  //                 me.startEditing({ id : record.id, columnId : column.id, field : column.field });
  //                 me.preventFinish = true;
  //             }
  //         });
  //     }
  //     return items;
  // }

  //endregion

  //region Events

  /**
   * Event handler added when editing is active called when user clicks a cell in the grid during editing.
   * It finishes editing and moves editor to the selected cell instead.
   * @private
   * @category Internal event handling
   */
  onCellClickWhileEditing({ event, cellSelector }) {
    const me = this;

    // Ignore clicks in the editor.
    if (!me.editorContext.editor.owns(event.target)) {
      if (me.getEditingContext(cellSelector)) {
        // Attempt to finish the current edit.
        // Will return false if the field is invalid.
        if (me.finishEditing()) {
          me.startEditing(cellSelector);
        }
        // Previous edit was invalid, return to it.
        else {
          me.grid.focusCell(me.editorContext.selector);
          me.editor.inputField.focus();
        }
      } else {
        me.finishEditing();
      }
    }
  }

  onViewportResizeWhileEditing() {
    const { editor, column } = this.editorContext;

    editor.width = column.element.offsetWidth;
  }

  /**
   * Starts editing if user taps selected cell again on touch device. Chained function called when user clicks a cell.
   * @private
   * @category Internal event handling
   */
  onCellClick({ source: grid, record, cellSelector, cellElement, target, event }) {
    const selected = grid.focusedCell || {},
      column = grid.columns.getById(cellSelector.columnId);

    // Columns may provide their own handling of cell editing
    if (column.onCellClick) {
      column.onCellClick({ grid, column, record, cellSelector, cellElement, target, event });
    } else if (target.matches('.b-tree-expander')) {
      this.cancelEditing();
      return false;
    } else if (DomHelper.isTouchEvent && cellSelector.id == selected.id && cellSelector.columnId == selected.columnId) {
      this.startEditing(cellSelector);
    }
  }

  /**
   * Chained function called when user dbl clicks a cell. Starts editing.
   * @private
   * @category Internal event handling
   */
  onCellDblClick({ cellSelector }) {
    const me = this;

    if (me.editorContext && !me.finishEditing()) {
      return;
    }
    me.startEditing(cellSelector);
  }

  /**
   * Update the input field if underlying data changes during edit.
   * @private
   * @category Internal event handling
   */
  onStoreUpdate({ changes, record }) {
    const { editorContext } = this;

    if (editorContext && editorContext.editor.isVisible) {
      if (record === editorContext.record && editorContext.editor.dataField in changes) {
        editorContext.editor.refreshEdit();
      }
    }
  }

  /**
   * Invalidate editor when grid renders rows.
   * @private
   * @category Internal event handling
   */
  onGridBeforeRenderRows() {
    // grid rows are being rerendered, meaning the underlying data might be changed.
    // the editor probably won't be over the same record, so cancel
    if (this.editorContext && this.editorContext.editor.isVisible) {
      this.cancelEditing();
    }
  }

  /**
   * Chained function called on key down. [enter] or [f2] starts editing. [enter] also finishes editing and starts
   * editing next row, [f2] also finishes editing without moving to the next row. [esc] cancels editing. [tab]
   * edits next column, [shift] + [tab] edits previous.
   * @param event
   * @private
   * @category Internal event handling
   */
  onElementKeyDown(event) {
    const me = this;

    // flagging event with handled = true used to signal that other features should probably not care about it
    if (event.handled) return;

    if (!me.editorContext) {
      const key = event.key,
        editingStartedWithCharacterKey = me.autoEdit && (key.length === 1 || key === 'Backspace');

      // enter or f2 to edit, or any character key if autoEdit is enabled
      if ((editingStartedWithCharacterKey || validNonEditingKeys[key]) && me.grid.focusedCell) {
        event.preventDefault();

        if (!me.startEditing(me.grid.focusedCell)) {
          return;
        }

        const inputField = me.editor.inputField,
          input = inputField.input;

        // if editing started with a keypress and the editor has an input field, set its value
        if (editingStartedWithCharacterKey && input) {
          // Simulate a keydown in an input field by setting input value
          // plus running our internal processing of that event
          input.value = key === 'Backspace' ? '' : key;
          inputField.internalOnInput(event);

          // IE11 + Edge put caret at 0 when focusing
          inputField.moveCaretToEnd();
        }
      }
    } else {
      // enter
      if (event.key === 'Enter') {
        event.preventDefault();
        event.stopPropagation();
        if (me.finishEditing()) {
          // Finalizing might have been blocked by an invalid value
          if (!me.isEditing) {
            // Enter in combination with special keys finishes editing
            // On touch Enter always finishes editing. Feels more natural since no tab-key etc.
            if (event.ctrlKey || event.metaKey || event.altKey || me.grid.touch) {
              return;
            }
            // Edit previous
            else if (event.shiftKey) {
              if (me.grid.navigateUp()) {
                me.startEditing(me.grid.focusedCell);
              }
            }
            // Edit next
            else if (me.grid.navigateDown()) {
              me.startEditing(me.grid.focusedCell);
            }
          }
        }
      }

      // f2
      if (event.key === 'F2') {
        event.preventDefault();
        me.finishEditing();
      }

      // esc
      if (event.key === 'Escape') {
        event.stopPropagation();
        event.preventDefault();
        me.cancelEditing();
      }

      // tab
      if (event.key === 'Tab') {
        event.preventDefault();

        let focusedCell = me.grid.focusedCell;

        if (focusedCell) {
          let cellInfo = me.getAdjacentEditableCell(focusedCell, !event.shiftKey);

          if (cellInfo) {
            if (me.finishEditing()) {
              me.grid.focusCell(cellInfo, {
                animate: 100
              });

              me.startEditing(cellInfo);
            }
          }
        }
      }

      // prevent arrow keys from moving editor
      if (validEditingKeys[event.key]) {
        event.handled = true;
      }
    }
  }

  onElementMouseDown(event) {
    // If it's a contextmenu mousedown during cell edit, prevent default
    // because the contextmenu handler will move focus directly to the context menu.
    // If we allow it to go through the grid, the edit will not terminate because
    // that usually means begin editing somewhere else in the grid.
    // TODO: This won't be necessary when cells are the focusable DOM unit.
    if (event.button === 2 && this.editorContext) {
      event.preventDefault();
    }
  }

  /**
   * Cancel editing on widget focusout
   * @private
   */
  onEditorFocusOut(event) {
    const me = this,
      { grid } = me;

    // If the editor is not losing focus as a result of its tidying up process
    // And focus is moving to outside of the grid, or back to the initiating cell
    // (which indicates a click on empty space below rows), then explicitly terminate.
    if (
      me.editorContext &&
      !me.editor.isFinishing &&
      me.editor.inputField.owns(event.target) &&
      (event.toWidget !== grid || grid.isLocationEqual(me.grid.focusedCell, me.editorContext.selector))
    ) {
      if (me.blurAction === 'cancel') {
        me.cancelEditing();
      } else {
        me.finishEditing();
      }
    }
  }

  onEditorFocusIn(event) {
    const widget = event.toWidget;

    if (widget === this.editor.inputField) {
      if (this.autoSelect && widget.selectAll && !widget.readOnly && !widget.disabled) {
        widget.selectAll();
      }
    }
  }

  /**
   * Cancel edit on touch outside of grid for mobile Safari (focusout not triggering unless you touch something focusable)
   * @private
   */
  onTapOut({ event }) {
    const me = this;

    if (!me.grid.bodyContainer.contains(event.target)) {
      if (!me.editor.inputField.owns(event.target)) {
        if (me.blurAction === 'cancel') {
          me.cancelEditing();
        } else {
          me.finishEditing();
        }
      }
    }
  }

  /**
   * Finish editing if clicking below rows (only applies when grid is higher than rows).
   * @private
   * @category Internal event handling
   */
  onElementClick(event) {
    const me = this;
    if (event.target.classList.contains('b-grid-body-container') && me.editorContext) {
      me.finishEditing();
    }
  }

  //endregion
}

CellEdit.featureClass = 'b-cell-edit';

CellEdit._$name = 'CellEdit';
GridFeatureManager.registerFeature(CellEdit, true);

/**
 * @module Grid/feature/ColumnDragToolbar
 */

/**
 * Displays a toolbar while dragging column headers. Drop on a button in the toolbar to activate a certain function,
 * for example to group by that column. This feature simplifies certain operations on touch devices.
 *
 * This feature is <strong>disabled</strong> by default, but turned on automatically on touch devices.
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @classtype columnDragToolbar
 * @externalexample feature/ColumnDragToolbar.js
 */
class ColumnDragToolbar extends Delayable(InstancePlugin) {
  //region Config

  // Plugin configuration. This plugin chains some of the functions in Grid
  static get pluginConfig() {
    return {
      after: ['render']
    };
  }

  //endregion

  //region Init

  construct(grid, config) {
    if (grid.features.columnReorder) {
      grid.features.columnReorder.on('beforedestroy', this.onColumnReorderBeforeDestroy, this);
    }

    this.grid = grid;

    super.construct(grid, config);
  }

  doDestroy() {
    const me = this;

    if (me.grid.features.columnReorder && !me.grid.features.columnReorder.isDestroyed) {
      me.detachFromColumnReorder();
    }

    me.element && me.element.remove();
    me.element = null;
    super.doDestroy();
  }

  init() {
    const me = this,
      grid = me.grid;

    if (!grid.features.columnReorder) {
      return;
    }

    me.reorderDetacher = grid.features.columnReorder.on({
      gridheaderdragstart({ context }) {
        const column = grid.columns.getById(context.element.dataset.columnId);
        me.showToolbar(column);
      },

      gridheaderdrag: ({ context }) => me.onDrag(context),

      gridheaderabort: () => {
        me.hideToolbar();
      },

      gridheaderdrop: ({ context }) => {
        if (context.valid) {
          me.hideToolbar();
        } else {
          me.onDrop(context);
        }
      }
    });

    me.initialized = true;
  }

  onColumnReorderBeforeDestroy() {
    this.detachFromColumnReorder();
  }

  detachFromColumnReorder() {
    const me = this;

    me.grid.features.columnReorder.un('beforedestroy', me.onColumnReorderBeforeDestroy, me);

    me.reorderDetacher && me.reorderDetacher();
    me.reorderDetacher = null;
  }

  /**
   * Initializes this feature on grid render.
   * @private
   */
  render() {
    if (!this.initialized) this.init();
  }

  //endregion

  //region Toolbar

  showToolbar(column) {
    const me = this,
      buttons = me.grid.getColumnDragToolbarItems(column, []),
      groups = [];

    me.clearTimeout(me.buttonHideTimer);
    me.clearTimeout(me.toolbarHideTimer);

    buttons.forEach((button) => {
      let group = groups.find((group) => group.text === button.group);
      if (!group) {
        group = { text: button.group, buttons: [] };
        groups.push(group);
      }

      group.buttons.push(button);
    });

    me.element = DomHelper.append(me.grid.element, me.template(groups));

    me.groups = groups;
    me.buttons = buttons;
    me.column = column;
  }

  hideToolbar() {
    const me = this;

    return new Promise((resolve) => {
      if (me.element && !me.toolbarHideTimer) {
        me.element.classList.add('b-remove');

        // TODO: use AnimationHelper when available
        me.toolbarHideTimer = me.setTimeout(() => {
          me.toolbarHideTimer = null;
          me.element && me.element.remove();
          me.element = null;
          resolve();
        }, 200);
      }
    });
  }

  //endregion

  //region Events

  onDrag(info) {
    const me = this;

    if (info.dragProxy.getBoundingClientRect().top - me.grid.element.getBoundingClientRect().top > 100) {
      me.element.classList.add('b-closer');
    } else {
      me.element.classList.remove('b-closer');
    }

    if (me.hoveringButton) {
      me.hoveringButton.classList.remove('b-hover');
      me.hoveringButton = null;
    }

    if (info.targetElement && info.targetElement.closest('.b-columndragtoolbar')) {
      me.element.classList.add('b-hover');

      let button = info.targetElement.closest('.b-columndragtoolbar  .b-target-button:not([data-disabled=true])');
      if (button) {
        button.classList.add('b-hover');
        me.hoveringButton = button;
      }
    } else {
      me.element.classList.remove('b-hover');
    }
  }

  onDrop(info) {
    const me = this;

    if (
      info.targetElement &&
      info.targetElement.matches('.b-columndragtoolbar .b-target-button:not([data-disabled=true])')
    ) {
      const buttonEl = info.targetElement,
        button = me.buttons.find((button) => button.name === buttonEl.dataset.name);

      if (button) {
        buttonEl.classList.add('b-activate');

        me.buttonHideTimer = me.setTimeout(() => {
          me.hideToolbar();
          button.onDrop({ column: me.column });
        }, 100);
      }
    } else {
      me.hideToolbar();
    }
  }

  //endregion

  template(groups) {
    return TemplateHelper.tpl`
            <div class="b-columndragtoolbar">     
            <div class="b-title"></div>          
            ${groups.map(
              (group) => TemplateHelper.tpl`
                <div class="b-group">
                    <div class="b-buttons">
                    ${group.buttons.map(
                      (btn) => TemplateHelper.tpl`
                        <div class="b-target-button" data-name="${btn.name}" data-disabled="${btn.disabled}">
                            <i class="${btn.icon}"></i>
                            ${btn.text}
                        </div>
                    `
                    )}
                    </div>
                    <div class="b-title">${group.text}</div>
                </div>
            `
            )}
            </div>`;
  }
}

ColumnDragToolbar.featureClass = 'b-hascolumndragtoolbar';

// used by default on touch devices, can be enabled otherwise
ColumnDragToolbar._$name = 'ColumnDragToolbar';
GridFeatureManager.registerFeature(ColumnDragToolbar, BrowserHelper.isTouchDevice);

/**
 * @module Grid/feature/ColumnPicker
 */

/**
 * Displays a column picker (to show/hide columns) in the header context menu. Columns can be displayed in sub menus
 * by region or tag. Grouped headers are displayed as menu hierarchies.
 *
 * This feature is <strong>enabled</strong> by default.
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @demo columns
 * @classtype columnPicker
 * @externalexample feature/ColumnPicker.js
 */
class ColumnPicker extends InstancePlugin {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Groups columns in the picker by region (each region gets its own sub menu)
       * @config {Boolean}
       * @default
       */
      groupByRegion: false,

      /**
       * Groups columns in the picker by tag, each column may be shown under multiple tags. See
       * {@link Grid.column.Column#config-tags}
       * @config {Boolean}
       * @default
       */
      groupByTag: false
    };
  }

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['getHeaderMenuItems', 'getColumnDragToolbarItems']
    };
  }

  //endregion

  //region Init

  construct(grid, config) {
    this.grid = grid;
    super.construct(grid, config);
  }

  //endregion

  //region Context menu

  /**
   * Get menu items, either a straight list of columns or sub menus per subgrid
   * @private
   * @param columnStore Column store to traverse
   * @returns {Object[]} Menu item configs
   */
  getColumnPickerItems(columnStore) {
    const me = this;

    if (me.groupByRegion) {
      // submenus for grids regions
      return me.grid.regions.map((region) => {
        const columns = me.grid.getSubGrid(region).columns.records;

        return {
          text: StringHelper.capitalizeFirstLetter(region),
          menu: me.buildColumnMenu(columns),
          disabled: columns.length === 0,
          region: region
        };
      });
    } else if (me.groupByTag) {
      // submenus for column tags
      const tags = {};
      columnStore.forEach((column) => {
        column.tags &&
          column.hideable &&
          column.tags.forEach((tag) => {
            if (!tags[tag]) {
              tags[tag] = 1;
            }
          });
      });

      // TODO: as checkitems, but how to handle toggling? hide a column only when all tags for it are unchecked?
      return Object.keys(tags)
        .sort()
        .map((tag) => ({
          text: StringHelper.capitalizeFirstLetter(tag),
          menu: me.buildColumnMenu(me.getColumnsForTag(tag)),
          tag: tag,
          onBeforeSubMenu: ({ item, itemEl }) => {
            me.refreshTagMenu(item, itemEl);
          }
        }));
    } else {
      // all columns in same menu
      return me.buildColumnMenu(columnStore.records);
    }
  }

  /**
   * Get all columns that has the specified tag
   * TODO: if tags are useful from somewhere else, move to ColumnStore
   * @private
   * @param tag
   * @returns {Grid.column.Column[]}
   */
  getColumnsForTag(tag) {
    // TODO: if tags are usefull from somewhere else, move to ColumnStore
    return this.grid.columns.records.filter(
      (column) => column.tags && column.tags.includes(tag) && column.hideable !== false
    );
  }

  /**
   * Refreshes checked status for a tag menu. Needed since columns can appear under multiple tags.
   * @private
   */
  refreshTagMenu(item, itemEl) {
    const columns = this.getColumnsForTag(item.tag);
    columns.forEach((column) => {
      const subItem = item.items.find((subItem) => subItem.column === column);
      if (subItem) subItem.checked = column.hidden !== true;
    });
  }

  /**
   * Traverses columns to build menu items for the column picker.
   * @private
   */
  buildColumnMenu(columns) {
    let currentRegion = columns.length > 0 && columns[0].region,
      { grid } = this;

    return columns.reduce((items, column) => {
      const visibleInRegion = this.grid.columns.visibleColumns.filter((col) => col.region === column.region);

      if (column.hideable !== false) {
        const itemConfig = {
          grid,
          text: column.text,
          column: column,
          name: column.id,
          checked: column.hidden !== true,
          disabled: column.hidden !== true && visibleInRegion.length === 1,
          cls: column.region !== currentRegion ? 'b-separator' : ''
        };

        currentRegion = column.region;

        if (column.children) {
          itemConfig.menu = this.buildColumnMenu(column.children);
        }

        items.push(itemConfig);
      }
      return items;
    }, []);
  }

  /**
   * Supply items for headers context menu.
   * @private
   * @param column Header for this column
   * @param items Array of items to add to
   * @returns {Object[]} Modified items
   */
  getHeaderMenuItems(column, items) {
    const me = this,
      { grid } = me,
      { columns } = grid;

    if (column.showColumnPicker !== false && columns.some((col) => col.hideable)) {
      // column picker
      items.push({
        text: me.L('columnsMenu'),
        name: 'columnPicker',
        icon: 'b-fw-icon b-icon-columns',
        cls: 'b-separator',
        weight: 100,
        menu: me.getColumnPickerItems(columns),
        onToggle: me.onColumnToggle
      });
    }

    // menu item for hiding this column
    if (column.hideable !== false) {
      const visibleInRegion = columns.visibleColumns.filter((col) => col.region === column.region);

      items.push({
        text: me.L('hideColumn'),
        icon: 'b-fw-icon b-icon-hide-column',
        weight: 101,
        name: 'hideColumn',
        disabled: visibleInRegion.length === 1,
        onItem: () => column.hide()
      });
    }
  }

  /**
   * Handler for column hide/show menu checkitems.
   * @private
   * @param {Object} The {@link Common.widget.MenuItem#event-toggle} event.
   */
  onColumnToggle({ menu, item, checked }) {
    if (!!item.column.hidden !== !checked) {
      item.column[checked ? 'show' : 'hide']();

      const { grid, column } = item,
        { columns } = grid,
        // Sibling items, needed to disable other item if it is the last one in region
        siblingItems = menu.items,
        // Columns left visible in same region as this items column
        visibleInRegion = columns.visibleColumns.filter((col) => col.region === item.column.region),
        // Needed to access "hide-column" item outside of column picker
        { currentMenu } = grid.features.contextMenu,
        // TODO: When we have actual MenuItems there should be a way to store the item and not have to look it up
        hideItem = currentMenu.items.find((item) => item.name === 'hideColumn');

      // Do not allow user to hide the last column in any region
      if (visibleInRegion.length === 1) {
        const lastVisibleItem = siblingItems.find((i) => i.name === visibleInRegion[0].id);
        if (lastVisibleItem) {
          lastVisibleItem.disabled = true;
        }

        // Also disable "Hide column" item if only one column left in this region
        if (hideItem && column.region === item.column.region) {
          hideItem.disabled = true;
        }
      }
      // Multiple columns visible, enable "hide-column" and all items for that region
      else {
        visibleInRegion.forEach((col) => {
          const siblingItem = siblingItems.find((sibling) => sibling.column === col);
          if (siblingItem) {
            siblingItem.disabled = false;
          }
        });

        if (hideItem && column.region === item.column.region) {
          hideItem.disabled = false;
        }
      }

      if (item.menu) {
        // Reflect status in submenu.
        // Cannot use short form () => foo because eachWidget aborts on return of false
        item.menu.eachWidget((subItem) => {
          subItem.checked = checked;
        });
      }

      const parentItem = menu.owner;
      if (parentItem && parentItem.column === column.parent) {
        const anyChecked = siblingItems.some((subItem) => subItem.checked === true);
        parentItem.checked = anyChecked;
      }
    }
  }

  /**
   * Supply items to ColumnDragToolbar
   * @private
   */
  getColumnDragToolbarItems(column, items) {
    const visibleInRegion = this.grid.columns.visibleColumns.filter((col) => col.region === column.region);

    if (column.hideable !== false && visibleInRegion.length > 1) {
      items.push({
        text: this.L('hideColumnShort'),
        group: this.L('Column'),
        icon: 'b-fw-icon b-icon-hide-column',
        weight: 101,
        name: 'hideColumn',
        onDrop: ({ column }) => column.hide()
      });
    }
    return items;
  }

  //endregion
}

ColumnPicker._$name = 'ColumnPicker';
GridFeatureManager.registerFeature(ColumnPicker, true);

// TODO: Make this work for grouped columns

/**
 * @module Grid/feature/ColumnReorder
 */

/**
 * Allows user to reorder columns by dragging headers. To get notified about column reorder listen to `change` event
 * on {@link Grid.data.ColumnStore columns} store.
 *
 * This feature is <strong>enabled</strong> by default.
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @demo columns
 * @classtype columnReorder
 * @externalexample feature/ColumnReorder.js
 */
class ColumnReorder extends Delayable(InstancePlugin) {
  //region Init

  construct(grid) {
    this.ignoreSelectors = ['.b-grid-header-resize-handle', '.b-field'];

    this.grid = grid;

    super.construct(grid);
  }

  doDestroy() {
    this.dragHelper && this.dragHelper.destroy();

    super.doDestroy();
  }

  /**
   * Initialize drag & drop (called from render)
   * @private
   */
  init() {
    const me = this,
      { grid } = me,
      gridEl = grid.element,
      containers = DomHelper.children(gridEl, '.b-grid-headers');

    containers.push(...DomHelper.children(gridEl, '.b-grid-header-children'));

    if (me.dragHelper) {
      // update the dragHelper with the new set of containers it should operate upon
      me.dragHelper.containers = containers;
    } else {
      me.dragHelper = new DragHelper({
        name: 'columnReorder',
        mode: 'container',
        dragThreshold: 10,
        targetSelector: '.b-grid-header',
        outerElement: gridEl.querySelector('header.b-grid-header-container'),
        containers,
        isElementDraggable(element) {
          const abort = Boolean(DomHelper.up(element, me.ignoreSelectors.join(',')));

          if (abort) {
            return false;
          }

          const columnEl = DomHelper.up(element, this.targetSelector),
            column = columnEl && grid.columns.getById(columnEl.dataset.columnId),
            isLast = column && column.childLevel === 0 && grid.subGrids[column.region].columns.count === 1;

          // TODO: If we want to prevent dragging last column out of group we can use the code below...
          /*isLast = column.level !== 0
                            // In grouped header, do not allow dragging last remaining child
                            ? column.parent.children.length === 1
                            // Not in a grouped header, do not allow dragging last remaining column
                            : grid.subGrids[column.region].columns.count === 1;*/

          return Boolean(column) && column.draggable !== false && !isLast;
        },
        ignoreSelector: '.b-filter-icon,.b-grid-header-resize-handle',
        listeners: {
          dragstart: me.onDragStart,
          drag: me.onDrag,
          drop: me.onDrop,
          thisObj: me
        }
      });

      me.relayEvents(me.dragHelper, ['dragstart', 'drag', 'drop', 'abort'], 'gridheader');
    }
  }

  //endregion

  //region Plugin config

  // Plugin configuration. This plugin chains some of the functions in Grid
  static get pluginConfig() {
    return {
      after: ['render', 'renderContents']
    };
  }

  //endregion

  //region Events (drop)

  onDrag({ context, event }) {
    const me = this,
      targetHeader = IdHelper.fromElement(event.target, 'header');

    // If SubGrid is configured with a sealed column set, do not allow moving into it
    if (targetHeader && targetHeader.subGrid.sealedColumns) {
      context.valid = false;
      return;
    }

    // Require that we drag inside grid header while dragging if we don't have a drag toolbar
    if (!me.grid.features.columnDragToolbar) {
      context.valid = Boolean(event.target.closest('.b-grid-headers'));
    }
  }

  onDragStart() {
    const me = this;

    if (!me.grid.features.columnDragToolbar) {
      const headerContainerBox = me.grid.element.querySelector('.b-grid-header-container').getBoundingClientRect();

      me.dragHelper.minY = headerContainerBox.top;
      me.dragHelper.maxY = headerContainerBox.bottom;
    }

    this.grid.headerContainer.classList.add('b-dragging-header');
  }

  /**
   * Handle drop
   * @private
   */
  onDrop({ context }) {
    if (!context.valid) {
      return this.onInvalidDrop({ context });
    }

    const me = this,
      grid = me.grid,
      element = context.dragging,
      onHeader = DomHelper.up(context.target, '.b-grid-header'),
      onColumn = grid.columns.get(onHeader.dataset.column),
      toRegion = context.draggedTo.dataset.region || onColumn.region,
      sibling = context.insertBefore,
      column = grid.columns.getById(element.dataset.columnId),
      insertBefore = sibling
        ? grid.columns.getById(sibling.dataset.columnId)
        : grid.subGrids[toRegion].columns.last.nextSibling,
      newParent = insertBefore ? insertBefore.parent : grid.columns.rootNode;

    grid.headerContainer.classList.remove('b-dragging-header');

    // Dropped into its current position in the same SubGrid - abort
    if (toRegion === column.region && onColumn === column.previousSibling) {
      me.dragHelper.abort();
      return;
    }

    // Check if we should remove last child
    const emptyParent = column.parent && column.parent.children.length === 1 && column.parent;

    if (emptyParent) {
      emptyParent.parent.removeChild(emptyParent);
    }

    // Clean up element used during drag drop as it will not be removed by Grid when it refreshes its header elements
    element.remove();

    column.region = toRegion;

    // Insert the column into its new place
    newParent.insertChild(column, insertBefore);
  }

  /**
   * Handle invalid drop
   * @private
   */
  onInvalidDrop({ context }) {
    this.grid.headerContainer.classList.remove('b-dragging-header');
  }

  //endregion

  //region Render

  /**
   * Updates DragHelper with updated headers when grid contents is rerendered
   * @private
   */
  renderContents() {
    // columns shown, hidden or reordered
    this.init();
  }

  /**
   * Initializes this feature on grid render.
   * @private
   */
  render() {
    // always reinit on render
    this.init();
  }

  //endregion
}

ColumnReorder.featureClass = 'b-column-reorder';

ColumnReorder._$name = 'ColumnReorder';
GridFeatureManager.registerFeature(ColumnReorder, true);

/**
 * @module Grid/feature/ColumnResize
 */

/**
 * Enables user to resize columns by dragging a handle on the righthand side of the header. To get notified about column
 * resize listen to `change` event on {@link Grid.data.ColumnStore columns} store.
 *
 * This feature is <strong>enabled</strong> by default.
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @demo columns
 * @classtype columnResize
 * @externalexample feature/ColumnResize.js
 */
class ColumnResize extends InstancePlugin {
  static get defaultConfig() {
    return {
      /**
       * Resize all cells below a resizing header during dragging.
       * `'auto'` means `true` on non-mobile platforms.
       * @config {String/Boolean}
       * @default
       */
      liveResize: 'auto'
    };
  }

  //region Init

  construct(grid, config) {
    const me = this;

    me.grid = grid;

    super.construct(grid, config);

    me.resizer = new ResizeHelper({
      name: 'columnResize',
      targetSelector: '.b-grid-header',
      handleSelector: '.b-grid-header-resize-handle',
      outerElement: grid.element,
      listeners: {
        resizestart: me.onResizeStart,
        resizing: me.onResizing,
        resize: me.onResize,
        thisObj: me
      }
    });
  }

  //endregion

  // This plugin needs no functions chaining into the client grid
  static get pluginConfig() {
    return [];
  }

  set liveResize(liveResize) {
    if (liveResize === 'auto') {
      liveResize = !BrowserHelper.isMobileSafari;
    }
    this._liveResize = liveResize;
  }

  get liveResize() {
    return this._liveResize;
  }

  doDestroy() {
    this.resizer && this.resizer.destroy();
    super.doDestroy();
  }

  //region Events

  onResizeStart({ context }) {
    const me = this,
      column = (context.column = me.grid.columns.getById(context.element.dataset.columnId));

    me.resizer.minWidth = column.minWidth;

    // remove minWidth value as it's used as a rendering workaround for IE flexbox bugs
    context.element.style.minWidth = '';

    me.grid.element.classList.add('b-column-resizing');
  }

  /**
   * Handle drag event - resize the column live unless it's a touch gesture
   * @private
   */
  onResizing({ context }) {
    if (context.valid && this.liveResize) {
      this.grid.dragResizing = true;
      context.column.width = context.newWidth;
    }
  }

  /**
   * Handle drop event (only used for touch)
   * @private
   */
  onResize({ context }) {
    const me = this,
      column = context.column;

    me.grid.element.classList.remove('b-column-resizing');

    if (context.valid) {
      if (me.liveResize) {
        me.grid.dragResizing = false;
        me.grid.afterColumnsResized();
      } else {
        context.column.width = context.newWidth;
      }

      // In case of IE 11 we should calculate flex basis to fix header width
      // covered by ColumnResize.t
      if (BrowserHelper.isIE11 && column.parent && column.parent.flex) {
        const parent = column.parent,
          headerEl = me.grid.getHeaderElement(parent.id);

        headerEl.style.flexBasis =
          parent.children.reduce((result, column) => {
            return result + me.grid.getHeaderElement(column.id).offsetWidth;
          }, 0) + 'px';
      }
    }
  }

  /**
   * Start resizing on touch start. Only cares about the first touch.
   * @private
   * @param event
   */
  /*onElementTouchStart(event) {
     const me     = this,
     target = event.target;

     if (target.classList.contains('b-resizer')) {
     me.startResize(target, event.touches[0].clientX);
     event.preventDefault();
     }
     }*/

  /**
   * Update size on touch move.
   * @private
   * @param event
   */
  /*onElementTouchMove(event) {
     if (this.element) {
     this.updateResize(event.touches[0].clientX);
     event.preventDefault();
     }
     }*/

  /**
   * Stop resizing on touch end.
   * @private
   * @param event
   * @returns {Boolean}
   */
  /*onElementTouchEnd(event) {
     if (this.element) {
     this.endResize();
     event.preventDefault();
     return false;
     }
     }*/

  //endregion
}

ColumnResize.featureClass = 'b-column-resize';

ColumnResize._$name = 'ColumnResize';
GridFeatureManager.registerFeature(ColumnResize, true);

//TODO: Context menu should hide when clicking elsewhere

/**
 * @module Grid/feature/ContextMenu
 */

/**
 * Right click to display context menu for headers and cells. Items for the menu are requested by calling
 * {@link Grid.view.Grid#function-getHeaderMenuItems Grid.getHeaderMenuItems()} or
 * {@link Grid.view.Grid#function-getCellMenuItems Grid.getCellMenuItems()} (see {@link Grid.feature.Sort Sort} feature).
 * It is also possible to add items via the features config and via column configs. See examples below.
 *
 * Add extra items to both header and cell for all columns:
 *
 * ```javascript
 * // Extra items for all columns
 * const grid = new Grid({
 *   features: {
 *     contextMenu: {
 *       headerItems: [
 *         { text: 'My header item', icon: 'fa fa-car', weight: 200, onItem : () => ... }
 *       ],
 *
 *       cellItems: [
 *         { text: 'My cell item', icon: 'fa fa-bus', weight: 200, onItem : () => ... }
 *       ]
 *     }
 *   }
 * });
 * ```
 *
 * Add extra items to both header and cell for a single column:
 *
 * ```javascript
 * // Extra items for single column
 * const grid = new Grid({
 *   columns: [
 *     { field: 'name', text: 'Name', headerMenuItems: [
 *       { text: 'My unique header item', icon: 'fa fa-flask', onItem : () => ... }
 *     ]},
 *     { field: 'city', text: 'City', cellMenuItems: [
 *       { text: 'My unique cell item', icon: 'fa fa-beer', onItem : () => ... }
 *     ]},
 *   ]
 * });
 * ```
 *
 * It is also possible to manipulate the default items and add new ones in a processing function (same pattern applies
 * for header menu):
 *
 * ```javascript
 * const grid = new Grid({
 *   features: {
 *     contextMenu: {
 *       processCellItems({items, record}) {
 *           if (record.cost > 5000) {
 *              items.push({ text : 'Split cost' });
 *           }
 *       }
 *     }
 *   }
 * });
 * ```
 *
 * This feature is <strong>enabled</strong> by default.
 *
 * @extends Common/mixin/InstancePlugin
 * @demo filtering
 * @classtype contextMenu
 * @externalexample feature/ContextMenu.js
 */
class ContextMenu extends InstancePlugin {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Extra items to add to the header context menu. See {@link Common.widget.MenuItem} for more info.
       *
       * ```javascript
       * features : {
       *     contextMenu : {
       *         headerItems : [
       *             { text : 'Header item', onItem : () => ... }
       *         ]
       *     }
       * }
       * ```
       *
       * @config {Object[]}
       */
      headerItems: [],

      /**
       * A function called before displaying the header menu that allows manipulations of its items. Called with a
       * single parameter with format { column, items }. Returning `false` from this function prevents
       * the menu from being shown.
       *
       * ```javascript
       * features : {
       *     contextMenu : {
       *         processHeaderItems({record, items}) {
       *             // Add or remove items here as needed
       *             if (column.field === 'age') {
       *                 items.push({ text: 'Hide youngsters', icon : 'b-fa b-fa-fw b-fa-baby' })
       *             }
       *         }
       *     }
       * }
       * ```
       *
       * @config {Function}
       */
      processHeaderItems: null,

      /**
       * Extra items to add to the cell context menu. See {@link Common.widget.MenuItem} for more info.
       *
       * ```javascript
       * features : {
       *     contextMenu : {
       *         cellItems : [
       *             { text : 'Cell item', onItem : () => ... }
       *         ]
       *     }
       * }
       * ```
       *
       * @config {Object[]}
       */
      cellItems: [],

      /**
       * A function called before displaying the cell menu that allows manipulations of its items. Called with a
       * single parameter with format { record, items }. Returning `false` from this function prevents
       * the menu from being shown.
       *
       * ```javascript
       * features : {
       *     contextMenu : {
       *         processCellItems({record, items}) {
       *             // Add or remove items here as needed
       *             if (record.age > 50) {
       *                 items.push({ text: 'Add extra vacation', icon : 'b-fa b-fa-fw b-fa-umbrella-beach' })
       *             }
       *         }
       *     }
       * }
       * ```
       *
       * @config {Function}
       */
      processCellItems: null
    };
  }

  //endregion

  //region Events

  /**
   * Fired from grid before the context menu is shown for a header. Allows manipulation of the items
   * to show in the same way as in `processHeaderItems`. Returning false from a listener prevents the
   * menu from being shown.
   * @event headerContextMenuBeforeShow
   * @preventable
   * @param {Grid.view.Grid} source
   * @param {Object} items Menu item configs
   * @param {Grid.column.Column} column Column
   */

  /**
   * Fired from grid after showing the context menu for a header
   * @event headerContextMenuShow
   * @preventable
   * @param {Grid.view.Grid} source
   * @param {Common.widget.Menu} menu The menu
   * @param {Grid.column.Column} column Column
   */

  /**
   * Fired from grid before the context menu is shown for a cell. Allows manipulation of the items
   * to show in the same way as in `processCellItems`. Returning false from a listener prevents the
   * menu from being shown.
   * @event cellContextMenuBeforeShow
   * @preventable
   * @param {Grid.view.Grid} source
   * @param {Object} items Menu item configs
   * @param {Grid.column.Column} column Column
   * @param {Common.data.Model} record Record
   */

  /**
   * Fired from grid after showing the context menu for a cell
   * @event cellContextMenuShow
   * @preventable
   * @param {Grid.view.Grid} source
   * @param {Common.widget.Menu} menu The menu
   * @param {Grid.column.Column} column Column
   * @param {Common.data.Model} record Record
   */

  /**
   * Fired when an item is selected in the context menu.
   * @event contextMenuItem
   * @param {Grid.view.Grid} grid The grid
   * @param {Object} item Selected menu item
   * @param {Grid.column.Column} column Column
   * @param {HTMLElement} itemEl Menu item element
   */

  /**
   * Fired when an check item is toggled in the context menu.
   * @event contextMenuToggleItem
   * @param {Grid.view.Grid} grid The grid
   * @param {Object} item Selected menu item
   * @param {Grid.column.Column} column Column
   * @param {Boolean} checked Checked or not
   * @param {HTMLElement} itemEl Menu item element
   */

  //endregion

  //region Init

  construct(grid, config) {
    this.grid = grid;

    super.construct(grid, config);
  }

  doDestroy() {
    if (this.currentMenu) {
      this.currentMenu.destroy();
    }

    super.doDestroy();
  }

  //endregion

  //region Plugin config

  // Plugin configuration. This plugin chains some of the functions in Grid.
  // The contextmenu event is emulated from a taphold gesture on touch platforms.
  static get pluginConfig() {
    return {
      chain: ['onElementContextMenu']
    };
  }

  //endregion

  //region Events

  /**
   * Called when user right clicks.
   * @param event
   * @fires contextmenuitem
   * @fires contextmenutoggleitem
   * @private
   */
  onElementContextMenu(event) {
    const me = this,
      grid = me.grid,
      target = event.target,
      header = DomHelper.up(target, '.b-grid-header'),
      cellData = grid.getEventData(event);

    if (header) {
      me.handleHeaderContextMenu(header, event);
    } else if (cellData) {
      me.handleCellContextMenu(cellData, event);
    }
  }

  handleHeaderContextMenu(header, event) {
    if (header.dataset.column) {
      const me = this,
        grid = me.grid,
        column = grid.columns.getById(header.dataset.columnId),
        setColumn = (item) => {
          if (!item.column) {
            item.column = column;
          }

          let menu = item.menu;
          if (menu) {
            if (!Array.isArray(menu)) {
              menu = menu.items || menu.widgets;
            }
            menu.forEach(setColumn);
          }
        };

      if (column.enableHeaderContextMenu !== false) {
        // User's items for all headers and for specific column correspondingly. Check Context Menu demo for details.
        const items = [...me.headerItems, ...(column.headerMenuItems || [])],
          { processHeaderItems } = me,
          eventParams = { items, column, event, element: header };

        // getHeaderMenuItems() is chained by mixins, thus each feature can supply items
        grid.getHeaderMenuItems(column, items);

        if ((!processHeaderItems || processHeaderItems(eventParams) !== false) && items.length > 0) {
          event.preventDefault();

          items.sort((a, b) => (a.weight || 150) - (b.weight || 150));

          // Propagate the operating column down to all MenuItem levels
          // Will not override if they are preconfigured with a column.
          items.forEach(setColumn);

          // Trigger event that allows preventing menu or manipulating its items
          if (grid.trigger('headerContextMenuBeforeShow', eventParams) !== false) {
            // Align to header element when using arrow down key
            me.currentMenu = WidgetHelper.showContextMenu(
              event.type === 'keydown' ? header : [event.clientX + 1, event.clientY + 1],
              {
                owner: me.client,
                constrainTo: document,
                cls: 'b-context-menu',
                items: items,

                // We can only realign if we are aligning to an element.
                scrollAction: 'hide',
                onItem({ source, item, element }) {
                  grid.trigger('contextMenuItem', { source: grid, item, column, element });
                },

                onToggle({ source, item, checked, element }) {
                  grid.trigger('contextMenuToggleItem', {
                    source: grid,
                    item,
                    column,
                    checked,
                    element
                  });
                },

                onDestroy() {
                  // If menu is destroyed by WidgetHelper, make sure we don't keep a reference to it anymore
                  me.currentMenu = null;
                },

                listeners: {
                  show({ source: menu }) {
                    eventParams.menu = menu;
                    grid.trigger('headerContextMenuShow', eventParams);
                  }
                }
              }
            );
          }
        }
      }
    }
  }

  handleCellContextMenu(cellData, event) {
    const me = this,
      grid = me.grid,
      cell = cellData.cellElement,
      column = grid.columns.getById(cellData.columnId);

    if (column.enableCellContextMenu !== false) {
      // Process the gesture as navigation so that the use may select/multiselect
      // the items to include in their context menu operation.
      // Also select if not already selected.
      grid.focusCell(cellData.cellSelector, {
        doSelect: !grid.isSelected(cellData.id),
        event
      });

      const record = cellData.record,
        items = [...(me.cellItems || []), ...(column.cellMenuItems || [])],
        { processCellItems } = me,
        eventParams = { items, column, event, record, element: cell };

      // getCellMenuItems() is chained by mixins, thus each feature can supply items
      grid.getCellMenuItems(column, record, items);

      if ((!processCellItems || processCellItems(eventParams) !== false) && items.length > 0) {
        items.forEach((item) => {
          item.column = column;
          item.record = record;
        });

        event.preventDefault();

        items.sort((a, b) => (a.weight || 150) - (b.weight || 150));

        // Trigger event that allows preventing menu or manipulating its items
        if (grid.trigger('cellContextMenuBeforeShow', eventParams) !== false) {
          me.currentMenu = WidgetHelper.showContextMenu([event.clientX + 1, event.clientY + 1], {
            owner: me.client,
            items: items,

            // Load up the item event with the contextual info
            onBeforeItem: (itemEvent) => {
              Object.assign(itemEvent, eventParams);
            },

            onItem({ item }) {
              grid.trigger('contextMenuItem', { source: grid, item, column, record, cell });
            },

            onClose({ reason }) {
              // return focus to grid when context menu is closed, if not cause by clicking outside of grid
              if (reason !== 'outside') {
                grid.element.focus();
              }
            },

            onDestroy() {
              // If menu is destroyed by WidgetHelper, make sure we don't keep a reference to it anymore
              me.currentMenu = null;
            },

            listeners: {
              show({ source: menu }) {
                eventParams.menu = menu;
                grid.trigger('cellContextMenuShow', eventParams);
              }
            }
          });
        }
      }
    }
  }

  /**
   * Hides the context menu
   * @protected
   * @internal
   */
  hideContextMenu(animate) {
    this.currentMenu && this.currentMenu.hide(animate);
  }

  //endregion
}

ContextMenu.featureClass = '';

ContextMenu._$name = 'ContextMenu';
GridFeatureManager.registerFeature(ContextMenu, true);

/**
 * @module Common/data/DomDataStore
 */

/**
 * Stores data on a dom element (by setting element._domData).
 * Instead of using HTML5:s element.dataset, which turned out to be slow.
 * @private
 */
class DomDataStore {
  /**
   * Get data that is connected to specified element.
   * @param {HTMLElement} element DOM element
   * @param {String} [key] The name of the property in the element data to return;
   * @returns {Object} Data
   */
  static get(element, key) {
    const result = element._domData || (element._domData = {});

    if (key != null) {
      return result[key];
    }
    return result;
  }

  /**
   * Set data connected to specified element (completely replacing any existing).
   * To update data, use DomDataStore#assign instead.
   * @param {HTMLElement} element DOM element
   * @param {Object|String} data Data object to set, or property name to set
   * @param {*} [value] If the previous parameter was a property name, this is the value to set.
   */
  static set(element, data, value) {
    if (arguments.length === 3) {
      (element._domData || (element._domData = {}))[data] = value;
    } else {
      element._domData = data;
    }
  }

  /**
   * Updates data connected to specified element.
   * @param element DOM element
   * @param data Data to assign
   */
  static assign(element, data) {
    Object.assign(element._domData || (element._domData = {}), data);
  }
}
DomDataStore._$name = 'DomDataStore';

/**
 * @module Grid/feature/CellTooltip
 */

/**
 * Displays a tooltip when hovering cells. Contents can be customized by specifying a global `tooltipRenderer` function
 * for the feature and/or on a per column basis.
 *
 * Configuration properties passed into this feature are used to configure the {@link Common.widget.Tooltip} instance
 * used.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @example
 * // Enable CellTooltip and configure it to show the cell's full value
 * let grid = new Grid({
 *   features: {
 *     cellTooltip: ({value}) => value
 *   }
 * });
 *
 * // Column with its own tooltip renderer
 * {
 *   text            : 'Name',
 *   field           : 'name',
 *   tooltipRenderer : ({ record }) => `My name is\xa0<b>${record.name}</b>`
 * }
 *
 * // Async tooltip with some custom settings
 * let grid = new Grid({
 *   features: {
 *     cellTooltip: {
 *       // Time that mouse needs to be over cell before tooltip is shown
 *       hoverDelay : 4000,
 *       // Time after mouse out to hide the tooltip, 0 = instantly
 *       hideDelay  : 0,
 *       // Async tooltip renderer
 *       tooltipRenderer({ record, tip }) {
 *         // Initiate some async action
 *         AjaxHelper.get(`tooltip.php?id=${record.id}`).then(() => {
 *             tip.html = 'Async content here...';
 *         });
 *
 *         // Signal async tooltip. The tooltip will display a load mask until its html is updated (above)
 *         return false;
 *       }
 *     }
 *   }
 * });
 *
 * @demo celltooltip
 * @classtype cellTooltip
 * @externalexample feature/CellTooltip.js
 */
class CellTooltip extends InstancePlugin {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Function called to generated html for the contents of the a cells tooltip. Called with a single argument
       * with format `{ cellElement, record, column, tip, cellTooltip, event }`. Return a html string, or false to
       * flag that it will be done async
       * @config {Function}
       */
      tooltipRenderer: null
    };
  }

  //endregion

  // region Init

  construct(grid, config) {
    const me = this;

    super.construct(grid, me.processConfig(config));

    me.tip = new Tooltip(
      Object.assign(
        {
          forElement: grid.element,
          forSelector: '.b-grid-cell',
          hoverDelay: 1000,
          trackMouse: false,
          cls: 'b-celltooltip-tip',
          getHtml: me.getTooltipContent.bind(me),
          listeners: {
            pointerOver: 'onPointerOver',
            thisObj: me
          }
        },
        config
      )
    );
    me.relayEvents(me.tip, ['beforeshow', 'show']);
  }

  onPointerOver({ target }) {
    const column = this.client.getColumnFromElement(target);

    // Veto onPointerOver if column's tooltipRenderer is false
    return column.tooltipRenderer !== false;
  }

  // CellTooltip feature handles special config cases, where user can supply a function to use as tooltipRenderer
  // instead of a normal config object
  processConfig(config) {
    if (typeof config === 'function') {
      return {
        tooltipRenderer: config
      };
    }

    return config;
  }

  // override setConfig to process config before applying it (used mainly from ReactGrid)
  setConfig(config) {
    super.setConfig(this.processConfig(config));
  }

  doDestroy() {
    this.tip.destroy();
    super.doDestroy();
  }

  //endregion

  //region Content

  /**
   * Called from Tooltip to populate it with html.
   * @private
   */
  getTooltipContent({ tip, forElement: cellElement, event }) {
    const me = this,
      record = me.client.getRecordFromElement(cellElement),
      column = me.client.getColumnFromElement(cellElement);

    let result;

    // If we have not changed context, we should not change content.
    if (record === me.lastRecord && column === me.lastColumn) {
      return me.tip._html;
    }

    // first, use columns tooltipRenderer if any
    if (column.tooltipRenderer) {
      result = column.tooltipRenderer({ cellElement, record, column, event, tip, cellTooltip: me });
    }
    // secondly, try features renderer (but specifying column.tooltipRenderer as false prevents tooltip in that column)
    else if (me.tooltipRenderer && column.tooltipRenderer !== false) {
      result = me.tooltipRenderer({ cellElement, record, column, event, tip, cellTooltip: me });
    }

    if (result != null) {
      me.lastRecord = record;
      me.lastColumn = column;
    }
    return result;
  }

  //endregion
}

CellTooltip._$name = 'CellTooltip';
GridFeatureManager.registerFeature(CellTooltip);

//TODO: Format value in header filter tooltip (see date)

/**
 * @module Grid/feature/Filter
 */

/**
 * Feature that allows filtering of the grid by settings filters on columns. The actual filtering is done by the store.
 * For info on programmatically handling filters, see {@link Common.data.mixin.StoreFilter StoreFilter}.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @example
 * // Filtering turned on but no default filter
 * let grid = new Grid({
 *   features : {
 *     filter : true
 *   }
 * });
 *
 * // Using default filter
 * let grid = new Grid({
 *   features : {
 *     filter : { property : 'city', value : 'Gavle' }
 *   }
 * });
 *
 * // Custom filtering function for a column
 * let grid = new Grid({
 *    features : {
 *        filter : true
 *    },
 *
 *    columns: [
 *        {
 *          field      : 'age',
 *          text       : 'Age',
 *          type       : 'number',
 *          // Custom filtering function that checks "greater than" no matter which field user filled in :)
 *          filterable : ({ record, value, operator }) => record.age > value
 *        }
 *    ]
 * });
 *
 * @demo filtering
 * @classtype filter
 * @externalexample feature/Filter.js
 */
class Filter extends InstancePlugin {
  //region Init

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['renderHeader', 'getCellMenuItems', 'getHeaderMenuItems', 'onElementClick']
    };
  }

  construct(grid, config) {
    const me = this;

    me.grid = grid;
    me.store = grid.store;
    me.closeFilterEditor = me.closeFilterEditor.bind(me);

    super.construct(grid, config);

    me.store.on({ filter: me.onStoreFilter }, me);

    if (config && typeof config === 'object') {
      me.store.filter(config, null, me.client.isConfiguring);
    }
  }

  //endregion

  //region Plugin config

  doDestroy() {
    const me = this;

    me.filterTip && me.filterTip.destroy();

    me.store.un({ sort: me.onStoreFilter }, me);

    super.doDestroy();
  }

  //endregion

  //region Refresh headers

  /**
   * Update headers to match stores filters. Called on store load and grid header render.
   * @param reRenderRows Also refresh rows?
   * @private
   */
  refreshHeaders(reRenderRows) {
    let me = this,
      grid = me.grid,
      element = grid.headerContainer;

    if (element) {
      // remove .latest from all filters, will be applied to actual latest
      DomHelper.children(element, '.b-filter-icon.b-latest').forEach((iconElement) =>
        iconElement.classList.remove('b-latest')
      );

      if (!me.filterTip) {
        me.filterTip = new Tooltip({
          forElement: element,
          forSelector: '.b-filter-icon',
          getHtml({ forElement }) {
            return forElement.dataset.filterText;
          }
        });
      }

      for (let column of grid.columns) {
        if (column.filterable !== false) {
          let filter = me.store.filters.getBy('property', column.field),
            headerEl = column.element;

          if (headerEl) {
            let textEl = column.textWrapper,
              filterIconEl = textEl && textEl.querySelector('.b-filter-icon'),
              filterText;

            if (filter) {
              filterText =
                me.L('filter') +
                ': ' +
                (typeof filter === 'string'
                  ? filter
                  : `${filter.operator} ${filter.displayValue || filter.value || ''}`);
              //TODO: filter.value needs to be formatted using column format or something
            } else {
              filterText = me.L('applyFilter');
            }

            if (!filterIconEl) {
              // putting icon in header text to have more options for positioning it
              filterIconEl = DomHelper.createElement({
                parent: textEl,
                tag: 'div',
                className: 'b-filter-icon',
                dataset: {
                  filterText: filterText
                }
              });
              headerEl.classList.add('b-filterable');
            } else {
              filterIconEl.dataset.filterText = filterText;
            }

            // latest applied filter distinguished with class to enable highlighting etc.
            if (column.field === me.store.latestFilterField) filterIconEl.classList.add('b-latest');

            headerEl.classList[filter ? 'add' : 'remove']('b-filter');
            // When IE11 support is dropped
            // headerEl.classList.toggle('b-filter', !!filter);
          }

          column.meta.isFiltered = !!filter;
        }
      }

      if (reRenderRows) {
        grid.refreshRows();
      }
    }
  }

  //endregion

  //region Filter

  applyFilter(config) {
    const { store } = this,
      column = this.grid.columns.get(config.property);

    if (typeof column.filterable === 'function') {
      store.filter({
        filterBy: (record) => column.filterable(Object.assign({}, config, { record })),
        // To be able to retrieve the value next time filtering popup is shown, not actually used by the filter
        value: config.value,
        property: config.property,
        operator: config.operator,
        displayValue: config.displayValue
      });
    } else {
      store.filter(config);
    }
  }

  // TODO: break out as own views, registering with Filter the same way columns register with ColumnManager

  getPopupDateItems(fieldType, filter, initialValue, field, store, changeCallback, closeCallback) {
    const me = this,
      onClose = changeCallback,
      onClear = closeCallback;

    function onChange({ source, value }) {
      if (value == null) {
        closeCallback();
      } else {
        me.applyFilter({ property: field, operator: source.operator, value, displayValue: source._value });
        changeCallback();
      }
    }

    return [
      {
        type: 'date',
        ref: 'on',
        placeholder: me.L('on'),
        clearable: true,
        label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
        value: filter && filter.operator === '=' ? filter.value : initialValue,
        operator: '=',
        onChange,
        onClose,
        onClear
      },
      {
        type: 'date',
        ref: 'before',
        placeholder: me.L('before'),
        clearable: true,
        label: '<i class="b-fw-icon b-icon-filter-before"></i>',
        value: filter && filter.operator === '<' ? filter.value : null,
        operator: '<',
        onChange,
        onClose,
        onClear
      },
      {
        type: 'date',
        ref: 'after',
        cls: 'b-last-row',
        placeholder: me.L('after'),
        clearable: true,
        label: '<i class="b-fw-icon b-icon-filter-after"></i>',
        value: filter && filter.operator === '>' ? filter.value : null,
        operator: '>',
        onChange,
        onClose,
        onClear
      }
    ];
  }

  getPopupNumberItems(fieldType, filter, initialValue, field, store, changeCallback, closeCallback) {
    const me = this,
      onEsc = changeCallback,
      onClear = closeCallback;

    function onChange({ source, value }) {
      if (value == null) {
        closeCallback();
      } else {
        me.applyFilter({ property: field, operator: source.operator, value });
        changeCallback();
      }
    }

    return [
      {
        type: 'number',
        placeholder: me.L('equals'),
        clearable: true,
        label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
        value: filter && filter.operator === '=' ? filter.value : initialValue,
        operator: '=',
        onChange,
        onEsc,
        onClear
      },
      {
        type: 'number',
        placeholder: me.L('lessThan'),
        clearable: true,
        label: '<i class="b-fw-icon b-icon-filter-less"></i>',
        value: filter && filter.operator === '<' ? filter.value : null,
        operator: '<',
        onChange,
        onEsc,
        onClear
      },
      {
        type: 'number',
        cls: 'b-last-row',
        placeholder: me.L('moreThan'),
        clearable: true,
        label: '<i class="b-fw-icon b-icon-filter-more"></i>',
        value: filter && filter.operator === '>' ? filter.value : null,
        operator: '>',
        onChange,
        onEsc,
        onClear
      }
    ];
  }

  getPopupStringItems(fieldType, filter, initialValue, field, store, changeCallback, closeCallback) {
    const me = this;

    return [
      {
        type: fieldType,
        cls: 'b-last-row',
        placeholder: me.L('filter'),
        clearable: true,
        label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
        value: filter ? filter.value || filter : initialValue,
        onChange: ({ value }) => {
          if (value === '') {
            closeCallback();
          } else {
            me.applyFilter({ property: field, value });
            changeCallback();
          }
        },
        onClose: changeCallback,
        onClear: closeCallback
      }
    ];
  }

  /**
   * Get fields to display in filter popup.
   * @param fieldType Type of field, number, date etc.
   * @param filter Current filter filter
   * @param initialValue
   * @param field Column
   * @param store Grid store
   * @param changeCallback Callback for when filter has changed
   * @param closeCallback Callback for when editor should be closed
   * @returns {*}
   * @private
   */
  getPopupItems(fieldType, filter, initialValue, field, store, changeCallback, closeCallback) {
    switch (fieldType) {
      case 'date':
        return this.getPopupDateItems(...arguments);
      case 'number':
        return this.getPopupNumberItems(...arguments);
      default:
        return this.getPopupStringItems(...arguments);
    }
  }

  /**
   * Shows a popup where a filter can be edited.
   * @param {Grid.column.Column} column Column to show filter editor for
   * @param {*} value Value to init field with
   */
  showFilterEditor(column, value) {
    let me = this,
      col = typeof column === 'string' ? me.grid.columns.getById(column) : column,
      headerEl = col.element,
      filter = me.store.filters.getBy('property', col.field),
      type = col.filterType || col.type || 'string',
      fieldType =
        {
          string: 'text',
          number: 'number',
          date: 'date'
        }[type] || 'text';

    if (col.filterable === false) return;

    me.filterEditorPopup = WidgetHelper.openPopup(headerEl, {
      width: '16em',
      cls: 'b-filter-popup',
      scrollAction: 'realign',
      items: me.getPopupItems(fieldType, filter, value, col.field, me.store, me.closeFilterEditor, () => {
        me.store.removeFieldFilter(col.field);
        me.closeFilterEditor();
      })
    });
  }

  /**
   * Close the filter editor.
   */
  closeFilterEditor() {
    const me = this;

    // Must defer the destroy because it may be closed by an event like a "change" event where
    // there may be plenty of code left to execute which must not execute on destroyed objects.
    me.filterEditorPopup && me.filterEditorPopup.setTimeout(me.filterEditorPopup.destroy);
    me.filterEditorPopup = null;
  }

  //endregion

  //region Context menu

  //TODO: break out together with getPopupXXItems() (see comment above)

  getMenuDateItems(column, record) {
    const me = this,
      value = record[column.field],
      filter = (operator) => {
        me.applyFilter({
          property: column.field,
          operator,
          value,
          displayValue: column.formatValue ? column.formatValue(value) : value
        });
      };

    return [
      {
        text: me.L('on'),
        icon: 'b-fw-icon b-icon-filter-equal',
        cls: 'b-separator',
        name: 'filterDateEquals',
        onItem: () => filter('=')
      },
      {
        text: me.L('before'),
        icon: 'b-fw-icon b-icon-filter-before',
        name: 'filterDateBefore',
        onItem: () => filter('<')
      },
      {
        text: me.L('after'),
        icon: 'b-fw-icon b-icon-filter-after',
        name: 'filterDateAfter',
        onItem: () => filter('>')
      }
    ];
  }

  getMenuNumberItems(column, record) {
    const me = this,
      filter = (operator) => {
        me.applyFilter({
          property: column.field,
          operator: operator,
          value: record[column.field]
        });
      };

    return [
      {
        text: me.L('equals'),
        icon: 'b-fw-icon b-icon-filter-equal',
        cls: 'b-separator',
        name: 'filterNumberEquals',
        onItem: () => filter('=')
      },
      {
        text: me.L('lessThan'),
        icon: 'b-fw-icon b-icon-filter-less',
        name: 'filterNumberLess',
        onItem: () => filter('<')
      },
      {
        text: me.L('moreThan'),
        icon: 'b-fw-icon b-icon-filter-more',
        name: 'filterNumberMore',
        onItem: () => filter('>')
      }
    ];
  }

  getMenuStringItems(column, record) {
    return [
      {
        text: this.L('equals'),
        icon: 'b-fw-icon b-icon-filter-equal',
        cls: 'b-separator',
        name: 'filterStringEquals',
        onItem: () => {
          this.applyFilter({ property: column.field, value: record[column.field] });
        }
      }
    ];
  }

  /**
   * Add menu items for filtering, depending on filter type etc.
   * @param column
   * @param record
   * @param items
   * @returns {Object[]}
   * @private
   */
  getCellMenuItems(column, record, items) {
    const me = this,
      field = record.getFieldDefinition(column.field);

    if (column.filterable !== false) {
      let filterItems = [];

      if (column.meta.isFiltered) {
        filterItems.push({
          text: me.L('removeFilter'),
          icon: 'b-fw-icon b-icon-clear',
          cls: 'b-separator',
          name: 'filterRemove',
          onItem: () => {
            me.store.removeFieldFilter(column.field);
          }
        });
      }

      switch (column.filterType || column.type || (field && field.type)) {
        case 'date':
          filterItems.push(...me.getMenuDateItems(...arguments));
          break;
        case 'number':
          filterItems.push(...me.getMenuNumberItems(...arguments));
          break;
        default:
          filterItems.push(...me.getMenuStringItems(...arguments));
          break;
      }

      // remove separator from second item if filtered
      if (column.meta.isFiltered && filterItems.length > 1) {
        filterItems[1].cls = '';
      }

      items.push(...filterItems);
    }
  }

  /**
   * Add menu item for removing filter if column is filtered.
   * @private
   * @param column Column
   * @param items Menu items
   * @returns {Object[]}
   */
  getHeaderMenuItems(column, items) {
    const me = this;

    if (column.meta.isFiltered) {
      items.push({
        text: me.L('editFilter'),
        name: 'editFilter',
        icon: 'b-fw-icon b-icon-filter',
        cls: 'b-separator',
        onItem() {
          me.showFilterEditor(column);
        }
      });
      items.push({
        text: me.L('removeFilter'),
        name: 'removeFilter',
        icon: 'b-fw-icon b-icon-remove',
        onItem: () => {
          me.store.removeFieldFilter(column.field);
        }
      });
    } else if (column.filterable !== false) {
      items.push({
        text: me.L('filter'),
        name: 'filter',
        icon: 'b-fw-icon b-icon-filter',
        cls: 'b-separator',
        onItem() {
          me.showFilterEditor(column);
        }
      });
    }
  }

  //endregion

  //region Events

  /**
   * Store filtered; refresh headers.
   * @private
   */
  onStoreFilter() {
    // Pass false to not refresh rows.
    // Store's refresh event will refresh the rows.
    this.refreshHeaders(false);
  }

  /**
   * Called after headers are rendered, make headers match stores initial sorters
   * @private
   */
  renderHeader() {
    this.refreshHeaders(false);
  }

  /**
   * Called when user clicks on the grid. Only care about clicks on the filter icon.
   * @param {MouseEvent} event
   * @private
   */
  onElementClick(event) {
    const target = event.target;

    if (this.filterEditorPopup) this.closeFilterEditor();

    // Checks if click is on node expander icon, then toggles expand/collapse
    if (target.classList.contains('b-filter-icon')) {
      const headerEl = DomHelper.up(target, '.b-grid-header');

      this.showFilterEditor(headerEl.dataset.columnId);
      return false;
    }
  }

  //endregion
}

Filter.featureClass = 'b-filter';

Filter._$name = 'Filter';
GridFeatureManager.registerFeature(Filter);

/**
 * @module Grid/feature/FilterBar
 */

/**
 * Feature that allows filtering of the grid by entering filters on column headers.
 * The actual filtering is done by the store.
 * For info on programmatically handling filters, see {@link Common.data.mixin.StoreFilter StoreFilter}.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * The individual filterability of columns is defined by a `filterable`
 * property on the column which defaults to `true`. If `false`, that column
 * is not filterable.
 *
 * The property value may also be a custom filter function.
 *
 * The property value may also be an object which may contain the following two properties:
 *  - **filterFn** : `Function` A custom filtering function
 *  - **filterField** : `Object` A config object for the filter value input field.
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @example
 * // filtering turned on but no default filter
 * let grid = new Grid({
 *   features: {
 *     filterBar : true
 *   }
 * });
 *
 * @example
 * // using default filter
 * let grid = new Grid({
 *   features : {
 *     filterBar : { filter: { property : 'city', value : 'Gavle' } }
 *   }
 * });
 *
 * @example
 * // Custom filtering function for a column
 * let grid = new Grid({
 *   features : {
 *     filter : true
 *   },
 *
 *   columns: [
 *      {
 *        field      : 'age',
 *        text       : 'Age',
 *        type       : 'number',
 *        // Custom filtering function that checks "greater than"
 *        filterable : ({ record, value }) => record.age > value
 *      },
 *        field : 'name',
 *        // Filterable may specify a filterFn and a config for the filtering input field
 *        filterable : {
 *          filterFn : ({ record, value }) => record.name.toLowerCase().indexof(value.toLowerCase()) !== -1,
 *          filterField : {
 *            emptyText : 'Filter name'
 *          }
 *        }
 *      }
 *   ]
 * });
 *
 * @demo filterbar
 * @classtype filterBar
 * @externalexample feature/FilterBar.js
 */
class FilterBar extends InstancePlugin {
  //region Default config

  static get defaultConfig() {
    return {
      /**
       * The delay in milliseconds to wait after the last keystroke before applying filters.
       * Set to 0 to not trigger filtering from keystrokes, requires pressing ENTER instead
       * @config {Number}
       * @default
       */
      keyStrokeFilterDelay: 300,

      // Destroying data level filters when we hiding UI is supposed to be optional someday. So far this flag is private
      clearStoreFiltersOnHide: true
    };
  }

  //endregion

  //region Init

  construct(grid, config) {
    const me = this;

    Object.assign(me, {
      filterFieldCls: 'b-filter-bar-field',
      filterFieldInputCls: 'b-filter-bar-field-input',
      filterableColumnCls: 'b-filter-bar-enabled',
      filterFieldInputSelector: '.b-filter-bar-field-input',
      filterableColumnSelector: '.b-filter-bar-enabled',
      filterParseRegExp: /^\s*([<>=*])?(.*)$/,
      storeTrackingSupended: 0,
      store: grid.store,
      grid: grid
    });

    me.onColumnFilterFieldChange = me.onColumnFilterFieldChange.bind(me);

    super.construct(
      grid,
      Array.isArray(config)
        ? {
            filter: config
          }
        : config
    );

    me.store.on({
      filter: me.onStoreFilter,
      thisObj: me
    });

    if (me.filter) {
      me.store.filter(me.filter);
    }

    me.gridDetacher = grid.on('beforeelementclick', me.onBeforeElementClick, me);
  }

  doDestroy() {
    const me = this;

    me.destroyFilterBar();
    me.gridDetacher && me.gridDetacher();

    super.doDestroy();
  }

  static get pluginConfig() {
    return {
      before: ['onElementKeyDown'],
      chain: ['renderHeader', 'getHeaderMenuItems']
    };
  }

  //endregion

  //region FilterBar

  destroyFilterBar() {
    const me = this,
      columns = me.grid.columns;

    columns && columns.forEach(me.destroyColumnFilterField, me);
  }

  /**
   * Hides the filtering fields.
   */
  hideFilterBar() {
    const me = this,
      columns = me.grid.columns;

    // we don't want to hear back store "filter" event while we're resetting store filters
    me.clearStoreFiltersOnHide && me.suspendStoreTracking();

    // hide the fields, each silently - no updating of the store's filtered state until the end
    columns && columns.forEach((col) => me.hideColumnFilterField(col, true));

    // Now update the filtered state
    me.grid.store.filter();

    me.clearStoreFiltersOnHide && me.resumeStoreTracking();

    me.hidden = true;
  }

  /**
   * Shows the filtering fields.
   */
  showFilterBar() {
    this.renderFilterBar();

    this.hidden = false;
  }

  /**
   * Toggles the filtering fields visibility.
   */
  toggleFilterBar() {
    const me = this;

    if (me.hidden) {
      me.showFilterBar();
    } else {
      me.hideFilterBar();
    }
  }

  /**
   * Renders the filtering fields for filterable columns.
   * @private
   */
  renderFilterBar() {
    const me = this;

    me.grid.columns.visibleColumns.forEach((column) => me.renderColumnFilterField(column));
  }

  //endregion

  //region FilterBar fields

  /**
   * Renders text field filter in the provided column header.
   * @param {Grid.column.Column} column Column to render text field filter for.
   * @private
   */
  renderColumnFilterField(column) {
    const me = this,
      grid = me.grid,
      filterable = me.getColumnFilterable(column);

    // we render fields for filterable columns only
    if (filterable && !column.hidden) {
      const headerEl = column.element;

      let widget = me.getColumnFilterField(column);

      // if we don't haven't created a field yet
      // we build it from scratch
      if (!widget) {
        const filter = grid.store.filters.getBy('property', column.field),
          type = `${column.filterType || 'text'}field`;

        widget = WidgetHelper.append(
          Object.assign(
            {
              type,
              owner: me.grid,
              clearable: true,
              column: column,
              name: column.field,
              value: filter && me.buildFilterString(filter),
              cls: me.filterFieldCls,
              inputCls: me.filterFieldInputCls,
              keyStrokeChangeDelay: me.keyStrokeFilterDelay,
              onChange: me.onColumnFilterFieldChange,
              onClear: me.onColumnFilterFieldChange
            },
            filterable.filterField
          ),
          headerEl
        )[0];

        me.setColumnFilterField(column, widget);
      }
      // if we have one..
      else {
        // re-apply widget filter
        me.onColumnFilterFieldChange({ source: widget, value: widget.value });
        // re-append the widget to its parent node (in case the column header was redrawn (happens when resizing columns))
        widget.render(headerEl);
        // show widget in case it was hidden
        widget.show();
      }

      headerEl.classList.add(me.filterableColumnCls);
    }
  }

  /**
   * Fills in column filter fields with values from the grid store filters.
   * @private
   */
  updateColumnFilterFields() {
    const me = this,
      grid = me.grid;

    let field, filter;

    for (let column of grid.columns) {
      field = me.getColumnFilterField(column);
      if (field) {
        filter = grid.store.filters.getBy('property', column.field);
        field.value = (filter && me.buildFilterString(filter)) || '';
      }
    }
  }

  getColumnFilterable(column) {
    if (!column.isRoot && column.filterable !== false && column.field) {
      if (typeof column.filterable === 'function') {
        column.filterable = {
          filterFn: column.filterable
        };
      }
      return column.filterable;
    }
  }

  destroyColumnFilterField(column) {
    const me = this,
      widget = me.getColumnFilterField(column);

    if (widget) {
      me.hideColumnFilterField(column);
      // destroy filter UI field
      widget.destroy();
      // remember there is no field bound anymore
      me.setColumnFilterField(column, undefined);
    }
  }

  hideColumnFilterField(column, silent) {
    const me = this,
      store = me.grid.store,
      columnEl = column.element,
      widget = me.getColumnFilterField(column);

    if (widget) {
      // hide field
      widget.hide();

      if (me.clearStoreFiltersOnHide && column.field) {
        store.removeFieldFilter(column.field, silent);
      }

      columnEl.classList.remove(me.filterableColumnCls);
    }
  }

  getColumnFilterField(column) {
    const me = this;

    return me._columnFilters && me._columnFilters[column.data.id];
  }

  setColumnFilterField(column, widget) {
    const me = this;

    me._columnFilters = me._columnFilters || {};

    me._columnFilters[column.data.id] = widget;
  }

  //endregion

  //region Filters

  parseFilterValue(value) {
    const match = String(value).match(this.filterParseRegExp);

    return {
      operator: match[1] || '*',
      value: match[2]
    };
  }

  buildFilterString(filter) {
    let result;

    if (filter && !filter.initialConfig.filterBy) {
      result = (filter.operator === '*' ? '' : filter.operator) + filter.value;
    }

    return result;
  }

  //endregion

  // region Events

  /**
   * Fires when store gets filtered. Refreshes field values in column headers.
   * @private
   */
  onStoreFilter() {
    if (!this.storeTrackingSupended) {
      this.updateColumnFilterFields();
    }
  }

  suspendStoreTracking() {
    this.storeTrackingSupended++;
  }

  resumeStoreTracking() {
    this.storeTrackingSupended--;
  }

  /**
   * Called after headers are rendered, make headers match stores initial sorters
   * @private
   */
  renderHeader(element) {
    this.renderFilterBar();
  }

  onElementKeyDown(event) {
    const me = this;

    // flagging event with handled = true used to signal that other features should probably not care about it
    if (event.handled) return;

    // if we are pressing left/right arrow keys while being in a filter editor
    // we set event.handled flag (otherwise other features prevent the event)
    if (event.target.matches(me.filterFieldInputSelector)) {
      switch (event.key) {
        case 'ArrowLeft':
        case 'ArrowRight':
          event.handled = true;
      }
    }
  }

  onBeforeElementClick({ event }) {
    const me = this;

    // prevent other features reacting when clicking a filter field (or any element inside it)
    if (event.target.closest('.' + me.filterFieldCls)) {
      return false;
    }
  }

  /**
   * Called when a column text filter field value is changed by user.
   * @param  {TextField} field Filter text field.
   * @param  {String} value New filtering value.
   * @private
   */
  onColumnFilterFieldChange({ source: field, value }) {
    const me = this,
      store = me.grid.store,
      filterable = me.getColumnFilterable(field.column);

    // we don't want to hear back store "filter" event
    // so we suspend store tracking
    me.suspendStoreTracking();

    if (value == null || value === '') {
      // remove filter if setting to empty
      store.removeFieldFilter(field.name);
    } else if (filterable.filterFn) {
      store.filter({
        filterBy: (record) => filterable.filterFn({ property: field.name, value, record }),
        // To be able to clear the filter
        property: field.name
      });
    } else {
      store.filter(
        Object.assign(
          {
            property: field.name
          },
          me.parseFilterValue(value)
        )
      );
    }

    me.resumeStoreTracking();
  }

  //endregion

  //region Menu items

  /**
   * Adds a menu item to toggle filter bar visibility.
   * @param column Column
   * @param items Menu items
   * @returns {Object[]} Menu items.
   * @private
   */
  getHeaderMenuItems(column, items) {
    const me = this;

    items.push({
      text: me.L(me.hidden ? 'enableFilterBar' : 'disableFilterBar'),
      name: 'toggleFilterBar',
      icon: 'b-fw-icon b-icon-filter',
      cls: 'b-separator',
      onItem: () => me.toggleFilterBar()
    });
  }

  //endregion
}

FilterBar.featureClass = 'b-filter-bar';

FilterBar._$name = 'FilterBar';
GridFeatureManager.registerFeature(FilterBar);

//TODO: Expand function?

/**
 * @module Grid/feature/Group
 */

/**
 * Enables rendering and handling of row groups. The actual grouping is done in the store, but triggered by [shift] +
 * clicking headers or by using two finger tap (one on header, one anywhere on grid). Groups can be expanded/collapsed
 * by clicking on the group row or pressing [space] when group row is selected.
 *
 * This feature is <strong>enabled</strong> by default.
 *
 * @example
 * // grouping turned on but no default grouper
 * let grid = new Grid({
 *   features: {
 *     group: true
 *   }
 * });
 *
 * // default grouper, group by field 'name'
 * let grid = new Grid({
 *   features: {
 *     group: 'name'
 *   }
 * });
 *
 * // default grouper and custom renderer, which will be applied to each cell except the "group" cell
 * let grid = new Grid({
 *   features: {
 *     group: {
 *       field: 'name',
 *       ascending: false,
 *       renderer: () => 'Text'
 *     }
 *   }
 * });
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @demo grouping
 * @classtype group
 * @externalexample feature/Group.js
 */
class Group extends InstancePlugin {
  static get defaultConfig() {
    return {
      /**
       * The name of the record field to group by.
       * @config {String}
       * @default
       */
      field: null,

      /**
       * A function which yields the HTML for a group header when passed a data block.
       * The function is called in the context of this Group feature object.
       * The data block passed contains the following properties:
       *  - `groupRowFor` The value of the {@link #config-field} for the group.
       *  - `groupColumn` Optionally, the column under which the {@link #config-field} is shown.
       *  - `record` The group record reresenting the group, containing a `children` property which contains the child records for the group.
       *
       * The default renderer displays the `groupRowFor` and `record.meta.childCount`
       * @config {Function}
       * @default
       */
      renderer: null
    };
  }
  //region Init

  construct(grid, config) {
    const me = this;

    if (grid.features.tree) return;

    // groupSummary feature needs to be initialized first, if it is used
    me._thisIsAUsedExpression(grid.features.groupSummary);

    // process initial config into an actual config object
    config = me.processConfig(config);

    Object.assign(me, {
      grid: grid,
      rowManager: grid.rowManager,
      store: grid.store
    });

    super.construct(grid, config);

    me.store.on({
      group: me.onStoreGroup,
      groupingoff: me.onStoreGroupingOff,
      thisObj: me
    });

    me.rowManager.on({
      rendercell: me.renderCell,
      thisObj: me
    });
  }

  // Group feature handles special config cases, where user can supply a string or a group config object
  // instead of a normal config object
  processConfig(config) {
    if (typeof config === 'string') {
      return {
        field: config,
        ascending: null
      };
    }

    return config;
  }

  // override setConfig to process config before applying it (used mainly from ReactGrid)
  setConfig(config) {
    const me = this;

    if (config === null) {
      me.store.clearGroupers();
    } else {
      super.setConfig(me.processConfig(config));
    }
  }

  set renderer(renderer) {
    this.groupRenderer = renderer;
  }

  set field(field) {
    this._field = field;
    this.store.group(field, this.ascending);
  }

  get field() {
    return this._field;
  }

  doDestroy() {
    super.doDestroy();
  }

  //endregion

  //region Plugin config

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      assign: ['collapseAll', 'expandAll'],
      chain: [
        'renderHeader',
        'getHeaderMenuItems',
        'getColumnDragToolbarItems',
        'onElementTouchStart',
        'onElementClick',
        'onElementKeyDown'
      ],
      override: ['onStoreDataChange']
    };
  }

  //endregion

  //region Expand/collapse

  /**
   * Collapses or expands a group depending on its current state
   * @param recordOrId Record or records id for a group row to collapse or expand
   * @param collapse Force collapse (true) or expand (true)
   * @fires togglegroup
   */
  toggleCollapse(recordOrId, collapse) {
    this.internalToggleCollapse(recordOrId, collapse);
  }

  /**
   * Collapses or expands a group depending on its current state
   * @param recordOrId Record or records id for a group row to collapse or expand
   * @param collapse Force collapse (true) or expand (true)
   * @param skipRender True to not render rows
   * @internal
   * @fires togglegroup
   */
  internalToggleCollapse(recordOrId, collapse, skipRender = false) {
    const me = this,
      store = me.store,
      groupRecord = store.getById(recordOrId),
      meta = groupRecord.meta;

    if (meta.groupRowFor === undefined) return;

    collapse = collapse === undefined ? !meta.collapsed : collapse;

    if (collapse) {
      store.excludeGroupRecords(groupRecord);
    } else {
      store.includeGroupRecords(groupRecord);
    }

    // note to self, all this could be done in collapsed setter on GroupModel if desired...
    meta.collapsed = collapse;

    /**
     * Group expanded or collapsed
     * @event toggleGroup
     * @param groupRecord Group record
     * @param {Boolean} collapse Collapsed (true) or expanded (false)
     */
    me.grid.trigger('toggleGroup', { groupRecord, collapse });

    if (!skipRender) {
      // render from grouprecord and down, no need to touch those above
      me.rowManager.renderFromRecord(groupRecord);
    }
  }

  /**
   * Collapse all groups. This function is exposed on Grid and can thus be called as `grid.collapseAll()`
   */
  collapseAll() {
    const me = this;
    if (me.store.isGrouped) {
      me.store.groupRecords.forEach((r) => me.internalToggleCollapse(r, true, true));
      me.grid.refreshRows(true);
    }
  }

  /**
   * Expand all groups. This function is exposed on Grid and can thus be called as `grid.expandAll()`
   */
  expandAll() {
    const me = this;
    if (me.store.isGrouped) {
      me.store.groupRecords.forEach((r) => me.internalToggleCollapse(r, false, true));
      me.grid.refreshRows();
    }
  }

  //endregion

  //region Rendering

  /**
   * Called when a cell is rendered, styles the group rows first cell.
   * @private
   */
  renderCell(renderData) {
    const me = this;

    // no need to run the code below if not grouping
    if (!me.store.isGrouped) return;

    let { cellElement, rowElement, column } = renderData,
      grid = me.grid,
      meta = renderData.record.meta,
      firstColumn = grid.columns.visibleColumns[0],
      subGrid = grid.getSubGridFromColumn(column);

    if (meta.hasOwnProperty('groupRowFor')) {
      // Let column clear the cell, in case it needs to do some cleanup
      column.clearCell(cellElement);

      // this is a group row, add css classes

      // IE11 doesnt support this
      //rowElement.classList.toggle('b-grid-group-collapsed', meta.collapsed === undefined ? false : meta.collapsed);
      if (meta.collapsed) {
        rowElement.classList.add('b-grid-group-collapsed');
      } else {
        rowElement.classList.remove('b-grid-group-collapsed');
      }

      rowElement.classList.add('b-group-row');

      if (
        column.region === grid.regions[0] &&
        ((firstColumn.type === 'rownumber' && column === subGrid.columns.visibleColumns[1]) ||
          (firstColumn.type !== 'rownumber' && column === subGrid.columns.visibleColumns[0]))
      ) {
        cellElement.classList.add('b-group-title');
      }

      me.buildGroupHeader(renderData);
    } else {
      // not a group row, remove css classes
      // TODO: use dom query to remove before render instead?
      if (cellElement === rowElement.firstElementChild) {
        // IE11 doesnt support this
        //rowElement.classList.remove('b-group-row', 'b-grid-group-collapsed');
        rowElement.classList.remove('b-group-row');
        rowElement.classList.remove('b-grid-group-collapsed');
        cellElement.classList.remove('b-group-title');
      }
    }
  }

  // renderData.cellElement is required
  buildGroupHeader(renderData) {
    const me = this,
      { record, cellElement, rowElement, column, persist } = renderData,
      grid = me.grid,
      meta = record.meta,
      firstColumn = grid.columns.visibleColumns[0],
      subGrid = column && grid.getSubGridFromColumn(column);

    let html = null;

    if (
      persist ||
      (column && firstColumn.type === 'rownumber' && column === subGrid.columns.visibleColumns[1]) ||
      (firstColumn.type !== 'rownumber' && column === subGrid.columns.visibleColumns[0])
    ) {
      // build group header no matter what cell it is or
      // build group value in first cell of first subgrid
      if (persist || column.region === grid.regions[0]) {
        const groupColumn = grid.columns.get(meta.groupField);
        // First try using columns groupRenderer (might not even have a column if grouping programmatically)
        if (groupColumn && groupColumn.groupRenderer) {
          // groupRenderer could return nothing and just apply changes directly to DOM element
          html = groupColumn.groupRenderer({
            cellElement,
            groupRowFor: meta.groupRowFor,
            record,
            rowElement,
            groupColumn
          });
        }
        // Secondly use features groupRenderer, if configured with one
        else if (me.groupRenderer) {
          // groupRenderer could return nothing and just apply changes directly to DOM element
          html = me.groupRenderer(
            Object.assign({}, renderData, {
              groupRowFor: meta.groupRowFor,
              groupColumn
            })
          );
        }
        // Third, just display unformatted value and child count
        else {
          // Need to adjust count if group summary is used
          // TODO remove this when grouping has been refactored to not store group headers/footers in the Store
          const count = meta.childCount - (grid.features.groupSummary ? 1 : 0);

          html = `${meta.groupRowFor == null ? '' : meta.groupRowFor} (${count})`;
        }
      }
    } else if (me.groupRenderer) {
      // groupRenderer could return nothing and just apply changes directly to DOM element
      html = me.groupRenderer(renderData);
    }

    // Renderers could return nothing and just apply changes directly to DOM element
    if (typeof html === 'string') {
      cellElement.innerHTML = html;
    }

    return cellElement.innerHTML;
  }

  /**
   * Called when an header is rendered, adds grouping icon if grouped by that column.
   * @private
   * @param headerContainerElement
   */
  renderHeader(headerContainerElement) {
    let me = this,
      grid = me.grid,
      groupers = me.store.groupers;

    // Sorted from start, reflect in rendering
    for (let groupInfo of groupers) {
      // Might be grouping by field without column, which is valid
      const column = grid.columns.get(groupInfo.field),
        header = column && grid.getHeaderElement(column.id);
      // IE11 doesnt support this
      //header && header.classList.add('b-group', groupInfo.ascending ? 'b-asc' : 'b-desc');
      if (header) {
        header.classList.add('b-group');
        header.classList.add(groupInfo.ascending ? 'b-asc' : 'b-desc');
      }
    }
  }

  //endregion

  //region Context menu

  /**
   * Supply items for headers context menu.
   * @private
   * @param column Header for this column
   * @param items Add items to this array
   * @returns {Object[]} Modified items array
   */
  getHeaderMenuItems(column, items) {
    const me = this,
      store = me.store;

    if (column.groupable !== false) {
      items.push(
        {
          text: me.L('groupAscending'),
          icon: 'b-fw-icon b-icon-group-asc',
          name: 'groupAsc',
          cls: 'b-separator',
          weight: 110,
          onItem: ({ item: { column } }) => store.group(column.field, true)
        },
        {
          text: me.L('groupDescending'),
          icon: 'b-fw-icon b-icon-group-desc',
          name: 'groupDesc',
          weight: 110,
          onItem: ({ item: { column } }) => store.group(column.field, false)
        }
      );
    }

    if (store.isGrouped) {
      items.push({
        text: me.L('stopGrouping'),
        icon: 'b-fw-icon b-icon-clear',
        name: 'groupRemove',
        cls: column.groupable ? '' : 'b-separator',
        weight: 110,
        onItem: ({ item: { column } }) => store.clearGroupers()
      });
    }
  }

  /**
   * Supply items to ColumnDragToolbar
   * @private
   */
  getColumnDragToolbarItems(column, items) {
    const me = this,
      store = me.store;

    items.push({
      text: me.L('groupAscendingShort'),
      group: me.L('Group'),
      icon: 'b-icon b-icon-group-asc',
      name: 'groupAsc',
      cls: 'b-separator',
      weight: 110,
      onDrop: ({ column }) => store.group(column.field, true)
    });

    items.push({
      text: me.L('groupDescendingShort'),
      group: me.L('Group'),
      icon: 'b-icon b-icon-group-desc',
      name: 'groupDesc',
      weight: 110,
      onDrop: ({ column }) => store.group(column.field, false)
    });

    let grouped = store.groupers && store.groupers.find((col) => col.field === column.field);
    items.push({
      text: me.L('stopGroupingShort'),
      group: me.L('Group'),
      icon: 'b-icon b-icon-clear',
      name: 'groupRemove',
      disabled: !grouped,
      weight: 110,
      onDrop: ({ column }) => store.removeGrouper(column.field)
    });

    return items;
  }

  //endregion

  //region Events - Store

  /**
   * Called when store grouping changes. Reflects on header and rerenders rows.
   * @private
   */
  onStoreGroup({ groupers }) {
    const grid = this.grid,
      element = grid.element,
      curGroupHeaders = element && DomHelper.children(element, '.b-grid-header.b-group');

    if (element) {
      for (let header of curGroupHeaders) {
        // IE11 doesnt support this
        //header.classList.remove('b-group', 'b-asc', 'b-desc');
        header.classList.remove('b-group');
        header.classList.remove('b-asc');
        header.classList.remove('b-desc');
      }

      for (let groupInfo of groupers) {
        let header = grid.getHeaderElementByField(groupInfo.field);
        // IE11 doesnt support this
        //header && header.classList.add('b-group', groupInfo.ascending ? 'b-asc' : 'b-desc');
        if (header) {
          header.classList.add('b-group');
          header.classList.add(groupInfo.ascending ? 'b-asc' : 'b-desc');
        }
      }
    }
  }

  /**
   * Called when grouping is turned of in the store. Updates headers and rows.
   * @private
   * @param store
   */
  onStoreGroupingOff() {
    const me = this,
      grid = me.grid,
      curGroupHeaders = DomHelper.children(grid.element, '.b-grid-header.b-group');

    for (let header of curGroupHeaders) {
      // IE11 doesnt support this
      //header.classList.remove('b-group', 'b-asc', 'b-desc');
      header.classList.remove('b-group');
      header.classList.remove('b-asc');
      header.classList.remove('b-desc');
    }

    grid.refreshRows();
  }

  //endregion

  //region Events - Grid

  /**
   * Store touches when user touches header, used in onElementTouchEnd.
   * @private
   */
  onElementTouchStart(event) {
    const me = this,
      target = event.target,
      header = DomHelper.up(target, '.b-grid-header'),
      column = header && me.grid.getColumnFromElement(header);

    // If it's a multi touch, group.
    if (event.touches.length > 1 && column && column.groupable !== false) {
      me.store.group(column.field);
    }
  }

  /**
   * React to click on headers (to group by that column if [alt] is pressed) and on group rows (expand/collapse).
   * @private
   * @param event
   * @returns {Boolean}
   */
  onElementClick(event) {
    const me = this,
      store = me.store,
      target = event.target,
      row = DomHelper.up(target, '.b-group-row'),
      header = DomHelper.up(target, '.b-grid-header'),
      field = header && header.dataset.column;

    if (target.classList.contains('b-resizer')) return;

    // Header
    if (header && field) {
      const columnGrouper = store.groupers.find((g) => g.field === field);

      // Store has a grouper for this column's field; flip grouper order
      if (columnGrouper && !event.shiftKey) {
        store.group(field, !columnGrouper.ascending);
        return false;
      }
      // Group or ungroup
      else if (event.shiftKey) {
        const column = me.grid.columns.get(field);

        if (column.groupable !== false) {
          if (event.altKey) {
            store.removeGrouper(field);
          } else {
            store.group(field);
          }
        }
      }
      event.preventDefault();
    }

    // Anywhere on group-row
    if (row) {
      me.internalToggleCollapse(DomDataStore.get(row).id);
      return false;
    }
  }

  /**
   * Toggle groups with [space].
   * @private
   * @param event
   * @returns {*}
   */
  onElementKeyDown(event) {
    const me = this;

    // only catch space on grid element, not in editors etc...
    if (me.store.isGrouped && event.target === me.client.element && event.key === ' ' && me.grid.focusedCell) {
      event.preventDefault();

      me.internalToggleCollapse(me.grid.focusedCell.id);
    }
  }

  //endregion

  //region Grid overrides

  onStoreDataChange(data) {
    const store = data.source;

    // Grouping mixin needs to process data which then makes sure UI is refeshed
    if (store.isGrouped && store.count > 0) return;

    this.overridden.onStoreDataChange(data);
  }

  //endregion
}

Group.featureClass = 'b-group';

Group._$name = 'Group';
GridFeatureManager.registerFeature(Group, true, ['Grid', 'Scheduler']);

//TODO: Handle date columns

/**
 * @module Grid/feature/QuickFind
 */

/**
 * Feature that allows the user to search in a column by focusing a cell and typing. Navigate between hits using the
 * keyboard, [f3] or [ctrl]/[cmd] + [g] moves to next, also pressing [shift] moves to previous.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @example
 * // enable QuickFind
 * let grid = new Grid({
 *   features: {
 *     quickFind: true
 *   }
 * });
 *
 * // navigate to next hit programmatically
 * grid.features.quickFind.gotoNextHit();
 *
 * @demo quickfind
 * @classtype quickFind
 * @externalexample feature/QuickFind.js
 */
class QuickFind extends InstancePlugin {
  //region Config

  static get defaultConfig() {
    return {
      mode: 'header',
      find: ''
    };
  }

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['onElementKeyDown', 'onElementKeyPress', 'onCellNavigate']
    };
  }

  //endregion

  //region Init

  construct(grid, config) {
    const me = this;

    me.grid = grid;
    me.store = grid.store;

    super.construct(grid, config);
  }

  //endregion

  //region Plugin config

  //endregion

  //region Show/hide QuickFind

  /**
   * Shows a "searchfield" in the header. Triggered automatically when you have a cell focused and start typing.
   * @private
   */
  showQuickFind() {
    const me = this,
      header = me.grid.getHeaderElement(me.columnId);

    if (header) {
      if (!me.headerField) {
        const [element, field, badge] = DomHelper.createElement(
          {
            tag: 'div',
            className: 'b-quick-hit-header',
            children: [
              { tag: 'div', className: 'b-quick-hit-field' },
              { tag: 'div', className: 'b-quick-hit-badge' }
            ]
          },
          true
        );

        if (me.mode === 'header') {
          header.appendChild(element);
        } else {
          element.className += ' b-quick-hit-mode-grid';
          me.grid.element.appendChild(element);
        }

        me.headerField = {
          header: element,
          field: field,
          badge: badge,
          colHeader: header
        };
      }

      me.headerField.field.innerHTML = me.find;
      me.headerField.badge.innerHTML = me.found.length;

      header.classList.add('b-quick-find-header');

      if (!me.renderListenerInitialized) {
        me.grid.rowManager.on({
          rendercell: me.renderCell,
          thisObj: me
        });
        me.renderListenerInitialized = true;
      }
    }
  }

  /**
   * Hide the "searchfield" and remove highlighted hits. Called automatically when pressing [esc] or backspacing away
   * the keywords.
   * @private
   */
  hideQuickFind() {
    const me = this;

    // rerender cells to remove quick-find markup
    for (let hit of me.prevFound || me.found) {
      let row = me.grid.getRowById(hit.id);
      if (row) row.renderCell(row.getCell(me.columnId), hit.data);
    }

    if (me.headerField) {
      me.headerField.header.parentNode.removeChild(me.headerField.header);
      me.headerField.colHeader.classList.remove('b-quick-find-header');
      me.headerField = null;
    }

    if (me.renderListenerInitialized) {
      me.grid.rowManager.un({ rendercell: me.renderCell }, me);
      me.renderListenerInitialized = false;
    }

    me.grid.trigger('hideQuickFind');
  }

  //endregion

  //region Search

  /**
   * Performs a search and highlights hits. If find is empty, QuickFind is closed.
   * @param find Text to search for
   * @param columnFieldOrId Column to search
   */
  search(find, columnFieldOrId = this.columnId) {
    let me = this,
      column = me.grid.columns.getById(columnFieldOrId) || me.grid.columns.get(columnFieldOrId),
      found = me.store.findByField(column.field, find),
      i = 1,
      grid = me.grid;

    Object.assign(me, {
      foundMap: {},
      prevFound: me.found,
      found: found,
      find: find,
      columnId: column.id
    });

    if (find) {
      me.showQuickFind();
    } else {
      me.hideQuickFind();
    }

    // reset column to use its normal settings for htmlEncoding
    if (me.currentColumn && me.currentColumn !== column) me.currentColumn.disableHtmlEncode = false;

    // clear old hits
    for (let cell of DomHelper.children(grid.element, '.b-quick-hit')) {
      //IE11 doesnt support this
      //cell.classList.remove('b-quick-hit', 'b-quick-hit-cell');
      cell.classList.remove('b-quick-hit');
      cell.classList.remove('b-quick-hit-cell');

      // rerender cell to remove quick-hit-text
      let row = DomDataStore.get(cell).row;
      row.renderCell(cell);
    }

    // want to set innerHTML each time for cell decoration to work
    column.disableHtmlEncode = true;
    me.currentColumn = column;

    if (!found) return;

    if (found.length > 0) {
      me.gotoClosestHit(grid.focusedCell, found);
    }

    // highlight hits for visible cells
    for (let hit of found) {
      me.foundMap[hit.id] = i++;

      let row = grid.getRowById(hit.data.id);
      if (row) {
        row.renderCell(row.getCell(column.id));
      }

      // limit highlighted hits
      if (i > 1000) break;
    }

    me.grid.trigger('quickFind', { find, found });
  }

  /**
   * Clears and closes QuickFind.
   */
  clear() {
    if (this.found && this.found.length) {
      this.search('');
    }
  }

  /**
   * Number of results found
   * @type {Number}
   * @readonly
   */
  get foundCount() {
    return this.found ? this.found.length : 0;
  }

  /**
   * Found results (as returned by Store#findByField), an array in format { index: x, data: record }
   * @member {Object[]} found
   * @readonly
   */

  //endregion

  //region Navigation

  /**
   * Go to specified hit.
   * @param index
   */
  gotoHit(index) {
    let me = this,
      grid = me.grid,
      nextHit = me.found[index];

    if (nextHit) {
      grid.focusCell({
        columnId: me.columnId,
        id: nextHit.id
      });
    }

    return !!nextHit;
  }

  gotoClosestHit(focusedCell, found) {
    let focusedIndex = focusedCell ? this.grid.store.indexOf(focusedCell.id) : 0,
      foundSorted = found.slice().sort((a, b) => Math.abs(a.index - focusedIndex) - Math.abs(b.index - focusedIndex));

    this.gotoHit(found.indexOf(foundSorted[0]));
  }

  /**
   * Go to the first hit.
   */
  gotoFirstHit() {
    this.gotoHit(0);
  }

  /**
   * Go to the last hit.
   */
  gotoLastHit() {
    this.gotoHit(this.found.length - 1);
  }

  /**
   * Select the next hit, scrolling it into view. Triggered with [f3] or [ctrl]/[cmd] + [g].
   */
  gotoNextHit() {
    let me = this,
      grid = me.grid,
      // start from focused cell, or if focus has left grid use lastFocusedCell
      currentId = grid._focusedCell ? grid._focusedCell.id : grid.lastFocusedCell.id,
      currentIndex = grid.store.indexOf(currentId) || 0,
      nextHit = me.found.find((hit) => hit.index > currentIndex);

    if (nextHit) {
      grid.focusCell({
        columnId: me.columnId,
        id: nextHit.id
      });
    } else {
      me.gotoFirstHit();
    }
  }

  /**
   * Select the previous hit, scrolling it into view. Triggered with [shift] + [f3] or [shift] + [ctrl]/[cmd] + [g].
   */
  gotoPrevHit() {
    let me = this,
      grid = me.grid,
      currentId = grid._focusedCell ? grid._focusedCell.id : grid.lastFocusedCell.id,
      currentIndex = grid.store.indexOf(currentId) || 0,
      found = me.found,
      prevHit;

    if (!found.length) return;

    for (let i = found.length - 1; i--; i >= 0) {
      if (found[i].index < currentIndex) {
        prevHit = found[i];
        break;
      }
    }

    if (prevHit) {
      grid.focusCell({
        columnId: me.columnId,
        id: prevHit.id
      });
    } else {
      me.gotoLastHit();
    }
  }

  //endregion

  //region Render

  /**
   * Called from SubGrid when a cell is rendered.
   * @private
   */
  renderCell(renderData) {
    let me = this,
      cellElement = renderData.cellElement,
      foundMap = me.foundMap && me.columnId === renderData.column.id && me.foundMap[renderData.record.id];

    if (foundMap) {
      // Check also TreeColumn's special internal `shouldHtmlEncode` flag
      const htmlEncoded = renderData.column.htmlEncode || renderData.column.shouldHtmlEncode;

      // highlight cell
      cellElement.classList.add('b-quick-hit');

      // Special treatment of columns outputting HTML, just highlight whole cell
      if (!htmlEncoded) {
        cellElement.classList.add('b-quick-hit-cell');
      } else {
        // if features have added other stuff to the cell, value is in div.b-grid-cell-value
        // highlight in cell if found in innerHTML
        let inner = DomHelper.down(cellElement, '.b-grid-cell-value,.b-tree-cell-value') || cellElement,
          html = inner.innerText,
          where = html && html.toLowerCase().indexOf(me.find.toLowerCase());

        if (where > -1) {
          let end = where + me.find.length,
            casedFind = html.slice(where, end),
            spaceChar = '';

          // Insert a space if matching char preceded by whitespace
          if (html[where - 1] === ' ') {
            spaceChar = '&nbsp;';
          }

          html =
            html.slice(0, where) + `<span class="b-quick-hit-text">${spaceChar}${casedFind}</span>` + html.slice(end);
          inner.innerHTML = html + `<div class="b-quick-hit-cell-badge">${foundMap}</div>`;
        } else {
          cellElement.classList.add('b-quick-hit-cell');
        }
      }
    }
  }

  //endregion

  //region Events

  /**
   * Chained function called on grids keydown event. Handles backspace, escape, f3 and ctrl/cmd + g keys.
   * @private
   * @param event KeyboardEvent
   */
  onElementKeyDown(event) {
    const me = this,
      filterFeature = this.grid.features.filter;

    // Only react to keystrokes on grid cell elements. IE11 gets event.target wrong compared to other browsers...
    if (
      DomHelper.up(
        event.target,
        BrowserHelper.isIE11 ? '.b-widget:not(.b-grid-subgrid):not(.b-grid)' : '.b-widget:not(.b-grid)'
      )
    ) {
      return;
    }

    if (me.find.length > 0) {
      // backspace
      if (event.key === 'Backspace') {
        event.preventDefault();
        me.find = me.find.substr(0, me.find.length - 1);
        //console.log(me.find);

        me.search(me.find);
      }

      // escape
      else if (event.key === 'Escape') {
        event.preventDefault();
        me.find = '';
        me.search(me.find);
      }

      // F3 or CTRL+g
      else if (event.key === 'F3' || (event.key.toLowerCase() === 'g' && (event.ctrlKey || event.metaKey))) {
        event.preventDefault();
        if (event.shiftKey) {
          me.gotoPrevHit();
        } else {
          me.gotoNextHit();
        }
      }
      // Ctrl+Shift+F
      else if (filterFeature && me.columnId && me.foundCount && event.ctrlKey && event.shiftKey && event.key === 'F') {
        filterFeature.showFilterEditor(me.grid.columns.getById(me.columnId), me.find);
      }
    }
  }

  /**
   * Chained function called on grids keypress event. Handles input for "searchfield".
   * @private
   * @param event
   */
  onElementKeyPress(event) {
    const me = this;

    // Only react to keystrokes on grid cell elements
    if (
      DomHelper.up(
        event.target,
        BrowserHelper.isIE11 ? '.b-widget:not(.b-grid-subgrid):not(.b-grid)' : '.b-widget:not(.b-grid)'
      ) ||
      event.key === 'Enter'
    ) {
      return;
    }

    if (me.grid._focusedCell) {
      const column = me.grid.columns.getById(me.grid._focusedCell.columnId);
      // if trying to search in invalid column, it's a hard failure

      if (column && column.searchable !== false) {
        me.columnId = me.grid._focusedCell.columnId;

        if (event.key && event.key.length === 1) {
          me.find += event.key;
          me.search(me.find);
        }
      }
    }
  }

  onCellNavigate(grid, fromCellSelector, toCellSelector, event) {
    const me = this,
      found = me.prevFound || me.found;

    if (found && (!toCellSelector || toCellSelector.columnId !== me.columnId)) {
      me.clear();
    }
  }

  //endregion
}

QuickFind.featureClass = 'b-quick-find';

QuickFind._$name = 'QuickFind';
GridFeatureManager.registerFeature(QuickFind);

//TODO: Should listen for store search also, to work the other way around

/**
 * @module Grid/feature/Search
 */

/**
 * Feature that allows the user to search the entire grid. Navigate between hits using the
 * keyboard, [f3] or [ctrl]/[cmd] + [g] moves to next, also pressing [shift] moves to previous.
 *
 * Note that this feature does not include a UI, please build your own and call appropriate methods in the feature. For
 * a demo implementation, see
 * <a href="../examples/search" target="_blank">Search example</a>.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @example
 * // enable Search
 * let grid = new Grid({
 *   features: {
 *     search: true
 *   }
 * });
 *
 * // perform search
 * grid.features.search.search('steve');
 *
 * @demo search
 * @classtype search
 * @externalexample feature/Search.js
 */
class Search extends InstancePlugin {
  //region Init

  construct(grid, config) {
    const me = this;

    super.construct(grid, config);

    Object.assign(me, {
      store: grid.store,
      grid: grid,
      find: '',
      hitEls: []
    });
  }

  doDestroy() {
    this.clear(true);
    super.doDestroy();
  }

  //endregion

  //region Plugin config

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['getCellMenuItems', 'onElementKeyDown']
    };
  }

  //endregion

  //region Search

  /**
   * Performs a search and highlights hits.
   * @param {String} find Text to search for
   * @param {Boolean} gotoHit Go to first hit after search
   * @param {Boolean} reapply Pass true to force search
   */
  search(find, gotoHit = true, reapply = false) {
    // empty search considered a clear
    if (!find) {
      return this.clear();
    }

    // searching for same thing again, do nothing
    if (!reapply && find === this.find) {
      return;
    }

    const me = this,
      grid = me.grid,
      // Only search columns in use
      columns = grid.columns.visibleColumns.filter((col) => col.searchable !== false),
      fields = columns.map((col) => col.field),
      found = me.store.search(find, fields);

    let i = 1;

    Object.assign(me, {
      foundMap: {},
      prevFound: me.found,
      found: found,
      find: find
    });

    // clear old hits
    for (let cell of DomHelper.children(grid.element, '.b-search-hit')) {
      // IE11 doesnt support this
      //cell.classList.remove('b-search-hit', 'b-search-hit-cell');
      cell.classList.remove('b-search-hit');
      cell.classList.remove('b-search-hit-cell');

      // rerender cell to remove search-hit-text
      let row = DomDataStore.get(cell).row;
      row.renderCell(cell);
    }

    if (!found) return;

    // columns from previous search, reset htmlEncode
    if (me.hitColumns) {
      me.hitColumns.forEach((col) => (col.disableHtmlEncode = false));
    }

    me.hitColumns = [];

    // highlight hits for visible cells
    for (let hit of found) {
      me.foundMap[hit.field + '-' + hit.id] = i++;

      // disable htmlEncode for columns with hits
      const column = me.grid.columns.get(hit.field);
      if (column) {
        column.disableHtmlEncode = true;
        me.hitColumns.push(column);
      }
      // limit hits
      if (i > 1000) break;
    }

    if (!me.listenersInitialized) {
      me.grid.rowManager.on({ rendercell: me.renderCell }, me);
      me.store.on({ refresh: me.onStoreRefresh }, me);
      me.listenersInitialized = true;
    }

    grid.refreshRows();

    me.grid.trigger('search', { grid, find, found });

    if (gotoHit && !me.isHitFocused) {
      me.gotoNextHit(true);
    }

    return found;
  }

  /**
   * Clears search results.
   */
  clear(silent = false) {
    const me = this,
      grid = me.grid;

    if (me.foundMap) {
      delete me.foundMap;
      delete me.find;
    }

    DomHelper.forEachSelector(grid.element, '.b-search-hit', (cell) => {
      // IE11 doesnt support this
      //cell.classList.remove('b-search-hit', 'b-search-hit-cell');
      cell.classList.remove('b-search-hit');
      cell.classList.remove('b-search-hit-cell');
    });

    DomHelper.removeEachSelector(grid.element, '.b-search-hit-cell-badge,.b-search-hit-text');

    if (me.listenersInitialized) {
      grid.rowManager.un({ rendercell: me.renderCell }, me);
      me.store.un({ refresh: me.onStoreRefresh }, me);
      me.listenersInitialized = false;
    }

    if (!silent) {
      grid.refreshRows();

      me.grid.trigger('clearSearch', { grid });
    }
  }

  /**
   * Number of results found
   * @readonly
   * @returns {Number}
   */
  get foundCount() {
    return (this.found && this.found.length) || 0;
  }

  //endregion

  //region Navigation

  /**
   * Checks if focused row is a search hit.
   * @returns {Boolean} Returns true if focused row is a hit
   * @readonly
   */
  get isHitFocused() {
    let me = this,
      grid = me.grid,
      currentIndex = grid.focusedCell ? grid.store.indexOf(grid.focusedCell.id) : -1,
      currentColumn = grid.focusedCell ? grid.columns.getById(grid.focusedCell.columnId) : null;

    return (
      currentIndex !== -1 &&
      me.found.some((hit) => hit.index === currentIndex && currentColumn && hit.field === currentColumn.field)
    );
  }

  /**
   * Select the next hit, scrolling it into view. Triggered with [f3] or [ctrl]/[cmd] + [g].
   */
  gotoNextHit(fromStart = false) {
    const me = this;

    if (!me.found || !me.found.length) return;

    const grid = me.grid,
      fromCell = grid.focusedCell || grid.lastFocusedCell,
      currentIndex = fromCell && !fromStart ? grid.store.indexOf(fromCell.id) : -1,
      nextHit = me.found.findIndex((hit) => hit.index > currentIndex);

    if (nextHit !== -1) {
      me.gotoHit(nextHit);
    }
  }

  /**
   * Select the previous hit, scrolling it into view. Triggered with [shift] + [f3] or [shift] + [ctrl]/[cmd] + [g].
   */
  gotoPrevHit() {
    const me = this;

    if (!me.found || !me.found.length) return;

    const grid = me.grid,
      fromCell = grid.focusedCell || grid.lastFocusedCell,
      currentIndex = fromCell ? grid.store.indexOf(fromCell.id) : 0,
      found = me.found;

    for (let i = found.length - 1; i--; i >= 0) {
      let hit = found[i];
      if (hit.index < currentIndex) {
        me.gotoHit(i);
        break;
      }
    }
  }

  /**
   * Go to specified hit.
   * @param index
   */
  gotoHit(index) {
    let me = this,
      grid = me.grid,
      nextHit = me.found[index];

    if (nextHit) {
      grid.focusCell({
        field: nextHit.field,
        id: nextHit.id
      });
    }

    return !!nextHit;
  }

  /**
   * Go to the first hit.
   */
  gotoFirstHit() {
    this.gotoHit(0);
  }

  /**
   * Go to the last hit.
   */
  gotoLastHit() {
    this.gotoHit(this.found.length - 1);
  }

  //endregion

  //region Render

  /**
   * Called from SubGrid when a cell is rendered. Highlights search hits.
   * @private
   */
  renderCell({ cellElement, column, record, value, cellContent }) {
    const me = this,
      hitIndex = me.foundMap && me.foundMap[column.field + '-' + record.id];

    // clear search stuff from cell, might not be done by rendering since it does not always set innerHTML any longer
    //if (me.hitElements.includes(cellElement)) {
    //    const textElement  = cellElement.querySelector('.b-search-hit-text'),
    //        badgeElement = cellElement.querySelector('.b-search-hit-cell-badge');
    //
    //    textElement && textElement.remove();
    //    badgeElement && badgeElement.remove();
    //
    //    cellElement.classList.remove('b-search-hit');
    //    cellElement.classList.remove('b-search-hit-cell');
    //
    //    me.hitElements.splice(me.hitElements.indexOf(cellElement), 1);
    //}

    if (hitIndex) {
      // highlight cell
      cellElement.classList.add('b-search-hit');

      // highlight in cell if found in innerHTML
      const inner = DomHelper.down(cellElement, '.b-grid-cell-value') || cellElement,
        find = String(me.find).toLowerCase();

      if (String(value).toLowerCase() === find) {
        inner.innerHTML = `<span class="b-search-hit-text">${cellContent}</span><div class="b-search-hit-cell-badge">${hitIndex}</div>`;
      } else {
        const find = String(me.find).toLowerCase(),
          where = cellContent && cellContent.toLowerCase().indexOf(find);

        if (where > -1) {
          let end = where + find.length,
            casedFind = cellContent.slice(where, end);

          inner.innerHTML = `${cellContent.slice(
            0,
            where
          )}<span class="b-search-hit-text">${casedFind}</span>${cellContent.slice(
            end
          )}<div class="b-search-hit-cell-badge">${hitIndex}</div>`;
        } else {
          cellElement.classList.add('b-search-hit-cell');
        }
      }

      me.hitEls.push(cellElement);
    }
  }

  //endregion

  //region Context menu

  /**
   * Add search menu item to cell context menu.
   * @param column
   * @param record
   * @param items
   * @returns {*}
   * @private
   */
  getCellMenuItems(column, record, items) {
    const me = this;

    if (column.searchable) {
      items.push({
        text: me.L('searchForValue'),
        icon: 'b-fw-icon b-icon-search',
        cls: 'b-separator',
        name: 'search',
        onItem: ({ item }) => {
          const { column, record } = item;
          // TODO: Only extract selection from current cell instead? Lazy way for now
          let sel = window.getSelection().toString();
          if (!sel) sel = record[column.field];
          me.search(sel);
        }
      });
    }

    return items;
  }

  //endregion

  //region Events

  /**
   * Chained function called on grids keydown event. Handles backspace, escape, f3 and ctrl/cmd + g keys.
   * @private
   * @param event KeyboardEvent
   */
  onElementKeyDown(event) {
    const me = this;

    if (me.find && me.find !== '') {
      if (event.key === 'F3' || (event.key.toLowerCase() === 'g' && (event.ctrlKey || event.metaKey))) {
        event.preventDefault();

        if (event.shiftKey) {
          me.gotoPrevHit();
        } else {
          me.gotoNextHit();
        }
      }
    }
  }

  onStoreRefresh() {
    this.search(this.find, false, true);
  }

  //endregion
}

Search.featureClass = 'b-search';

Search._$name = 'Search';
GridFeatureManager.registerFeature(Search);

//TODO: Allow multisort using multitouch?

/**
 * @module Grid/feature/Sort
 */

/**
 * Allows sorting of grid by clicking (or tapping) headers, also displays which columns grid is sorted by (numbered if
 * using multisort). Use modifier keys for multisorting: meta + click to add sorter, meta + alt + click to remove sorter.
 * The actual sorting is done by the store.
 *
 * For info on programmatically handling sorting, see {@link Common.data.mixin.StoreSort StoreSort}.
 *
 * This feature is <strong>enabled</strong> by default.
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @example
 * // use initial sorting
 * let grid = new Grid({
 *   features: {
 *     sort: 'name'
 *   }
 * });
 *
 * // can also be specified on store
 * let grid = new Grid({
 *   store: {
 *     sorters: [
 *       { field: 'name', ascending: false }
 *     ]
 *   }
 * });
 *
 * @demo sorting
 * @classtype sort
 * @externalexample feature/Sort.js
 */
class Sort extends InstancePlugin {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Enable multi sort
       * @config {Boolean}
       * @default
       */
      multiSort: true,

      ignoreRe: new RegExp(
        [
          // Stop this feature from having to know the internals of two other optional features.
          'b-grid-header-resize-handle',
          'b-filter-icon'
        ].join('|')
      ),

      sortableCls: 'b-sortable',
      sortedCls: 'b-sort',
      sortedAscCls: 'b-asc',
      sortedDescCls: 'b-desc'
    };
  }

  //endregion

  //region Init

  construct(grid, config) {
    const me = this;

    // process initial config into an actual config object
    config = me.processConfig(config);

    me.store = grid.store;
    me.grid = grid;

    me.store.on({
      sort: me.syncHeaderSortState,
      thisObj: me
    });

    super.construct(grid, config);
  }

  // Sort feature handles special config cases, where user can supply a string or an array of sorters
  // instead of a normal config object
  processConfig(config) {
    if (typeof config === 'string' || Array.isArray(config)) {
      return {
        field: config,
        ascending: null
      };
    }

    return config;
  }

  // override setConfig to process config before applying it
  setConfig(config) {
    super.setConfig(this.processConfig(config));
  }

  set field(field) {
    // Use columns sortable config for initial sorting if it is specified
    const column = this.grid.columns.get(field);
    if (column && typeof column.sortable === 'object') {
      // Normalization of Store & CollectionSorter differences
      column.sortable.field = column.sortable.property || field;
      field = column.sortable;
    }

    this.store.sort(field, this.ascending);
  }

  doDestroy() {
    super.doDestroy();
  }

  //endregion

  //region Plugin config

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['onElementClick', 'getHeaderMenuItems', 'getColumnDragToolbarItems', 'renderHeader']
    };
  }

  //endregion

  //region Headers

  /**
   * Update headers to match stores sorters (displays sort icon in correct direction on them)
   * @private
   */
  syncHeaderSortState() {
    const me = this,
      sorterMap = {};

    if (!me.grid.isConfiguring) {
      let storeSorters = me.store.sorters,
        sorterCount = storeSorters.length,
        classList = new DomClassList(),
        sorter;

      // Key sorters object by field name so we can find them.
      for (let sortIndex = 0; sortIndex < sorterCount; sortIndex++) {
        const sorter = storeSorters[sortIndex];
        if (sorter.field) {
          sorterMap[sorter.field] = {
            ascending: sorter.ascending,
            sortIndex: sortIndex + 1
          };
        }
      }

      // Sync the sortable, sorted, and sortIndex state of each leaf header element
      for (const leafColumn of me.grid.columns.bottomColumns) {
        const leafHeader = leafColumn.element;

        if (leafHeader) {
          // TimeAxisColumn in Scheduler has no textWrapper, since it has custom rendering,
          // but since it cannot be sorted by anyway lets just ignore it
          const dataset = leafColumn.textWrapper && leafColumn.textWrapper.dataset;

          // data-sortIndex is 1-based, and only set if there is > 1 sorter.
          // iOS Safari throws a JS error if the requested delete property is not present.
          dataset && dataset.sortIndex && delete dataset.sortIndex;

          classList.value = leafHeader.classList;

          if (leafColumn.sortable !== false) {
            classList.add(me.sortableCls);
            sorter = sorterMap[leafColumn.field];
            if (sorter) {
              if (sorterCount > 1 && dataset) {
                dataset.sortIndex = sorter.sortIndex;
              }
              classList.add(me.sortedCls);
              if (sorter.ascending) {
                classList.add(me.sortedAscCls);
                classList.remove(me.sortedDescCls);
              } else {
                classList.add(me.sortedDescCls);
                classList.remove(me.sortedAscCls);
              }
            } else {
              classList.remove(me.sortedCls);
              // Not optimal, but easiest way to make sure sort feature does not remove needed classes.
              // Better solution would be to use different names for sorting and grouping
              if (!classList['b-group']) {
                classList.remove(me.sortedAscCls);
                classList.remove(me.sortedDescCls);
              }
            }
          } else {
            classList.remove(me.sortableCls);
          }

          // Update the element's classList
          DomHelper.syncClassList(leafHeader, classList);
        }
      }
    }
  }

  //endregion

  //region Context menu

  /**
   * Adds sort menu items to header context menu.
   * @param column
   * @param items
   * @returns {Object[]}
   * @private
   */
  getHeaderMenuItems(column, items) {
    const me = this;

    if (column.sortable !== false) {
      items.push({
        text: me.L('sortAscending'),
        icon: 'b-fw-icon b-icon-sort-asc',
        name: 'sortAsc',
        cls: 'b-separator',
        weight: 105,
        onItem: ({ item: { column } }) => me.store.sort(column.field, true)
      });
      items.push({
        text: me.L('sortDescending'),
        icon: 'b-fw-icon b-icon-sort-desc',
        name: 'sortDesc',
        weight: 105,
        onItem: ({ item: { column } }) => me.store.sort(column.field, false)
      });

      if (me.multiSort && me.grid.columns.records.filter((col) => col.sortable).length > 1) {
        const sorter = this.grid.store.sorters.find((s) => s.field === column.field);

        items.push({
          text: me.L('multiSort'),
          icon: 'b-fw-icon b-icon-sort',
          name: 'multiSort',
          weight: 105,
          menu: [
            {
              text: sorter ? me.L('toggleSortAscending') : me.L('addSortAscending'),
              icon: 'b-fw-icon b-icon-sort-asc',
              name: 'addSortAsc',
              disabled: sorter && sorter.ascending,
              weight: 105,
              onItem: ({ item: { column } }) => me.store.addSorter(column.field, true)
            },
            {
              text: sorter ? me.L('toggleSortDescending') : me.L('addSortDescending'),
              icon: 'b-fw-icon b-icon-sort-desc',
              name: 'addSortDesc',
              disabled: sorter && !sorter.ascending,
              weight: 105,
              onItem: ({ item: { column } }) => me.store.addSorter(column.field, false)
            },
            {
              text: me.L('removeSorter'),
              icon: 'b-fw-icon b-icon-remove',
              name: 'remove-sorter',
              weight: 105,
              disabled: !sorter,
              onItem: ({ item: { column } }) => me.store.removeSorter(column.field)
            }
          ]
        });
      }
    }
    return items;
  }

  /**
   * Supply items to ColumnDragToolbar
   * @private
   */
  getColumnDragToolbarItems(column, items) {
    const me = this,
      store = me.store;

    if (column.sortable !== false) {
      items.push({
        text: me.L('sortAscendingShort'),
        group: me.L('Sort'),
        icon: 'b-icon b-icon-sort-asc',
        name: 'sortAsc',
        cls: 'b-separator',
        weight: 105,
        onDrop: ({ column }) => store.sort(column.field, true)
      });
      items.push({
        text: me.L('sortDescendingShort'),
        group: me.L('Sort'),
        icon: 'b-icon b-icon-sort-desc',
        name: 'sortDesc',
        weight: 105,
        onDrop: ({ column }) => store.sort(column.field, false)
      });

      const sorter = store.sorters.find((s) => s.field === column.field);

      Array.prototype.push.apply(items, [
        {
          text: me.L('addSortAscendingShort'),
          group: me.L('Multisort'),
          icon: 'b-icon b-icon-sort-asc',
          name: 'multisortAddAsc',
          disabled: sorter && sorter.ascending,
          weight: 105,
          onDrop: ({ column }) => store.addSorter(column.field, true)
        },
        {
          text: me.L('addSortDescendingShort'),
          group: me.L('Multisort'),
          icon: 'b-icon b-icon-sort-desc',
          name: 'multisortAddDesc',
          disabled: sorter && !sorter.ascending,
          weight: 105,
          onDrop: ({ column }) => store.addSorter(column.field, false)
        },
        {
          text: me.L('removeSorterShort'),
          group: me.L('Multisort'),
          icon: 'b-icon b-icon-remove',
          name: 'multisortRemove',
          weight: 105,
          disabled: !sorter,
          onDrop: ({ column }) => store.removeSorter(column.field)
        }
      ]);
    }
    return items;
  }

  //endregion

  //region Events

  /**
   * Clicked on header, sort Store.
   * @private
   */
  onElementClick(event) {
    const me = this,
      store = me.store,
      target = event.target,
      header = DomHelper.up(target, '.b-grid-header.b-sortable'),
      field = header && header.dataset.column;

    if (me.ignoreRe.test(target.className)) return;

    //Header
    if (header && field) {
      const column = me.grid.columns.getById(header.dataset.columnId),
        columnGrouper = store.groupers.find((g) => g.field === field);

      // The Group feature will handle the change of the grouper's direction
      if (columnGrouper && !event.shiftKey) {
        return;
      }

      if (column.sortable && !event.shiftKey) {
        if (event.metaKey && event.altKey) {
          store.removeSorter(column.field);
        } else {
          let sortBy = column.field;

          if (typeof column.sortable === 'function') {
            sortBy = {
              field: column.field,
              fn: column.sortable
            };
          } else if (typeof column.sortable === 'object') {
            sortBy = column.sortable;
            // Handle mismatch between Store#sort and CollectionSorter (field/property)
            if (!sortBy.field) {
              sortBy.field = sortBy.property || column.field;
            }
          }
          store.sort(sortBy, null, event.metaKey);
        }
      }
    }
  }

  /**
   * Called when grid headers are rendered, make headers match current sorters.
   * @private
   */
  renderHeader() {
    this.syncHeaderSortState();
  }

  //endregion
}

Sort.featureClass = 'b-sort';

Sort._$name = 'Sort';
GridFeatureManager.registerFeature(Sort, true);

/**
 * @module Grid/feature/RegionResize
 */

/**
 * Makes the splitter between grid section draggable so you can resize grid sections.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @example
 * // enable RegionResize
 * let grid = new Grid({
 *   features: {
 *     regionResize: true
 *   }
 * });
 *
 * @demo features
 * @classtype regionResize
 * @externalexample feature/RegionResize.js
 */
class RegionResize extends InstancePlugin {
  // region Init

  construct(grid, config) {
    this.grid = grid;

    super.construct(grid, config);
  }

  doDestroy() {
    // TODO: Cleanup
    super.doDestroy();
  }

  //endregion

  //region Plugin config

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: [
        'onElementTouchStart',
        'onElementTouchMove',
        'onElementTouchEnd',
        'onElementMouseDown',
        'onElementMouseMove',
        'onElementDblClick',
        'onElementMouseUp',
        'onSubGridCollapse',
        'onSubGridExpand',
        'render'
      ]
    };
  }

  //endregion

  onElementDblClick(event) {
    const me = this,
      grid = me.grid,
      splitterEl = DomHelper.up(event.target, '.b-grid-splitter-collapsed');

    // If collapsed splitter is dblclicked and region is not expanding
    // It is unlikely that user might dblclick splitter twice and even if he does, nothing should happen.
    // But just in case lets not expand twice.
    if (splitterEl && !me.expanding) {
      me.expanding = true;

      let region = splitterEl.dataset.region,
        subGrid = grid.getSubGrid(region);

      // Usually collapsed splitter means corresponding region is collapsed. But in case of last two regions one
      // splitter can be collapsed in two directions. So, if corresponding region is expanded then last one is collapsed
      if (!subGrid.collapsed) {
        region = grid.getLastRegions()[1];
        subGrid = grid.getSubGrid(region);
      }

      subGrid.expand().then(() => (me.expanding = false));
    }
  }

  //region Move splitter

  /**
   * Begin moving splitter.
   * @private
   * @param splitterElement Splitter element
   * @param clientX Initial x position from which new width will be calculated on move
   */
  startMove(splitterElement, clientX) {
    let me = this,
      { grid } = me,
      region = splitterElement.dataset.region,
      gridEl = grid.element,
      subGrid = grid.getSubGrid(region),
      nextRegion = grid.regions[grid.regions.indexOf(region) + 1],
      nextSubGrid = grid.getSubGrid(nextRegion),
      flip = 1;

    if (subGrid.flex != null) {
      // If subgrid has flex, check if next one does not
      if (nextSubGrid.flex == null) {
        subGrid = nextSubGrid;
        flip = -1;
      }
    }

    if (splitterElement.classList.contains('b-grid-splitter-collapsed')) {
      return;
    }

    const availableWidth = subGrid.element.offsetWidth + nextSubGrid.element.offsetWidth;

    me.dragContext = {
      element: splitterElement,
      headerEl: subGrid.header.element,
      subGridEl: subGrid.element,
      subGrid: subGrid,
      originalWidth: subGrid.element.offsetWidth,
      originalX: clientX,
      minWidth: subGrid.minWidth || 0,
      maxWidth: Math.min(availableWidth, subGrid.maxWidth || availableWidth),
      flip
    };

    gridEl.classList.add('b-moving-splitter');

    splitterElement.classList.add('b-moving');
  }

  onCollapseClick(subGrid, splitterEl) {
    const me = this,
      grid = me.grid,
      region = splitterEl.dataset.region,
      regions = grid.getLastRegions();

    // Last splitter in the grid is responsible for collapsing/expanding last 2 regions and is always related to the
    // left one. Check if we are working with last splitter
    if (regions[0] === region) {
      const lastSubGrid = grid.getSubGrid(regions[1]);
      if (lastSubGrid.collapsed) {
        lastSubGrid.expand();
        return;
      }
    }

    subGrid.collapse();
  }

  onExpandClick(subGrid, splitterEl) {
    const me = this,
      grid = me.grid,
      region = splitterEl.dataset.region,
      regions = grid.getLastRegions();

    // Last splitter in the grid is responsible for collapsing/expanding last 2 regions and is always related to the
    // left one. Check if we are working with last splitter
    if (regions[0] === region) {
      if (!subGrid.collapsed) {
        const lastSubGrid = grid.getSubGrid(regions[1]);
        lastSubGrid.collapse();
        return;
      }
    }

    subGrid.expand();
  }

  /**
   * Update splitter position.
   * @private
   * @param newClientX
   */
  updateMove(newClientX) {
    const { dragContext } = this;

    if (dragContext) {
      const difX = newClientX - dragContext.originalX,
        newWidth = Math.min(dragContext.maxWidth, dragContext.originalWidth + difX * dragContext.flip);

      // SubGrids monitor their own size and keep any splitters synced
      dragContext.subGrid.width = Math.max(newWidth, dragContext.minWidth);
    }
  }

  /**
   * Stop moving splitter.
   * @private
   */
  endMove() {
    const me = this,
      dragContext = me.dragContext;

    if (dragContext) {
      me.grid.element.classList.remove('b-moving-splitter');
      dragContext.element.classList.remove('b-moving');
      me.dragContext = null;
    }
  }

  //endregion

  //region Events

  /**
   * Start moving splitter on touch start.
   * @private
   * @param event
   */
  onElementTouchStart(event) {
    const me = this,
      target = event.target;

    if (target.classList.contains('b-grid-splitter')) {
      me.startMove(target, event.touches[0].clientX);
      event.preventDefault();
    }
  }

  /**
   * Move splitter on touch move.
   * @private
   * @param event
   */
  onElementTouchMove(event) {
    if (this.dragContext) {
      this.updateMove(event.touches[0].clientX);
      event.preventDefault();
    }
  }

  /**
   * Stop moving splitter on touch end.
   * @private
   * @param event
   */
  onElementTouchEnd(event) {
    if (this.dragContext) {
      this.endMove();
      event.preventDefault();
    }
  }

  /**
   * Start moving splitter on mouse down (on splitter).
   * @private
   * @param event
   */
  onElementMouseDown(event) {
    const me = this,
      target = event.target,
      splitter = event.target.closest(
        ':not(.b-row-reordering):not(.b-dragging-event):not(.b-dragging-task):not(.b-dragging-header):not(.b-dragselecting) .b-grid-splitter'
      ),
      subGrid = splitter && me.grid.getSubGrid(splitter.dataset.region);

    // Only care about left clicks, avoids a bug found by monkeys
    if (event.button === 0) {
      // In case of touch screen inner splitter has 100% height and we should handle
      // it as target too
      if (target.classList.contains('b-grid-splitter') || target.classList.contains('b-grid-splitter-inner')) {
        me.startMove(splitter, event.clientX);
        event.preventDefault();
      } else if (target.classList.contains('b-icon-collapse-gridregion')) {
        me.onCollapseClick(subGrid, splitter);
      } else if (target.classList.contains('b-icon-expand-gridregion')) {
        me.onExpandClick(subGrid, splitter);
      }
    }
  }

  /**
   * Move splitter on mouse move.
   * @private
   * @param event
   */
  onElementMouseMove(event) {
    if (this.dragContext) {
      this.updateMove(event.clientX);
      event.preventDefault();
    }
  }

  /**
   * Stop moving splitter on mouse up.
   * @private
   * @param event
   */
  onElementMouseUp(event) {
    if (this.dragContext) {
      this.endMove();
      event.preventDefault();
    }
  }

  onSubGridCollapse(subGrid) {
    const splitterEl = this.grid.resolveSplitter(subGrid),
      regions = this.grid.getLastRegions();

    // if last region was collapsed
    if (regions[1] === subGrid.region) {
      splitterEl.classList.add('b-grid-splitter-allow-collapse');
    }
  }

  onSubGridExpand(subGrid) {
    const splitterEl = this.grid.resolveSplitter(subGrid);
    splitterEl.classList.remove('b-grid-splitter-allow-collapse');
  }

  //endregion

  render() {
    const { regions, subGrids } = this.grid;

    // Multiple regions, only allow collapsing to the edges by hiding buttons
    if (regions.length > 2) {
      // Only works in a 3 subgrid scenario. To support more subgrids we have to merge splitters or something
      // on collapse. Not going down that path currently...
      subGrids[regions[0]].splitterElement.classList.add('b-left-only');
      subGrids[regions[1]].splitterElement.classList.add('b-right-only');
    }
  }
}

RegionResize.featureClass = 'b-split';

RegionResize._$name = 'RegionResize';
GridFeatureManager.registerFeature(RegionResize);

/**
 * @module Grid/feature/RowReorder
 */

/**
 * Allows user to reorder rows by dragging them. To get notified about row reorder listen to `change` event
 * on the grid {@link Common.data.Store store}.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * If the grid is set to {@link Grid.view.Grid#config-readOnly}, reordering is disabled.
 *
 * You can validate the drag drop flow by listening to the `gridrowdrag` event. Inside this listener you have access to the `index` property which is the target drop position.
 * For trees you get access to the `parent` record and `index`, where index means the child index inside the parent.
 *
 * ```
 * features : {
 *     rowReorder : {
 *         listeners : {
 *             gridRowDrag : ({ context }) => {
 *                // Here you have access to context.insertBefore, and additionally context.parent for trees
 *
 *                context.valid = false;
 *             }
 *         }
 *     }
 * }
 * ```
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @classtype rowReorder
 */
class RowReorder extends Delayable(InstancePlugin) {
  //region Events
  /**
   * Fired before dragging starts, return false to prevent the drag operation.
   * @preventable
   * @event beforeGridRowDragStart
   * @param {DragHelper} source
   * @param {Object} context
   * @param {MouseEvent|TouchEvent} event
   */

  /**
   * Fired when dragging starts.
   * @event gridRowDragStart
   * @param {DragHelper} source
   * @param {Object} context
   * @param {MouseEvent|TouchEvent} event
   */

  /**
   * Fired while the row is being dragged, in the listener function you have access to `context.insertBefore` a grid / tree record, and additionally `context.parent` (a TreeNode) for trees. You can
   * signal that the drop position is valid or invalid by setting `context.valid = false;`
   * @event gridRowDrag
   * @param {DragHelper} source
   * @param {Object} context
   * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid.
   * @param {Common.data.Model} context.insertBefore The record to insert before (`null` if inserting at last position of a parent node)
   * @param {Common.data.Model} context.parent The parent record of the current drop position (only applicable for trees)
   * @param {MouseEvent} event
   */

  /**
   * Fired on row drop
   * @event gridRowDrop
   * @param {DragHelper} source
   * @param {Object} context
   * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid.
   * @param {Common.data.Model} context.insertBefore The record to insert before (`null` if inserting at last position of a parent node)
   * @param {Common.data.Model} context.parent The parent record of the current drop position (only applicable for trees)
   * @param {MouseEvent} event
   */

  /**
   * Fired when a row drag operation is aborted
   * @event gridRowAbort
   * @param {DragHelper} source
   * @param {Object} context
   * @param {MouseEvent} event
   */
  //endregion

  //region Init

  static get defaultConfig() {
    return {
      /**
       * If hovering over a parent node for this period of a time in a tree, the node will expand
       * @config {Number}
       */
      hoverExpandTimeout: 1000
    };
  }

  construct(grid, config) {
    this.grid = grid;

    super.construct(...arguments);
  }

  doDestroy() {
    this.dragHelper && this.dragHelper.destroy();

    super.doDestroy();
  }

  /**
   * Initialize drag & drop (called from render)
   * @private
   */
  init() {
    const me = this,
      { grid } = me;

    me.dragHelper = new DragHelper({
      name: 'rowReorder',
      mode: 'translateXY',
      cloneTarget: true,
      dragThreshold: 10,
      targetSelector: '.b-grid-row',
      lockX: true,
      scrollManager: grid.scrollManager,
      dragWithin: grid.verticalScroller,
      outerElement: grid.verticalScroller,

      // Since parent nodes can expand after hovering, meaning original drag start position now refers to a different point in the tree
      ignoreSamePositionDrop: false,

      createProxy(element) {
        const clone = element.cloneNode(true),
          container = document.createElement('div');

        clone.removeAttribute('id');
        // The containing element will be positioned instead
        clone.style.transform = '';

        container.appendChild(clone);

        return container;
      },

      listeners: {
        beforedragstart: me.onBeforeDragStart,
        dragstart: me.onDragStart,
        drag: me.onDrag,
        drop: me.onDrop,
        reset: me.onReset,
        thisObj: me
      }
    });

    me.dropIndicator = DomHelper.createElement({
      parent: grid.bodyContainer,
      className: 'b-row-drop-indicator'
    });

    me.relayEvents(me.dragHelper, ['beforeDragStart', 'dragStart', 'drag', 'drop', 'abort'], 'gridRow');
  }

  //endregion

  //region Plugin config

  static get pluginConfig() {
    return {
      after: ['render']
    };
  }

  //endregion

  //region Events (drop)

  onBeforeDragStart({ context }) {
    const grid = this.grid,
      targetSubGrid = grid.regions[0],
      subGridEl = grid.subGrids[targetSubGrid].element;

    // Disabled for touch devices until implemented fully. https://app.assembla.com/spaces/bryntum/tickets/8185-fix-row-reorder-for-touch-devices/details#
    // Only dragging enabled in the leftmost grid section
    if (this.disabled || grid.readOnly || DomHelper.isTouchEvent || !subGridEl.contains(context.element)) {
      return false;
    }

    const record = this.grid.getRecordFromElement(context.element);

    return !record.meta.specialRow;
  }

  onDragStart({ context }) {
    const me = this,
      record = me.grid.getRecordFromElement(context.grabbed);

    if (!record) {
      throw new Error('Failed to find record for dragged element');
    }

    if (me.grid.features.cellEdit) {
      me.grid.readOnly = true;
      me.grid.features.cellEdit.cancelEditing(true);
    }

    if (me.grid.features.contextMenu) {
      me.grid.features.contextMenu.hideContextMenu(false);
    }

    me.grid.element.classList.add('b-row-reordering');

    const focusedCell = context.element.querySelector('.b-focused');
    focusedCell && focusedCell.classList.remove('b-focused');

    DomHelper.removeClasses(context.element.firstElementChild, ['b-selected', 'b-hover']);

    me.record = record;
  }

  onDrag({ context, event }) {
    const me = this,
      { store, rowManager } = me.grid;

    // Ignore if user drags outside grid area
    if (!me.dragHelper.outerElement.contains(event.target) || !event.target.closest('.b-grid-subgrid')) {
      context.valid = false;
      return;
    }

    let valid = context.valid,
      row = me.grid.rowManager.getRowAt(event.clientY),
      overRecord,
      dataIndex,
      after,
      insertBefore;

    if (row) {
      const rowTop = row.top + me.grid._bodyRectangle.y,
        middleY = rowTop + row.height / 2;

      dataIndex = row.dataIndex;
      overRecord = row && store.getAt(dataIndex);

      // Drop after row below if mouse is in bottom half of hovered row
      after = event.clientY > middleY;
    }
    // Below the rows. Drop after last row
    else {
      dataIndex = store.count - 1;
      overRecord = store.last;
      row = me.grid.rowManager.getRow(dataIndex);
      after = true;
    }

    // Hovering the dragged record. This is a no-op.
    // But still gather the contextual data.
    if (overRecord === me.record) {
      valid = false;
    }

    if (store.tree) {
      DomHelper.removeClsGlobally(me.grid.element, 'b-row-reordering-target-parent');

      insertBefore = after ? overRecord.nextSibling : overRecord;

      // For trees, prevent moving a parent into its own hierarchy
      if (me.record.contains(overRecord)) {
        valid = false;
      }

      context.parent = overRecord.parent;

      if (!context.parent.isRoot) {
        const parentRow = rowManager.getRowById(context.parent);

        if (parentRow) {
          parentRow.addCls('b-row-reordering-target-parent');
        }
      }

      me.clearTimeout(me.hoverTimer);

      if (overRecord && overRecord.isParent && !overRecord.isExpanded(store)) {
        me.hoverTimer = me.setTimeout(() => me.grid.expand(overRecord), me.hoverExpandTimeout);
      }
    } else {
      // Public property used for validation
      insertBefore = after ? store.getAt(dataIndex + 1) : overRecord;
    }

    // Provide visual clue to user of the drop position
    DomHelper.setTranslateY(me.dropIndicator, row.top + (after ? row.height : 0));

    context.insertBefore = insertBefore;

    context.valid = valid;
  }

  /**
   * Handle drop
   * @private
   */
  onDrop({ context }) {
    const me = this,
      grid = me.grid,
      store = grid.store;

    context.asyncCleanup = context.async = true;

    context.element.classList.add('b-dropping');

    me.setTimeout(() => {
      grid.element.classList.remove('b-row-reordering');

      if (context.valid) {
        if (store.tree) {
          context.parent.insertChild(me.record, context.insertBefore);
        } else {
          store.insert(context.insertBefore ? store.indexOf(context.insertBefore) : store.count, me.record);
        }

        store.clearSorters();

        context.finalize();
      }
    }, 300);
  }

  /**
   * Clean up on reset
   * @private
   */
  onReset() {
    const me = this;

    me.grid.element.classList.remove('b-row-reordering');
    me.grid.readOnly = false;

    DomHelper.removeClsGlobally(me.grid.element, 'b-row-reordering-target-parent');
  }

  //endregion

  //region Render

  /**
   * Updates DragHelper with updated headers when grid contents is rerendered
   * @private
   */
  render() {
    // columns shown, hidden or reordered
    this.init();
  }

  //endregion
}

RowReorder.featureClass = '';

RowReorder._$name = 'RowReorder';
GridFeatureManager.registerFeature(RowReorder, false);
GridFeatureManager.registerFeature(RowReorder, true, 'Gantt');

/**
 * @module Grid/feature/Stripe
 */

/**
 * Stripes rows, by adding even (b-even) or odd (b-odd) css classes to row elements.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @example
 * let grid = new Grid({
 *   features: {
 *     stripe: true
 *   }
 * });
 *
 * @demo columns
 * @classtype stripe
 * @externalexample feature/Stripe.js
 */
class Stripe extends InstancePlugin {
  construct(grid, config) {
    this.grid = grid;

    super.construct(grid, config);

    grid.rowManager.on({
      renderrow: this.onRenderRow,
      thisObj: this
    });
  }

  /**
   * Applies even/odd CSS when row is rendered
   * @param {Grid.row.Row} rowModel
   * @private
   */
  onRenderRow({ row }) {
    row.addCls(row.dataIndex % 2 === 0 ? 'b-even' : 'b-odd');
  }
}

Stripe._$name = 'Stripe';
GridFeatureManager.registerFeature(Stripe);

//TODO: Handle paths? Like expandPath('Parent A/Sub B/Leaf')

/**
 * @module Grid/feature/Tree
 */

const immediatePromise$3 = new Promise((resolve) => resolve());

/**
 * Feature that makes the grid work more like a tree. Included by default in {@link Grid.view.TreeGrid}. Requires
 * exactly one {@link Grid.column.TreeColumn} among grids columns. That column will have its renderer replaced with a
 * tree renderer that adds padding and icon to give the appearance of a tree. The original renderer is preserved and
 * also called.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @demo tree
 * @classtype tree
 * @externalexample feature/Tree.js
 */
class Tree extends Delayable(InstancePlugin) {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Expand parent nodes when clicking on their cell
       * @config {Boolean}
       * @default
       */
      expandOnCellClick: false
    };
  }

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      assign: ['collapseAll', 'expandAll', 'collapse', 'expand', 'expandTo', 'toggleCollapse'],
      before: ['navigateRight', 'navigateLeft'],
      chain: ['onElementClick', 'onElementKeyDown']
    };
  }

  //endregion

  //region Init

  construct(grid, config) {
    const me = this;

    super.construct(grid, config);

    // find column
    const treeColumn = grid.columns.find((col) => col instanceof TreeColumn);

    Object.assign(me, {
      grid: grid,
      store: grid.store,
      rowManager: grid.rowManager,
      treeColumn: treeColumn
    });
  }

  doDestroy() {
    //TODO: Cleanup
    super.doDestroy();
  }

  //endregion

  //region Expand & collapse

  /**
   * Collapse an expanded node or expand a collapsed. Optionally forcing a certain state.
   * @param {String|Number|Common.data.Model} idOrRecord Record (the node itself) or id of a node to toggle
   * @param {Boolean} [collapse] Force collapse (true) or expand (false)
   * @param {Boolean} [skipRefresh] Set to true to not refresh rows (if calling in batch)
   * @returns {Promise}
   */
  async toggleCollapse(idOrRecord, collapse, skipRefresh = false) {
    const me = this,
      { store, grid } = me,
      rowManager = grid.rowManager,
      record = store.getById(idOrRecord),
      meta = record.instanceMeta(store);

    // If in the middle of a load, we cannot proceed.
    // If its a leaf, this is a no-op.
    if (meta.isLoadingChildren || record.isLeaf) {
      return;
    }

    let success = true,
      row = rowManager.getRowFor(record);

    if (collapse === undefined) {
      collapse = !meta.collapsed;
    }

    // Reject a no-op before the beforeToggleNode is fired
    if (Boolean(meta.collapsed) === collapse) {
      return;
    }

    grid.trigger('beforeToggleNode', { source: grid, record, collapse });
    meta.collapsed = collapse;

    if (meta.collapsed) {
      store.onNodeCollapse(record);
    } else {
      store.onNodeExpand(record);

      // Children not yet loaded, ask store for them.
      // It will append them. Appending to a node which
      // is expandded will insert the children into the UI.
      if (!record.isLoaded) {
        meta.isLoadingChildren = true;

        if (row) {
          row.addCls('b-loading-children');
        }

        try {
          await store.loadChildren(record);

          // Recache the row after possible async render
          row = rowManager.getRowFor(record);
        } catch (exception) {
          // fail triggers event within loadChildren, no need to do much here
          success = false;
          meta.collapsed = true;
        } finally {
          // row might have changed during load
          if (row) {
            row.removeCls('b-loading-children');
          }

          meta.isLoadingChildren = false;
        }
      }
    }

    if (success) {
      if (row) {
        const cell = row.getCell(me.treeColumn.id);

        // Toggle cell's expanded/collapsed state
        row.renderCell(cell, record);
      }

      // Add a temporary cls, used by Scheduler & Gantt to prevent transitions on events/tasks
      // Block multiple applications in the case of a recursive collapseAll operation
      if (!me.isTogglingNode) {
        grid.element.classList.add('b-toggling-node');
        me.isTogglingNode = true;
        me.requestAnimationFrame(() => {
          grid.element.classList.remove('b-toggling-node');
          me.isTogglingNode = false;
        });
      }

      grid.trigger(meta.collapsed ? 'collapseNode' : 'expandNode', { source: grid, record });
      grid.trigger('toggleNode', { source: grid, record, collapse });
    }
  }

  /**
   * Collapse a single node. This function is exposed on Grid and can thus be called as `grid.collapse()`
   * @param {String|Number|Common.data.Model} idOrRecord Record (the node itself) or id of a node to collapse
   * @returns {Promise}
   */
  async collapse(idOrRecord) {
    return this.toggleCollapse(idOrRecord, true);
  }

  /**
   * Expand a single node. This function is exposed on Grid and can thus be called as `grid.expand()`
   * @param {String|Number|Common.data.Model} idOrRecord Record (the node itself) or id of a node to expand
   * @returns {Promise}
   */
  async expand(idOrRecord) {
    return this.toggleCollapse(idOrRecord, false);
  }

  /**
   * Expand or collapse all nodes, as specified by param, starting at the passed node (which defaults to the root node)
   * @param {Boolean} [collapse] Set to true to collapse, false to expand (defaults to true)
   * @param {Common.data.Model} [topNode] The topmost node from which to cascade a collapse.
   * Defaults to the {@link Common.data.Store#property-rootNode}. Not included in the cascade if
   * the root node is being used.
   * @returns {Promise}
   */
  expandOrCollapseAll(collapse = true, topNode = this.store.rootNode) {
    // TODO: Some logic here and some in the store, keep in same place maybe
    const { grid, store } = this,
      promises = [];

    grid.trigger('beforeToggleAllNodes', { source: grid, collapse });

    // Each collapse/expand will trigger events on store, avoid that by suspending
    store.suspendEvents();
    topNode.traverse((record) => {
      const gridMeta = record.instanceMeta(store);
      if (!record.isLeaf) {
        if (collapse && !gridMeta.collapsed) {
          this.toggleCollapse(record, true, true);
        } else if (!collapse && gridMeta.collapsed) {
          promises.push(this.toggleCollapse(record, false, true));
        }
      }
    }, topNode === store.rootNode);
    store.resumeEvents();

    // Return to top when collapsing all
    grid.refreshRows(true);

    grid.trigger('toggleAllNodes', { source: grid, collapse });

    return collapse ? immediatePromise$3 : Promise.all(promises);
  }

  /**
   * Collapse all nodes. This function is exposed on Grid and can thus be called as `grid.collapseAll()`
   * @returns {Promise}
   */
  async collapseAll() {
    return this.expandOrCollapseAll(true);
  }

  /**
   * Expand all nodes. This function is exposed on Grid and can thus be called as `grid.expandAll()`
   * @returns {Promise}
   */
  async expandAll() {
    return this.expandOrCollapseAll(false);
  }

  /**
   * Expands parent nodes to make this node "visible". This function is exposed on Grid and can thus be called as
   * `grid.expandTo()`
   * @param {String|Number|Common.data.Model} idOrRecord Record (the node itself) or id of a node
   * @returns {Promise}
   */
  async expandTo(idOrRecord) {
    const me = this,
      record = me.store.getById(idOrRecord),
      recordMeta = record.instanceMeta(me.store);

    // Already visible? abort
    if (recordMeta.hiddenByCollapse === false) return;

    // Expand each parent
    let refreshNeeded = false,
      parent = record.parent,
      parents = [];

    // To expand path correctly we need to do it from top
    // so parent record for each record will be in the store already
    while (parent && !parent.isRoot) {
      parents.push(parent);
      parent = parent.parent;
    }

    await parents.reverse().forEach(async (parent) => {
      if (parent.instanceMeta(me.store).collapsed) {
        refreshNeeded = true;
      }
      await me.toggleCollapse(parent, false, true);
    });

    if (refreshNeeded) {
      me.grid.refreshRows();
    }

    await me.grid.scrollRowIntoView(record);
  }

  //endregion

  //region Renderer

  //endregion

  //region Events

  /**
   * Called when user clicks somewhere in the grid. Expand/collapse node on icon click.
   * @private
   */
  onElementClick(event) {
    const me = this,
      target = event.target,
      cellData = me.grid.getEventData(event);

    // Checks if click is on node expander icon, then toggles expand/collapse. Also toggles on entire cell if expandOnCellClick is true
    if (
      target.classList.contains('b-tree-expander') ||
      (me.expandOnCellClick && cellData && cellData.record.isParent)
    ) {
      me.toggleCollapse(cellData.record);
    }
  }

  /**
   * Called on key down in grid. Expand/collapse node on [space]
   * @private
   */
  onElementKeyDown(event) {
    // only catch space on grid element, not in editors etc...
    if (event.target === this.client.element && event.key === ' ') {
      event.preventDefault();

      this.toggleCollapse(this.grid.focusedCell.id);
    }
  }

  //endregion

  navigateRight(event) {
    const me = this,
      grid = me.grid,
      cellSelector = grid.focusedCell;

    if (cellSelector) {
      const record = grid.store.getById(cellSelector.id);

      // shift triggers tree navigation behaviour, also used by default for single column which is tree
      if (grid.columns.getById(cellSelector.columnId).tree && (event.shiftKey || grid.columns.count === 1)) {
        // on collapsed parent, expand
        if (record.isParent && record.instanceMeta(grid.store).collapsed) {
          me.expand(record);
        }
        // otherwise go down
        else {
          grid.navigateDown(event);
        }
        return false;
      }
    }
  }

  navigateLeft(event) {
    const me = this,
      grid = me.grid,
      cellSelector = grid.focusedCell;

    if (cellSelector) {
      const record = grid.store.getById(cellSelector.id);

      if (grid.columns.getById(cellSelector.columnId).tree && (event.shiftKey || grid.columns.count === 1)) {
        // on expanded parent, collapse
        if (record.isParent && !record.instanceMeta(grid.store).collapsed) {
          me.collapse(record);
        }
        // otherwise go to parent
        else if (record.parent) {
          grid.focusCell({
            id: record.parent.id,
            columnId: cellSelector.columnId
          });
        }
        return false;
      }
    }
  }
}

Tree.featureClass = 'b-tree';

Tree._$name = 'Tree';
GridFeatureManager.registerFeature(Tree, false, 'Grid');
GridFeatureManager.registerFeature(Tree, true, 'TreeGrid');

/**
 * @module Grid/util/ScrollManager
 */

/**
 * Allows features to scroll grid when for example dragging close to edges. Normally you should not need to interact
 * with this class.
 * @internal
 */
class ScrollManager extends Delayable(Base) {
  //region Default config

  static get defaultConfig() {
    return {
      /**
       * Width in pixels of zone at element edges where scrolling can be triggered
       * @config {Number}
       * @default
       */
      zoneWidth: 50,

      /**
       * Scroll speed, higher number is slower. Calculated as "distance from zone edge / scrollSpeed"
       * @config {Number}
       * @default
       */
      scrollSpeed: 5,

      /**
       * Default element to use for vertical scrolling. Can be overridden in calls to `startMonitoring()`.
       * @config {HTMLElement}
       */
      verticalElement: null,

      /**
       * The direction(s) to scroll ('horizontal', 'vertical' or 'both')
       * @config {String}
       */
      direction: 'both',

      monitoring: []
    };
  }

  //endregion

  //region Start/stop monitoring

  /**
   * Starts monitoring an element. It will be scrolled if mouse is pressed and within zoneWidth pixels from element edge.
   * @param {HTMLElement|Object} elementOrConfig Element which might be scrolled or config { element, callback, thisObj }
   */
  startMonitoring(elementOrConfig) {
    const me = this,
      config = elementOrConfig instanceof HTMLElement ? { element: elementOrConfig } : elementOrConfig,
      element = config.element,
      verticalElement = config.verticalElement || me.verticalElement || element;

    // only interested in elements that exists and are scrollable
    if (
      element &&
      (element.scrollWidth > element.offsetWidth || verticalElement.scrollHeight > verticalElement.offsetHeight)
    ) {
      // already monitoring, bail out
      if (me.monitoring.find((m) => m.element === element)) return;

      config.direction = config.direction || me.direction;

      // store some stuff needed later
      Object.assign(config, {
        verticalElement,
        scrollManager: me,
        startScrollLeft: element.scrollLeft,
        startScrollTop: verticalElement.scrollTop,
        scrollLeft: element.scrollLeft,
        scrollTop: verticalElement.scrollTop,
        scrollRelativeLeft: 0,
        scrollRelativeTop: 0
      });

      const handler = me.onMouseMove.bind(config);

      // listen to mousemove to determine if scroll needed or not
      me.mouseMoveDetacher = EventHelper.on({
        mousemove: handler,
        touchmove: handler,
        element
      });

      // Cache scrollWidth because it may actually change in Edge and allow scrolling to empty space when creating
      // dependency
      config.scrollWidth = element.scrollWidth;

      me.monitoring.push(config);
    }
  }

  /**
   * Stops monitoring an element.
   * @param {HTMLElement} element Element for which monitoring is not desired any more and should stop as soon as possible. Preferably right away, but no later than on next frame :)
   */
  stopMonitoring(element) {
    const me = this,
      config = me.monitoring.find((m) => m.element === element);

    // cant stop nothing...
    if (!config) return;

    me.stopScroll(config);
    me.mouseMoveDetacher && me.mouseMoveDetacher();
    me.monitoring.splice(me.monitoring.indexOf(config), 1);
  }

  //endregion

  //region Internals

  /**
   * Starts scrolling (see #performScroll). Called from onMouseMove.
   * @private
   * @param {Object} config Config object
   */
  startScroll(config) {
    config.scrolling = true;
    this.performScroll(config);
  }

  /**
   * Stops scrolling. Called from onMouseMove.
   * @private
   * @param {Object} config
   */
  stopScroll(config) {
    config.scrolling = false;
    if (config.scrollRequested) {
      this.cancelAnimationFrame(config.frameId);
      config.scrollRequested = false;
    }
  }

  /**
   * Scrolls by an amount determined by config.scrollDeltaX/Y on each frame. Start/stop by calling #startScroll and
   * #stopScroll.
   * @private
   * @param {Object} config Config object
   */
  performScroll(config) {
    // this function is called repeatedly on each frame for as long as scrolling is needed

    // check that scrolling is needed
    if (config.scrolling && !config.scrollRequested) {
      let element = config.element,
        vertical = config.verticalElement;

      // scroll the determined amount of pixels
      if (config.scrollDeltaX !== 0) {
        config.scrollLeft += config.scrollDeltaX;

        // limit to element edges
        config.scrollLeft = Math.max(Math.min(config.scrollLeft, config.scrollWidth - element.offsetWidth), 0);

        config.scrollRelativeLeft = config.scrollLeft - config.startScrollLeft;
        element.scrollLeft = config.scrollLeft;
      }

      if (config.scrollDeltaY !== 0) {
        config.scrollTop += config.scrollDeltaY;

        // limit to element edges
        config.scrollTop = Math.max(Math.min(config.scrollTop, vertical.scrollHeight - vertical.offsetHeight), 0);

        config.scrollRelativeTop = config.scrollTop - config.startScrollTop;
        vertical.scrollTop = config.scrollTop;
      }

      // call callback if scrolled in any direction
      if ((config.scrollRelativeLeft !== 0 || config.scrollRelativeTop !== 0) && config.callback) {
        config.callback.call(config.thisObj || this, config);
      }

      // scroll some more on next frame
      config.scrollRequested = true;

      config.frameId = this.requestAnimationFrame(() => {
        config.scrollRequested = false;
        this.performScroll(config);
      });
    }
  }

  /**
   * Listener for mouse move on monitored element. Determines if scrolling is needed, and if so how fast to scroll.
   * See #zoneWidth & #scrollSpeed configs.
   * @private
   * @param {MouseEvent} event
   */
  onMouseMove(event) {
    const config = this,
      me = config.scrollManager,
      element = config.element,
      vertical = config.verticalElement,
      box = element.getBoundingClientRect(),
      vbox = vertical.getBoundingClientRect(),
      width = me.zoneWidth,
      speed = me.scrollSpeed;

    // scroll left or right?
    config.scrollDeltaX = 0;

    if (config.direction !== 'vertical') {
      if (event.clientX > box.right - width) {
        config.scrollDeltaX = Math.round((width - (box.right - event.clientX)) / speed) + 1;
      } else if (event.clientX < box.left + width) {
        config.scrollDeltaX = -Math.round((width + (box.left - event.clientX)) / speed) - 1;
      }
    }

    //console.log(config.scrollDeltaX, event.clientX, box.right, element.scrollLeft);

    // scroll up or down?
    config.scrollDeltaY = 0;
    if (config.direction !== 'horizontal') {
      if (event.clientY > vbox.bottom - width) {
        config.scrollDeltaY = Math.round((width - (vbox.bottom - event.clientY)) / speed) + 1;
      } else if (event.clientY < vbox.top + width) {
        config.scrollDeltaY = -Math.round((width + (vbox.top - event.clientY)) / speed) - 1;
      }
    }

    if (config.scrollDeltaX === 0 && config.scrollDeltaY === 0) {
      me.stopScroll(config);
    } else {
      me.startScroll(config);
    }
  }

  //endregion
}
ScrollManager._$name = 'ScrollManager';

/**
 * @module Grid/row/Row
 */

/**
 * Represents a single rendered row in the grid. Consists of one row element for each SubGrid in use. The grid only
 * creates as many rows as needed to fill the current viewport (and a buffer). As the grid scrolls
 * the rows are repositioned and reused, there is not a one to one relation between rows and records.
 *
 * For normal use cases you should not have to use this class directly. Rely on using renderers instead.
 * @extends Common/Base
 */
class Row extends Delayable(Base) {
  static get defaultConfig() {
    return {
      cls: 'b-grid-row'
    };
  }
  //region Init

  /**
   * Constructs a Row setting its index.
   * @param {Object} config A configuration object which must contain the following two properties:
   * @param {Grid.view.Grid} config.grid The owning Grid.
   * @param {Grid.row.RowManager} config.rowManager The owning RowManager.
   * @param {Number} index The index of the row within the RowManager's cache.
   * @function constructor
   */
  construct(config) {
    // Set up defaults and properties
    Object.assign(this, {
      _elements: {},
      _elementsArray: [],
      _cells: {},
      _allCells: [],
      _regions: [],
      lastHeight: 0,
      lastTop: -1,
      transitionDuration: 500,
      _dataIndex: 0,
      _top: 0,
      _height: 0,
      _id: null,
      forceInnerHTML: false,
      isGroupFooter: false
    });

    Object.assign(this, config);
    super.construct();
  }

  //endregion

  //region Data getters/setters

  /**
   * Get index in RowManagers rows array
   * @property {Number}
   * @readonly
   */
  get index() {
    return this._index;
  }

  set index(index) {
    this._index = index;
  }

  /**
   * Get/set this rows current index in grids store
   * @property {Number}
   */
  get dataIndex() {
    return this._dataIndex;
  }

  set dataIndex(dataIndex) {
    if (this._dataIndex !== dataIndex) {
      const elements = this._elementsArray;

      this._dataIndex = dataIndex;
      for (let i = 0; i < elements.length; i++) {
        elements[i].dataset.index = dataIndex;
      }
    }
  }

  /**
   * Get/set id for currently rendered record
   * @property {String|Number}
   */
  get id() {
    return this._id;
  }

  set id(id) {
    const me = this,
      idObj = { id },
      idMap = me.rowManager.idMap,
      elements = me._elementsArray,
      cells = me._allCells;

    if (me._id != id || idMap[id] !== me) {
      if (idMap[me._id] === me) delete idMap[me._id];
      idMap[id] = me;

      me._id = id;
      for (let i = 0; i < elements.length; i++) {
        DomDataStore.assign(elements[i], idObj);
      }
      for (let i = 0; i < cells.length; i++) {
        DomDataStore.assign(cells[i], idObj);
      }
    }
  }

  //endregion

  //region Row elements

  /**
   * Add a row element for specified region.
   * @param {String} region Region to add element for
   * @param {HTMLElement} element Element
   * @private
   */
  addElement(region, element) {
    const me = this;

    let cellElement = element.firstElementChild;

    me._elements[region] = element;
    me._elementsArray.push(element);
    me._regions.push(region);
    DomDataStore.assign(element, { index: me.index });

    me._cells[region] = [];

    while (cellElement) {
      me._cells[region].push(cellElement);
      me._allCells.push(cellElement);

      DomDataStore.set(cellElement, {
        column: cellElement.dataset.column, // TODO: dataset is slow, read from columnstore using index instead
        columnId: cellElement.dataset.columnId,
        rowElement: cellElement.parentNode,
        row: me
      });

      cellElement = cellElement.nextElementSibling;
    }

    // making css selectors simpler, dataset has bad performance but it is only set once and never read
    element.dataset.index = me.index;
  }

  /**
   * Get the element for the specified region.
   * @param {String} region
   * @returns {HTMLElement}
   */
  getElement(region) {
    return this._elements[region];
  }

  /**
   * Execute supplied function for each regions element.
   * @param {Function} fn
   */
  eachElement(fn) {
    for (let i = 0; i < this._elementsArray.length; i++) {
      fn(this._elementsArray[i], i);
    }
    //this._elementsArray.forEach(fn);
  }

  /**
   * Execute supplied function for each cell.
   * @param {Function} fn
   */
  eachCell(fn) {
    this._allCells.forEach(fn);
  }

  /**
   * Row elements (one for each region)
   * @type {HTMLElement[]}
   * @readonly
   */
  get elements() {
    return this._elements;
  }

  //endregion

  //region Cell elements

  /**
   * Row cell elements
   * @returns {HTMLElement[]}
   * @readonly
   */
  get cells() {
    return this._allCells;
  }

  /**
   * Get cell elements for specified region.
   * @param {String} region Region to get elements for
   * @returns {HTMLElement[]} Array of cell elements
   */
  getCells(region) {
    return this._cells[region];
  }

  /**
   * Get the cell element for the specified column.
   * @param {String|Number} columnId Column id
   * @returns {HTMLElement} Cell element
   */
  getCell(columnId) {
    /*let found = null;
         // look in all regions
         this._regions.forEach(region => {
         if (!found) found = this.getCells(region).find(cell => DomDataStore.get(cell).column === column);
         });*/
    return this._allCells.find((cell) => {
      const cellData = DomDataStore.get(cell);
      return cellData.columnId === columnId || cellData.column === columnId;
    });
  }

  removeElements(onlyRelease = false) {
    const me = this;

    if (!onlyRelease) {
      me._elementsArray.forEach((element) => element.remove());
    }
    me._elements = {};
    me._cells = {};
    me._elementsArray.length = me._regions.length = me._allCells.length = me.lastHeight = me.height = 0;
    me.lastTop = -1;
  }

  //endregion

  //region Height

  /**
   * Get/set row height
   * @property {Number}
   */
  get height() {
    return this._height;
  }

  set height(height) {
    this._height = height;
  }

  /**
   * Get row height including border
   * @property {Number}
   */
  get offsetHeight() {
    // me.height is specified height, add border height to it to get cells height to match specified rowHeight
    // border height is measured in Grid#get rowManager
    return this.height + this.grid._rowBorderHeight;
  }

  /**
   * Sets row height, but only if the height is bigger than currently set height (used when rendering rows to
   * match height for highest region element)
   * @param height Height to set
   * @private
   */
  setHeightIfBigger(height) {
    if (height > this.height) this.height = height;
  }

  /**
   * Sync elements height to rows height
   * @private
   */
  updateElementsHeight() {
    const me = this;
    // prevent unnecessary style updates
    if (me.lastHeight !== me.height) {
      const elements = me._elementsArray;

      for (let i = 0; i < elements.length; i++) {
        elements[i].style.height = `${me.offsetHeight}px`;
      }
      me.lastHeight = me.height;
    }
  }

  //endregion

  //region CSS

  /**
   * Add css classes to each element.
   * @param {...String} classes
   */
  addCls(...classes) {
    this.eachElement((element) => DomHelper.addClasses(element, classes));
  }

  /**
   * Remove css classes from each element.
   * @param {...String} classes
   */
  removeCls(...classes) {
    this.eachElement((element) => DomHelper.removeClasses(element, classes));
  }

  //endregion

  //region Position

  /**
   * Is this the very first row?
   * @property {Boolean}
   * @readonly
   */
  get isFirst() {
    return this.dataIndex === 0;
  }

  /**
   * Row top coordinate
   * @property {Number}
   * @readonly
   */
  get top() {
    return this._top;
  }

  /**
   * Row bottom coordinate
   * @property {Number}
   * @readonly
   */
  get bottom() {
    return this._top + this._height + this.grid._rowBorderHeight;
  }

  /**
   * Sets top coordinate, translating elements position.
   * @param top Top coordinate
   * @internal
   */
  setTop(top) {
    if (this._top !== top) {
      this._top = top;
      this.translateElements();
    }
  }

  /**
   * Sets bottom coordinate, translating elements position.
   * @param bottom Bottom coordinate
   * @private
   */
  setBottom(bottom) {
    this.setTop(bottom - this.offsetHeight);
  }

  /**
   * Sets css transform to position elements at correct top position (translateY)
   * @private
   */
  translateElements() {
    const me = this,
      positionMode = me.grid.positionMode;

    if (me.lastTop !== me.top) {
      const elements = me._elementsArray;

      for (let i = 0; i < elements.length; i++) {
        const style = elements[i].style;

        if (positionMode === 'translate') {
          style.transform = `translate(0,${me.top}px)`;
        } else if (positionMode === 'translate3d') {
          style.transform = `translate3d(0,${me.top}px,0)`;
        } else if (positionMode === 'position') {
          style.top = `${me.top}px`;
        }
      }
      me.rowManager.trigger('translateRow', { row: me });
      me.lastTop = me.top;
    }
  }

  /**
   * Moves all row elements up or down and updates model.
   * @param {Number} offsetTop Pixels to offset the elements
   * @private
   */
  offset(offsetTop) {
    let newTop = this._top + offsetTop;

    // Not allowed to go below zero (won't be reachable on scroll in that case)
    if (newTop < 0) {
      offsetTop -= newTop;
      newTop = 0;
    }
    this.setTop(newTop);
    return offsetTop;
  }

  //endregion

  //region Render

  /**
   * Renders a record into this rows elements (trigger event that subgrids catch to do the actual rendering).
   * @param {Common.data.Model} record
   * @private
   */
  render(recordIndex, record, updatingSingleRow = true, batch = false) {
    const me = this,
      oldId = me._id,
      elements = me._elementsArray,
      cells = me.cells,
      rowElData = DomDataStore.get(elements[0]),
      rowManager = me.rowManager,
      rowHeight = rowManager._rowHeight,
      oldHeight = me.height, // not using getter since we don't want to use average row height here
      defaultRowCls = updatingSingleRow ? `${me.cls} b-grid-row-updating` : me.cls;

    let i = 0,
      rowElement,
      cell,
      size;

    // no record specified, try looking up in store (false indicates empty row, don't do lookup
    if (!record && record !== false) {
      record = me.grid.store.getById(rowElData.id);
      recordIndex = me.grid.store.indexOf(record);
    }

    const selected = record && me.grid.isSelected(record.id);

    // used by GroupSummary feature to clear row before
    rowManager.trigger('beforeRenderRow', { row: me, record, oldId });

    for (i; i < elements.length; i++) {
      rowElement = elements[i];

      // Clean classList
      rowElement.className = defaultRowCls;

      // Apply cls from data directly to row
      // TODO: should be configurable on grid
      if (selected) {
        rowElement.classList.add('b-selected');
      }

      // no record & data says it is displayed, "undisplay" it
      if (!record) {
        rowElData.displayed = false;
        rowElement.classList.add('b-grid-row-not-displayed');
      }

      if (record) {
        if (record.cls) record.cls.split(' ').forEach((cls) => rowElement.classList.add(cls));
        // has record and data says it is not displayed, flag as displayed
        //if (rowElData.displayed === false) rowEl.classList.remove('b-grid-row-not-displayed');
        rowElData.displayed = true;
      }
    }

    if (updatingSingleRow) {
      me.setTimeout(() => {
        // We should iterate all elements, in case we have regions in the grid
        elements.forEach((element) => {
          element.classList.remove('b-grid-row-updating');
        });
      }, me.transitionDuration);
    }

    // Will be set from renderers
    me.height = 0;

    if (record) {
      me.id = record.id;
      me.dataIndex = recordIndex;
    } else {
      // More rows then records, render it empty for now...
      me.id = null;
      me.dataIndex = null;
    }

    for (i = 0; i < cells.length; i++) {
      cell = cells[i];

      size = me.renderCell(cell, record, i, updatingSingleRow);
      // we want to make row in all parts as high as the highest cell
      me.setHeightIfBigger((size && size.height) || rowHeight);
    }

    // Height gets set during render, reflect on elements
    me.updateElementsHeight();

    // Rerendering a row might change its height, which forces translation of all following rows
    if (updatingSingleRow) {
      if (oldHeight !== me.height) {
        rowManager.translateFromRow(me, batch);
      }
      rowManager.trigger('updateRow', { row: me, record, oldId });
    }

    // TODO: Make direct function call if no more features than Stripe needs this
    rowManager.trigger('renderRow', { row: me, record, oldId });

    me.forceInnerHTML = false;
  }

  /**
   * Renders a single cell, calling features to allow them to hook.
   * @param cellElement Cell element to render
   * @param record Record, fetched from store if undefined
   * @param index
   * @param updatingSingleRow
   * @private
   */
  renderCell(cellElement, record, index, updatingSingleRow = true) {
    const me = this,
      cellElementData = DomDataStore.get(cellElement),
      col = me.grid.columns.getById(cellElementData.columnId),
      rowElement = cellElementData.rowElement,
      rowElementData = DomDataStore.get(rowElement),
      {
        // Avoid two calls to col's getters by gathering these fields.
        internalCellCls,
        cellCls,
        align,
        renderer,
        defaultRenderer,
        id: columnId
      } = col,
      cellContext = { columnId, id: rowElementData.id },
      useRenderer = renderer || defaultRenderer;

    if (!record) {
      // Clear out row without record
      // Edge case, only happens if groups/tree is collapsed leading to fewer records than row elements
      if (rowElementData.id === null) {
        // setting to ' ' (space) makes it not remove firstChild, thus not breaking
        // when doing real render the next time
        // NOTE: have opted to not clear cell. might be confusing in DOM but simplifies for cells reusing
        // elements internally. Another option would be to have a derenderer per column which is called
        // cell.innerHTML = ' ';
        cellElement.className = 'b-grid-cell';
        return;
      }

      record = me.grid.store.getById(rowElementData.id);

      if (!record) return;
    }

    const newCellClass = {
      'b-grid-cell': 1,
      [internalCellCls]: internalCellCls,
      [cellCls]: cellCls,
      'b-cell-dirty': record.isFieldModified(col.field),
      [`b-grid-cell-align-${align}`]: align,
      'b-selected': me.grid.isSelected(cellContext),
      'b-focused': me.grid.isFocused(cellContext)
    };
    DomHelper.syncClassList(cellElement, newCellClass);

    let // TODO: record.rowHeight should be configurable (which field)
      size = { height: record.get('rowHeight') || 0 },
      cellContent = col.getRawValue(record),
      shouldSetContent = true,
      rendererData = {
        cellElement,
        rowElement,
        value: cellContent,
        record: record,
        column: col,
        size: size,
        grid: me.grid,
        row: cellElementData.row,
        updatingSingleRow
      };

    // Call renderer or set innerHTML directly if none
    // if renderer returns a value, set it in innerHTML below. render is also free to do it itself
    if (useRenderer) {
      cellContent = useRenderer.call(col, rendererData);
      if (cellContent === undefined) shouldSetContent = false;
    }

    // Listeners might need to know what string went into the DOM
    // Maintainer: the == null test below ensures that values of both null and undefined
    // result in an empty cell.
    const text = (rendererData.cellContent = cellContent == null ? '' : String(cellContent));

    if (shouldSetContent) {
      // row might be flagged by GroupSummary to require full "redraw"
      if (me.forceInnerHTML) {
        cellElement.innerHTML = text;
      }
      // display cell contents as text or use actual html?
      // (disableHtmlEncode set by features that decorate cell contents)
      else if (col.htmlEncode && !col.disableHtmlEncode) {
        if (BrowserHelper.isLinux) {
          // linux does not have firstChild.data
          cellElement.innerText = text;
        } else {
          // setting firstChild.data is faster than innerText (and innerHTML),
          // but in some cases the inner node is lost and needs to be recreated
          const firstChild = cellElement.firstChild;
          if (!firstChild) {
            cellElement.innerText = text;
          } else {
            firstChild.data = text;
          }
        }
      } else {
        if (col.autoSyncHtml && cellElement.childElementCount) {
          // update cell with only changed attributes etc.
          DomHelper.sync(text, cellElement.firstElementChild);
        } else {
          cellElement.innerHTML = text;
        }
      }
    }

    // Allow others to affect rendering
    me.rowManager.trigger('renderCell', rendererData);

    return size;
  }

  //endregion
}
Row._$name = 'Row';

//TODO: Handle vertical resize, add/remove row elements?

/**
 * @module Grid/row/RowManager
 * @private
 */

/**
 * Virtual representation of the grid, using {@link Grid.row.Row} to represent rows. Plugs into {@link Grid.view.Grid}
 * and exposes the following functions on grid itself:
 * * {@link #function-getRecordCoords()}
 * * {@link #function-getRowById()}
 * * {@link #function-getRow()}
 * * {@link #function-getRowFor()}
 * * {@link #function-getRowFromElement()}
 *
 * @example
 * let row = grid.getRowById(1);
 * @private
 */
class RowManager extends InstancePlugin {
  //region Config

  // Plugin configuration.
  static get pluginConfig() {
    return {
      chain: [
        'getRowById',
        'topRow',
        'bottomRow',
        'getRecordCoords',
        'getRow',
        'getRowFor',
        'getRowFromElement',
        'destroy'
      ],
      assign: ['rowHeight']
    };
  }

  static get defaultConfig() {
    return {
      /**
       * Number of rows to render above current viewport
       * @config {Number}
       * @default
       */
      prependRowBuffer: 5,

      /**
       * Number of rows to render below current viewport
       * @config {Number}
       * @default
       */
      appendRowBuffer: 5,

      /**
       * Default row height, assigned from Grid at construction (either from config
       * {@link Grid.view.Grid#config-rowHeight} or CSS). Can be set from renderers
       * @config {Number}
       * @default
       */
      rowHeight: null,

      idMap: {},
      rowScrollMode: 'move',
      autoHeight: false,
      // TODO: investigate if topIndex can to built away, since topRow is always first in array and has dataIndex??
      topIndex: 0,
      lastScrollTop: 0,
      _rows: []
    };
  }

  //endregion

  //region Init

  construct(config) {
    config.grid._rowManager = this;
    this.scrollTargetRecordId = null;
    super.construct(config.grid, config);
  }

  /**
   * Initializes the RowManager with Rows to fit specified height.
   * @param {Number} height
   * @private
   * @category Init
   */
  initWithHeight(height, isRendering = false) {
    const me = this;

    // no valid height, make room for all rows
    if (me.autoHeight) {
      height = me.store.allCount * me.rowOffsetHeight;
    }

    me.viewHeight = height;
    me.calculateRowCount(isRendering);

    return height;
  }

  /**
   * Releases all elements (not from dom), calculates how many are needed, creates those and renders
   */
  reinitialize(returnToTop = false) {
    const me = this,
      top = me.topRow ? me.topRow.top : 0;

    me._rows.length = 1;

    me.scrollTargetRecordId = null;

    if (returnToTop) {
      me.topIndex = 0;
      me.lastScrollTop = 0;
    }

    // any elements currently used for rows should be released.
    // actual removal of elements is done in SubGrid#clearRows
    me.releaseElements();

    // Calculate and correct the amount of rows needed (without triggering render)
    me.calculateRowCount(false, true, true);

    if (!returnToTop && me.topRow) {
      // since all rows were removed and new ones added, we need to restore dataIndex and position for rendering
      // to happen at correct pos
      me.topRow.dataIndex = me.topIndex;
      me.topRow.setTop(top);
    }

    // Need to estimate height in case we have Grid using autoHeight
    me.estimateTotalHeight();

    me.renderFromRow(me.topRow);
  }

  //endregion

  //region Rows

  /**
   * Add or remove rows to fit row count
   * @private
   * @category Rows
   */
  matchRowCount(skipRender = false) {
    const me = this,
      rows = me._rows,
      numRows = rows.length,
      delta = numRows - me.rowCount,
      grid = me.grid;

    if (delta) {
      if (delta < 0) {
        const newRows = [];

        // add rows
        for (
          let index = numRows, dataIndex = numRows ? rows[numRows - 1].dataIndex + 1 : 0;
          index < me.rowCount;
          index++, dataIndex++
        ) {
          newRows.push(
            new Row({
              rowManager: me,
              grid,
              index,
              dataIndex
            })
          );
        }
        rows.push.apply(rows, newRows);
        // and elements (by triggering event used by SubGrid to add elements)
        me.trigger('addRows', { rows: newRows });

        if (!skipRender) {
          // render
          me.renderFromRow(rows[Math.max(0, numRows - 1)]);
        }
      } else {
        // remove rows from bottom
        const removedRows = rows.splice(numRows - delta, delta);
        // and linked elements
        removedRows.forEach((row) => row.eachElement((element) => element.remove()));

        // trigger event in case some feature needs to cleanup when removing (widget column might be interested)
        me.trigger('removeRows', { rows: removedRows });

        // no need to rerender or such when removing from bottom. all is good :)
      }
    }
  }

  /**
   * Calculates how many rows fit in the available height (view height)
   * @private
   * @category Rows
   */
  calculateRowCount(skipMatchRowCount = false, allowRowCountShrink = true, skipRender = false) {
    // TODO: replace prependRowBuffer, appendXX with bufferSize
    const me = this,
      store = me.store,
      visibleRowCount = Math.ceil(me.viewHeight / me.rowOffsetHeight), // Want whole rows
      maxRenderRowCount = visibleRowCount + me.prependRowBuffer + me.appendRowBuffer;

    if (!me.grid.columns.count) {
      me.rowCount = 0;
      return 0;
    }

    // when for example jumping we do not want to remove excess rows,
    // since we know they are needed at other scroll locations
    if (maxRenderRowCount < me.rowCount && !allowRowCountShrink) return me.rowCount;

    me.visibleRowCount = visibleRowCount;
    me.rowCount = Math.min(store.count, maxRenderRowCount); // No need for more rows than data

    if (me.rowScrollMode === 'all') {
      me.rowCount = store.allCount;
    }

    // If the row count doesn't match the calculated, ensure it matches,
    if (!skipMatchRowCount) {
      if (me._rows && me.rowCount !== me._rows.length) {
        me.matchRowCount(skipRender);
      } else if (!me.rowCount) {
        me.trigger('changeTotalHeight', { totalHeight: me.totalHeight });
      }
      me.grid.bodyContainer.classList[me.rowCount || store.isLoading ? 'remove' : 'add']('b-grid-empty');
    }

    return me.rowCount;
  }

  releaseElements() {
    this.forEach((row) => row.removeElements(true));
    this._rows.length = 0;
    this.idMap = {};
  }

  //endregion

  //region Rows - Getters

  get store() {
    return this.client.store;
  }

  /**
   * Get all Rows
   * @property {Grid.row.Row[]}
   * @readonly
   * @category Rows
   */
  get rows() {
    return this._rows;
  }

  /**
   * Get the Row at specified index. Returns `undefined` if the row index is not rendered.
   * @param {Number} index
   * @returns {Grid.row.Row}
   * @category Rows
   */
  getRow(index) {
    return this.rowCount && this.rows[index - this.topIndex];
  }

  /**
   * Get Row for specified record id
   * @param {Common.data.Model|String|Number} recordOrId Record id (or a record)
   * @returns {Grid.row.Row} Found Row or null if record not rendered
   * @category Rows
   */
  getRowById(recordOrId) {
    if (!(typeof recordOrId === 'string' || typeof recordOrId === 'number')) {
      recordOrId = recordOrId.id;
    }
    // Don't use ===, want to match 1 == '1' since id is stored on rowElement in dataset (html attribute, always string)
    return this.idMap[recordOrId]; // || this.rows.find(row => row.id == recordOrId);
  }

  /**
   * Get a Row from an HTMLElement
   * @param {HTMLElement} element
   * @returns {Grid.row.Row} Found Row or null if record not rendered
   * @category Rows
   */
  getRowFromElement(element) {
    element = element.closest('.b-grid-row');
    return element && this.getRow(element.dataset.index);
  }

  /**
   * Get the row at the specified Y coordinate, which is by default viewport-based.
   * @param {Number} y The `Y` coordinate to find the Row for.
   * @param {Boolean} [local=false] Pass `true` if the `Y` coordinate is local to the SubGrid's element.
   * @returns {Grid.row.Row} Found Row or null if no row is rendered at that point.
   */
  getRowAt(y, local = false) {
    // Make it local.
    if (!local) {
      y -= Rectangle.from(this.grid.bodyContainer, null, true).top;

      // Adjust for scrolling
      y += this.grid.scrollable.y;
    }
    y = roundPx(y);

    return this.rows.find((r) => y >= r.top && y < r.bottom);
  }

  /**
   * Get a Row for either a record, a record id or an HTMLElement
   * @param {HTMLElement|Common.data.Model|String|Number} recordOrId Record or record id or HTMLElement
   * @returns {Grid.row.Row} Found Row or null if record not rendered
   * @category Rows
   */
  getRowFor(recordOrId) {
    if (recordOrId instanceof HTMLElement) return this.getRowFromElement(recordOrId);
    return this.getRowById(recordOrId);
  }

  /**
   * Gets the Row following the specified Row (by index or object). Wraps around the end.
   * @param {Number|Grid.row.Row} indexOrRow index or Row
   * @returns {Grid.row.Row}
   * @category Rows
   */
  getNextRow(indexOrRow) {
    const me = this,
      index = typeof indexOrRow === 'number' ? indexOrRow : indexOrRow.index;
    return me.getRow((index + 1) % me.rowCount);
  }

  /**
   * Get the Row that is currently displayed at top.
   * @property {Grid.row.Row}
   * @readonly
   * @category Rows
   */
  get topRow() {
    return this._rows[0];
  }

  /**
   * Get the Row currently displayed furthest down.
   * @property {Grid.row.Row}
   * @readonly
   * @category Rows
   */
  get bottomRow() {
    const me = this,
      // TODO: remove when ticket on making sure rowCount is always up to date is fixed
      rowCount = Math.min(me.rowCount, me.store.count);

    return me.rows[rowCount - 1];
  }

  /**
   * Calls offset() for each Row passing along offset parameter
   * @param {Number} offset Pixels to translate Row elements.
   * @private
   * @category Rows
   */
  offsetRows(offset) {
    if (offset !== 0) {
      const rows = this.rows,
        length = rows.length;

      for (let i = 0; i < length; i++) {
        rows[i].offset(offset);
      }
    }
  }

  //endregion

  //region Row height

  // TODO: should support setting rowHeight in em and then convert internally to pixels. 1em = font-size. Not needed for 1.0
  /**
   * Set a fixed row height (can still be overridden by renderers) or get configured row height. Setting refreshes all rows
   * @category Rows
   */
  get rowHeight() {
    return this._rowHeight;
  }

  set rowHeight(height) {
    const me = this,
      { grid } = me,
      oldRowHeight = me._rowHeight;

    ObjectHelper.assertNumber(height, 'rowHeight');

    me.trigger('beforeRowHeight', { height });

    me._rowHeight = height;

    me.prependBufferHeight = me.prependRowBuffer * me.rowOffsetHeight;
    me.appendBufferHeight = me.appendRowBuffer * me.rowOffsetHeight;

    if (me.rows.length) {
      let average = me.averageRowHeight;
      const oldAverage = average;

      // Estimate a new averageRowHeight
      average -= grid._rowBorderHeight;
      average *= height / oldRowHeight;
      me.averageRowHeight = average += grid._rowBorderHeight;

      // Adjust number of rows, since it is only allowed to shrink in refresh()
      me.calculateRowCount(false, true, true);

      // Reposition the top row since it is used to position the rest
      me.topRow.setTop(me.topRow.dataIndex * average);

      me.refresh();

      const oldY = grid.scrollable.y,
        newY = oldY * (average / oldAverage);

      // Apply average diff to grid scroll to keep rows in view, but ignore the updating of rows triggered
      // by the scroll, since they are correctly updated by the refresh above.
      // Only set the ignore flag if there will be a scroll event to clear it.
      if (newY !== oldY) {
        me.ignoreScroll = true;
        grid.scrollable.y = newY;
      }
    }

    me.trigger('rowHeight', { height });
  }

  /**
   * Get actually used row height, which includes any border and might be an average if using variable row height.
   * @property {Number}
   */
  get rowOffsetHeight() {
    return Math.floor(this.averageRowHeight) || this._rowHeight + this.grid._rowBorderHeight;
  }

  //endregion

  //region Calculations

  /**
   * Returns top and bottom for rendered row or estimated coordinates for unrendered.
   * @param {Common.data.Model|string|Number} recordOrId Record or record id
   * @param {Boolean} [local] Pass true to get relative record coordinates
   * @returns {Common.helper.util.Rectangle} Record bounds with format { x, y, width, height, bottom, right }
   * @category Calculations
   */
  getRecordCoords(recordOrId, local = false) {
    const me = this,
      //id  = ['string', 'number'].includes(typeof recordOrId) ? recordOrId : recordOrId.id,
      id = typeof recordOrId === 'string' || typeof recordOrId === 'number' ? recordOrId : recordOrId.id,
      row = me.getRowById(recordOrId);

    let scrollingViewport = me.client._bodyRectangle;

    // _bodyRectangle is not updated on page/containing element scroll etc. Need to make sure it is correct in case
    // that has happend. This if-statement should be removed when fixing
    // https://app.assembla.com/spaces/bryntum/tickets/6587-cached-_bodyrectangle-should-be-updated-on--quot-external-quot--scroll/details
    if (!local) {
      scrollingViewport = me.client._bodyRectangle = Rectangle.client(me.client.bodyContainer);
    }

    // Rendered? Then we know position for certain
    if (row) {
      return new Rectangle(
        scrollingViewport.x,
        local ? Math.round(row.top) : Math.round(row.top + scrollingViewport.y - me.client.scrollable.y),
        scrollingViewport.width,
        row.offsetHeight
      );
    }

    return me.getRecordCoordsByIndex(me.store.indexOf(id), local);
  }

  /**
   * Returns estimated top and bottom coordinates for specified row.
   * @param {Number} recordIndex Record index
   * @returns {Common.helper.util.Rectangle} Estimated record bounds with format { x, y, width, height, bottom, right }
   * @category Calculations
   */
  getRecordCoordsByIndex(recordIndex, local = false) {
    const me = this,
      scrollingViewport = me.client._bodyRectangle,
      // Not using rowOffsetHeight since it floors the value and that rounding might give big errors far down
      height = me.averageRowHeight || me._rowHeight + me.grid._rowBorderHeight,
      currentTopIndex = me.topRow.dataIndex,
      currentBottomIndex = me.bottomRow.dataIndex,
      // Instead of estimating top from the very top, use closest known coordinate. Makes sure a coordinate is not
      // estimated on wrong side of rendered rows, needed to correctly draw dependencies where one event is located
      // on a unrendered row
      calculateFrom =
        // bottomRow is closest, calculate from it
        recordIndex > currentBottomIndex
          ? { index: recordIndex - currentBottomIndex - 1, y: me.bottomRow.bottom, from: 'bottomRow' }
          : //  closer to topRow than 0, use topRow
          recordIndex > currentTopIndex / 2
          ? { index: recordIndex - currentTopIndex, y: me.topRow.top, from: 'topRow' }
          : // closer to the very top, use it
            { index: recordIndex, y: 0, from: 'top' },
      top = Math.floor(calculateFrom.y + calculateFrom.index * height),
      //top               = Math.floor(recordIndex * height),
      result = new Rectangle(
        scrollingViewport.x,
        local ? top : top + scrollingViewport.y - me.client.scrollable.y,
        scrollingViewport.width,
        height
      );

    // Signal that it's not based on an element, so is only approximate.
    // Grid.scrollRowIntoView will have to go round again using the block options below to ensure it's correct.
    result.virtual = true;

    // When the block becomes visible, scroll it to the logical position using the scrollIntoView's block
    // option. If it's above, use block: 'start', if below, use block: 'end'.
    result.block =
      result.bottom < scrollingViewport.y ? 'start' : result.y > scrollingViewport.bottom ? 'end' : 'nearest';

    return result;
  }

  /**
   * Total estimated grid height (used for scroller)
   * @property {Number}
   * @readonly
   * @category Calculations
   */
  get totalHeight() {
    return Math.floor(this.store.count * this.rowOffsetHeight);
  }

  //endregion

  //region Iteration etc.

  /**
   * Calls a function for each Row
   * @param {Function} fn Function that will be called with Row as first parameter
   * @category Iteration
   */
  forEach(fn) {
    this.rows.forEach(fn);
  }

  /**
   * Iterator that allows you to do for (let row of rowManager)
   * @category Iteration
   */
  [Symbol.iterator]() {
    return this.rows[Symbol.iterator]();
  }

  //endregion

  //region Scrolling & rendering

  /**
   * Renders from the top of the grid, also resetting scroll to top. Used for example when collapsing all groups.
   * @category Scrolling & rendering
   */
  returnToTop() {
    const me = this;

    me.topIndex = 0;
    me.lastScrollTop = 0;
    me.topRow.dataIndex = 0;

    // Force the top row to the top of the scroll range
    me.topRow.setTop(0);

    me.refresh();

    // Rows rendered from top, make sure grid is scrolled to top also
    me.grid.scrollable.y = 0;
  }

  /**
   * Renders from specified records row and down (used for example when collapsing a group, does not affect rows above).
   * @param {Common.data.Model} record Record of first row to render
   * @category Scrolling & rendering
   */
  renderFromRecord(record) {
    const row = this.getRowById(record.id);
    if (row) {
      this.renderFromRow(row);
    }
  }

  /**
   * Renders from specified row and down (used for example when collapsing a group, does not affect rows above).
   * @param {Grid.row.Row} fromRow First row to render
   * @category Scrolling & rendering
   */
  renderFromRow(fromRow = null) {
    const me = this,
      { _rows, store } = me,
      storeCount = store.count;

    // Calculate row count, adding rows if needed, but do not rerender - we are going to do that below.
    // Bail out if no rows. Allow removing rows if we have more than store have rows
    if (me.calculateRowCount(false, storeCount < _rows.length, true) === 0) {
      return;
    }

    let // render from this row
      fromRowIndex = fromRow ? _rows.indexOf(fromRow) : 0,
      // starting either from its specified dataIndex or from its index (happens on first render, no dataIndex yet)
      dataIndex = fromRow ? fromRow.dataIndex : _rows[0].dataIndex,
      // amount of records after this one in store
      recordsAfter = storeCount - dataIndex - 1,
      // render to this row, either the last row or the row which will hold the last record available
      toRowIndex = Math.min(_rows.length - 1, fromRowIndex + recordsAfter),
      // amount of rows which wont be rendered below last record (if we have fewer records than topRow + row count)
      leftOverCount = _rows.length - toRowIndex - 1,
      // Start with top correctly just below the previous row's bottom
      top = fromRowIndex > 0 ? _rows[fromRowIndex - 1].bottom : _rows[fromRowIndex].top,
      row;

    // _rows array is ordered in display order, just iterate to the end
    for (let i = fromRowIndex; i <= toRowIndex; i++) {
      row = _rows[i];
      // Needed in scheduler when translating events, happens before render
      row.dataIndex = dataIndex;
      row.setTop(top);
      row.render(dataIndex, store.getAt(dataIndex++), false);
      top += row.offsetHeight;
    }

    // if number for records to display has decreased, for example by collapsing a node, we might get unused rows
    // below bottom. move those to top to not have unused rows laying around
    while (leftOverCount-- > 0) {
      me.displayRecordAtTop();
    }

    if (me.averageRowHeight) {
      // Adjust average, subtracting the rendered block's estimated height and then adding the actual height
      me.averageRowHeight = (me.averageRowHeight * (storeCount - me.rowCount) + (top - me.topRow.top)) / storeCount;
    } else {
      me.averageRowHeight = (top - me.topRow.top) / me.rowCount;
    }

    // Reestimate total height
    me.estimateTotalHeight();
  }

  /**
   * Renders the passed array (or [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)) of {@link Grid.row.Row rows}
   * @param {Grid.row.Row[]|Set} rows The rows to render
   * @category Scrolling & rendering
   */
  renderRows(rows) {
    let oldHeight,
      heightChanged = false;

    rows = Array.from(rows);

    // Render the requested rows.
    for (const row of rows) {
      oldHeight = row.height;

      // Pass updatingSingleRow as false, so that it does not shuffle following
      // rows downwards on each render. We do that once here after the rows are all refreshed.
      row.render(null, null, false);
      heightChanged |= row.height !== oldHeight;
    }

    // If this caused a height change, shuffle following rows.
    if (heightChanged) {
      this.translateFromRow(rows[0], true);

      // Reestimate total height
      this.estimateTotalHeight();
    }
  }

  /**
   * Translates all rows after the specified row. Used when a single rows height is changed and the others should
   * rearrange. (Called from Row#render)
   * @param {Grid.row.Row} fromRow
   * @private
   * @category Scrolling & rendering
   */
  translateFromRow(fromRow, batch = false) {
    let me = this,
      top = fromRow.bottom,
      storeCount = me.store.count,
      row,
      index;

    for (index = fromRow.dataIndex + 1, row = me.getRow(index); row; row = me.getRow(++index)) {
      row.setTop(top);
      top += row.offsetHeight;
    }

    // Adjust average, subtracting the rendered block's estimated height and then adding the actual height
    me.averageRowHeight =
      (me.averageRowHeight * (storeCount - me.rowCount) + (me.bottomRow.bottom - me.topRow.top)) / storeCount;

    // Reestimate total height
    if (!batch) {
      me.estimateTotalHeight();
    }
  }

  /**
   * Rerender all rows
   * @category Scrolling & rendering
   */
  refresh() {
    const me = this,
      { topRow } = me;

    // too early
    if (!topRow) {
      return;
    }

    me.idMap = {};

    me.renderFromRow(topRow);

    me.trigger('refresh');
  }

  /**
   * Makes sure that specified record is displayed in view
   * @param newScrollTop Top of visible section
   * @param [forceRecordIndex] Index of record to display at center
   * @private
   * @category Scrolling & rendering
   */
  jumpToPosition(newScrollTop, forceRecordIndex) {
    // There are two very different requirements here.
    // If there is a forceRecordIndex, that takes precedence to get it into the center of the
    // viewport, and wherever we render the calculated row block, we may then *adjust the scrollTop*
    // to get that row to the center.
    //
    // If there's no forceRecordIndex, then the scroll position is the primary objective and
    // we must render what we calculate to be correct at that viewport position.
    const me = this,
      rowHeight = me.rowOffsetHeight,
      storeCount = me.store.count,
      // Calculate index of the top of the rendered block.
      // If we are targeting the scrollTop, this will be the top index at the scrollTop minus prepend count.
      // If we are targeting a recordIndex, this will attempt to place that in the center of the rendered block.
      targetIndex =
        forceRecordIndex == null
          ? Math.floor(newScrollTop / rowHeight) - me.prependRowBuffer
          : forceRecordIndex - Math.floor(me.rowCount / 2),
      startIndex = Math.max(Math.min(targetIndex, storeCount - me.rowCount), 0),
      viewportTop = me.client.scrollable.y,
      viewportBottom = Math.min(me.client._bodyRectangle.height + viewportTop + me.appendBufferHeight, me.totalHeight);

    me.lastScrollTop = newScrollTop;
    me.topRow.dataIndex = me.topIndex = startIndex;
    me.topRow.setTop(startIndex * rowHeight, false);

    // render entire buffer
    me.refresh();

    // TODO: It is likely the approach below will be needed for scrolling in opposite direction also, although no
    //   problem encountered yet

    // Not filled all the way down?
    if (me.bottomRow.bottom < viewportBottom) {
      // Fill with available rows (might be available above buffer because of var row height), stop if we run out of records :)
      while (
        me.bottomRow.bottom < viewportBottom &&
        me._rows[me.prependRowBuffer].top < viewportTop &&
        me.bottomRow.dataIndex < storeCount - 1
      ) {
        me.displayRecordAtBottom();
      }

      // Average row height in rendered block
      const blockHeight = me.bottomRow.bottom - me.topRow.top;

      // Adjust average, subtracting the rendered block's estimated height and then adding the actual height
      me.averageRowHeight = (me.averageRowHeight * (storeCount - me.rowCount) + blockHeight) / storeCount;

      // TODO: Block below was not needed for current tests, but if row height in one block is enough smaller
      //  than average row height then we will need to add more rows

      // Still not filled all the way down? Need more rows
      // if (me.bottomRow.bottom < viewportBottom) {
      //     //const localAverage = blockHeight / me.rowCount;
      //     while (me.bottomRow.bottom < viewportBottom) {
      //        me.addRecordAtBottom();
      //     }
      // }
    }

    me.estimateTotalHeight();

    // If the row index is our priority, then scroll it into the center
    if (forceRecordIndex != null) {
      const targetRow = me.getRow(forceRecordIndex),
        // When coming from a block of high rowHeights to one with much lower we might still miss the target...
        // TODO: Jump again in these cases?
        rowCenter = targetRow && Rectangle.from(targetRow._elementsArray[0]).center.y,
        viewportCenter = me.grid.scrollable.viewport.center.y;

      // Scroll the targetRow into the center of the viewport
      if (targetRow) {
        me.grid.scrollable.y = newScrollTop = Math.floor(me.grid.scrollable.y + (rowCenter - viewportCenter));
      }
    }

    return newScrollTop;
  }

  /**
   * Jumps to a position if it is far enough from current position. Otherwise does nothing.
   * @private
   * @category Scrolling & rendering
   */
  warpIfNeeded(newScrollTop) {
    const me = this,
      result = { newScrollTop, deltaTop: newScrollTop - me.lastScrollTop };

    // if gap to fill is large enough, better to jump there than to fill row by row
    if (Math.abs(result.deltaTop) > me.rowCount * me.rowOffsetHeight * 3) {
      // no specific record targeted
      let index;

      // Specific record specified as target of scroll?
      if (me.scrollTargetRecordId) {
        index = me.store.indexOf(me.scrollTargetRecordId);

        // since scroll is happening async record might have been removed after requesting scroll,
        // in that case we rely on calculated index (as when scrolling without target)
      }

      // perform the jump and return results
      result.newScrollTop = me.jumpToPosition(newScrollTop, index);
      result.deltaTop = 0; // no extra filling needed
    }

    return result;
  }

  /**
   * Handles virtual rendering (only visible rows + buffer are in dom) for rows
   * @param {Number} newScrollTop The `Y` scroll position for which to render rows.
   * @param {Boolean} [force=false] Pass `true` to update the rendered row block even if the scroll position has not changed.
   * @return {Number} Adjusted height required to fit rows
   * @private
   * @category Scrolling & rendering
   */
  updateRenderedRows(newScrollTop, force, ignoreError) {
    const me = this,
      clientRect = me.client._bodyRectangle;

    // Changing row height will trigger a scroll, ignore it here
    if (me.ignoreScroll) {
      me.ignoreScroll = false;
      return null;
    }

    // Might be triggered after removing all records, should not crash
    if (me.rowCount === 0) {
      return 0;
    }

    let result = me.estimatedTotalHeight;

    // Only react if we have scrolled by more than one row
    if (force || Math.abs(newScrollTop - me.lastScrollTop) > me.rowOffsetHeight) {
      // If scrolled by a large amount, jump instead of rendering each row
      const posInfo = me.warpIfNeeded(newScrollTop);

      me.scrollTargetRecordId = null;

      // Cache the last correct render scrollTop before fill.
      // it can be adjusted to hide row position corrections.
      me.lastScrollTop = posInfo.newScrollTop;

      if (posInfo.deltaTop > 0) {
        // Scrolling down
        me.fillBelow(posInfo.newScrollTop);
      } else if (posInfo.deltaTop < 0) {
        // Scrolling up
        me.fillAbove(posInfo.newScrollTop);
      }

      // Calculate the new height based on new content
      result = me.estimateTotalHeight();

      // If it's a temporary scroll, we can be told to ignore the drift.
      // Apart from that, we must correct keep the rendered block position correct.
      // Otherwise, when rolling upwards after a teleport, we may not be able to reach
      // the top. Some rows may end up at -ve positions.
      if (!ignoreError) {
        // Only correct the rendered block position if we are in danger of running out of scroll space.
        // That is if we are getting towards the top or bottom of the scroll range.
        if (
          // Scrolling up within top zone
          (posInfo.deltaTop < 0 && newScrollTop < clientRect.height * 2) ||
          // Scrolling down within bottom zone
          (posInfo.deltaTop > 0 && newScrollTop > me.estimatedTotalHeight - clientRect.height * 2 - 3)
        ) {
          // Correct the rendered block position if it's not at the calculated position.
          // Keep the visual position correct by adjusting the scrollTop by the same amount.
          // When variable row heights are used, this will keep the rendered block top correct.
          // TODO: Calc could be eased more, using distance left to have less effect the further away from top/bottom
          const error = me.topRow.top - me.topIndex * me.rowOffsetHeight;
          if (error) {
            me.offsetRows(-error);
            me.grid.scrollable.y = me.lastScrollTop = me.grid.scrollable.y - error;
          }
        }
      }
    }

    return result;
  }

  /**
   * Moves as many rows from the bottom to the top that are needed to fill to current scroll pos.
   * @param newTop Scroll position
   * @private
   * @category Scrolling & rendering
   */
  fillAbove(newTop) {
    const me = this,
      fillHeight = newTop - me.topRow.top - me.prependBufferHeight;

    let accumulatedHeight = 0;

    while (accumulatedHeight > fillHeight && me.topIndex > 0) {
      // We want to show prev record at top of rows
      accumulatedHeight -= me.displayRecordAtTop();
    }
  }

  /**
   * Moves as many rows from the top to the bottom that are needed to fill to current scroll pos.
   * @param newTop Scroll position
   * @private
   * @category Scrolling & rendering
   */
  fillBelow(newTop) {
    const me = this,
      fillHeight = newTop - me.topRow.top - me.prependBufferHeight,
      recordCount = me.store.count,
      rowCount = me.rowCount;

    let accumulatedHeight = 0;

    // Repeat until we have filled empty height
    while (
      accumulatedHeight < fillHeight && // fill empty height
      me.topIndex + rowCount < recordCount && // as long as we have records left
      me.topRow.top + me.topRow.offsetHeight < newTop // and do not run move top row fully into view (can happen with var row height)
    ) {
      // We want to show next record at bottom of rows
      accumulatedHeight += me.displayRecordAtBottom();
    }
  }

  /**
   * Estimates height needed to fit all rows, based on average row height. Also offsets rows if needed to not be above
   * the reachable area of the view.
   * @returns {Number}
   * @private
   * @category Scrolling & rendering
   */
  estimateTotalHeight() {
    let me = this,
      recordCount = me.store.count,
      // When used to estimate initial height in a grid with autoHeight there is no averageRowHeight yet
      estimate = Math.floor(recordCount * (me.averageRowHeight || me.rowOffsetHeight)),
      { bottomRow } = me;

    // No bottomRow yet if estimating initial height in autoHeight grid
    if (bottomRow) {
      const bottom = bottomRow.bottom;
      //top                   = topRow.top;

      // To low estimate or reached the end with scroll left, adjust to fit current bottom
      if (bottom > estimate || (me.topIndex + me.rowCount >= recordCount && estimate > bottom)) {
        estimate = bottom;

        // estimate all the way down
        if (bottomRow.dataIndex < recordCount - 1) {
          estimate += (recordCount - 1 - bottomRow.dataIndex) * me.rowOffsetHeight;
        }
      }
    }

    // TODO: Remove these lines if tests are green, error correction should handle this
    // We have reached the very first row but are not at top, compensate.
    // Keep the visuals correct by scrolling down by the same amount.
    // if (topRow.isFirst && top !== 0) {
    //     debugger;
    //     me.offsetRows(-top);
    //     me.grid.scrollable.y = me.lastScrollTop = me.grid.scrollable.y - top;
    // }

    if (estimate != me.estimatedTotalHeight) {
      me.trigger('changeTotalHeight', { totalHeight: estimate });
    }

    me.estimatedTotalHeight = estimate;

    return estimate;
  }

  /**
   * Moves a row from bottom to top and renders the corresponding record to it.
   * @returns {Number} New row height
   * @private
   * @category Scrolling & rendering
   */
  displayRecordAtTop() {
    const me = this,
      recordIndex = me.topIndex - 1,
      record = me.store.getAt(recordIndex),
      recordCount = me.store.count,
      // Row currently rendered at the bottom, the row we want to move
      bottomRow = me.bottomRow,
      bottomRowTop = bottomRow.top;

    me.trigger('beforeTranslateRow', {
      row: bottomRow,
      newRecord: record
    });

    // estimated top, for rendering that depends on having top
    bottomRow._top = me.topRow.top - me.rowOffsetHeight;
    bottomRow.estimatedTop = true;

    // Render row
    bottomRow.render(recordIndex, record, false);

    // Move it to top. Restore top so that the setter won't reject non-change
    // if the estimate happened to be correct.
    bottomRow._top = bottomRowTop;
    bottomRow.setBottom(me.topRow.top);
    bottomRow.estimatedTop = false;

    // Prev row is now at top
    me.topIndex--;

    // move to start of array (bottomRow becomes topRow)
    me._rows.unshift(me._rows.pop());

    me.averageRowHeight = (me.averageRowHeight * (recordCount - 1) + bottomRow.offsetHeight) / recordCount;

    return bottomRow.offsetHeight;
  }

  /**
   * Moves a row from top to bottom and renders the corresponding record to it.
   * @returns {Number} New row height
   * @private
   * @category Scrolling & rendering
   */
  displayRecordAtBottom() {
    const me = this,
      //scrollMode  = me.rowScrollMode,
      recordIndex = me.topIndex + me.rowCount,
      record = me.store.getAt(recordIndex),
      recordCount = me.store.count,
      // Row currently rendered on the top, the row we want to move
      topRow = me.topRow;

    // if (scrollMode === 'dom') {
    //     // only for performance evaluation, not to be used
    //
    //     // remove divs
    //     topRow.removeElements();
    //
    //     // add new divs
    //     me.grid.regions.forEach(region => {
    //         let div = me.grid.getSubGrid(region).addNewRowElement();
    //         topRow.addElement(region, div);
    //     });
    // }

    me.trigger('beforeTranslateRow', {
      row: topRow,
      newRecord: record
    });

    topRow.dataIndex = recordIndex;

    // Move it to bottom
    topRow.setTop(me.bottomRow.bottom);
    // Render row
    topRow.render(recordIndex, record, false);

    // Next row is now at top
    me.topIndex++;

    // move to end of array (topRow becomes bottomRow)
    me._rows.push(me._rows.shift());

    me.averageRowHeight = (me.averageRowHeight * (recordCount - 1) + topRow.offsetHeight) / recordCount;

    return topRow.offsetHeight;
  }

  //endregion
}
RowManager._$name = 'RowManager';

/**
 * @module Grid/view/Bar
 */

/**
 * Base class used by Header and Footer. Holds an element for each column. Not intended to be used directly.
 *
 * @extends Common/widget/Widget
 * @internal
 * @abstract
 */
class Bar extends Widget {
  static get defaultConfig() {
    return {
      scrollable: {} // We need a scroller, but no dimensions scroll by default
    };
  }

  //region Init

  /**
   * Construct a bar for the specified SubGrid.
   * @param {Object} config Bar config
   * @function constructor
   */
  construct(config) {
    let subGrid = config.subGrid;

    if (subGrid) {
      config.grid = subGrid.grid;
      config.columns = subGrid.columns;
      if (subGrid.width) {
        config.width = subGrid.width;
      } else if (subGrid.flex) {
        config.flex = subGrid.flex;
      }
    }

    super.construct(config);
  }

  get columns() {
    return this._columns;
  }

  set columns(columns) {
    this._columns = columns;
  }

  //endregion

  /**
   * Fix cell widths (flex or fixed width) after rendering.
   * Not a part of template any longer because of CSP
   * @private
   */
  fixCellWidths() {
    const me = this;

    let hasFlex = false,
      flexBasis;

    // single header "cell"
    me.columns.traverse((column) => {
      const cellEl = me.getBarCellElement(column.id),
        domWidth = DomHelper.setLength(column.width),
        domMinWidth = DomHelper.setLength(column.minWidth);

      if (cellEl) {
        // We have to work round the IE11 bug that flex-basis affects the content-box
        // and any padding is added as extra.
        // TODO: Remove  this when IE11 retires.
        if (BrowserHelper.isIE11) {
          flexBasis = `calc(${domWidth} - ${me.getLrPadding(cellEl)}px)`;
        } else {
          flexBasis = domWidth;
        }

        hasFlex = hasFlex || Boolean(column.flex);

        // Parent column without any specified width and flex should have flex calculated if any child has flex
        if (column.isParent && column.width == null && column.flex == null) {
          const flex = column.children.reduce((result, child) => (result += (!child.hidden && child.flex) || 0), 0);

          // Do not want to store this flex value on the column since it is always calculated
          cellEl.style.flex = flex > 0 ? `${flex} 0 auto` : '';

          if (flex > 0) {
            // TODO: Figure out a better way of handling this, minWidth on the columns breaks the flexbox
            //  calculation compared to cells, making them misalign
            column.traverse((col) => (col.data.minWidth = null));
          }
        }
        // Normal case, set flex, width etc.
        else {
          if (parseInt(column.minWidth) >= 0) {
            cellEl.style.minWidth = domMinWidth;
          }

          // Clear all the things we might have to set to correct cell widths
          cellEl.style.flex = cellEl.style.flexBasis = cellEl.style.width = '';

          if (column.flex) {
            // If column has children we need to give it
            // flex-shrink: 0, flex-basis: auto so that it always
            // shrinkwraps its children without shrinking
            if (!isNaN(parseInt(column.flex)) && column.children) {
              cellEl.style.flex = `${column.flex} 0 auto`;
            } else {
              cellEl.style.flex = column.flex;
            }
          } else if (parseInt(column.width) >= 0) {
            const parent = column.parent;

            // Only grid header bar has a notion of group headers
            // Column is a child of an unwidthed group. We have to use width
            // to stretch it.
            if (me.isHeader && !parent.isRoot && !parent.width) {
              cellEl.style.width = domWidth;
            } else {
              // https://app.assembla.com/spaces/bryntum/tickets/8041
              // Column header widths must be set using flex-basis.
              // Using width means that wide widths cause a flexed SubGrid
              // to bust the flex rules.
              // TODO: When IE11 retires, remove calc() hacks to overcome its flexbox bugs.
              // Note that grid in Grid#onColumnsResized and SubGrid#fixCellWidths,
              // cells MUST still be sized using width since rows
              // are absolutely positioned and will not cause the busting out
              // problem, and rows will not stretch to shrinkwrap the cells
              // unless they are widthed with width.
              cellEl.style.flexBasis = flexBasis;
            }
          }
        }

        if (column.height >= 0) {
          cellEl.style.height = DomHelper.setLength(column.height);
        }
      }
    });

    me.element.classList[hasFlex ? 'add' : 'remove']('b-has-flex');
  }

  getLrPadding(cellEl) {
    if (!this.cellLrPadding) {
      const s = cellEl.ownerDocument.defaultView.getComputedStyle(cellEl);
      this.cellLrPadding =
        parseInt(s.getPropertyValue('padding-left')) +
        parseInt(s.getPropertyValue('padding-right')) +
        parseInt(s.getPropertyValue('border-left-width')) +
        parseInt(s.getPropertyValue('border-right-width'));
    }
    return this.cellLrPadding;
  }

  /**
   * Get the header or footer cell element for the specified column.
   * @param {String} columnId Column id
   * @returns {HTMLElement} Header or footer element, depending on which subclass is in use.
   * @private
   */
  getBarCellElement(columnId) {
    return this.element.querySelector(`[data-column-id="${columnId}"]`);
  }
}
Bar._$name = 'Bar';

//import styles from '../../../resources/sass/grid/view/footer.scss';

/**
 * @module Grid/view/Footer
 */

/**
 * Grid footer, used by Summary feature. You should not need to create instances manually.
 *
 * @extends Grid/view/Bar
 * @internal
 */
class Footer extends Bar {
  static get defaultConfig() {
    return {
      isFooter: true
    };
  }

  startConfigure(config) {
    config.scrollable.overflowX = 'hidden-scroll';
    super.startConfigure(config);
  }

  get subGrid() {
    return this._subGrid;
  }

  set subGrid(subGrid) {
    this._subGrid = this.owner = subGrid;
  }

  refreshContent() {
    this.element.firstElementChild.innerHTML = this.contentTemplate();
    this.fixFooterWidths();
  }

  render(appendToElement) {
    super.render(appendToElement);
    this.refreshContent();
  }

  template() {
    const region = this.subGrid.region;

    return TemplateHelper.tpl`
            <div class="b-grid-footer-scroller b-grid-footer-scroller-${region}">
                <div reference="footersElement" class="b-grid-footers b-grid-footers-${region}" data-region="${region}"></div>
            </div>
        `;
  }

  get overflowElement() {
    return this.footersElement;
  }

  //region Getters

  /**
   * Get the footer cell element for the specified column.
   * @param {String} columnId Column id
   * @returns {HTMLElement} Footer cell element
   */
  getFooter(columnId) {
    return this.getBarCellElement(columnId);
  }

  //endregion

  /**
   * Footer template. Iterates leaf columns to create content.
   * Style not included because of CSP. Widths are fixed up in
   * {@link #function-fixFooterWidths}
   * @private
   */
  contentTemplate() {
    const me = this;

    return me.columns.visibleColumns
      .map((column) => {
        return column.hidden
          ? ''
          : TemplateHelper.tpl`
                <div 
                    class="b-grid-footer ${column.align ? `b-grid-footer-align-${column.align}` : ''} ${column.cls ||
              ''}" 
                    data-column="${column.field}" data-column-id="${column.id}" data-all-index="${column.allIndex}"
                    >
                    ${column.footerText || ''}
                </div>`;
      })
      .join('');
  }

  /**
   * Fix footer widths (flex or fixed width) after rendering. Not a part of template any longer because of CSP
   * @private
   */
  fixFooterWidths() {
    this.fixCellWidths();
  }
}
Footer._$name = 'Footer';

/**
 * @module Grid/util/GridScroller
 */

const xAxis$1 = {
  x: 1
};

/**
 * A Scroller subclass which handles scrolling in a grid.
 *
 * If the grid has no parallel scrolling grids (No locked columns), then this functions
 * transparently as a Scroller.
 *
 * If there are locked columns, then scrolling to an _element_ will invoke the scroller
 * of the subgrid which contains that element.
 * @internal
 */
class GridScroller extends Scroller {
  addScroller(scroller) {
    (this.xScrollers || (this.xScrollers = [])).push(scroller);
  }

  addPartner(otherScroller, axes = xAxis$1) {
    if (typeof axes === 'string') {
      axes = {
        [axes]: 1
      };
    }

    // Link up all our X scrollers
    if (axes.x) {
      for (let i = 0; i < this.xScrollers.length; i++) {
        this.xScrollers[i].addPartner(otherScroller.xScrollers[i], 'x');
      }
    }
    // We are the only Y scroller
    if (axes.y) {
      super.addPartner(otherScroller, 'y');
    }
  }

  updateOverflowX(overflowX) {
    this.xScrollers && this.xScrollers.forEach((s) => (s.overflowX = overflowX));
    this.widget.virtualScrollers.classList[overflowX === false ? 'add' : 'remove']('b-hide-display');
  }

  scrollIntoView(element, options) {
    // If we are after an element, we have to ask the scroller of the SubGrid
    // that the element is in. It will do the X scrolling and delegate the Y
    // scrolling up to this GridScroller.
    if (element.nodeType === 1) {
      for (const subGridScroller of this.xScrollers) {
        if (subGridScroller.element.contains(element)) {
          return subGridScroller.scrollIntoView(element, options);
        }
      }
    } else {
      return super.scrollIntoView(element, options);
    }
  }

  set x(x) {
    this.xScrollers[0].x = x;
  }

  get x() {
    return this.xScrollers[0].x;
  }
}
GridScroller._$name = 'GridScroller';

/**
 * @module Grid/view/Header
 */

/**
 * The Grid header, which contains simple columns but also allows grouped columns. One instance is created and used per SubGrid
 * automatically, you should not need to instantiate this class manually. See {@link Grid.column.Column} for information about
 * column configuration.
 *
 * @extends Grid/view/Bar
 * @internal
 *
 * @externalexample grid/Header.js
 */
class Header extends Bar {
  static get defaultConfig() {
    return {
      isHeader: true
    };
  }

  startConfigure(config) {
    config.scrollable.overflowX = 'hidden-scroll';
    super.startConfigure(config);
  }

  get subGrid() {
    return this._subGrid;
  }

  set subGrid(subGrid) {
    this._subGrid = subGrid;
    this.id = subGrid.id + '-header';
  }

  get region() {
    return this.subGrid && this.subGrid.region;
  }

  template() {
    const me = this,
      region = me.region;

    return TemplateHelper.tpl`
            <div class="b-grid-header-scroller b-grid-header-scroller-${region}">
                <div reference="headersElement" class="b-grid-headers b-grid-headers-${region}" data-region="${region}" data-max-depth="${me.maxDepth}" reference="headersElement"></div>
            </div>
        `;
  }

  get overflowElement() {
    return this.headersElement;
  }

  /**
   * Header template, recursive template for column headers.
   * Style not included because of CSP. Widths are fixed up in
   * {@link #function-fixHeaderWidths}
   * @private
   */
  contentTemplate(column) {
    const me = this;

    if (column.hidden) {
      return '';
    } else {
      /* eslint-disable */
      return TemplateHelper.tpl`
                <div class="b-grid-header" data-column="${column.field}" data-column-id="${column.id}" ${
        column.isLeaf ? 'tabindex="0"' : ''
      }>
                    <div class="b-grid-header-text">
                        <div class="b-grid-header-text-content"></div>
                    </div>
                    ${
                      column.children
                        ? `
                    <div class="b-grid-header-children">
                            ${column.children.map((child) => me.contentTemplate(child)).join('')}
                    </div>
                    `
                        : ''
                    }
                    <div class="b-grid-header-resize-handle"></div>
                </div>
            `;
      /* eslint-enable */
    }
  }

  // used by safari to fix flex when rows width shrink below this value
  calculateMinWidthForSafari() {
    let minWidth = 0,
      columns = this.columns.visibleColumns;

    columns.forEach((column) => {
      minWidth += column.calculateMinWidth();
    });

    return minWidth;
  }

  /**
   * Fix header widths (flex or fixed width) after rendering. Not a part of template any longer because of CSP
   * @private
   */
  fixHeaderWidths() {
    this.fixCellWidths();
  }

  refreshHeaders() {
    const me = this;

    // run renderers, not done from template to work more like cell rendering
    me.columns.traverse((column) => {
      const headerElement = me.getBarCellElement(column.id);

      if (headerElement) {
        const classList = new DomClassList({
          'b-grid-header': 1,
          'b-grid-header-parent': column.isParent,
          [`b-level-${column.childLevel}`]: 1,
          [`b-depth-${column.meta.depth}`]: 1,
          [`b-grid-header-align-${column.align}`]: column.align,
          'b-grid-header-resizable': column.resizable && column.isLeaf,
          [column.cls]: column.cls,
          'b-last-parent': column.isParent && column.isLastInSubGrid,
          'b-last-leaf': column.isLeaf && column.isLastInSubGrid
        });

        let html = column.text;

        headerElement.className = classList;

        if (column.headerRenderer) {
          html = column.headerRenderer.call(column.thisObj || me, { column, headerElement });
        }

        if (column.icon) {
          html = `<i class="${column.icon}"></i>` + (html || '');
        }

        const innerEl = headerElement.querySelector('.b-grid-header-text-content');
        if (innerEl) {
          innerEl.innerHTML = html || '';
        }
      }
    });

    me.fixHeaderWidths();
  }

  get columns() {
    return super.columns;
  }

  set columns(columns) {
    const me = this;

    me.columnsDetacher && me.columnsDetacher();

    if (columns) {
      // columns is a chained store, it will be repopulated from master when columns change.
      // That action always triggers change with action dataset.
      me.columnsDetacher = columns.on({
        change() {
          this.initDepths();
        },

        thisObj: me
      });
    }

    super.columns = columns;

    me.initDepths();
  }

  /**
   * Depths are used for styling of grouped headers. Sets them on meta.
   * @private
   */
  initDepths(columns = this.columns, parent = null) {
    let me = this,
      maxDepth = 0;

    if (parent && parent.meta) parent.meta.depth++;

    for (let column of columns) {
      // TODO: this should maybe move
      column.meta.depth = 0;

      if (column.children) {
        me.initDepths(column.children, column);
        if (column.meta.depth && parent) parent.meta.depth += column.meta.depth;
      }

      if (column.meta.depth > maxDepth) maxDepth = column.meta.depth;
    }

    if (!parent) {
      this.maxDepth = maxDepth;
    }

    return maxDepth;
  }

  //endregion

  //region Getters

  /**
   * Get the header cell element for the specified column.
   * @param {String} columnId Column id
   * @returns {HTMLElement} Header cell element
   */
  getHeader(columnId) {
    return this.getBarCellElement(columnId);
  }

  //endregion

  get contentElement() {
    return this.element.firstElementChild;
  }

  refreshContent() {
    const me = this;

    me.content = me.columns.map((col) => me.contentTemplate(col)).join('');

    me.refreshHeaders();
  }

  render(appendToElement) {
    super.render(appendToElement);
    this.refreshContent();
  }
}
Header._$name = 'Header';

//TODO: Should it fire more own events instead and rely less on function chaining?

const domEventHandlers = {
  touchstart: 'onElementTouchStart',
  touchmove: 'onElementTouchMove',
  touchend: 'onElementTouchEnd',
  mouseover: 'onElementMouseOver',
  mouseout: 'onElementMouseOut',
  mousedown: 'onElementMouseDown',
  mousemove: 'onElementMouseMove',
  mouseup: 'onElementMouseUp',
  click: 'handleElementClick',
  dblclick: 'onElementDblClick',
  keydown: 'onElementKeyDown',
  keyup: 'onElementKeyUp',
  keypress: 'onElementKeyPress',
  contextmenu: 'onElementContextMenu',
  focus: 'onGridElementFocus'
};

/**
 * @module Grid/view/mixin/GridElementEvents
 */

/**
 * Mixin for Grid that handles dom events. Some listeners fire own events but all can be chained by features. None of
 * the functions in this class are indented to be called directly.
 *
 * @mixin
 */
var GridElementEvents = (Target) =>
  class GridElementEvents extends (Target || Base) {
    //region Config

    static get defaultConfig() {
      return {
        /**
         * Time in ms until a longpress is triggered
         * @config {Number}
         * @default
         * @category Events
         */
        longPressTime: 400
      };
    }

    //endregion

    //region Events

    /**
     * User clicked in a grid cell
     * @event cellClick
     * @param {Grid.view.Grid} grid
     * @param {Common.data.Model} record
     * @param {Grid.column.Column} column
     * @param {Object} cellSelector
     * @param {HTMLElement} cellElement
     * @param {HTMLElement} target
     * @param {Event} event
     */

    /**
     * User double clicked in a grid cell
     * @event cellDblClick
     * @param {Grid.view.Grid} grid
     * @param {Common.data.Model} record
     * @param {Grid.column.Column} column
     * @param {Object} cellSelector
     * @param {HTMLElement} cellElement
     * @param {HTMLElement} target
     * @param {Event} event
     */

    /**
     * User activated contextmenu in a grid cell
     * @event cellContextMenu
     * @param {Grid.view.Grid} grid
     * @param {Common.data.Model} record
     * @param {Grid.column.Column} column
     * @param {Object} cellSelector
     * @param {HTMLElement} cellElement
     * @param {HTMLElement} target
     * @param {Event} event
     */

    /**
     * User moved moused to a grid cell
     * @event cellMouseOver
     * @param {Grid.view.Grid} grid
     * @param {Common.data.Model} record
     * @param {Grid.column.Column} column
     * @param {Object} cellSelector
     * @param {HTMLElement} cellElement
     * @param {HTMLElement} target
     * @param {Event} event
     */

    /**
     * User moved moused out of a grid cell
     * @event cellMouseOut
     * @param {Grid.view.Grid} grid
     * @param {Common.data.Model} record
     * @param {Grid.column.Column} column
     * @param {Object} cellSelector
     * @param {HTMLElement} cellElement
     * @param {HTMLElement} target
     * @param {Event} event
     */

    //endregion

    //region Event handling

    /**
     * Init listeners for a bunch of dom events. All events are handled by handleEvent().
     * @private
     * @category Events
     */
    initInternalEvents() {
      const handledEvents = Object.keys(domEventHandlers),
        len = handledEvents.length,
        listeners = {
          element: this.element,
          thisObj: this
        };

      // Route all events through handleEvent, so that we can capture this.event
      // before we route to the handlers
      for (let i = 0; i < len; i++) {
        listeners[handledEvents[i]] = 'handleEvent';
      }

      EventHelper.on(listeners);
    }

    /**
     * This method find the cell location of the passed event. It returns an object describing the cell.
     * @param {Event} event A Mouse, Pointer or Touch event targeted at part of the grid.
     * @returns {Object} An object containing the following properties:
     * - `cellElement` - The cell element clicked on.
     * - `columnId` - The `id` of the column clicked under.
     * - `record` - The {@link Common.data.Model record} clicked on.
     * - `id` - The `id` of the {@link Common.data.Model record} clicked on.
     * @private
     * @category Events
     */
    getEventData(event) {
      const me = this,
        cellElement = DomHelper.up(event.target, '.b-grid-cell');

      // There is a cell
      if (cellElement) {
        const cellData = DomDataStore.get(cellElement),
          { id, columnId } = cellData,
          record = me.store.getById(id);

        // Row might not have a record, since we transition record removal
        // https://app.assembla.com/spaces/bryntum/tickets/6805
        return record
          ? {
              cellElement,
              cellData,
              columnId,
              id,
              record,
              cellSelector: { id, columnId }
            }
          : null;
      }
    }

    /**
     * Handles all dom events, routing them to correct functions (touchstart -> onElementTouchStart)
     * @param event
     * @private
     * @category Events
     */
    handleEvent(event) {
      if (!this.disabled) {
        this.event = event;

        if (domEventHandlers[event.type]) {
          this[domEventHandlers[event.type]](event);
        }
      }
    }

    //endregion

    //region Touch events

    /**
     * Touch start, chain this function in features to handle the event.
     * @param event
     * @category Touch events
     * @internal
     */
    onElementTouchStart(event) {
      const me = this;

      DomHelper.isTouchEvent = true;

      if (event.touches.length === 1) {
        me.longPressTimeout = setTimeout(() => {
          me.onElementLongPress(event);
          event.preventDefault();
          me.longPressPerformed = true;
        }, me.longPressTime);
      }
    }

    /**
     * Touch move, chain this function in features to handle the event.
     * @param event
     * @category Touch events
     * @internal
     */
    onElementTouchMove(event) {
      if (this.longPressTimeout) {
        clearTimeout(this.longPressTimeout);
        this.longPressTimeout = null;
      }
    }

    /**
     * Touch end, chain this function in features to handle the event.
     * @param event
     * @category Touch events
     * @internal
     */
    onElementTouchEnd(event) {
      const me = this;

      if (me.longPressPerformed) {
        if (event.cancelable) {
          event.preventDefault();
        }
        me.longPressPerformed = false;
      }

      if (me.longPressTimeout) {
        clearTimeout(me.longPressTimeout);
        me.longPressTimeout = null;
      }
    }

    onElementLongPress(event) {}

    //endregion

    //region Mouse events

    // Trigger events in same style when clicking, dblclicking and for contextmenu
    triggerCellMouseEvent(name, event) {
      const me = this,
        cellData = me.getEventData(event);

      // There is a cell
      if (cellData) {
        const column = me.columns.getById(cellData.columnId);

        me.trigger('cell' + StringHelper.capitalizeFirstLetter(name), {
          grid: this,
          record: cellData.record,
          column,
          cellSelector: cellData.cellSelector,
          cellElement: cellData.cellElement,
          target: event.target,
          event
        });
      }
    }

    /**
     * Mouse down, chain this function in features to handle the event.
     * @param event
     * @category Mouse events
     * @internal
     */
    onElementMouseDown(event) {
      const me = this,
        cellData = me.getEventData(event);

      me.skipFocusSelection = true;

      me.triggerCellMouseEvent('mousedown', event);

      // Browser event unification fires a mousedown on touch tap prior to focus.
      if (!event.defaultPrevented) {
        me.onFocusGesture(cellData, event);
      }
    }

    /**
     * Move move, chain this function in features to handle the event.
     * @param event
     * @category Mouse events
     * @internal
     */
    onElementMouseMove(event) {}

    /**
     * Mouse up, chain this function in features to handle the event.
     * @param event
     * @category Mouse events
     * @internal
     */
    onElementMouseUp(event) {}

    handleElementClick(event) {
      if (this.trigger('beforeElementClick', { event }) !== false) {
        this.onElementClick(event);
      }
    }

    /**
     * Click, select cell on click and also fire 'cellClick' event.
     * Chain this function in features to handle the dom event.
     * @param event
     * @fires cellClick
     * @category Mouse events
     * @internal
     */
    onElementClick(event) {
      const me = this,
        cellData = me.getEventData(event);

      // There is a cell
      if (cellData) {
        me.triggerCellMouseEvent('click', event);

        // Clear hover styling when clicking in a row to avoid having it stick around if you keyboard navigate
        // away from it
        // https://app.assembla.com/spaces/bryntum/tickets/5848
        DomDataStore.get(cellData.cellElement).row.removeCls('b-hover');
      }
    }

    onFocusGesture(cellData, event) {
      //TODO: should be able to cancel focusCell from listeners
      if (cellData) {
        this.focusCell(cellData.cellSelector, {
          doSelect: true,
          event
        });
      }
    }

    /**
     * Double click, fires 'cellDblClick' event.
     * Chain this function in features to handle the dom event.
     * @param {Event} event
     * @fires cellDblClick
     * @category Mouse events
     * @internal
     */
    onElementDblClick(event) {
      const me = this,
        target = event.target;

      me.triggerCellMouseEvent('dblClick', event);

      if (target.classList.contains('b-grid-header-resize-handle')) {
        const header = DomHelper.up(target, '.b-grid-header'),
          column = me.columns.getById(header.dataset.columnId);

        column.resizeToFitContent();
      }
    }

    /**
     * Mouse over, adds 'hover' class to elements.
     * @param event
     * @fires mouseOver
     * @category Mouse events
     * @internal
     */
    onElementMouseOver(event) {
      // bail out early if scrolling
      if (!this.scrolling) {
        const cellElement = DomHelper.up(event.target, '.b-grid-cell');

        if (cellElement) {
          const row = DomDataStore.get(cellElement).row;

          // No hover effect needed if a mouse button is pressed (like when resizing window, region, or resizing something etc).
          // NOTE: 'buttons' not supported in Safari
          if (row && (typeof event.buttons !== 'number' || event.buttons === 0)) {
            row.addCls('b-hover');
          }

          this.triggerCellMouseEvent('mouseOver', event);
        }

        /**
         * Mouse moved in over element in grid
         * @event mouseOver
         * @param {Event} event
         */
        this.trigger('mouseOver', { event });
      }
    }

    /**
     * Mouse out, removes 'hover' class from elements.
     * @param event
     * @fires mouseOut
     * @category Mouse events
     * @internal
     */
    onElementMouseOut(event) {
      const me = this;

      // bail out early if scrolling
      if (!me.scrolling) {
        const cellElement = DomHelper.up(event.target, '.b-grid-cell');

        if (cellElement) {
          const row = DomDataStore.get(cellElement).row;

          if (row) row.removeCls('b-hover');

          me.triggerCellMouseEvent('mouseOut', event);
        }

        /**
         * Mouse moved out from element in grid
         * @event mouseOut
         * @param {Event} event
         */
        me.trigger('mouseOut', { event });
      }
    }

    //endregion

    //region Keyboard events

    /**
     * Key down, handles arrow keys for selection.
     * Chain this function in features to handle the dom event.
     * @param event
     * @category Keyboard events
     * @internal
     */
    onElementKeyDown(event) {
      const me = this;

      // flagging event with handled = true used to signal that other features should probably not care about it.
      // for this to work you should specify overrides for onElementKeyDown to be run before this function
      // (see for example CellEdit feature)
      if (event.handled) return;

      if (event.target.matches('.b-grid-header.b-depth-0')) {
        me.handleHeaderKeyDown(event);
      } else if (event.target === this.element || (BrowserHelper.isIE11 && event.currentTarget === this.element)) {
        // IE11 Browser check is not placed in EventHelper to maintain built-in delegated functionality
        me.handleViewKeyDown(event);
      }
      // If focus is *within* a cell (eg WidgetColumn or CheckColumn), jump up to focus the cell.
      else if (event.key === 'Escape' && me.isActionableLocation) {
        const focusedCell = ObjectHelper.clone(me.focusedCell);
        focusedCell.element = null;
        me.focusCell(focusedCell);
        DomHelper.focusWithoutScrolling(me.element);
      }
    }

    handleViewKeyDown(event) {
      const me = this;

      switch (event.key) {
        case 'ArrowLeft':
          event.preventDefault();
          return me.navigateLeft(event);
        case 'ArrowRight':
          event.preventDefault();
          return me.navigateRight(event);
        case 'ArrowUp':
          event.preventDefault();
          return me.navigateUp(event);
        case 'ArrowDown':
          event.preventDefault();
          return me.navigateDown(event);
      }
    }

    handleHeaderKeyDown(event) {
      const me = this,
        column = me.columns.getById(event.target.dataset.columnId);

      column.onKeyDown && column.onKeyDown(event);
      switch (event.key) {
        case 'ArrowLeft':
          const prev = me.columns.getAdjacentVisibleLeafColumn(column, false);

          if (prev) {
            let element = me.getHeaderElement(prev.id);
            element.focus();
          }

          break;

        case 'ArrowRight':
          const next = me.columns.getAdjacentVisibleLeafColumn(column, true);

          if (next) {
            let element = me.getHeaderElement(next.id);
            element.focus();
          }

          break;

        case 'ArrowDown':
          me.onElementContextMenu(event);
          break;

        case 'Enter':
          const element = me.getHeaderElement(column.id);

          element.click();
          break;
      }
    }

    /**
     * Key press, chain this function in features to handle the dom event.
     * @param event
     * @category Keyboard events
     * @internal
     */
    onElementKeyPress(event) {}

    /**
     * Key up, chain this function in features to handle the dom event.
     * @param event
     * @category Keyboard events
     * @internal
     */
    onElementKeyUp(event) {}

    //endregion

    //region Other events

    /**
     * Context menu, chain this function in features to handle the dom event.
     * In most cases, include ContextMenu feature instead.
     * @param event
     * @category Other events
     * @internal
     */
    onElementContextMenu(event) {
      const me = this,
        cellData = me.getEventData(event);

      // There is a cell
      if (cellData) {
        me.triggerCellMouseEvent('contextMenu', event);

        // Focus on tap for touch events.
        // Selection follows from focus.
        if (DomHelper.isTouchEvent) {
          me.onFocusGesture(cellData, event);
        }
      }
    }

    /**
     * Overrides empty base function in View, called when view is resized.
     * @fires resize
     * @param element
     * @param width
     * @param height
     * @param oldWidth
     * @param oldHeight
     * @category Other events
     * @internal
     */
    onInternalResize(element, width, height, oldWidth, oldHeight) {
      const me = this;

      if (me._devicePixelRatio && me._devicePixelRatio !== window.devicePixelRatio) {
        // Pixel ratio changed, likely because of browser zoom. This affects the relative scrollbar width also
        DomHelper.resetScrollBarWidth();
      }

      me._devicePixelRatio = window.devicePixelRatio;
      // cache to avoid recalculations in the middle of rendering code (RowManger#getRecordCoords())
      me._bodyRectangle = Rectangle.client(me.bodyContainer);

      super.onInternalResize(...arguments);

      if (height !== oldHeight) {
        me._bodyHeight = me.bodyContainer.offsetHeight;
        if (me.rendered) {
          // initial height will be set from render(),
          // it reaches onInternalResize too early when rendering, headers/footers are not sized yet
          me.rowManager.initWithHeight(me._bodyHeight);
        }
      }
      me.refreshVirtualScrollbars();

      if (width !== oldWidth) {
        // Slightly delay to avoid resize loops.
        me.setTimeout(() => {
          if (!me.isDestroyed) {
            me.updateResponsive(width, oldWidth);
          }
        }, 0);
      }
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Grid/view/mixin/GridFeatures
 */

let validConfigTypes = {
  string: 1,
  object: 1,
  function: 1 // used by CellTooltip
};

/**
 * Mixin for Grid that handles features. Features are plugins that add functionality to the grid. Feature classes should
 * register with Grid by calling {@link Grid.feature.GridFeatureManager#function-registerFeature-static registerFeature}. This
 * enables features to be specified and configured in grid
 * config.
 *
 * Define which features to use:
 *
 * ```javascript
 * // specify which features to use (note that some features are used by default)
 * const grid = new Grid({
 *   features: {
 *      sort: 'name',
 *      search: true
 *   }
 * });
 * ```
 *
 * Access a feature in use:
 *
 * ```javascript
 * grid.features.search.search('cat');
 * ```
 *
 * Basic example of implementing a feature:
 *
 * ```javascript
 * class MyFeature extends InstancePlugin {
 *
 * }
 *
 * GridFeatures.registerFeature(MyFeature);
 *
 * // using the feature
 * const grid = new Grid({
 *   features: {
 *     myFeature: true
 *   }
 * });
 * ```
 *
 * @mixin
 */
var GridFeatures = (Target) =>
  class GridFeatures extends (Target || Base) {
    //region Init

    /**
     * Specify which features to use on the grid. Most features accepts a boolean, some also accepts a config object.
     * Please note that if you are not using the bundles you might need to import the features you want to use.
     *
     * ```javascript
     * const grid = new Grid({
     *     features : {
     *         stripe : true,   // Enable stripe feature
     *         sort   : 'name', // Configure sort feature
     *         group  : false   // Disable group feature
     *     }
     * }
     * ```
     *
     * @config {Object} features
     * @category Common
     */

    /**
     * Map of the features available on the grid. Use it to access them on your grid object
     *
     * ```javascript
     * grid.features.group.expandAll();
     * ```
     *
     * @readonly
     * @property {Object}
     * @category Common
     * @typings any
     */
    set features(features) {
      const me = this,
        defaultFeatures = GridFeatureManager.getInstanceDefaultFeatures(this);

      features = me._features = ObjectHelper.assign({}, features);

      // default features, enabled unless otherwise specified
      if (defaultFeatures) {
        Object.entries(defaultFeatures).forEach(([as, featureClass]) => {
          if (!(as in features)) {
            features[as] = true;
          }
        });
      }

      // We *prime* the features so that if any configuration code accesses a feature, it
      // will self initialize, but if not, they will remain in a primed state until afterConfigure.
      let featureName, config, featureClass;

      const registeredInstanceFeatures = GridFeatureManager.getInstanceFeatures(this);

      for (featureName of Object.keys(features)) {
        config = features[featureName];

        // Create feature initialization property if config is truthy.
        // Config must be a valid configuration value for the feature class.
        if (config) {
          // Feature configs name must start with lowercase letter to be valid
          if (StringHelper.lowercaseFirstLetter(featureName) !== featureName) {
            throw new Error(me.L('invalidFeatureNameFormat', featureName));
          }

          featureClass = registeredInstanceFeatures[featureName];

          if (!featureClass) {
            throw new Error(me.L('featureNotFound', featureName));
          }

          // Create a self initializing property on the features object named by the feature name.
          // when accessed, it will create and return the real feature.
          // Now, if some Feature initiualization code attempt to access a feature which has not yet been initialized
          // it will be initialized just in time.
          Reflect.defineProperty(
            features,
            featureName,
            me.createFeatureInitializer(features, featureName, featureClass, config)
          );
        }
      }
    }

    get features() {
      return this._features;
    }

    createFeatureInitializer(features, featureName, featureClass, config) {
      const constructorArgs = [this],
        construct = featureClass.prototype.construct;

      // Only pass config if there is one.
      // The constructor(config = {}) only works for undefined config
      if (validConfigTypes[typeof config]) {
        constructorArgs[1] = config;
      }

      return {
        configurable: true,
        get() {
          // Delete this defined property and replace it with the Feature instance.
          delete features[featureName];

          // Ensure the feature is injected into the features object before initialization
          // so that it is available from call chains from its initialization.
          featureClass.prototype.construct = function(...args) {
            features[featureName] = this;
            construct.apply(this, args);
            featureClass.prototype.construct = construct;
          };

          // Return the Feature instance
          return new featureClass(...constructorArgs);
        }
      };
    }

    //endregion

    //region Other stuff

    /**
     * Check if a feature is included
     * @param {String} name Feature name, as registered with `GridFeatureManager.registerFeature()`
     * @returns {Boolean}
     * @category Misc
     */
    hasFeature(name) {
      return !!(this.features && name in this.features);
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Grid/view/mixin/GridNavigation
 */

const defaultFocusOptions = Object.freeze({
  doSelect: true
});

/**
 * Mixin for Grid that handles cell to cell navigation.
 *
 * @mixin
 */
var GridNavigation = (Target) =>
  class GridNavigation extends (Target || Base) {
    //region Cell

    /**
     * User navigated to a grid cell
     * @event navigate
     * @param {Grid.view.Grid} grid
     * @param {Object} last focused location
     * @param {Object} location focus moved to
     * @param {Event} [event] The UI event which caused navigation.
     */

    /**
     * Cell selector for focused cell, set to focus a cell or use {@link #function-focusCell}.
     * @property {Object}
     */
    get focusedCell() {
      return this._focusedCell;
    }

    /**
     * This property is `true` if an element _within_ a cell is focused.
     * @property {Boolean}
     * @readonly
     */
    get isActionableLocation() {
      const focusedCell = this._focusedCell;
      return Boolean(focusedCell && focusedCell.element && this.getCell(focusedCell).contains(focusedCell.element));
    }

    set focusedCell(cellSelector) {
      this.focusCell(cellSelector, {
        doSelect: false
      });
    }

    get focusedRecord() {
      if (this._focusedCell) {
        return this.store.getById(this._focusedCell.id);
      }
    }

    /**
     * CSS selector for currently focused cell. Format is "[data-index=index] [data-column-id=columnId]".
     * @property {String}
     * @readonly
     */
    get cellCSSSelector() {
      const me = this,
        cell = me._focusedCell,
        row = cell && me.getRowById(cell.id);

      if (!cell || !row) return '';

      return `[data-index=${row.index}] [data-column-id=${cell.columnId}]`;
    }

    /**
     * Grid element focus, selects first row and cell when grid is focused if none is selected (otherwise user cannot
     * see that grid is focused).
     * Chain this function it features to handle the dom event.
     * @param event
     * @category Other events
     * @internal
     */
    onGridElementFocus(event) {
      // Select first row if none is selected when grid is focused (to show that it has focus)
      const me = this,
        focusOptions = {
          doSelect: false,
          event
        };

      if (me._focusedCell) {
        me.focusCell(me._focusedCell, focusOptions);
      } else {
        // If they just clicked in blank space, do not refocus the last focused cell.
        // We focus cell 0, 0 on that gesture.
        const targetCell = me.element.contains(event.relatedTarget) ? null : me.lastFocusedCell;

        if (targetCell) {
          // The previously focused record has since been removed.
          // Fallback to reverting to where focus endtered the grid from.
          // TODO: CellContext should store the record index
          // to fall back to if the actual record is no longer present.
          if (!me.store.getById(targetCell.id)) {
            me.revertFocus();
            return;
          }

          // flag to not affect selection
          me.returningFocus = true;
          me.focusCell(targetCell, focusOptions);
          me.returningFocus = false;
        } else if (!me.skipFocusSelection && me.store.first) {
          me.focusCell(
            {
              id: me.store.first.id,
              columnId: me.columns.visibleColumns[0].id
            },
            focusOptions
          );
        }
      }
      me.skipFocusSelection = false;
    }

    onFocusOut(event) {
      super.onFocusOut(event);

      this.clearFocus();
    }

    /**
     * Checks whether or not a cell is focused.
     * @param {Object|string|Number} cellSelector Cell selector { id: x, columnId: xx } or row id
     * @returns {Boolean} true if cell or row is focused, otherwise false
     */
    isFocused(cellSelector) {
      return Boolean(this._focusedCell) && this.isLocationEqual(cellSelector, this._focusedCell);
    }

    /**
     * Navigates to a cell and/or its row (depending on selectionMode)
     * @param {Object} cellSelector { id: rowId, columnId: 'columnId' }
     * @param {Object} options Modifier options for how to deal with focusing the cell. These
     * are used as the {@link Common.helper.util.Scroller#function-scrollTo} options.
     * @param {Boolean} [options.doSelect=true] Optionally pass `false` to not continue to selection.
     * @param {Event} [options.event] Optionally pass the UI event which instigated the focus request.
     * @returns {Object} Cell selector
     * @fires navigate
     */
    focusCell(cellSelector, options = defaultFocusOptions) {
      // If we're being passed a context object (as opposed to a record), clone in case we were
      // passed the _focusedCell, and after refresh isLocationEqual needs to detect a difference.
      cellSelector = this.normalizeCellContext(
        cellSelector === Object ? Object.assign({}, cellSelector) : cellSelector
      );

      const me = this,
        doSelect = options.doSelect !== false,
        { event } = options,
        lastFocusedCell = (me.lastFocusedCell = me._focusedCell),
        isNotMove = me.isLocationEqual(cellSelector, lastFocusedCell),
        lastCell = lastFocusedCell && me.getCell(lastFocusedCell);

      let cell = me.getCell(cellSelector);

      // If we're focusing due to a mousedown on a focusable element *within* a cell
      // then we do not "navigate" to the cell - we allow the element to be focused.
      // For example a CheckColumn or WidgetColumn.
      if (event && event.type === 'mousedown') {
        for (let target = event.target; target !== cell; target = target.parentElement) {
          if (DomHelper.isFocusable(target)) {
            cellSelector.element = target;
            return;
          }
        }
      }

      // No navigation takes place, but the selection still needs to know if a UI event happened.
      if (isNotMove) {
        if (event) {
          me.onCellNavigate && me.onCellNavigate(me, null, me._focusedCell, event, doSelect);
        }
        return cellSelector;
      }

      if (lastCell) {
        lastCell.classList.remove('b-focused');
      }

      me.scrollRowIntoView(
        cellSelector.id,
        Object.assign(
          {
            column: cellSelector.columnId
          },
          options
        )
      );

      // Get the newly visible cell *after* it has been scrolled into view.
      // With buffered rendering, it may not have existed before the scroll.
      cell = me.getCell(cellSelector);
      if (cell) {
        cellSelector.element = cell;
        cell.classList.add('b-focused');
      }

      //Remember
      me._focusedCell = cellSelector;

      me.onCellNavigate && me.onCellNavigate(me, lastFocusedCell, me._focusedCell, event, doSelect);

      me.trigger('navigate', { lastFocusedCell, focusedCell: me._focusedCell, event });
      //TODO: should be able to cancel selectcell from listeners

      return cellSelector;
    }

    isLocationEqual(cellSelector, otherCellSelector) {
      return (
        cellSelector &&
        otherCellSelector &&
        cellSelector.id === otherCellSelector.id &&
        cellSelector.columnId === otherCellSelector.columnId &&
        // Normalized cellSelectors are not required to have an element, only compare elements if both selectors
        // have it specified
        (!cellSelector.element || !otherCellSelector.element || cellSelector.element === otherCellSelector.element)
      );
    }

    blurCell(cellSelector) {
      const me = this,
        cell = me.getCell(cellSelector);

      if (cell) {
        cell.classList.remove('b-focused');
      }
    }

    clearFocus() {
      const me = this;

      if (me._focusedCell) {
        // set last to have focus return to previous cell when alt tabbing
        me.lastFocusedCell = me._focusedCell;

        me.blurCell(me._focusedCell);
        me._focusedCell = null;
      }
    }

    /**
     * Selects the cell before or after currently focused cell.
     * @private
     * @param next Specify true to select the next cell, false to select the previous
     * @param {Event} [event] Optionally, the UI event which caused navigation.
     * @returns {Object} Used cell selector
     */
    internalNextPrevCell(next = true, event) {
      let me = this,
        cellSelector = me._focusedCell;

      if (cellSelector) {
        return me.focusCell(
          {
            id: cellSelector.id,
            columnId: me.columns.getAdjacentVisibleLeafColumn(cellSelector.columnId, next, true).id
          },
          {
            doSelect: true,
            event
          }
        );
      }
      return null;
    }

    /**
     * Select the cell after the currently focused one.
     * @param {Event} [event] Optionally, the UI event which caused navigation.
     * @returns {Object} Cell selector
     */
    navigateRight(event) {
      return this.internalNextPrevCell(true, event);
    }

    /**
     * Select the cell before the currently focused one.
     * @param {Event} [event] Optionally, the UI event which caused navigation.
     * @returns {Object} Cell selector
     */
    navigateLeft(event) {
      return this.internalNextPrevCell(false, event);
    }

    //endregion

    //region Row

    /**
     * Selects the next or previous record in relation to the current selection. Scrolls into view if outside.
     * @private
     * @param next Next record (true) or previous (false)
     * @param {Boolean} skipSpecialRows True to not return specialRows like headers
     * @param {Event} [event] Optionally, the UI event which caused navigation.
     * @returns {Object/Boolean} Selection context for the focused row (& cell) or false if no selection was made
     */
    internalNextPrevRow(next, skipSpecialRows = true, event) {
      const me = this,
        cell = me._focusedCell;

      if (!cell) return false;

      const record = me.store[`get${next ? 'Next' : 'Prev'}`](cell.id, false, skipSpecialRows);

      if (!record) return false;

      return me.focusCell(
        {
          id: record.id,
          columnId: me._focusedCell && me._focusedCell.columnId
        },
        {
          doSelect: true,
          event
        }
      );
    }

    /**
     * Navigates to the cell below the currently focused cell
     * @param {Event} [event] Optionally, the UI event which caused navigation.
     * @returns {Object} Selector for focused row (& cell)
     */
    navigateDown(event) {
      return this.internalNextPrevRow(true, false, event);
    }

    /**
     * Navigates to the cell above the currently focused cell
     * @param {Event} [event] Optionally, the UI event which caused navigation.
     * @returns {Object} Selector for focused row (& cell)
     */
    navigateUp(event) {
      return this.internalNextPrevRow(false, false, event);
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Grid/view/mixin/GridResponsive
 */

/**
 * Simplifies making grid responsive. Supply levels as {@link #config-responsiveLevels} config, default levels are:
 * <dl>
 * <dt>small <dd>< 400px,
 * <dt>medium <dd>< 600px
 * <dt>large <dd>> 600px
 * </dl>
 *
 * Columns can define configs per level to be resized etc:
 *
 * ```
 * let grid = new Grid({
 *   responsiveLevels: {
 *     small: 300,
 *     medium: 400,
 *     large: '*' // everything above 400
 *   },
 *
 *   columns: [
 *     {
 *       field: 'name',
 *       text: 'Name',
 *       responsiveLevels: {
 *         small: { hidden: true },
 *         '*': { hidden: false } // all other levels
 *       }
 *     },
 *     { field: 'xx', ... }
 *   ]
 * });
 * ```
 *
 * It is also possible to give a [Grid state](#Grid/view/mixin/GridState) object instead of a level width, but in that
 * case the object must contain a `levelWidth` property:
 *
 * ```
 * let grid = new Grid({
 *   responsiveLevels: {
 *     small: {
 *       // Width is required
 *       levelWidth : 400,
 *       // Other configs are optional, see GridState for available options
 *       rowHeight  : 30
 *     },
 *     medium : {
 *       levelWidth : 600,
 *       rowHeight  : 40
 *     },
 *     large: {
 *       levelWidth : '*', // everything above 300
 *       rowHeight  : 45
 *     }
 *   }
 * });
 * ```
 *
 * @demo responsive
 * @externalexample grid/Responsive.js
 * @mixin
 */
var GridResponsive = (Target) =>
  class GridResponsive extends (Target || Base) {
    static get defaultConfig() {
      return {
        /**
         * "Break points" for which responsive config to use for columns and css.
         * @config {Object}
         * @category Misc
         * @default <code>{ small : 400, medium : 600, large : '*' }</code>
         */
        responsiveLevels: Object.freeze({
          small: 400,
          medium: 600,
          large: '*'
        })
      };
    }

    /**
     * Find closes bigger level, aka level we want to use.
     * @private
     * @category Misc
     */
    getClosestBiggerLevel(width) {
      let me = this,
        levels = Object.keys(me.responsiveLevels),
        useLevel = null,
        minDelta = 99995,
        biggestLevel = null;

      levels.forEach((level) => {
        let levelSize = me.responsiveLevels[level];

        // responsiveLevels can contains config objects, in which case we should use width from it
        if (!['number', 'string'].includes(typeof levelSize)) {
          levelSize = levelSize.levelWidth;
        }

        if (levelSize === '*') {
          biggestLevel = level;
        } else if (width < levelSize) {
          const delta = levelSize - width;
          if (delta < minDelta) {
            minDelta = delta;
            useLevel = level;
          }
        }
      });

      return useLevel || biggestLevel;
    }

    /**
     * Get currently used responsive level (as string)
     * @returns {String}
     * @readonly
     * @category Misc
     */
    get responsiveLevel() {
      return this.getClosestBiggerLevel(this.width);
    }

    /**
     * Check if resize lead to a new responsive level and take appropriate actions
     * @private
     * @fires responsive
     * @param width
     * @param oldWidth
     * @category Misc
     */
    updateResponsive(width, oldWidth) {
      const me = this,
        oldLevel = me.getClosestBiggerLevel(oldWidth),
        level = me.getClosestBiggerLevel(width);

      if (oldLevel !== level) {
        // Level might be a state object
        const levelConfig = me.responsiveLevels[level];
        if (!['number', 'string'].includes(typeof levelConfig)) {
          me.applyState(levelConfig);
        }

        // check columns for responsive config
        me.columns.forEach((column) => {
          const levels = column.responsiveLevels;
          if (levels) {
            if (levels[level]) {
              // using state to apply responsive config, since it already does what we want...
              column.applyState(levels[level]);
            } else if (levels['*']) {
              column.applyState(levels['*']);
            }
          }
        });

        me.element.classList.remove('b-responsive-' + oldLevel);
        me.element.classList.add('b-responsive-' + level);

        /**
         * Grid resize lead to a new responsive level being applied
         * @event responsive
         * @param {Grid.view.Grid} grid Grid that was resized
         * @param {String} level New responsive level (small, large, etc)
         * @param {Number} width New width in px
         * @param {String} oldLevel Old responsive level
         * @param {Number} oldWidth Old width in px
         */
        me.trigger('responsive', { level, width, oldLevel, oldWidth });
      }
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

const validIdTypes = {
  string: 1,
  number: 1
};

/**
 * @module Grid/view/mixin/GridSelection
 */

/**
 * Mixin for Grid that handles row and cell selection.
 *
 * @example
 * // select a row
 * grid.selectedRow = 7;
 *
 * // select a cell
 * grid.selectedCell = { id: 5, columnId: 'column1' }
 *
 * // select a record
 * grid.selectedRecord = grid.store.last;
 *
 * // select multiple records by ids
 * grid.selectedRecords = [1, 2, 4, 6]
 *
 * @mixin
 */
var GridSelection = (Target) =>
  class GridSelection extends (Target || Base) {
    static get defaultConfig() {
      return {
        recordCollection: {}
      };
    }

    //region Init

    afterConfigure() {
      const me = this;

      // Inject our CheckColumn into the ColumnStore
      if (me.selectionMode.checkbox) {
        const col = (me.checkboxColumn = new CheckColumn({
          id: `${me.id}-selection-column`,
          width: '4em',
          field: null,
          // Always put the checkcolumn in the first region
          region: Object.keys(me.subGridConfigs).sort()[0]
        }));
        col.meta.depth = 0;
        // This is assigned in Column.js for normal columns
        col._grid = me;

        // Override renderer to inject the rendered record's selected status into the value
        const checkboxRenderer = col.renderer;
        col.renderer = (renderData) => {
          renderData.value = me.isSelected(renderData.record);
          checkboxRenderer.call(col, renderData);
        };

        col.on({
          toggle: 'onCheckChange',
          thisObj: me
        });

        // Insert the checkbox after any rownumber column. If not there, -1 means in at 0.
        const insertIndex = me.columns.indexOf(me.columns.findRecord('type', 'rownumber')) + 1;

        me.columns.insert(insertIndex, col);
      }
      super.afterConfigure();
    }

    //endregion

    //region Events

    /**
     * The selection has been changed.
     * @event selectionchange
     * @param {String} action `'select'`/`'deselect'`
     * @param {String} mode `'row'`/`'cell'`
     * @param {Grid.view.Grid} source
     * @param {Common.data.Model[]|Object} deselected The records or cells (depending on the `mode`) deselected in this operation.
     * @param {Common.data.Model[]|Object} selected The records or cells (depending on the `mode`) selected in this operation.
     * @param {Common.data.Model[]|Object} selection  The records or cells (depending on the `mode`) in the new selection.
     */

    /**
     * Responds to mutations of the underlying storage Collection
     * @param {Object} event
     * @private
     */
    onRecordCollectionChange({ source: recordCollection, action, added = [], removed }) {
      const me = this;

      if (me._selectedCell && !me.isSelectable(me._selectedCell)) {
        me.deselectCell(me._selectedCell);
      }

      // Filter out unselectable rows
      added = added.filter((row) => me.isSelectable(row));

      me.triggerChangeEvent(
        {
          mode: 'row',
          action: added.length ? 'select' : 'deselect',
          selection: me.selectedRecords,
          selected: added,
          deselected: removed
        },
        me.silent
      );
    }

    onCheckChange({ checked, record }) {
      if (checked) {
        this.selectRow(record, false, true);
      } else {
        this.deselectRow(record);
      }
    }

    onElementKeyDown(event) {
      const me = this,
        { focusedCell, checkboxColumn } = me;

      super.onElementKeyDown(event);

      // SPACE key on our CheckColumn toggles it
      if (
        focusedCell &&
        event.key === ' ' &&
        checkboxColumn &&
        me.columns.getById(focusedCell.columnId) === checkboxColumn
      ) {
        const checkbox = me.getCell(focusedCell).widget;

        if (checkbox) {
          checkbox.toggle();
        }
      }
    }

    //endregion

    //region Selection collection

    set recordCollection(recordCollection) {
      if (!(recordCollection instanceof Collection)) {
        recordCollection = new Collection(recordCollection);
      }
      this._recordCollection = recordCollection;

      // Fire row change events from onRecordCollectionChange
      recordCollection.on({
        change: 'onRecordCollectionChange',
        thisObj: this
      });
    }

    get recordCollection() {
      return this._recordCollection;
    }

    /**
     * Removes and adds records to/from the selection at the same time. Analogous
     * to the `Array` `splice` method.
     *
     * Note that if items that are specified for removal are also in the `toAdd` array,
     * then those items are *not* removed then appended. They remain in the same position
     * relative to all remaining items.
     *
     * @param {Number} index Index at which to remove a block of items. Only valid if the
     * second, `toRemove` argument is a number.
     * @param {Object[]|Number} toRemove Either the number of items to remove starting
     * at the passed `index`, or an array of items to remove (If an array is passed, the `index` is ignored).
     * @param  {Object[]|Object} toAdd An item, or an array of items to add.
     */
    spliceSelectedRecords(index, toRemove, toAdd) {
      this._recordCollection.splice(index, toRemove, toAdd);
    }

    //endregion

    //region Cell & row

    /**
     * Checks whether or not a cell or row is selected.
     * @param {Object|string|Number|Common.data.Model} cellSelectorOrId Cell selector { id: x, column: xx } or row id, or record
     * @returns {Boolean} true if cell or row is selected, otherwise false
     * @category Selection
     */
    isSelected(cellSelectorOrId) {
      const me = this;

      // A record passed
      if (cellSelectorOrId instanceof Model) {
        cellSelectorOrId = cellSelectorOrId.id;
      }

      if (validIdTypes[typeof cellSelectorOrId]) {
        return me.recordCollection.includes(cellSelectorOrId);
      } else {
        return (
          me._selectedCell &&
          me._selectedCell.id == cellSelectorOrId.id &&
          me._selectedCell.columnId === cellSelectorOrId.columnId
        );
      }
    }

    /**
     * Checks whether or not a cell or row can be selected.
     * @param recordCellOrId Record or cell or record id
     * @returns {Boolean} true if cell or row cane be selected, otherwise false
     * @category Selection
     */
    isSelectable(recordCellOrId) {
      // Selection disabled for undefined record, special row (group header / footer) and
      // record which was already removed from store

      if (!recordCellOrId) {
        return false;
      }
      const row = this.store.getById(recordCellOrId.id || recordCellOrId);
      return row && !(row.meta && row.meta.specialRow);
    }

    /**
     * Cell selector for selected cell, set to select a cell or use {@link #function-selectCell()}.
     * @property {Object}
     * @category Selection
     */
    get selectedCell() {
      return this._selectedCell;
    }

    set selectedCell(cellSelector) {
      this.selectCell(cellSelector);
    }

    /**
     * The last selected record. Set to select a row or use Grid#selectRow. Set to null to
     * deselect all
     * @property {Common.data.Model}
     * @category Selection
     */
    get selectedRecord() {
      return this.recordCollection.last || null;
    }

    set selectedRecord(record) {
      this.selectRow(record);
    }

    /**
     * Selected records.
     * Can be set as array of ids.
     * ```
     * grid.selectedRecords = [1, 2, 4, 6]
     * ```
     *
     * @property {Common.data.Model[]|Number[]}
     * @category Selection
     */
    get selectedRecords() {
      return this.recordCollection.values;
    }

    set selectedRecords(selectedRecords) {
      const { recordCollection, store } = this,
        toSelect = [];

      if (selectedRecords && selectedRecords.length) {
        for (let record of selectedRecords) {
          record = store.getById(record);
          if (record) {
            toSelect.push(record);
          }
        }
      }

      // Replace the entire selected collection with the new record set
      recordCollection.splice(0, recordCollection.count, toSelect);
    }

    /**
     * CSS selector for the currently selected cell. Format is "[data-index=index] [data-column=column]".
     * @type {String}
     * @category Selection
     * @readonly
     */
    get selectedCellCSSSelector() {
      const me = this,
        cell = me._selectedCell,
        row = cell && me.getRowById(cell.id);

      if (!cell || !row) return '';

      return `[data-index=${row.dataIndex}] [data-column-id=${cell.columnId}]`;
    }

    /**
     * Selects a row (without selecting a cell).
     * @param recordOrId Record or record id, specifying null will deselect all
     * @param {Boolean} scrollIntoView Specify `false` to prevent row from being scrolled into view
     * @param {Boolean} addToSelection Specify `true` to add to selection, defaults to `false` which replaces
     * @fires selectionchange
     * @category Selection
     */
    selectRow(recordOrId, scrollIntoView = true, addToSelection = false) {
      const me = this,
        record = me.store.getById(recordOrId);

      if (record) {
        me.selectCell({ id: record.id }, scrollIntoView, addToSelection);
      } else {
        me.deselectAll();
      }
    }

    /**
     * Selects a cell and/or its row (depending on selectionMode)
     * @param {Object} cellSelector { id: rowId, columnId: 'columnId' }
     * @param {Boolean} scrollIntoView Specify false to prevent row from being scrolled into view
     * @param {Boolean} addToSelection Specify `true` to add to selection, defaults to `false` which replaces
     * @param {Boolean} silent Specify `true` to not trigger any events when selecting the cell
     * @returns {Object} Cell selector
     * @fires selectionchange
     * @category Selection
     */
    selectCell(cellSelector, scrollIntoView = false, addToSelection = false, silent = false) {
      const me = this,
        { recordCollection, selectionMode } = me,
        selector = me.normalizeCellContext(cellSelector),
        record = selector.record || me.store.getById(selector.id);

      // Clear selection if row is not selectable
      if (!me.isSelectable(record)) {
        this.deselectAll();
        return;
      }

      if (scrollIntoView) {
        me.scrollRowIntoView(selector.id, {
          column: selector.columnId
        });
      }

      // Row selection (both sides if locked columns)
      if (selectionMode.row) {
        if (silent) {
          me.silent = (me.silent || 0) + 1;
        }
        if (addToSelection) {
          recordCollection.add(record);
        }
        // Clear all others
        else {
          recordCollection.splice(0, recordCollection.count, record);
        }
        if (silent) {
          me.silent--;
        }

        // When starting a selection, register the start cell
        if (me.recordCollection.count === 1) {
          me.startCell = selector;
          me.lastRange = null;
        }
      }

      // Cell selection
      if (selectionMode.cell && (selector.columnId || selector.column) && !me.isSelected(selector)) {
        let deselected = me._selectedCell ? [me._selectedCell] : [];

        //Remember
        me._selectedCell = selector;

        me.triggerChangeEvent(
          {
            mode: 'cell',
            action: 'select',
            selected: [selector],
            deselected,
            selection: [selector]
          },
          silent
        );
      }

      return selector;
    }

    /**
     * Deselects all selected rows and cells
     * @category Selection
     */
    deselectAll() {
      const me = this;
      me.recordCollection.clear();
      if (me._selectedCell) {
        me.deselectCell(me._selectedCell);
      }
    }

    /**
     * Deselect a row
     * @param {Common.data.Model|String|Number} recordOrId Record or an id for a record
     * @category Selection
     */
    deselectRow(recordOrId) {
      const record = recordOrId instanceof Model ? recordOrId : this.store.getById(recordOrId);
      record && this.recordCollection.remove(record);
    }

    /**
     * Deselect a cell/row, depending on settings in Grid#selectionMode
     * @param {Object} cellSelector
     * @returns {Object} Normalized cell selector
     * @category Selection
     */
    deselectCell(cellSelector) {
      const me = this,
        selector = me.normalizeCellContext(cellSelector),
        selMode = me.selectionMode,
        record = selector.record || me.store.getById(selector.id),
        selectedCell = me._selectedCell;

      // Row selection (both sides if locked columns)
      if (selMode.row) {
        me.recordCollection.remove(record);
      }

      // Cell selection
      if (selMode.cell && selector.columnId && selectedCell) {
        if (selectedCell.id === selector.id && selectedCell.columnId === selector.columnId) {
          me._selectedCell = null;

          me.triggerChangeEvent({
            mode: 'cell',
            action: 'deselect',
            selected: [],
            deselected: [selector],
            selection: []
          });
        }
      }

      return selector;
    }

    //endregion

    //region Record

    /**
     * Selects rows corresponding to a range of records (from fromId to toId)
     * @param {String|Number} fromId
     * @param {String|Number} toId
     * @category Selection
     */
    selectRange(fromId, toId) {
      const { store, recordCollection } = this,
        fromIndex = store.indexOf(fromId),
        toIndex = store.indexOf(toId),
        startIndex = Math.min(fromIndex, toIndex),
        endIndex = Math.max(fromIndex, toIndex);

      if (startIndex === -1 || endIndex === -1) {
        throw new Error('Record not found in selectRange');
      }

      recordCollection.splice(0, recordCollection.count, store.getRange(startIndex, endIndex + 1, false));
    }

    /**
     * Triggered from Grid view when records get removed from the store.
     * Deselects all records which have been removed.
     * @private
     * @category Selection
     */
    onStoreRemove(event) {
      // If the next mixin up the inheritance chain has an implementation, call it
      super.onStoreRemove && super.onStoreRemove(event);

      this.recordCollection.remove(event.records);
    }

    /**
     * Triggered from Grid view when the store changes. This might happen
     * if store events are batched and then resumed.
     * Deselects all records which have been removed.
     * @private
     * @category Selection
     */
    onStoreDataChange({ action, source: store }) {
      // If the next mixin up the inheritance chain has an implementation, call it
      super.onStoreDataChange && super.onStoreDataChange(...arguments);

      if (['dataset', 'batch'].includes(action)) {
        const selectedRecords = this.recordCollection,
          toRemove = [];

        selectedRecords.forEach((record) => {
          if (!store.includes(record)) {
            toRemove.push(record);
          }
        });

        // Remove in one go to fire a single selectionChange event
        selectedRecords.remove(toRemove);
      }
    }

    /**
     * Triggered from Grid view when all records get removed from the store.
     * Deselects all records.
     * @private
     * @category Selection
     */
    onStoreRemoveAll() {
      // If the next mixin up the inheritance chain has an implementation, call it
      super.onStoreRemoveAll && super.onStoreRemoveAll();

      this.deselectAll();
    }

    //endregion

    //region Handle multiSelect

    /**
     * Handles multi selection using the mouse. Called from GridElementEvents on mousedown in a cell and
     * simultaneously pressing a modifier key.
     * @param cellData
     * @param event
     * @private
     * @category Selection
     */
    handleMouseMultiSelect(cellData, event) {
      const me = this,
        id = cellData.id;

      function mergeRange(fromId, toId) {
        const { store, recordCollection } = me,
          fromIndex = store.indexOf(fromId),
          toIndex = store.indexOf(toId),
          startIndex = Math.min(fromIndex, toIndex),
          endIndex = Math.max(fromIndex, toIndex);

        if (startIndex === -1 || endIndex === -1) {
          throw new Error('Record not found in selectRange');
        }

        const newRange = store.getRange(startIndex, endIndex + 1, false).filter((row) => me.isSelectable(row));
        recordCollection.splice(0, me.lastRange || 0, newRange);
        me.lastRange = newRange;
      }

      if ((event.metaKey || event.ctrlKey) && me.isSelected(id)) {
        // ctrl/cmd deselects row if selected
        me.deselectRow(id);
      } else if (me.selectionMode.multiSelect) {
        if (event.shiftKey && me.startCell) {
          // shift appends selected range (if we have previously focused cell)
          mergeRange(me.startCell.id, id);
        } else if (event.ctrlKey || event.metaKey) {
          // ctrl/cmd adds to selection if using multiselect (and not selected)
          me.selectRow(id, false, true);
        }
      }
    }

    //endregion

    //region Navigation

    /**
     * Triggered from GridNavigation when focus is moved to another cell within the grid. Selects the cell unless
     * modifier keys are pressed, in which case it has already been handled
     * @private
     * @category Selection
     */
    onCellNavigate(me, fromCellSelector, toCellSelector, event, doSelect = true) {
      // CheckColumn events are handled by the CheckColumn itself.
      if (me.columns.getById(toCellSelector.columnId) === me.checkboxColumn) {
        return;
      }

      // 1.do not affect selection if focus is returning to the grid from some widget
      // 2. don't select when clicking expander icon in a tree
      if (!doSelect || me.returningFocus || (event && event.target.classList.contains('b-tree-expander'))) {
        return;
      }

      const isSameRecord = fromCellSelector && toCellSelector.id === fromCellSelector.id,
        isMouse = event && event.type === 'mousedown',
        isMouseCtrl = isMouse && event.ctrlKey;

      // SHIFT for keyboard / mouse and CTRL for mouse events indicate multiselect
      if (event && (!event.button || event.button === 2) && (event.shiftKey || isMouseCtrl)) {
        me.handleMouseMultiSelect(toCellSelector, event);
      } else {
        me.selectCell(
          toCellSelector,
          false,
          (isSameRecord && (!event || event.shiftKey || event.ctrlKey)) ||
            (event && (isMouseCtrl || (event.button === 2 && me.isSelected(toCellSelector.id))))
        );
      }

      // Remember last cell with ctrl pressed
      if (!me.startCell || isMouseCtrl) {
        me.startCell = toCellSelector;
        me.lastRange = null;
      }
    }

    /**
     * Keeps the UI synced with the selectionchange event before firing it out.
     * Event is not fired if the `silent` parameter is truthy.
     * @param {Object} selectionChangeEvent The change event to sync the UI to, and to possibly fire.
     * @param {Boolean} silent Specify `true` to not trigger any the passed.
     * @private
     * @category Selection
     */
    triggerChangeEvent(selectionChangeEvent, silent) {
      const me = this,
        { mode, selected, deselected } = selectionChangeEvent;

      let i, len, row, cell;

      // Keep the UI up to date with the triggered changes.
      // A mode: 'row' change selects and/or deselects records.
      if (mode === 'row') {
        for (i = 0, len = selected.length; i < len; i++) {
          row = me.getRowFor(selected[i]);
          if (row) {
            row.addCls('b-selected');
            if (me.checkboxColumn && !selected[i].meta.specialRow) {
              row.getCell(me.checkboxColumn.id).widget.checked = true;
            }
          }
        }
        for (i = 0, len = deselected.length; i < len; i++) {
          row = me.getRowFor(deselected[i]);
          if (row) {
            row.removeCls('b-selected');
            if (me.checkboxColumn && !deselected[i].meta.specialRow) {
              row.getCell(me.checkboxColumn.id).widget.checked = false;
            }
          }
        }
      }
      // A mode: 'cell' change selects and/or deselects *one* cell right now.
      // But we always use an array for future-proofing.
      else if (mode === 'cell') {
        for (i = 0, len = selected.length; i < len; i++) {
          cell = me.getCell(selected[i]);
          if (cell) {
            cell.classList.add('b-selected');
          }
        }
        for (i = 0, len = deselected.length; i < len; i++) {
          cell = me.getCell(deselected[i]);
          if (cell) {
            cell.classList.remove('b-selected');
          }
        }
      }

      if (!silent) {
        me.trigger('selectionChange', selectionChangeEvent);
      }
    }

    //endregion

    //region Getters/setters

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}

    //endregion
  };

// TODO: prevent multiple rerenders

/**
 * @module Grid/view/mixin/GridState
 */

/**
 * Mixin for Grid that handles state. It serializes the following grid properties:
 *
 * * rowHeight
 * * readOnly
 * * selectedCell
 * * selectedRecords
 * * columns (order, widths, visibility)
 * * store (sorters, groupers, filters)
 * * scroll position
 *
 * See {@link Common.mixin.State} for more information on state.
 *
 * @demo state
 * @externalexample grid/State.js
 * @mixin
 */
var GridState = (Target) =>
  class GridState extends (Target || Base) {
    /**
     * Get grids current state for serialization. State includes rowHeight, headerHeight, readOnly, selectedCell,
     * selectedRecordId, column states and store state.
     * @returns {Object} State object to be serialized
     * @private
     */
    getState() {
      const me = this,
        style = me.element.style.cssText,
        state = {
          rowHeight: me.rowHeight,
          readOnly: me.readOnly
        };

      if (style) {
        state.style = style;
      }

      if (me.selectedCell) {
        // TODO: Create wrapper class to avoid JSON.stringify recursion in state.selectedCell.
        const { id, columnId } = me.selectedCell;
        state.selectedCell = { id, columnId };
      }

      state.selectedRecords = me.selectedRecords.map((entry) => entry.id);
      state.columns = me.columns.map((column) => column.getState());
      state.store = me.store.state;
      state.scroll = me.storeScroll();
      state.width = {};
      state.collapsed = {};
      me.eachSubGrid((subGrid) => {
        if (subGrid.flex == null) {
          state.width[subGrid.region] = subGrid.width;
        }

        state.collapsed[subGrid.region] = subGrid.collapsed;
      });

      return state;
    }

    /**
     * Apply previously stored state.
     * @param {Object} state
     * @private
     */
    applyState(state) {
      const me = this;
      if ('readOnly' in state) {
        me.readOnly = state.readOnly;
      }

      if ('rowHeight' in state) {
        me.rowHeight = state.rowHeight;
      }

      if ('style' in state) {
        me.style = state.style;
      }

      if ('selectedCell' in state) {
        me.selectedCell = state.selectedCell;
      }

      if ('store' in state) {
        me.store.state = state.store;
      }

      if ('selectedRecords' in state) {
        me.selectedRecords = state.selectedRecords;
      }

      if ('columns' in state) {
        // each column triggers rerender at least once...
        state.columns.forEach((columnState) => {
          const column = me.columns.getById(columnState.id);
          if (column) {
            column.applyState(columnState);
            column.stateSortIndex = columnState.index;
          }
        });

        me.eachSubGrid((subGrid) => {
          subGrid.columns.records.sort((a, b) => a.stateSortIndex - b.stateSortIndex);
          subGrid.columns.allRecords.sort((a, b) => a.stateSortIndex - b.stateSortIndex);
        });
        me.columns.sort(
          {
            fn: (a, b) => a.stateSortIndex - b.stateSortIndex
            // always sort ascending
          },
          true
        );

        // manually triggered rerender
        me.rendered ? me.renderContents() : me.render();
      }

      if ('width' in state) {
        me.eachSubGrid((subGrid) => {
          if (subGrid.region in state.width) {
            subGrid.width = state.width[subGrid.region];
          }
        });
      }

      if ('collapsed' in state) {
        me.eachSubGrid((subGrid) => {
          subGrid.collapsed = state.collapsed[subGrid.region];
        });
      }

      if ('scroll' in state) {
        me.restoreScroll(state.scroll);
      }
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Grid/util/SubGridScroller
 */

const immediatePromise$4 = new Promise((resolve) => resolve()),
  defaultScrollOptions$1 = {
    block: 'nearest'
  };

/**
 * A Scroller subclass which handles scrolling in a SubGrid. Needs special treatment since the SubGrid itself only
 * allows horizontal scrolling, while the vertical scrolling is done by an outer element containing all subgrids.
 *
 * @internal
 */
class SubGridScroller extends Scroller {
  scrollIntoView(element, options = defaultScrollOptions$1) {
    const me = this,
      { xDelta, yDelta } = me.getDeltaTo(element, options),
      result = xDelta || yDelta ? me.scrollBy(xDelta, yDelta, options) : immediatePromise$4;

    if (options.highlight || options.focus) {
      result.then(() => {
        if (options.highlight) {
          if (element instanceof Rectangle) {
            element.translate(-xDelta, -yDelta).highlight();
          } else {
            DomHelper.highlight(element);
          }
        }
        options.focus && element.focus && element.focus();
      });
    }
    return result;
  }

  scrollBy(xDelta, yDelta, options) {
    const yPromise = yDelta && this.yScroller.scrollBy(0, yDelta, options),
      xPromise = xDelta && super.scrollBy(xDelta, 0, options);

    if (xPromise && xPromise.cancel && yPromise && yPromise.cancel) {
      const cancelX = xPromise.cancel,
        cancelY = yPromise.cancel;

      // Set up cross canceling
      xPromise.cancel = yPromise.cancel = () => {
        cancelX();
        cancelY();
      };
      return Promise.all([xPromise, yPromise]);
    }

    return xPromise || yPromise;
  }

  scrollTo(toX, toY, options) {
    const yPromise = toY != null && this.yScroller.scrollTo(null, toY, options),
      xPromise = toX != null && super.scrollTo(toX, null, options);

    if (xPromise && xPromise.cancel && yPromise && yPromise.cancel) {
      const cancelX = xPromise.cancel,
        cancelY = yPromise.cancel;

      // Set up cross canceling
      xPromise.cancel = yPromise.cancel = () => {
        cancelX();
        cancelY();
      };
      return Promise.all([xPromise, yPromise]);
    }

    return xPromise || yPromise;
  }

  get viewport() {
    return Rectangle.from(this.element).intersect(Rectangle.from(this.yScroller.element));
  }

  set y(y) {
    this.yScroller.y = y;
  }

  get y() {
    return this.yScroller ? this.yScroller.y : 0;
  }

  get maxY() {
    return this.yScroller ? this.yScroller.maxY : 0;
  }

  get scrollHeight() {
    return this.yScroller ? this.yScroller.scrollHeight : 0;
  }

  get clientHeight() {
    return this.yScroller ? this.yScroller.clientHeight : 0;
  }
}
SubGridScroller._$name = 'SubGridScroller';

/**
 * @module Grid/view/SubGrid
 */

/**
 * A SubGrid is a part of the grid (it has at least one and normally no more than two, called locked and normal). It
 * has its own header, which holds the columns to display rows for in the SubGrid. SubGrids are created by Grid, you
 * should not need to create instances directly.
 *
 * If not configured with a width or flex, the SubGrid will be sized to fit its columns. In this case, if all columns
 * have a fixed width (not using flex) then toggling columns will also affect the width of the SubGrid.
 *
 * @extends Common/widget/Widget
 */
class SubGrid extends Widget {
  //region Config

  /**
   * Region (name) for this SubGrid
   * @config {String} region
   */

  /**
   * Column store, a store containing the columns for this SubGrid
   * @config {Grid.data.ColumnStore} columns
   */

  static get defaultConfig() {
    return {
      insertRowsBefore: null,
      appendTo: null,
      hideHeaders: null,
      monitorResize: true,
      // Width of the subgrid in the collapsed state
      collapsedStateWidth: 5,
      // Default width of the splitter.
      splitterWidth: 1,
      /**
       * Set `true` to start subgrid collapsed. To operate collapsed state on subgrid use
       * {@link #function-collapse}/{@link #function-expand} methods.
       * @config {Boolean}
       * @default false
       */
      collapsed: null,

      scrollable: {
        // Each SubGrid only handles scrolling in the X axis.
        // The owning Grid handles the Y axis.
        overflowX: true
      },

      scrollerClass: SubGridScroller,

      // Will be set to true by GridSubGrids if it calculates the subgrids width based on its columns.
      // Used to determine if hiding a column should affect subgrids width
      hasCalculatedWidth: null,

      /**
       * Set `true` to disable moving columns into or out of this SubGrid.
       * @config {Boolean}
       * @default false
       * @private
       */
      sealedColumns: null,

      emptyText: null
    };
  }

  //endregion

  //region Init

  /**
   * SubGrid constructor
   * @param config
   * @private
   */
  construct(config) {
    const me = this;

    super.construct(config);

    me.initHeader();

    me.rowManager.on('addrows', me.onAddRow, me);
  }

  doDestroy() {
    const me = this;

    me.header && me.header.destroy();
    me.footer && me.footer.destroy();
    me.fakeScroller && me.fakeScroller.destroy();

    me.virtualScrollerElement && me.virtualScrollerElement.remove();
    me.splitterElement && me.splitterElement.remove();

    super.doDestroy();
  }

  /**
   * Creates a header for the SubGrid
   * @private
   */
  initHeader() {
    const me = this,
      config = Object.assign(
        {
          subGrid: me,
          columns: me.columns,
          hidden: me.hideHeaders,
          parent: me // Contained widgets need to know their parents
        },
        me.headerConfig
      );

    me.header = new me.headerClass(config);
  }

  /**
   * Initializes elements for the SubGrid and its header and footer (if any)
   * @private
   */
  initElements() {
    const me = this;

    me.footerElement = DomHelper.down(me.grid.element, '.b-grid-footer-scroller-' + me.region);

    me.updateHasFlex();
  }

  //endregion

  //region Template

  template() {
    const { grid, region } = this,
      isLastSubGrid = !grid || region === grid.regions[grid.regions.length - 1],
      splitterCls = `b-grid-splitter${BrowserHelper.isIE11 ? ' b-grid-splitter-transform' : ''}`;

    // The virtual scroller element in the template below will be moved to the virtual scroller container in grid on
    // render. It is defined as part of the SubGrid template to get references for free

    // Same applies to the splitter. Except for the last SubGrid, it does not have a splitter

    return TemplateHelper.tpl`
            <div class="b-grid-subgrid b-grid-subgrid-${region} b-grid-horizontal-scroller" data-region="${region}">
                <div reference="virtualScrollerElement" class="b-virtual-scroller" data-region="${region}">
                    <div reference="virtualScrollerWidth" class="b-virtual-width"></div>
                </div>
                ${
                  isLastSubGrid
                    ? ''
                    : TemplateHelper.tpl`
                <div reference="splitterElement" data-region="${region}" class="${splitterCls}">
                    <div class="b-grid-splitter-inner"></div>
                    <i class="b-icon b-icon-collapse-gridregion"></i>
                    <i class="b-icon b-icon-expand-gridregion"></i>
                </div>`
                }
            </div>
        `;
  }

  rowTemplate() {
    const me = this;

    return TemplateHelper.tpl`
            <div class="b-grid-row">
                ${me.columns.visibleColumns.map(me.cellTemplate, me)}
            </div>
        `;
  }

  cellTemplate(column) {
    return `<div class="b-grid-cell" data-column="${column.field}" data-column-id="${column.id}"></div>`;
  }

  //endregion

  //region Render

  onPaint() {
    const me = this;

    if (!me.rendered) {
      const { grid } = me,
        // Cannot use me.splitterElement, rightmost subgrid will "share" splitter with its predecessor
        // Need to check grid existence for standalone test
        splitter = grid && grid.resolveSplitter(me);

      // Unit tests create naked SubGrids so we have to do this.
      if (grid) {
        // Move virtual scroller & splitter to grids container for them
        grid.virtualScrollers.appendChild(me.virtualScrollerElement);
        me.splitterElement && grid.element.appendChild(me.splitterElement);

        me.renderHeader(grid.headerContainer);
        me.renderFooter(grid.footerContainer);

        me.initElements();
      }

      me.syncSplitter(true);
      me.splitterWidth = (splitter && splitter.offsetWidth) || 1;

      me._collapsed && me.collapse();

      me.rendered = true;
    }
  }

  renderHeader(appendToElement) {
    if (this.header) {
      this.header.render(appendToElement);
    }
  }

  renderFooter(appendToElement) {
    if (this.footer) {
      this.footer.render(appendToElement);
      // footerContainer starts hidden, since it is not used by default. make sure it is visible here
      this.grid.footerContainer.classList.remove('b-hidden');
    }
  }

  refreshHeader() {
    this.header.refreshContent();
  }

  refreshFooter() {
    this.footer && this.footer.refreshContent();
  }

  //endregion

  //region Size & resize

  /**
   * Sets cell widths. Cannot be done in template because of CSP
   * @private
   */
  fixCellWidths(rowElement, visibleColumns = null) {
    if (!visibleColumns) visibleColumns = this.columns.bottomColumns.filter((col) => !col.hidden);

    // fix cell widths, no longer allowed in template because of CSP
    let cellElement = rowElement.firstElementChild,
      i = 0;

    while (cellElement) {
      const column = visibleColumns[i];

      if (column.minWidth) {
        DomHelper.setLength(cellElement, 'minWidth', column.minWidth);
      }

      // either flex or width, flex has precedence
      if (column.flex) {
        cellElement.style.flex = column.flex;
        cellElement.style.width = '';
      } else if (column.width) {
        // https://app.assembla.com/spaces/bryntum/tickets/8041
        // Although header and footer elements must be sized
        // using flex-basis to avoid the busting out problem,
        // grid cells MUST be sized using width since rows are absolutely
        // positioned and will not cause the busting out problem,
        // and rows will not stretch to shrinkwrap the cells
        // unless they are widthed with width.
        cellElement.style.flex = '';
        cellElement.style.width = DomHelper.setLength(column.width);

        // IE11 calculates flexbox container width based on min-width rather than actual width. When column
        // has width defined greater than minWidth, row may have incorrect width
        if (BrowserHelper.isIE11) {
          cellElement.style.minWidth = cellElement.style.width;
        }
      } else {
        cellElement.style.flex = cellElement.style.width = cellElement.style.minWidth = '';
      }

      cellElement = cellElement.nextElementSibling;
      i++;
    }
  }

  get totalFixedWidth() {
    return this.columns.totalFixedWidth;
  }

  /**
   * Sets header width and scroller width (if needed, depending on if using flex). Might also change the subgrids
   * width, if it uses a width calculated from its columns.
   * @private
   */
  fixWidths() {
    const me = this,
      { element, header, footer } = me;

    if (me.flex) {
      header.flex = me.flex;
      if (footer) {
        footer.flex = me.flex;
      }
      element.style.flex = me.flex;
    } else {
      // If width is calculated and no column is using flex, check if total width is less than width. If so,
      // recalculate width and bail out of further processing (since setting width will trigger again)
      if (
        me.hasCalculatedWidth &&
        !me.columns.some((col) => !col.hidden && col.flex) &&
        me.totalFixedWidth !== me.width
      ) {
        me.width = me.totalFixedWidth;
        // Setting width above clears the hasCalculatedWidth flag, but we want to keep it set to react correctly
        // next time
        me.hasCalculatedWidth = true;
        return;
      }

      let totalWidth = me.width;

      if (!totalWidth) {
        totalWidth = 0;

        // summarize column widths, needed as container width when not using flex widths and for correct
        // overflow check in Edge
        for (let col of me.columns) {
          if (!col.flex && !col.hidden) totalWidth += col.width;
        }
      }

      // rows are absolutely positioned, meaning that their width won't affect container width
      // hence we must set it, if not using flex
      element.style.width = `${totalWidth}px`;

      header.width = totalWidth;
      if (footer) {
        footer.width = totalWidth;
      }
    }

    me.syncScrollingPartners(false);
  }

  // Safari/Edge do not shrink cells the same way as chrome & ff does without having a width set on the row
  fixRowWidthsInSafariEdge() {
    if (BrowserHelper.isSafari || BrowserHelper.isEdge) {
      const me = this,
        { region, header } = me,
        minWidth = header.calculateMinWidthForSafari();

      // fix row widths for safari, it does not size flex cells correctly at small widths otherwise.
      // there should be a css solution, but I have failed to find it
      me.rowManager.forEach((row) => {
        // This function runs on resize and rendering a SubGrid triggers a resize. When adding a new SubGrid
        // on the fly elements wont exists for it yet, so ignore...
        const element = row.getElement(region);
        // it is worth noting that setting a width does not prevent the row from growing beyond that with
        // when making view wider, it is used in flex calculation more like a min-width
        if (element) {
          element.style.width = `${minWidth}px`;
        }
      });

      header.headersElement.style.width = `${minWidth}px`;
    }
  }

  /**
   * Get/set SubGrid width, which also sets header and footer width (if available).
   * @property {Number}
   */
  set width(width) {
    const me = this;

    // Width explicitly set, remember that
    me.hasCalculatedWidth = false;

    if (me.header) me.header.width = width;
    if (me.footer) me.footer.width = width;
    super.width = width;

    // Can't wait until the  throttled resize occurs - it looks bad.
    if (!me.isConfiguring) {
      me.onElementResize();
    }
  }

  get width() {
    return super.width;
  }

  /**
   * Get/set SubGrid flex, which also sets header and footer flex (if available).
   * @property {Number|String}
   */
  set flex(flex) {
    const me = this;

    // Width explicitly set, remember that
    me.hasCalculatedWidth = false;

    if (me.header) me.header.flex = flex;
    if (me.footer) me.footer.flex = flex;
    super.flex = flex;

    // Can't wait until the  throttled resize occurs - it looks bad.
    if (!me.isConfiguring) {
      me.onElementResize();
    }
  }

  get flex() {
    return super.flex;
  }

  /**
   * Called when grid changes size. SubGrid determines if it has changed size and triggers scroll (for virtual
   * rendering in cells to work when resizing etc.)
   * @private
   */
  onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {
    const me = this,
      { grid } = me;

    // Widget caches dimensions
    super.onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight);

    // Unit tests create naked SubGrids so we have to do this.
    if (grid && newWidth !== oldWidth) {
      // trigger scroll, in case anything is done on scroll it needs to be done now also
      grid.trigger('horizontalScroll', { subGrid: me, grid, scrollLeft: me.scrollable.x });

      me.refreshFakeScroll();

      // Do not sync splitters while rendering, they need to be synced after render to appear at correct positions
      if (grid.rendered) {
        // One subgrid changing size might affect others, make sure splitters are at correct locations
        grid.eachSubGrid((subGrid) => subGrid.syncSplitter());
      }

      me.fixRowWidthsInSafariEdge();

      // This was originally triggered from within syncSplitters(). Moved it here since now syncing all splitters
      me.trigger('afterInternalResize', me);
    }
  }

  syncSplitter(initial = false) {
    const { element, splitterElement } = this;

    if (splitterElement) {
      splitterElement.style.left = `${element.offsetLeft + (this.collapsed && !initial ? 0 : element.offsetWidth)}px`;
    }
  }

  /**
   * Get the "viewport" for the SubGrid as a Rectangle
   * @property {Common.helper.util.Rectangle}
   * @readonly
   */
  get viewRectangle() {
    const me = this;
    return new Rectangle(me.scrollable.x, me.scrollable.y, me._width, me.rowManager.viewHeight);
  }

  /**
   * Called when updating column widths to apply 'b-has-flex' which is used when fillLastColumn is configured.
   * @internal
   */
  updateHasFlex() {
    const hasFlex = this.columns.visibleColumns.some((column) => column.flex);

    DomHelper.toggleClasses(this.element, ['b-has-flex'], hasFlex);
  }

  //endregion

  //region Scroll

  /**
   * Fixes widths of fake scrollers
   * @private
   */
  refreshFakeScroll() {
    const me = this,
      { element, virtualScrollerElement, virtualScrollerWidth } = me,
      scroller = me.scrollable;

    // Use a fixed scroll width if grid is empty, to make it scrollable without rows
    // https://app.assembla.com/spaces/bryntum/tickets/7184
    scroller.scrollWidth = me.store.count ? null : me.totalFixedWidth;

    virtualScrollerElement.style.width = `${element.offsetWidth}px`;

    //if (BrowserHelper.isEdge) {
    // Needed for Edge, it does not size correctly
    if (me.totalFixedWidth > scroller.clientWidth) {
      element.classList.add('b-overflowing-horizontally');
    } else {
      element.classList.remove('b-overflowing-horizontally');
    }
    //}

    // This is if *this* subGrid has horizontal overflow
    // +1 is for Edge, it messes up otherwise
    if (scroller.scrollWidth > scroller.clientWidth + (BrowserHelper.isEdge ? 1 : 0)) {
      virtualScrollerWidth.style.width = `${scroller.scrollWidth}px`;
      me.header.element.classList.add('b-overflowing');
      me.footer && me.footer.element.classList.add('b-overflowing');
      me.overflowingHorizontally = true;
      // If *any* SubGrids have horizontal overflow, the main grid
      // has to show its virtual horizontal scollbar.
      me.grid.virtualScrollers.classList.remove('b-hide-display');
    } else {
      virtualScrollerWidth.style.width = 0;
      me.header.element.classList.remove('b-overflowing');
      me.footer && me.footer.element.classList.remove('b-overflowing');
      me.overflowingHorizontally = false;
    }
  }

  /**
   * Init scroll syncing for header and footer (if available).
   * @private
   */
  initScroll() {
    const me = this,
      scroller = me.scrollable,
      virtualScrollerElement = me.virtualScrollerElement;

    if (BrowserHelper.isFirefox) {
      scroller.element.addEventListener('wheel', (event) => {
        if (event.deltaX) {
          scroller.x += event.deltaX;
          event.preventDefault();
        }
      });
    }

    scroller.yScroller = me.grid.scrollable;

    // Add our Scroller to the controlling GridScroller
    scroller.yScroller.addScroller(scroller);

    // Create a Scroller for the fake horizontal scrollbar so that it can partner
    me.fakeScroller = new Scroller({
      element: virtualScrollerElement,
      overflowX: true
    });

    // Fire horizontalscroll when our xScroller reports a scroll
    scroller.on('scroll', me.createOnFrame(me.syncScrollingPartners));
    scroller.on('scrollend', () => {
      me.scrolling = false;
    });

    scroller.addPartner(me.fakeScroller, 'x');
    if (me.header) {
      scroller.addPartner(me.header.scrollable, 'x');
    }
    if (me.footer) {
      scroller.addPartner(me.footer.scrollable, 'x');
    }
  }

  set scrolling(scrolling) {
    this._scrolling = scrolling;
    this.grid.bodyContainer.classList[scrolling ? 'add' : 'remove']('b-scrolling');
  }

  get scrolling() {
    return this._scrolling;
  }

  /**
   * This syncs the horizontal scroll position of the header and the footer with
   * the horizontal scroll position of the grid. Usually, this will be called automatically
   * when the grid scrolls. In some cases, such as a refresh caused by column changes
   * it will need to be called from elsewhere.
   * @internal
   */
  syncScrollingPartners(addCls = true) {
    const subGrid = this,
      { grid } = subGrid,
      scrollLeft = subGrid.scrollable.x;

    if (!subGrid.scrolling && addCls) {
      subGrid.scrolling = true;
    }

    grid.trigger('horizontalScroll', { subGrid, grid, scrollLeft });
  }

  /**
   * Scrolls a column into view (if it is not already). Called by Grid#scrollColumnIntoView, use it instead to not
   * have to care about which SubGrid contains a column.
   * @param {Grid.column.Column|String|Number} column Column name (data) or column index or actual column object.
   * @param {Object} [options] How to scroll.
   * @param {String} [options.block] How far to scroll the element: `start/end/center/nearest`.
   * @param {Number} [options.edgeOffset] edgeOffset A margin around the element or rectangle to bring into view.
   * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
   * or the number of milliseconds to animate over, or an animation config object.
   * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
   * @param {String} [options.animate.easing] The name of an easing function.
   * @param {Boolean} [options.highlight] Set to `true` to highlight the element when it is in view.
   * @param {Boolean} [options.focus] Set to `true` to focus the element when it is in view.
   * @returns {Promise} If the column exists, a promise which is resolved when the column header element has been scrolled into view.
   */
  scrollColumnIntoView(column, options) {
    const me = this,
      scroller = me.header.scrollable;

    // Allow column,column id,or column index to be passed
    column =
      column instanceof Column
        ? column
        : me.columns.get(column) || me.columns.getById(column) || me.columns.getAt(column);

    if (column) {
      // Get the current column header element.
      const columnHeaderElement = me.header.getHeader(column.id);

      if (columnHeaderElement) {
        return scroller.scrollIntoView(Rectangle.from(columnHeaderElement, null, true), options);
      }
    }
  }

  //endregion

  //region Rows

  /**
   * Creates elements for the new rows when RowManager has determined that more rows are needed
   * @private
   */
  onAddRow({ rows }) {
    const me = this,
      html = me.rowTemplate(),
      visibleColumns = me.columns.bottomColumns.filter((col) => !col.hidden),
      frag = document.createDocumentFragment();

    rows.forEach((row) => {
      const rowElement = DomHelper.createElementFromTemplate(html);

      frag.appendChild(rowElement);
      row.addElement(me.region, rowElement);

      // TODO: Stamp the correct width into the cells on creation
      me.fixCellWidths(rowElement, visibleColumns);
    });

    me.fixRowWidthsInSafariEdge();

    // Put the row elements into the SubGrid en masse.
    // If 2nd param is null, insertBefore appends.
    me.element.insertBefore(frag, me.insertRowsBefore);
  }

  /**
   * Get all row elements for this SubGrid.
   * @returns {HTMLElement[]} Row elements
   * @readonly
   */
  get rowElements() {
    return this.fromCache('.b-grid-row', true);
  }

  /**
   * Removes all row elements from the subgrids body and empties cache
   * @private
   */
  clearRows() {
    this.emptyCache();
    const all = this.element.querySelectorAll('.b-grid-row'),
      range = document.createRange();

    if (all.length) {
      range.setStartBefore(all[0]);
      range.setEndAfter(all[all.length - 1]);
      range.deleteContents();
    }
  }

  // only called when RowManager.rowScrollMode = 'dom', which is not intended to be used
  addNewRowElement() {
    const rowElement = DomHelper.append(this.element, this.rowTemplate());

    this.fixCellWidths(rowElement);

    return rowElement;
  }

  get emptyText() {
    return this._emptyText;
  }

  set emptyText(text) {
    this._emptyText = text;

    this.element.dataset.emptyText = text;
  }

  //endregion

  // region Expand/collapse

  // All usages are commented, uncomment when this is resolved: https://app.assembla.com/spaces/bryntum/tickets/5472
  toggleTransitionClasses(doRemove = false) {
    const me = this,
      grid = me.grid,
      nextRegion = grid.getSubGrid(grid.getNextRegion(me.region)),
      splitter = grid.resolveSplitter(nextRegion);

    nextRegion.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');
    nextRegion.header.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');

    me.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');
    me.header.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');

    splitter.classList[doRemove ? 'remove' : 'add']('b-grid-splitter-animate');
  }

  /**
   * Get/set collapsed state
   * @property {Boolean}
   */
  get collapsed() {
    return this._collapsed;
  }

  set collapsed(collapsed) {
    if (this.isConfiguring) {
      this._collapsed = collapsed;
    } else {
      if (collapsed) {
        this.collapse();
      } else {
        this.expand();
      }
    }
  }

  /**
   * Collapses subgrid. If collapsing subgrid is the only one expanded, next subgrid to the right (or previous) will
   * be expanded.
   *
   * @example
   * let locked = grid.getSubGrid('locked');
   * locked.collapse().then(() => {
   *     console.log(locked.collapsed); // Logs 'True'
   * });
   *
   * let normal = grid.getSubGrid('normal');
   * normal.collapse().then(() => {
   *     console.log(locked.collapsed); // Logs 'False'
   *     console.log(normal.collapsed); // Logs 'True'
   * });
   *
   * @async
   * @returns {Promise} A Promise which resolves when this SubGrid is fully collapsed.
   */
  async collapse() {
    const me = this,
      collapsedWidth = me.collapsedStateWidth,
      grid = me.grid,
      nextRegion = grid.getSubGrid(grid.getNextRegion(me.region));

    // Count all expanded regions. Grid must have always have at least one expanded
    let expandedRegions = 0;

    grid.eachSubGrid((subGrid) => {
      subGrid !== me && !subGrid._collapsed && ++expandedRegions;
    });

    // Current region is the only one expanded, expand next region
    if (expandedRegions === 0) {
      // expandPromise = nextRegion.expand();
      await nextRegion.expand();
    }

    return new Promise((resolve) => {
      if (!me._beforeCollapseState) {
        me._beforeCollapseState = {};

        let widthChanged = false;

        // If current width matches width expected after collapse (probably very narrow region plus wide collapse
        // placeholder) resize event will not be fired. In such case we want to trigger callback immediately
        if (me.width !== collapsedWidth) {
          widthChanged = true;

          // Toggle transition classes here, we will actually change width below
          // me.toggleTransitionClasses();

          // afterinternalresize event is buffered, it will be fired only once after animation is finished
          // and element size is final
          me.on({
            afterinternalresize: () => {
              // me.toggleTransitionClasses(true);
              resolve(me);
            },
            thisObj: me,
            once: true
          });
        }

        // When trying to collapse region we need its partner to occupy free space. Considering multiple
        // regions, several cases are possible:
        // 1) Both left and right regions have fixed width
        // 2) Left region has fixed width, right region is flexed
        // 3) Left region is flexed, right region has fixed width
        // 4) Both regions are flexed
        //
        // To collapse flexed region we need to remove flex style, remember it somehow and set fixed width.
        // If another region is flexed, it will fill the space. If it has fixed width, we need to increase
        // its width by collapsing region width. Same logic should be appliead to headers.
        //
        // Save region width first
        me._beforeCollapseState.width = me.width;
        // Save left coordinate too, to restore splitter position
        me._beforeCollapseState.splitterLeft = grid.resolveSplitter(me).offsetLeft;

        // Next region is not flexed, need to make it fill the space
        if (nextRegion.element.style.flex === '') {
          me._beforeCollapseState.nextRegionWidth = nextRegion.width;
          nextRegion.width += me._beforeCollapseState.width;
        }

        // Current region is flexed, store style to restore on expand
        if (me.element.style.flex !== '') {
          me._beforeCollapseState.style = me.element.style.flex;
          // remove flex state to reduce width later
          me.header.element.style.flex = me.element.style.flex = '';
        }

        me.element.classList.add('b-grid-subgrid-collapsed');
        me._collapsed = true;

        if (!widthChanged) {
          resolve(false);
        } else {
          // resize, will trigger afterinternalresize above
          me.width = collapsedWidth;
          // Since grid width is animated, we should animate splitter position too . Coordinate is not precise
          // but it will be fixed after collapse is done
          grid.resolveSplitter(me).style.left = me.element.offsetLeft;
        }
      }
    }).then((value) => {
      if (value !== false) {
        me.grid.trigger('subGridCollapse', me);
      }
    });
  }

  /**
   * Expands subgrid.
   *
   * @example
   * grid.getSubGrid('locked').expand().then(() => console.log('locked grid expanded'));
   *
   * @async
   * @returns {Promise} A Promise which resolves when this SubGrid is fully expanded.
   */
  async expand() {
    const me = this,
      grid = me.grid,
      nextRegion = grid.getSubGrid(grid.getNextRegion(me.region));

    return new Promise((resolve) => {
      if (me._beforeCollapseState != null) {
        // If current width matches width expected after expand resize event will not be fired. In such case
        // we want to trigger callback immediately
        let widthChanged = false;

        // See similar clause in collapse method above
        if (me.width !== me._beforeCollapseState.width) {
          widthChanged = true;

          // Toggle transition classes here, we will actually change width below
          // me.toggleTransitionClasses();

          me.on({
            afterinternalresize: () => {
              // me.toggleTransitionClasses(true);

              // Delay the resolve to avoid "ResizeObserver loop limit exceeded" errors
              // collapsing the only expanded region and it has to expand its nextRegion
              // before it can collapse.
              setTimeout(() => resolve(me), 10);
            },
            thisObj: me,
            once: true
          });
        }

        // previous region is not flexed, reduce its width as it was increased in collapse
        if (nextRegion.element.style.flex === '') {
          nextRegion.width = me._beforeCollapseState.nextRegionWidth;
        }

        me.element.classList.remove('b-grid-subgrid-collapsed');
        me._collapsed = false;

        // Always restore width, restoring flex wont trigger resize otherwise
        me.width = me._beforeCollapseState.width;

        // This region used to be flex, lets restore it
        if (me._beforeCollapseState.style) {
          me.header.element.style.flex = me.element.style.flex = me._beforeCollapseState.style;
          // set width to be empty, we want styles to be consistent and clean
          me.header.element.style.width = me.element.style.width = '';
          me._width = null;
        }

        // Since grid width is animated, we should animate splitter position too . Coordinate is not precise
        // but it will be fixed after collapse is done
        grid.resolveSplitter(me).style.left = `${me._beforeCollapseState.splitterLeft}px`;

        me.element.classList.remove('b-grid-subgrid-collapsed');
        me._collapsed = false;

        if (!widthChanged) {
          resolve(false);
        }

        delete me._beforeCollapseState;
      }
    }).then((value) => {
      if (value !== false) {
        me.grid.trigger('subGridExpand', me);
      }
    });
  }

  //endregion
}
SubGrid._$name = 'SubGrid';

/**
 * @module Grid/view/mixin/GridSubGrids
 */

/**
 * Mixin for grid that handles SubGrids. Each SubGrid is scrollable horizontally separately from the other SubGrids.
 * Having two SubGrids allows you to achieve what is usually called locked or frozen columns.
 *
 * By default a Grid has two SubGrids, one named 'locked' and one 'normal'. The `locked` region has fixed width, while
 * the `normal` region grows to fill all available width (flex).
 *
 * Which SubGrid a column belongs to is
 * determined using its {@link Grid.column.Column#config-region} config. For example to put a column into the locked
 * region, specify `{ region: 'locked' }`. For convenience, a column can be put in the locked region using
 * `{ locked: true }`.
 *
 * @example
 * { data: 'name', text: 'Name', locked: true }
 * { data: 'age', text: 'Age', region: 'locked' }
 *
 * @demo features
 * @mixin
 */
var GridSubGrids = (Target) =>
  class GridSubGrids extends (Target || Base) {
    //region Init

    /**
     * Initializes subGrids from subGrid configs in config.subGridConfigs. Regions specified on columns but not The default config.subGridConfigs is:
     * { normal: { flex: 1 } }
     * @private
     * @category SubGrid
     */
    initSubGrids() {
      const me = this,
        oldRegions = me._regions,
        usedRegions = new Set();

      let first = true,
        hasCalculatedWidth,
        subGridConfig,
        subGridColumns;

      // TODO: move into subgrid or columnmanager
      for (const column of me.columns.records) {
        if (column.region && !me.subGridConfigs[column.region]) {
          me.subGridConfigs[column.region] = {};
        }
        usedRegions.add(column.region);
      }

      // If "reconfiguring" columns, we are going to create new subgrids so destroy any existing
      if (oldRegions) {
        oldRegions.forEach((region) => me.subGrids[region].destroy());
      }

      /**
       * An object containing the {@link Grid.view.SubGrid} region instances, indexed by subGrid id ('locked', normal'...)
       * @property {Object} subGrids
       * @readonly
       */
      me.subGrids = {};

      me._regions = Array.from(usedRegions);
      me._regions.sort();

      // Implementer has provided configs for other subGrids but not normal, put defaults in place
      if (me.subGridConfigs.normal && Object.keys(me.subGridConfigs.normal).length === 0) {
        me.subGridConfigs.normal = Grid.defaultConfig.subGridConfigs.normal;
      }

      for (const region of me._regions) {
        subGridColumns = me.columns.makeChained((column) => column.childLevel === 0 && column.region === region, [
          'region'
        ]);
        subGridConfig = ObjectHelper.assign({}, me.subGridConfigs[region], {
          owner: me,
          grid: me,
          store: me.store,
          rowManager: me.rowManager,
          region: region,
          headerClass: me.subGridConfigs[region].headerClass || me.headerClass,
          columns: subGridColumns,
          hideHeaders: me.hideHeaders
        });

        hasCalculatedWidth = false;

        if (!subGridConfig.flex && !subGridConfig.width) {
          subGridConfig.width = subGridColumns.totalFixedWidth;
          hasCalculatedWidth = true;
        }

        me.subGrids[region] = new SubGrid(subGridConfig);

        // Must be set after creation, otherwise reset in SubGrid#set width
        me.subGrids[region].hasCalculatedWidth = hasCalculatedWidth;

        if (first) {
          // Have already done lookups for this in a couple of places, might as well store it...
          me.subGrids[region].isFirstRegion = true;
          first = false;
        }
      }
    }

    /**
     * Destroy all SubGrids.
     * @private
     */
    doDestroy() {
      this.callEachSubGrid('destroy');
      super.doDestroy();
    }

    //endregion

    //region Iteration & calling

    /**
     * Iterate over all subGrids, calling the supplied function for each.
     * @param {Function} fn Function to call for each instance
     * @param {Object} thisObj `this` reference to call the function in, defaults to the subGrid itself
     * @category SubGrid
     * @internal
     */
    eachSubGrid(fn, thisObj = null) {
      const me = this;
      //for (let subGrid of Object.values(this.subGrids)) {
      me.regions.forEach((region, i) => {
        const subGrid = me.subGrids[region];
        fn.call(thisObj || subGrid, subGrid, i++);
      });
    }

    eachWidget(fn, deep = true) {
      const me = this;
      me.regions.forEach((region) => {
        const widget = me.subGrids[region];
        if (fn(widget) === false) {
          return;
        }
        if (deep && widget.eachWidget) {
          widget.eachWidget(fn, deep);
        }
      });
    }

    /**
     * Call a function by name for all subGrids (that have the function).
     * @param {String} fnName Name of function to call, uses the subGrid itself as `this` reference
     * @param params Parameters to call the function with
     * @return {*} Return value from first SubGrid is returned
     * @category SubGrid
     * @internal
     */
    callEachSubGrid(fnName, ...params) {
      // TODO: make object { normal: retval, locked: retval } to return? or store. revisit when needed
      let me = this,
        returnValue = null;
      //Object.values(this.subGrids).forEach((subGrid, i) => {
      me.regions.forEach((region, i) => {
        const subGrid = me.subGrids[region];
        if (subGrid[fnName]) {
          const partialReturnValue = subGrid[fnName](...params);
          if (i === 0) returnValue = partialReturnValue;
        }
      });
      return returnValue;
    }

    //endregion

    //region Getters

    /**
     * This method should return names of the two last regions in the grid as they are visible in the UI. In case
     * `regions` property cannot be trusted, use different approach. Used by SubGrid and RegionResize to figure out
     * which region should collapse or expand.
     * @returns {String[]}
     * @private
     * @category SubGrid
     */
    getLastRegions() {
      const result = this.regions.slice(-2);
      // ALWAYS return array of length 2 in order to avoid extra conditions. Normally should not be called with 1 region
      return result.length === 2 ? result : [result[0], result[0]];
    }

    /**
     * This method should return right neighbour for passed region, or left neighbour in case last visible region is passed.
     * This method is used to decide which subgrid should take space of the collapsed one.
     * @param {String} region
     * @returns {String}
     * @private
     * @category SubGrid
     */
    getNextRegion(region) {
      const regions = this.regions;

      // return next region or next to last
      return regions[regions.indexOf(region) + 1] || regions[regions.length - 2];
    }

    getPreviousRegion(region) {
      return this.regions[this.regions.indexOf(region) - 1];
    }

    /**
     * Returns the subGrid for the specified region.
     * @param {String} region Region, eg. locked or normal (per default)
     * @returns {Grid.view.SubGrid} A subGrid
     * @category SubGrid
     */
    getSubGrid(region) {
      return this.subGrids[region];
    }

    /**
     * Get the SubGrid that contains specified column
     * @param {String|Grid.column.Column} column Column "name" or column object
     * @returns {Grid.view.SubGrid}
     * @category SubGrid
     */
    getSubGridFromColumn(column) {
      column = column instanceof Column ? column : this.columns.get(column) || this.columns.getById(column);

      return this.getSubGrid(column.region);
    }

    get regions() {
      if (!this._regions) {
        this.initSubGrids();
      }
      return this._regions;
    }

    //endregion

    //region Resize

    //endregion

    onSubGridCollapse(subGrid) {
      const splitterEl = this.resolveSplitter(subGrid);

      splitterEl.classList.add('b-grid-splitter-collapsed');
      // 5 in next 2 lines is the default splitter width as defined in SASS.
      splitterEl.style.width = `${subGrid.collapsedStateWidth + subGrid.splitterWidth}px`;
      splitterEl.style.left = `${Math.max(subGrid.element.offsetLeft - subGrid.splitterWidth, 0)}px`;
    }

    onSubGridExpand(subGrid) {
      const splitterEl = this.resolveSplitter(subGrid);

      splitterEl.classList.remove('b-grid-splitter-collapsed');
      splitterEl.style.width = '';
    }

    /**
     * Returns splitter element for subgrid
     * @param {Grid.view.SubGrid|String} subGrid
     * @returns {HTMLElement}
     * @private
     * @category SubGrid
     */
    resolveSplitter(subGrid) {
      const me = this,
        regions = me.getLastRegions();

      let region = subGrid instanceof SubGrid ? subGrid.region : subGrid;

      if (regions[1] === region) {
        region = regions[0];
      }

      return this.subGrids[region].splitterElement;
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

//region Import

//endregion

/**
 * @module Grid/view/Grid
 */

const resolvedPromise = new Promise((resolve) => resolve()),
  defaultScrollOptions$2 = {
    block: 'nearest',
    inline: 'nearest'
  };

/**
 * The Grid component is a very powerful and performant UI component that shows tabular data (or tree data using the {@link Grid.view.TreeGrid}).
 *
 * <h2>Intro</h2>
 * The Grid widget has a wide range of features and a large API to allow users to work with data efficiently in the browser. The two
 * most important configs are {@link #config-store} and {@link #config-columns}. With the store config, you decide which data to load into the grid.
 * You can work with both in-memory arrays or load data using ajax. See the {@link Common.data.Store} class to learn more about loading data into stores.
 *
 * The columns config accepts an array of {@link Grid.column.Column Column} descriptors defining which fields that will be displayed in the grid.
 * The {@link Grid.column.Column#config-field} property in the column descriptor maps to a field in your dataset. The simplest grid configured with inline data and two columns would
 * look like this:
 *
 *      let grid = new Grid({
 *          appendTo : document.body,
 *
 *          columns: [
 *              { field: 'name', text: 'Name' },
 *              { field: 'job', text: 'Job', renderer: ({value}) => value ? value : 'Unemployed' }
 *          ],
 *
 *          data: [
 *              { name: 'Bill', job: 'Retired' },
 *              { name: 'Elon', job: 'Visionary' },
 *              { name: 'Me' }
 *          ]
 *      });
 *
 * {@inlineexample grid/Grid.js}
 * <h2>Features</h2>
 * To avoid the Grid core being bloated, its main features are implemented in separate ´feature´ classes. These can be turned on and off based
 * on your requirements. To configure (or disable) a feature, use the {@link #config-features} object to provide your desired configuration for the features
 * you want to use. Each feature has an ´id´ that you use as a key in the features object:
 *
 *      let grid = new Grid({
 *          appendTo : document.body,
 *
 *          features : {
 *              cellEdit     : false,
 *              regionResize : true,
 *              cellTooltip  : {
 *                  tooltipRenderer : (data) => {
 *                  }
 *              },
 *              ...
 *          }
 *      });
 *
 * {@region Column configuration options}
 * A grid contains a number of columns that control how your data is rendered. The simplest option is to simply point a Column to a field in your dataset, or define a custom {@link Grid.column.Column#config-renderer}.
 * The renderer function receives one object parameter containing rendering data for the current cell being rendered.
 *
 *      let grid = new Grid({
 *          appendTo : document.body,
 *
 *          columns: [
 *              {
 *                  field: 'task',
 *                  text: 'Task',
 *                  renderer: (renderData) => {
 *                      const record = renderData.record;
 *
 *                      if (record.percentDone === 100) {
 *                          renderData.cellElement.classList.add('taskDone');
 *                          renderData.cellElement.style.background = 'green';
 *                      }
 *
 *                      return renderData.value;
 *                  }
 *              }
 *          ]
 *      });
 *
 * {@endregion}
 * {@region Grid sections (aka "locked" or "frozen" columns)}
 * The grid can be divided horizontally into individually scrollable sections. This is great if you have lots of columns that
 * don't fit the available width of the screen. To enable this feature, simply mark the columns you want to `lock`.
 * Locked columns are then displayed in their own section to the left of the other columns:
 *
 *      let grid = new Grid({
 *          appendTo : document.body,
 *          width    : 500,
 *          subGridConfigs : {
 *              // set a fixed locked section width if desired
 *              locked : { width: 300 }
 *          },
 *          columns : [
 *              { field : 'name', text : 'Name', width : 200, locked : true },
 *              { field : 'firstName', text : 'First name', width : 100, locked : true },
 *              { field : 'surName', text : 'Last name', width : 100, locked : true },
 *              { field : 'city', text : 'City', width : 100 },
 *              { type : 'number', field : 'age', text : 'Age', width : 200 },
 *              { field : 'food', text : 'Food', width : 200 }
 *          ]
 *      });
 *
 * {@inlineexample grid/LockedGrid.js}
 * You can also move columns between sections by using drag and drop, or use the built-in header context menu. If you want to be able to resize the
 * locked grid section, enable the {@link Grid.feature.RegionResize regionResize} feature.
 * {@endregion}
 * {@region Filtering}
 * One important requirement of a good Grid component is the ability to filter large datasets to quickly find what you're looking for. To
 * enable filtering (through the context menu), add the {@link Grid.feature.Filter filter} feature:
 *
 *      let grid = new Grid({
 *          features: {
 *              filter: true
 *          }
 *      });
 *
 * Or activate a default filter at initial rendering:
 *
 *      let grid = new Grid({
 *          features: {
 *              filter: { property : 'city', value : 'New York' }
 *          }
 *      });
 *
 * {@inlineexample feature/Filter.js}
 * {@endregion}
 * {@region Tooltips}
 * If you have a data models with many fields, and you want to show
 * additional data when hovering over a cell, use the {@link Grid.feature.CellTooltip cellTooltip} feature. To show a tooltip for all cells:
 *
 *      let grid = new Grid({
 *          features: {
 *              cellTooltip: ({value}) => value
 *          }
 *      });
 *
 * {@inlineexample feature/CellTooltip.js}
 * {@endregion}
 * {@region Inline Editing (default <strong>on</strong>)}
 * To enable inline cell editing in the grid, simply add the {@link Grid.feature.CellEdit cellEdit} feature:
 *
 *      let grid = new Grid({
 *          appendTo : document.body,
 *
 *          features : {
 *              cellEdit : true
 *          },
 *          columns: [
 *              {
 *                  field: 'task',
 *                  text: 'Task'
 *              }
 *          ]
 *      });
 *
 * {@inlineexample feature/CellEdit.js}
 * {@endregion}
 * {@region Context Menu}
 * Use the {@link Grid.feature.ContextMenu contextMenu} feature if you want your users to be able to interact with the data through the context menu:
 *
 *      let grid = new Grid({
 *          features: {
 *              contextMenu: {
 *                  headerItems: [
 *                      {
 *                          text: 'Show info',
 *                          icon: 'fa fa-info-circle',
 *                          weight: 200,
 *                          onItem : ({ item }) => console.log(item.text)
 *                      }
 *                  ],
 *
 *              cellItems: [
 *                  { text: 'Show options', icon: 'fa fa-gear', weight: 200 }
 *              ]
 *          }
 *      }
 *
 * {@inlineexample feature/ContextMenu.js}
 * {@endregion}
 * {@region Grouping}
 * To group rows by a field in your dataset, use the {@link Grid.feature.Group group} feature.
 * {@inlineexample feature/Group.js}
 * {@endregion}
 * {@region Searching}
 * When working with lots of data, a quick alternative to filtering is the {@link Grid.feature.Search search} feature. It highlights
 * matching values in the grid as you type.
 * {@inlineexample feature/Search.js}
 * {@endregion}
 * {@region Loading and saving data}
 * The grid keeps all its data in a {@link Common.data.Store}, which is essentially an Array of {@link Common.data.Model Model} items.
 * You define your own Model representing your data entities and use the Model API to get and set values.
 *
 *      class Person extends Model {}
 *
 *      let person = new Person({
 *          name: 'Steve',
 *          age: 38
 *      });
 *
 *      person.name = 'Linda'; // person object is now `dirty`
 *
 *      let store = new Store({
 *          data : [
 *              { name : 'Don', age : 40 }
 *          ]
 *      });
 *
 *      store.add(person);
 *
 *      console.log(store.count()); // === 2
 *
 *      store.remove(person); // Remove from store
 *
 * When you update a record in a store, it's considered dirty, until you call {@link Common.data.mixin.StoreCRUD#function-commit commit} on the containing Store. You can also configure your Store to commit automatically (like Google docs).
 * If you use an AjaxStore, it will send changes to your server when commit is called.
 * Any changes you make to the Store or its records are immediately reflected in the Grid, so there is no need to tell it to refresh manually.
 *
 * To learn more about loading and saving data, please refer to [this guide](#guides/data/displayingdata.md).
 * {@endregion}
 * {@region Default configs}
 * There is a myriad of configs and features available for Grid, some of them on by default and some of them requiring
 * extra configuration. The code below tries to illustrate the major things that are used by default:
 *
 * ```javascript
 * let grid = new Grid({
 *    // The following features are enabled by default:
 *    features : {
 *        cellEdit      : true,
 *        columnPicker  : true,
 *        columnReorder : true,
 *        columnResize  : true,
 *        contextMenu   : true,
 *        group         : true,
 *        sort          : true
 *    },
 *
 *    animateRemovingRows       : true,  // Rows will slide out on removal
 *    autoHeight                : false, // Grid needs to have a height supplied through CSS (strongly recommended) or by specifying `height`
 *    columnLines               : true,  // Themes might override it to hide lines anyway
 *    emptyText                 : 'No rows to display',
 *    enableTextSelection       : false, // Not allowed to select text in cells by default,
 *    fillLastColumn            : true,  // By default the last column is stretched to fill the grid
 *    fullRowRefresh            : true,  // Refreshes entire row when a cell value changes
 *    loadMask                  : 'Loading...',
 *    resizeToFitIncludesHeader : true,  // Also measure header when auto resizing columns
 *    responsiveLevels : {
 *      small : 400,
 *      medium : 600,
 *      large : '*'
 *    },
 *    rowHeight                 : null,  // Determined using CSS, it will measure rowHeight
 *    showDirty                 : false, // No indicator for changed cells
 *    showRemoveInContextMenu   : true   // Context menu has "Remove row" item
 * });
 * ```
 * {@endregion}
 * {@region Performance}
 * In general the Grid widget has very good performance and you can try loading any amount of data in the <a target="_blank" href="../examples/bigdataset">bigdataset</a> demo.
 * The overall rendering performance is naturally affected by many other things than
 * the data volume. Other important factors that can impact performance: number of columns, complex cell renderers, locked columns, the number of features enabled
 * and of course the browser (Chrome fastest, IE slowest).
 * {@endregion}
 *
 * @extends Common/widget/Widget
 * @mixes Common/mixin/Events
 * @mixes Common/mixin/Pluggable
 * @mixes Common/mixin/State
 * @mixes Grid/view/mixin/GridElementEvents
 * @mixes Grid/view/mixin/GridFeatures
 * @mixes Grid/view/mixin/GridResponsive
 * @mixes Grid/view/mixin/GridSelection
 * @mixes Grid/view/mixin/GridState
 * @mixes Grid/view/mixin/GridSubGrids
 *
 * @classType grid
 */
class Grid extends base(Widget).mixes(
  Pluggable,
  State,
  GridElementEvents,
  GridFeatures,
  GridNavigation,
  GridResponsive,
  GridSelection,
  GridState,
  GridSubGrids
) {
  //region Config

  // Default settings, applied in grids constructor.
  static get defaultConfig() {
    return {
      /**
       * Row height in pixels. When set to null, an empty row will be measured and its height will be used as
       * default row height, enabling it to be controlled using CSS
       * @config {Number}
       * @default null
       * @category Common
       */
      rowHeight: null,

      // used if no rowHeight specified and none found in CSS. not public since our themes have row height
      // specified and this is more of an internal failsafe
      defaultRowHeight: 45,

      /**
       * Text to display when there is no data to display in the grid
       * @config {String}
       * @default
       * @category Common
       */
      emptyText: this.L('noRows'),

      /**
       * Refresh entire row when a cells value changes (true) or only the cell (false).
       * @config {Boolean}
       * @default
       * @category Misc
       */
      fullRowRefresh: true,

      /**
       * Read only or not
       * @config {Boolean}
       * @default false
       * @category Common
       */
      readOnly: null,

      /**
       * True to not create any grid column headers
       * @config {Boolean}
       * @default false
       * @category Misc
       */
      hideHeaders: null,

      /**
       * Show "Remove row" item in context menu (if enabled and grid not read only)
       * @config {Boolean}
       * @default
       * @category Misc
       */
      showRemoveRowInContextMenu: true,

      /**
       * Automatically set grids height to fit all rows (no scrolling in the grid). In general you should avoid
       * using `autoHeight: true`, since it will bypass Grids virtual rendering and render all rows at once, which
       * in a larger grid is really bad for performance.
       * @config {Boolean}
       * @default false
       * @category Layout
       */
      autoHeight: null,

      /**
       * Store that holds records to display in the grid, or a store config object.
       * A store will be created if none is specified
       * @config {Common.data.Store/Object}
       * @category Common
       */
      store: {},

      /**
       * Data to set in grids store (a Store will be created if none is specified)
       * @config {Object[]}
       * @category Common
       */
      data: null,

      /**
       * Column definitions for the grid, will be used to create Column instances that are added to a ColumnStore:
       *
       * ```
       * new Grid({
       *   columns : [
       *     { text : 'Alias', field : 'alias' },
       *     { text : 'Superpower', field : 'power' }
       *   ]
       * });
       * ```
       *
       * Also accepts a store config object:
       *
       * ```
       * new Grid({
       *   columns : {
       *     data : [
       *       { text : 'Alias', field : 'alias' },
       *       { text : 'Superpower', field : 'power' }
       *     ],
       *     listeners : {
       *       update() {
       *         // Some update happened
       *       }
       *     }
       *   }
       * });
       * ```
       *
       * This store can be accessed using {@link #property-columns}:
       *
       * ```
       * grid.columns.add({ field : 'column', text : 'New column' });
       * ```
       * @config {Object[]|Object}
       * @category Common
       */
      columns: [],

      /**
       * Region to which columns are added when they have none specified
       * @config {String}
       * @default
       * @category Misc
       */
      defaultRegion: 'normal',

      /**
       * true to destroy the store when the grid is destroyed
       * @config {Boolean}
       * @default false
       * @category Misc
       */
      destroyStore: null,

      /**
       * Default selection settings
       * @config {Object}
       * @default
       * @category Selection
       */
      selectionMode: {
        row: true,
        cell: true,
        multiSelect: true,
        checkbox: false
      },

      /**
       * Set to true to allow text selection in the grid cells
       * @config {Boolean}
       * @default false
       * @category Selection
       */
      enableTextSelection: null,

      /**
       * A message to be shown when a store is performing a remote operation.
       * @config {String}
       * @default "Loading..."
       * @category Misc
       */
      loadMask: this.L('loadMask'),

      /**
       * Set to `false` to inhibit column lines
       * @config {Boolean}
       * @default
       * @category Misc
       */
      columnLines: true,

      /**
       * Set to `true` to stretch the last column in a grid with all fixed width columns
       * to fill extra available space if the grid's width is wider than the sum of all
       * configured column widths.
       * @config {Boolean}
       * @default
       * @category Layout
       */
      fillLastColumn: true,

      /**
       * Set to `false` to only measure cell contents when double clicking the edge between column headers.
       * @config {Boolean}
       * @default
       * @category Layout
       */
      resizeToFitIncludesHeader: true,

      /**
       * Set to `false` to prevent remove row animation and remove the delay related to that.
       * @config {Boolean}
       * @default
       * @category Misc
       */
      animateRemovingRows: !BrowserHelper.isIE11, // IE11 doesn't have reliable firing of transitionend

      /**
       * Set to `true` to not get a warning when using another base class than GridRowModel for your grid data. If
       * you do, and would like to use the full feature set of the grid then include the fields from GridRowModel
       * in your model definition.
       * @config {Boolean}
       * @default false
       * @category Misc
       */
      disableGridRowModelWarning: null,

      loadMaskErrorIcon: 'b-icon b-icon-warning',

      headerClass: Header,

      testPerformance: false,
      // TODO: break out as strategies
      positionMode: 'translate', // translate, translate3d, position
      rowScrollMode: 'move', // move, dom, all

      /**
       * Grid monitors window resize by default.
       * @config {Boolean}
       * @default true
       * @category Misc
       */
      monitorResize: true,

      /**
       * An object containing Feature configuration objects (or `true` if no configuration is required)
       * keyed by the Feature class name in all lowercase.
       * @config {Object}
       * @category Common
       * @typings any
       */
      features: true,

      /**
       * An object containing sub grid configuration objects keyed by a `region` property.
       * By default, grid has a 'locked' region (if configured with locked columns) and a 'normal' region.
       * The 'normal' region defaults to use `flex: 1`.
       *
       * This config can be used to reconfigure the "built in" sub grids or to define your own.
       * ```
       * // Redefining the "built in" regions
       * new Grid({
       *   subGridConfigs : {
       *     locked : { flex : 1 },
       *     normal : { width : 100 }
       *   }
       * });
       *
       * // Defining your own multi region sub grids
       * new Grid({
       *   subGridConfigs : {
       *     left   : { width : 100 },
       *     middle : { flex : 1 },
       *     right  : { width  : 100 }
       *   },
       *
       *   columns : {
       *     { field : 'manufacturer', text: 'Manufacturer', region : 'left' },
       *     { field : 'model', text: 'Model', region : 'middle' },
       *     { field : 'year', text: 'Year', region : 'middle' },
       *     { field : 'sales', text: 'Sales', region : 'right' }
       *   }
       * });
       * ```
       * @config {Object}
       * @category Misc
       */
      subGridConfigs: {
        normal: { flex: 1 }
      },

      /**
       * Configures whether the grid is scrollable in the `Y` axis. This is used to configure a {@link Grid.util.GridScroller}.
       * See the {@link #config-scrollerClass} config option.
       * @config {Object}
       * @category Scrolling
       */
      scrollable: {
        // Just Y for now until we implement a special grid.view.Scroller subclass
        // Which handles the X scrolling of subgrids.
        overflowY: true
      },

      /**
       * The class to instantiate to use as the {@link #config-scrollable}. Defaults to {@link Grid.util.GridScroller}.
       * @config {Common.helper.util.Scroller}
       * @internal
       * @category Scrolling
       */
      scrollerClass: GridScroller,

      /**
       * Configure as `true` to have the grid show a red "changed" tag in cells who's
       * field value has changed and not yet been committed.
       * @config {Boolean}
       * @default false
       * @category Misc
       */
      showDirty: null,

      loadMaskHideTimeout: 3000,

      refreshSuspended: 0

      // Grid requires a size to be considered visible
      //requireSize : true
    };
  }

  static getLKey() {
    return '%LICENSE%';
  }

  static get properties() {
    return {
      _selectedRecords: [],
      _verticalScrollHeight: 0,
      virtualScrollHeight: 0
    };
  }

  //endregion

  //region Init-destroy

  finishConfigure(config) {
    const me = this;

    super.finishConfigure(config);

    me.scrollManager = new ScrollManager({
      grid: me,
      // Horizontal scrolling might happen on different subgrids, but vertical is always on same element
      verticalElement: me.scrollable.element
    });

    // When locale is applied columns react and change, which triggers `change` event on columns store for each
    // changed column, and every change normally triggers rendering view. This overhead becomes noticeable with
    // larger amount of columns. So we set two listeners to locale events: prioritized listener to be executed first
    // and suspend renderContents method and unprioritized one to resume method and call it immediately.
    LocaleManagerSingelton.on({
      locale: 'onBeforeLocaleChange',
      prio: 1,
      thisObj: me
    });

    LocaleManagerSingelton.on({
      locale: 'onLocaleChange',
      prio: -1,
      thisObj: me
    });

    GlobalEvents.on({
      theme: 'onThemeChange',
      thisObj: me
    });

    // Access the property getter to ensure that all regions have been initialized
    me._thisIsAUsedExpression(me.regions);

    // Add the extra grid classes to the element
    me.setGridClassList(me.element.classList);
  }

  onBeforeLocaleChange() {
    this._suspendRenderContentsOnColumnsChanged = true;
  }

  onLocaleChange() {
    this._suspendRenderContentsOnColumnsChanged = false;
    this.rendered ? this.renderContents() : this.render();
  }

  finalizeInit() {
    super.finalizeInit();

    if (this.store.isLoading) {
      // Maybe show loadmask if store is already loading when grid is constructed
      this.onStoreLoadStart();
    }
  }

  /**
   * Cleanup
   * @private
   */
  doDestroy() {
    const me = this;

    me.storeDetacher && me.storeDetacher();

    for (let feature of Object.values(me.features)) {
      feature.destroy && feature.destroy();
    }

    if (me.columns) {
      me.columns = null;
    }

    if (me.store) {
      me.store = null;
    }

    super.doDestroy();
  }

  /**
   * Adds extra classes to the Grid element after it's been configured.
   * Also iterates through features, thus ensuring they have been initialized.
   * @private
   */
  setGridClassList(classList) {
    const me = this;

    classList.add(`b-grid-${me.positionMode}`);

    // TODO: enableTextSelection should be a setter, enabling toggling at any time
    if (!me.enableTextSelection) {
      classList.add('b-grid-notextselection');
    }

    if (me.autoHeight) {
      classList.add('b-autoheight');
    }

    if (me.readOnly) {
      classList.add('b-readonly');
    }

    if (me.fillLastColumn) {
      classList.add('b-fill-last-column');
    }

    if (me.showDirty) {
      classList.add('b-show-dirty');
    }

    for (let featureName in me.features) {
      let feature = me.features[featureName],
        featureClass;

      if (feature.constructor.hasOwnProperty('featureClass')) {
        featureClass = feature.constructor.featureClass;
      } else {
        featureClass = `b-${feature instanceof Base ? feature.$name : feature.constructor.name}`;
      }

      if (featureClass) {
        classList.add(featureClass.toLowerCase());
      }
    }
  }

  //endregion

  //region Functions & events injected by features

  // For documentation & typings purposes

  //region Feature events

  /**
   * *Only when the {@link Grid.feature.Tree} feature is enabled*.
   * <p>Fired before a record toggles its collapsed state.
   * @event beforeToggleNode
   * @param {Common.data.Model} record The record being toggled.
   * @param {Boolean} collapse `true` if the node is being collapsed.
   */
  /**
   * *Only when the {@link Grid.feature.Tree} feature is enabled*.
   * <p>Fired after a record has been collapsed.
   * @event collapseNode
   * @param {Common.data.Model} record The record which has been collapsed.
   */
  /**
   * *Only when the {@link Grid.feature.Tree} feature is enabled*.
   * <p>Fired after a record has been expanded.
   * @event expandNode
   * @param {Common.data.Model} record The record which has been expanded.
   */
  /**
   * *Only when the {@link Grid.feature.Tree} feature is enabled*.
   * <p>Fired after a record toggles its collapsed state.
   * @event toggleNode
   * @param {Common.data.Model} record The record being toggled.
   * @param {Boolean} collapse `true` if the node is being collapsed.
   */

  //endregion

  /**
   * Collapse all groups/parent nodes.
   *
   * *NOTE: Only available when the {@link Grid/feature/Group Group} or the {@link Grid/feature/Tree Tree} feature is enabled.*
   *
   * @function collapseAll
   * @category Feature shortcuts
   */

  /**
   * Expand all groups/parent nodes.
   *
   * *NOTE: Only available when the {@link Grid/feature/Group Group} or the {@link Grid/feature/Tree Tree} feature is enabled.*
   *
   * @function expandAll
   * @category Feature shortcuts
   */

  /**
   * Start editing specified cell. If no cellContext is given it starts with the first cell in the first row.
   *
   * *NOTE: Only available when the {@link Grid/feature/CellEdit CellEdit} feature is enabled.*
   *
   * @function startEditing
   * @param {Object} cellContext Cell specified in format { id: 'x', columnId/column/field: 'xxx' }. See {@link Grid.view.Grid#function-getCell} for details.
   * @returns {Boolean}
   * @category Feature shortcuts
   */

  /**
   * Collapse an expanded node or expand a collapsed. Optionally forcing a certain state.
   *
   * *NOTE: Only available when the {@link Grid/feature/Tree Tree} feature is enabled.*
   *
   * @function toggleCollapse
   * @param {String|Number|Common.data.Model} idOrRecord Record (the node itself) or id of a node to toggle
   * @param {Boolean} [collapse] Force collapse (true) or expand (false)
   * @param {Boolean} [skipRefresh] Set to true to not refresh rows (if calling in batch)
   * @returns {Promise}
   * @category Feature shortcuts
   */

  /**
   * Collapse a single node.
   *
   * *NOTE: Only available when the {@link Grid/feature/Tree Tree} feature is enabled.*
   *
   * @function collapse
   * @param {String|Number|Common.data.Model} idOrRecord Record (the node itself) or id of a node to collapse
   * @returns {Promise}
   * @category Feature shortcuts
   */

  /**
   * Expand a single node.
   *
   * *NOTE: Only available when the {@link Grid/feature/Tree Tree} feature is enabled.*
   *
   * @function expand
   * @param {String|Number|Common.data.Model} idOrRecord Record (the node itself) or id of a node to expand
   * @returns {Promise}
   * @category Feature shortcuts
   */

  /**
   * Expands parent nodes to make this node "visible".
   *
   * *NOTE: Only available when the {@link Grid/feature/Tree Tree} feature is enabled.*
   *
   * @function expandTo
   * @param {String|Number|Common.data.Model} idOrRecord Record (the node itself) or id of a node
   * @returns {Promise}
   * @category Feature shortcuts
   */

  //endregion

  //region Grid template & elements

  template(data) {
    const virtualScrollerStyle = BrowserHelper.isFirefox ? `height:${DomHelper.scrollBarWidth}px` : '';

    // SubGrids are set up first time regions are pulled in
    this._thisIsAUsedExpression(data.regions);

    return TemplateHelper.tpl`
            <div tabindex="-1">
                <header reference="headerContainer" class="b-grid-header-container ${
                  this.hideHeaders ? 'b-hidden' : ''
                }"></header>
                <div reference="bodyContainer" class="b-grid-body-container">
                    <div reference="verticalScroller" class="b-grid-vertical-scroller"></div>
                </div>
                <div reference="virtualScrollers" class="b-virtual-scrollers ${
                  DomHelper.scrollBarWidth ? '' : 'b-overlay-scrollbar'
                }" style="${virtualScrollerStyle}"></div>
                <footer reference="footerContainer" class="b-grid-footer-container b-hidden"></footer>
            </div>
        `;
  }

  get overflowElement() {
    return this.bodyContainer;
  }

  get focusElement() {
    return this.element;
  }

  //endregion

  //region Columns

  set columns(columns) {
    const me = this;

    if (me._columnStore) {
      if (columns) {
        // TODO: @johan: reconfiguring, ie changing whole column set should work.
        // That could mean a total recalculation of subGrids.
        // That's not possible right now, so
        //throw new Error('Cannot reconfigure column set');
        // me._columnStore.clear();
        me._columnStore.data = columns;
      } else {
        me._columnStore.destroy();
      }
    } else {
      // ColumnStore instance
      if (columns instanceof ColumnStore) {
        if (!columns.grid) {
          columns.grid = me;
        }
        me._columnStore = columns;
      }
      // Array of columns
      else if (Array.isArray(columns)) {
        me._columnStore = new ColumnStore({
          grid: me,
          data: columns
        });
      }
      // Store config object
      else if (columns) {
        me._columnStore = new ColumnStore(Object.assign({ grid: me }, columns));
      }

      // changes might be triggered when applying state, before grid is rendered
      // TODO: have this run a lighter weight, non-destructive response.
      // onColumnsChanged is a start, but lots of machinery is hooked to render.
      me._columnStore.on('change', me.onColumnsChanged, me);
      me._columnStore.on(columnResizeEvent(me.onColumnsResized, me));

      // Add touch class for touch devices
      if (BrowserHelper.isTouchDevice) {
        me.touch = true;

        // apply touchConfig for columns that defines it
        me._columnStore.forEach((column) => {
          const touchConfig = column.touchConfig;
          if (touchConfig) {
            column.applyState(touchConfig);
          }
        });
      }
    }
  }

  /**
   * Get the {@link Grid.data.ColumnStore ColumnStore} used by this Grid.
   *
   * @property {Grid.data.ColumnStore}
   * @category Common
   * @readonly
   */
  get columns() {
    return this._columnStore;
  }

  onColumnsChanged({ action, changes, record: column }) {
    const me = this;

    if (action === 'update') {
      // Just updating width is already handled in a minimal way.
      if ('width' in changes || 'minWidth' in changes || 'flex' in changes) {
        // Update any leaf columns that want to be repainted on size change
        if (me.rendered) {
          const region = column.region;

          me.columns.visibleColumns.forEach((col) => {
            if (col.region === region && col.repaintOnResize) {
              me.refreshColumn(col);
            }
          });
        }
        return;
      }

      // Column toggled, need to recheck if any visible column has flex
      if ('hidden' in changes) {
        const subGrid = me.getSubGridFromColumn(column.id);
        subGrid.header.fixHeaderWidths();
        if (subGrid.footer) {
          subGrid.footer.fixFooterWidths();
        }
        subGrid.updateHasFlex();
      }
    }

    // New columns set ("reconfiguring"), or moved to previously not available region
    if (action === 'dataset' || (changes && 'region' in changes && !me.regions.includes(changes.region.value))) {
      // Create required subgrids (removing existing)
      me.initSubGrids();
      // Render and jump start them
      me.eachSubGrid((subGrid) => {
        subGrid.render(me.verticalScroller);
        subGrid.initScroll();
      });
    }

    if (!me._suspendRenderContentsOnColumnsChanged) {
      me.renderContents();
    }
  }

  onColumnsResized({ changes, record: column }) {
    const me = this,
      setWidth = changes.width && column.flex == null,
      setMinWidth = changes.minWidth && column.flex == null,
      setFlex = changes.flex && column.width == null,
      domWidth = DomHelper.setLength(column.width),
      domMinWidth = DomHelper.setLength(column.minWidth),
      subGrid = me.getSubGridFromColumn(column.id);

    // Let header and footer fix their own widths
    subGrid.header.fixHeaderWidths();
    if (subGrid.footer) {
      subGrid.footer.fixFooterWidths();
    }
    subGrid.updateHasFlex();

    if (!me.cellEls || column !== me.lastColumnResized) {
      me.cellEls = DomHelper.children(me.element, `.b-grid-cell[data-column-id=${column.id}]`);
      me.lastColumnResized = column;
    }

    for (let cell of me.cellEls) {
      if (setWidth) {
        // https://app.assembla.com/spaces/bryntum/tickets/8041
        // Although header and footer elements must be sized
        // using flex-basis to avoid the busting out problem,
        // grid cells MUST be sized using width since rows are absolutely
        // positioned and will not cause the busting out problem,
        // and rows will not stretch to shrinkwrap the cells
        // unless they are widthed with width.
        cell.style.width = domWidth;
        cell.style.flex = '';

        // IE11 calculates flexbox container width based on min-width rather than actual width. When column
        // has width defined greater than minWidth, row may have incorrect width
        if (BrowserHelper.isIE11) {
          cell.style.minWidth = domWidth;
        }
      } else if (setMinWidth) {
        cell.style.minWidth = domMinWidth;
      } else if (setFlex) {
        cell.style.flex = column.flex;
        cell.style.width = '';
      } else {
        cell.style.flex = cell.style.width = cell.style.minWidth = '';
      }
    }

    // If we're being driven by the ColumnResizer, it will
    // call afterColumnsResized.
    if (!me.dragResizing) {
      me.afterColumnsResized();
    }
  }

  afterColumnsResized() {
    const me = this;

    me.refreshVirtualScrollbars();
    me.eachSubGrid((subGrid) => {
      if (!subGrid.collapsed) {
        subGrid.fixWidths();
        subGrid.fixRowWidthsInSafariEdge();
        subGrid.refreshFakeScroll();
      }
    });
    me.lastColumnResized = me.cellEls = null;
  }

  //endregion

  //region Rows

  /**
   * Get the Row that is currently displayed at top.
   * @member {Grid.row.Row} topRow
   * @readonly
   * @category Rows
   * @private
   */

  /**
   * Get the Row currently displayed furthest down.
   * @member {Grid.row.Row} bottomRow
   * @readonly
   * @category Rows
   * @private
   */

  /**
   * Get Row for specified record id.
   * @function getRowById
   * @param {Common.data.Model|String|Number} recordOrId Record id (or a record)
   * @returns {Grid.row.Row} Found Row or null if record not rendered
   * @category Rows
   * @private
   */

  /**
   * Returns top and bottom for rendered row or estimated coordinates for unrendered.
   * @function getRecordCoords
   * @param {Common.data.Model|string|Number} recordOrId Record or record id
   * @returns {Object} Record bounds with format { top, height, bottom }
   * @category Calculations
   * @private
   */

  /**
   * Get the Row at specified index. "Wraps" index if larger than available rows.
   * @function getRow
   * @param {Number} index
   * @returns {Grid.row.Row}
   * @category Rows
   * @private
   */

  /**
   * Get a Row for either a record, a record id or an HTMLElement
   * @function getRowFor
   * @param {HTMLElement|Common.data.Model|String|Number} recordOrId Record or record id or HTMLElement
   * @returns {Grid.row.Row} Found Row or null if record not rendered
   * @category Rows
   * @private
   */

  /**
   * Get a Row from an HTMLElement
   * @function getRowFromElement
   * @param {HTMLElement} element
   * @returns {Grid.row.Row} Found Row or null if record not rendered
   * @category Rows
   * @private
   */

  get rowManager() {
    const me = this;

    // Use row height from CSS if not specified in config. Did not want to turn this into a getter/setter for
    // rowHeight since RowManager will plug its implementation into Grid when created below, and after initial
    // configuration that is what should be used
    if (!me._isRowMeasured) {
      me.measureRowHeight();
    }

    // RowManager is a plugin, it is configured with its grid as its "client".
    // It uses client.store as its record source.

    return (
      me._rowManager ||
      (me._rowManager = new RowManager({
        grid: me,
        rowHeight: me.rowHeight,
        rowScrollMode: me.rowScrollMode || 'move',
        autoHeight: me.autoHeight,
        listeners: {
          changetotalheight: me.onRowManagerChangeTotalHeight,
          requestscrollchange: me.onRowManagerRequestScrollChange,
          thisObj: me
        }
      }))
    );
  }

  showEmptyText() {
    this.bodyContainer &&
      this.bodyContainer.classList[this.rowManager.rowCount || this.store.isLoading ? 'remove' : 'add']('b-grid-empty');
  }

  //endregion

  //region Store

  /**
   * Hooks up data store listeners
   * @private
   * @category Store
   */
  bindStore(store) {
    const me = this;

    me.storeDetacher = store.on(
      {
        refresh: me.onStoreDataChange,
        update: me.onStoreUpdateRecord,
        add: me.onStoreAdd,
        remove: me.onStoreRemove,
        move: me.onStoreMove,
        replace: me.onStoreReplace,
        removeall: me.onStoreRemoveAll,
        loadstart: me.onStoreLoadStart,
        afterrequest: me.onStoreAfterRequest,
        clearchanges: me.onStoreDataChange,
        exception: me.onStoreException
      },
      me
    );
  }

  get store() {
    return this._store;
  }

  /**
   * Get/set the store used by this Grid. The setter accepts Store or a configuration object for a store.
   * If the configuration contains a `readUrl`, an AjaxStore will be created.
   * @property {Common.data.Store|Object}
   * @category Common
   */
  set store(store) {
    const me = this,
      features = me.initialConfig.features;

    if (store !== me._store) {
      if (me.storeDetacher) {
        me.storeDetacher();
        me.storeDetacher = null;
      }

      if (store) {
        if (store instanceof Store);
        else {
          const storeCfg = {};
          if (me.data) {
            storeCfg.data = me.data;
          }
          if (features && features.tree) {
            storeCfg.tree = true;
          }
          // extend GridRowModel to not pollute it with custom fields (if we have multiple grids on page)
          if (!store.modelClass) {
            storeCfg.modelClass = class extends GridRowModel {};
          }

          store = new (store.readUrl ? AjaxStore : Store)(Object.assign(storeCfg, store));
        }

        me._store = store;

        me.bindStore(store);
      } else {
        if (me.destroyStore) {
          me._store.destroy();
        }
        me._store = null;
      }
    }
  }

  /**
   * Rerenders a cell if a record is updated in the store
   * @private
   * @category Store
   */
  onStoreUpdateRecord({ source: store, record, data }) {
    const me = this;

    if (me.forceFullRefresh) {
      // flagged to need full refresh (probably from using GroupSummary)
      me.rowManager.refresh();

      me.forceFullRefresh = false;
    } else {
      let row;
      // Search for old row if id was changed
      if (record.isFieldModified('id')) {
        row = me.getRowFor(record.meta.modified.id);
      }

      row = row || me.getRowFor(record);
      // not rendered, bail out
      if (!row) return;

      if (me.fullRowRefresh) {
        const index = store.indexOf(record);
        if (index !== -1) {
          row.render(index, record);
        }
      } else {
        Object.keys(data).forEach((field) => {
          let cell = row.getCell(field);
          if (cell) row.renderCell(cell, record);
        });
      }
    }
  }

  refreshFromRowOnStoreAdd(row, context) {
    const me = this,
      { rowManager } = me;

    rowManager.renderFromRow(row);
    rowManager.trigger('changeTotalHeight', { totalHeight: rowManager.totalHeight });

    // First record? Also update fake scrollers
    // TODO: Consider making empty grid scrollable to not have to do this
    if (me.store.count === 1) {
      me.callEachSubGrid('refreshFakeScroll');
    }
  }

  /**
   * Refreshes rows when data is added to the store
   * @private
   * @category Store
   */
  onStoreAdd({ source: store, records, index, oldIndex, isChild, oldParent, isMove }) {
    // Do not react if the content has not been rendered
    if (!this.rendered) {
      return;
    }

    // If it's the addition of a child to a collapsed zone, the UI does not change.
    if (isChild && !records[0].ancestorsExpanded(store)) {
      return;
    }

    this.rowManager.calculateRowCount(false, true, true);

    const me = this,
      { rowManager } = me,
      { topIndex, rows, rowCount } = rowManager,
      bottomIndex = rowManager.topIndex + rowManager.rowCount - 1,
      dataStart = index,
      dataEnd = index + records.length - 1,
      atEnd = bottomIndex >= store.count - records.length - 1;

    // When moving a node within a tree we might need the redraw to include its old parent and its children. Not worth
    // the complexity of trying to do a partial render for this, rerender all rows to be safe.
    // Moving records within a flat store is handled elsewhere, in onStoreMove
    // TODO: Moving within a tree should also trigger 'move' (https://app.assembla.com/spaces/bryntum/tickets/7270)
    if (oldParent || oldIndex > -1 || (isChild && isMove)) {
      rowManager.refresh();
    }
    // Added block starts in our visible block. Render from there downwards.
    else if (dataStart >= topIndex && dataStart < topIndex + rowCount) {
      me.refreshFromRowOnStoreAdd(rows[dataStart - topIndex], ...arguments);
    }
    // Added block ends in our visible block, render block
    else if (dataEnd >= topIndex && dataEnd < topIndex + rowCount) {
      rowManager.refresh();
    }
    // If added block is outside of the visible area, no visible change
    // but potentially a change in total dataset height.
    else {
      // If we are against the end of the dataset, and have appended records
      // ensure they are rendered below
      if (atEnd && index > bottomIndex) {
        rowManager.fillBelow(me.scrollable.y);
      }
      rowManager.trigger('changeTotalHeight', { totalHeight: rowManager.totalHeight });
    }
  }

  /**
   * Responds to exceptions signalled by the store
   * @private
   * @category Store
   */
  onStoreException(event) {
    const me = this;

    let message;

    switch (event.type) {
      case 'server':
        message = event.response.message || 'Unspecified failure';
        break;

      case 'exception':
        if (event.exceptionType === 'network') {
          message = 'Network error';
        } else {
          // Server sent something that couldn't be parsed
          message = (event.error && event.error.message) || 'Failed to parse server response';
        }
        break;

      default:
        message = event.response.status + ' - ' + event.response.statusText || 'Unknown error';
    }

    // eslint-disable-next-line
    const messageHTML = `<div class="b-grid-load-failure">
                <div class="b-grid-load-fail">${me.L('loadFailedMessage')}</div>
                <div class="b-grid-load-fail">${event.response.url ? event.response.url + ' responded with' : ''}</div>
                <div class="b-grid-load-fail">${message}</div>
            </div>`;

    if (me.activeMask) {
      me.activeMask.icon = me.loadMaskErrorIcon;
      me.activeMask.text = messageHTML;

      me.loadmaskHideTimer = me.setTimeout(() => {
        me.unmaskBody();
      }, me.loadMaskHideTimeout);
    }
  }

  /**
   * Refreshes rows when data is changed in the store
   * @private
   * @category Store
   */
  onStoreDataChange({ action, changes, source: store }) {
    // If the next mixin up the inheritance chain has an implementation, call it
    super.onStoreDataChange && super.onStoreDataChange(...arguments);

    const me = this,
      isGroupFieldChange = store.isGrouped && changes && me.groupers.find((grouper) => grouper.field in changes);

    // If it's new data, the old calculation is invalidated.
    if (action === 'dataset') {
      me.rowManager.averageRowHeight = null;
    }
    // No need to rerender if it's a change of the value of the group field which
    // will be responded to by StoreGroup
    if (me.rendered && !isGroupFieldChange) {
      // Return to top if setting new data or is filtering
      me.renderRows(null, action === 'dataset' || action === 'filter');
    }

    me.showEmptyText();
  }

  /**
   * Shows a load mask while the connected store is loading
   * @private
   * @category Store
   */
  onStoreLoadStart() {
    if (this.loadMask) {
      this.maskBody(this.loadMask);
    }
  }

  /**
   * Hides load mask after a load request ends either in success or failure
   * @private
   * @category Store
   */
  onStoreAfterRequest(event) {
    if (this.activeMask && !event.exception) {
      this.unmaskBody();
    }
  }

  /**
   * Animates removal of record.
   * @private
   * @category Store
   */
  onStoreRemove({ records, isCollapse, isChild, isMove }) {
    // Do not react if the content has not been rendered,
    // or if it is a move, which will be handled by onStoreAdd
    if (!this.rendered || isMove) {
      return;
    }

    // GridSelection mixin does its job on records removing
    super.onStoreRemove && super.onStoreRemove(...arguments);

    let topRowIndex = 2 ** 53 - 1;

    const me = this,
      { rowManager } = this,
      // Gather all visible rows which need to be removed.
      rowsToRemove = records.reduce((result, record) => {
        const row = rowManager.getRowById(record.id);
        if (row) {
          result.push(row);
          // Rows are repositioned in the array, it matches visual order. Need to find actual index in it
          topRowIndex = Math.min(topRowIndex, rowManager.rows.indexOf(row));
        }
        return result;
      }, []);

    if (me.animateRemovingRows && rowsToRemove.length && !isCollapse && !isChild) {
      const topRow = rowsToRemove[0];

      me.isAnimating = true;
      // As soon as first row has disappeared, rerender the view
      EventHelper.on({
        element: topRow._elementsArray[0],
        transitionend: (e) => {
          me.isAnimating = false;
          // hovering triggers background-color transitions, ignore those
          if (e.propertyName !== 'background-color' && e.propertyName !== 'width') {
            rowsToRemove.forEach((row) => row.removeCls('b-removing'));
            rowManager.refresh();
            // undocumented internal event for scheduler
            me.trigger('rowRemove');
          }
        },
        once: true
      });
      rowsToRemove.forEach((row) => row.addCls('b-removing'));
    } else {
      // Potentially remove rows and change dataset height
      rowManager.calculateRowCount(false, true, true);

      // If there were rows below which have moved up into place
      // then repurpose them with their new records
      if (rowManager.rows[topRowIndex]) {
        rowManager.renderFromRow(rowManager.rows[topRowIndex]);
      }
      // If nothing to render below, just update dataset height
      else {
        rowManager.trigger('changeTotalHeight', { totalHeight: rowManager.totalHeight });
      }
      me.trigger('rowRemove', { isCollapse });
    }
  }

  onStoreMove({ from, to }) {
    const { rowManager } = this,
      { topIndex, rowCount } = rowManager,
      [dataStart, dataEnd] = [from, to].sort();

    // Changed block starts in our visible block. Render from there downwards.
    if (dataStart >= topIndex && dataStart < topIndex + rowCount) {
      rowManager.renderFromRow(rowManager.rows[dataStart - topIndex]);
    }
    // Changed block ends in our visible block, render block
    else if (dataEnd >= topIndex && dataEnd < topIndex + rowCount) {
      rowManager.refresh();
    }
    // If changed block is outside of the visible area, this is a no-op
  }

  onStoreReplace({ records, all }) {
    if (all) {
      this.rowManager.refresh();
    } else {
      const rows = records.reduce((rows, [, record]) => {
        const row = this.getRowFor(record);
        if (row) {
          rows.push(row);
        }
        return rows;
      }, []);

      this.rowManager.renderRows(rows);
    }
  }

  /**
   * Rerenders grid when all records have been removed
   * @private
   * @category Store
   */
  onStoreRemoveAll() {
    // GridSelection mixin does its job on records removing
    super.onStoreRemoveAll && super.onStoreRemoveAll(...arguments);

    if (this.rendered) {
      this.renderRows();
      this.showEmptyText();
    }
  }

  /**
   * Convenience functions for getting/setting data in related store
   * @property {Object[]}
   * @category Common
   */
  get data() {
    if (this._store) {
      return this._store.records;
    } else {
      return this._data;
    }
  }

  set data(data) {
    if (this._store) {
      this._store.data = data;
    } else {
      this._data = data;
    }
  }

  get emptyText() {
    return this._emptyText;
  }

  set emptyText(text) {
    this._emptyText = text;
    this.eachSubGrid((subGrid) => (subGrid.emptyText = text));
  }

  //endregion

  //region Menu items

  /**
   * Populates the header context menu. Chained in features to add menu items.
   * @param column Column for which the menu will be shown
   * @param items Array of menu items, add to it and return it
   * @category Menu items
   * @internal
   */
  getHeaderMenuItems(column, items) {
    const me = this,
      { subGrids, regions } = me;

    let first = true;

    Object.entries(subGrids).forEach(([region, subGrid]) => {
      // If SubGrid is configured with a sealed column set, do not allow moving into it
      if (subGrid.sealedColumns) {
        return;
      }

      if (
        column.draggable &&
        region !== column.region &&
        ((!column.parent && subGrids[column.region].columns.count > 1) ||
          (column.parent && column.parent.children.length > 1))
      ) {
        const moveRight =
            subGrid.element.compareDocumentPosition(subGrids[column.region].element) ===
            document.DOCUMENT_POSITION_PRECEDING,
          // With 2 regions, use Move left, Move right. With multiple, include region name
          text =
            regions.length > 2
              ? me.L('Move column to ') + region
              : me.L(moveRight ? 'moveColumnRight' : 'moveColumnLeft');

        items.push({
          targetSubGrid: region,
          text,
          icon: 'b-fw-icon ' + (moveRight ? 'b-icon-column-move-right' : 'b-icon-column-move-left'),
          name: 'moveColumn',
          cls: first ? 'b-separator' : '',
          onItem: ({ item }) => {
            const { column } = item;

            column.traverse((col) => (col.region = region));

            // Changing region will move the column to the correct SubGrid, but we want it to go last
            me.columns.insert(me.columns.indexOf(subGrids[item.targetSubGrid].columns.last) + 1, column);

            me.scrollColumnIntoView(column);
          }
        });

        first = false;
      }
    });
  }

  /**
   * Populates the cell context menu. Chained in features to add menu items.
   * @param column {Grid.column.Column} Column for which the menu will be shown
   * @param record {Common.data.Model} Record (row) for which the menu will be shown
   * @param items {Object[]} Array of menu items, add to it and return it
   * @category Menu items
   * @internal
   */
  getCellMenuItems(column, record, items) {
    const me = this;

    if (me.showRemoveRowInContextMenu && !me.readOnly && record && !record.meta.specialRow) {
      if (me.selectedRecords.length > 1) {
        items.push({
          text: me.L('removeRows'),
          icon: 'b-fw-icon b-icon-trash',
          name: 'removeRows',
          onItem: () => me.store.remove(me.selectedRecords)
        });
      } else {
        items.push({
          text: me.L('removeRow'),
          icon: 'b-fw-icon b-icon-trash',
          name: 'removeRow',
          onItem: () => me.store.remove(record)
        });
      }
    }
  }

  getColumnDragToolbarItems(column, items) {
    return items;
  }

  //endregion

  //region Getters

  normalizeCellContext(cellContext) {
    const { columns, store } = this;

    // TODO: should clone instead of modify?
    // TODO: The answer is to use the Grid/util/Location class to robustly encapsulate a record/column intersection
    // And have them immutable, so that to change is to clone, as explained by MaximGB,
    // we want to use columnId for precision, but allow user to specify column name for ease of use...
    // modify cellContext to include columnId in those cases
    if (cellContext instanceof store.modelClass) {
      return {
        record: cellContext,
        id: cellContext.id,
        columnId: columns.bottomColumns[0].id
      };
    }
    if (!('columnId' in cellContext)) {
      if ('field' in cellContext) {
        const column = columns.get(cellContext.field);
        cellContext.columnId = column && column.id;
      } else if ('column' in cellContext) {
        const column =
          typeof cellContext.column === 'number' ? columns.bottomColumns[cellContext.column] : cellContext.column;
        cellContext.columnId = column && column.id;
      }

      // Fall back to first leaf column
      if (!('columnId' in cellContext)) {
        cellContext.columnId = columns.bottomColumns[0].id;
      }
    }

    if ('id' in cellContext) {
      // If the context is for an element, but it's stale (for a removed record)
      // then fix it up to refer to the record id at the same index.
      if (cellContext.element && !store.getById(cellContext.id)) {
        // This uses the data-index property to get the row at that index.
        const newRec = this.getRecordFromElement(cellContext.element);

        // We have a record at the same index.
        if (newRec) {
          cellContext.id = newRec.id;
        }
      }
    } else {
      if ('row' in cellContext) {
        cellContext.id = store.getAt(cellContext.row).id;
      } else if ('record' in cellContext) {
        cellContext.id = cellContext.record.id;
      }
    }

    return cellContext;
  }

  // TODO: move to RowManager? Or create a CellManager?
  /**
   * Returns a cell if rendered.
   * @param {Object} cellContext { id: rowId, columnId: columnId [,column: column number, field: column field] }
   * @param {Number} [cellContext.row] The row index of the row to access. Exclusive with `id` and 'record'.
   * @param {String|Number} [cellContext.id] The record id of the row to access. Exclusive with `row` and 'record'.
   * @param {Common.data.Model} [cellContext.record] The record of the row to access. Exclusive with `id` and 'row'.
   * @param {Number} [cellContext.column] The column instance or the index of the cell to access.  Exclusive with `columnId`.
   * @param {String|Number} [cellContext.columnId] The column id of the column to access. Exclusive with `column`.
   * @param {String} [cellContext.field] The field of the column to access. Exclusive with `column`.
   * @returns {HTMLElement}
   * @category Getters
   */
  getCell(cellContext) {
    let row,
      result = null;

    cellContext = this.normalizeCellContext(cellContext);

    if (cellContext.id) {
      row = this.getRowById(cellContext.id);
    }

    if (row && cellContext.columnId) {
      result = row.getCell(cellContext.columnId);
    }

    return result;
  }

  //TODO: Should move to ColumnManager? Or Header?
  /**
   * Returns the header element for the column
   * @param {String|Number|Grid.column.Column} columnId or Column instance
   * @returns {HTMLElement} Header element
   * @category Getters
   */
  getHeaderElement(columnId) {
    if (typeof columnId !== 'string') {
      columnId = columnId.id;
    }

    return this.fromCache(`.b-grid-header[data-column-id="${columnId}"]`);
  }

  getHeaderElementByField(field) {
    const column = this.columns.get(field);

    return column ? this.getHeaderElement(column) : null;
  }

  /**
   * Body height
   * @property {Number}
   * @readonly
   * @category Layout
   */
  get bodyHeight() {
    return this._bodyHeight;
  }

  /**
   * Header height
   * @property {Number}
   * @readonly
   * @category Layout
   */
  get headerHeight() {
    const me = this;
    // measure header if rendered and not stored
    if (me.rendered && !me._headerHeight) {
      me._headerHeight = me.headerContainer.offsetHeight;
    }

    return me._headerHeight;
  }

  /**
   * Searches up from the specified element for a grid row and returns the record associated with that row.
   * @param {HTMLElement} element Element somewhere within a row or the row container element
   * @returns {Common.data.Model} Record for the row
   * @category Getters
   */
  getRecordFromElement(element) {
    const el = element.closest('.b-grid-row');

    if (!el) return null;

    return this.store.getAt(el.dataset.index);
  }

  /**
   * Searches up from specified element for a grid cell or an header and returns the column which the cell belongs to
   * @param {HTMLElement} element Element somewhere in a cell
   * @returns {Grid.column.Column} Column to which the cell belongs
   * @category Getters
   */
  getColumnFromElement(element) {
    const cell = DomHelper.up(element, '.b-grid-cell, .b-grid-header');
    if (!cell) return null;

    if (cell.matches('.b-grid-header')) {
      return this.columns.getById(cell.dataset.columnId);
    }

    const cellData = DomDataStore.get(cell);
    return this.columns.getById(cellData.columnId);
  }

  // Getter and setter for autoHeight only added for type checking, since it seems common to get it wrong in react/angular
  get autoHeight() {
    return this._autoHeight;
  }

  set autoHeight(autoHeight) {
    ObjectHelper.assertBoolean(autoHeight, 'autoHeight');

    this._autoHeight = autoHeight;
  }

  /**
   * Toggle column line visibility. End result might be overruled by/differ between themes.
   * @property {Boolean}
   */
  get columnLines() {
    return this._columnLines;
  }

  set columnLines(columnLines) {
    ObjectHelper.assertBoolean(columnLines, 'columnLines');

    DomHelper.toggleClasses(this.element, 'b-no-column-lines', !columnLines);

    this._columnLines = columnLines;
  }

  //endregion

  //region ReadOnly

  /**
   * Get/set read only mode, which prevents cell editing etc.
   * Exactly what is prevented is up to each feature.
   * @property {Boolean}
   * @fires readonly
   * @category Common
   */
  set readOnly(readOnly) {
    const me = this;
    me._readOnly = readOnly;
    if (me.rendered) {
      /**
       * Fired when grids read only state is toggled
       * @event readOnly
       * @param {Boolean} readOnly Read only or not
       */
      me.trigger('readOnly', { readOnly });

      // IE11 doesnt support this
      //me.element.classList.toggle('b-readonly', readOnly);
      if (readOnly) {
        me.element.classList.add('b-readonly');
      } else {
        me.element.classList.remove('b-readonly');
      }
    }
  }

  get readOnly() {
    return this._readOnly;
  }

  //endregion

  //region Fix width & height

  /**
   * Sets widths and heights for headers, rows and other parts of the grid as needed
   * @private
   * @category Width & height
   */
  fixSizes() {
    // subGrid width
    this.callEachSubGrid('fixWidths');
  }

  onRowManagerChangeTotalHeight({ totalHeight }) {
    this.refreshTotalHeight(totalHeight);
  }

  /**
   * Makes height of vertical scroller match estimated total height of grid. Called when scrolling vertically and
   * when showing/hiding rows.
   * @param {Number} height
   * @private
   * @category Width & height
   */
  refreshTotalHeight(height = this.rowManager.totalHeight) {
    // Removed isVisible check here, since rows are rendered on paint now (when grid is visible)
    if (this.renderingRows) {
      return;
    }
    if (this.rowManager.bottomRow) {
      height = Math.max(height, this.rowManager.bottomRow.bottom);
    }
    const me = this,
      scroller = me.scrollable,
      delta = Math.abs(me.virtualScrollHeight - height),
      clientHeight = me._bodyRectangle.height,
      newMaxY = height - clientHeight;

    if (delta) {
      const // We must update immediately if we are nearing the end of the scroll range.
        isCritical =
          newMaxY - scroller.y < clientHeight * 2 ||
          // Or if we have scrolled pass visual height
          (me._verticalScrollHeight && me._verticalScrollHeight - clientHeight < scroller.y);

      // Update the true scroll range using the scroller. This will not cause a repaint.
      scroller.scrollHeight = me.virtualScrollHeight = height;

      // If we are scrolling, put this off because it causes
      // a full document layout and paint.
      if (me.scrolling && !isCritical) {
        if (!me.virtualScrollHeightDirty) {
          me.virtualScrollHeightDirty = scroller.on({
            scrollend: me.fixElementHeights,
            thisObj: me,
            once: true
          });
        }
      } else {
        me.virtualScrollHeightDirty && me.virtualScrollHeightDirty();
        me.fixElementHeights(height);
      }
    }
  }

  fixElementHeights() {
    const me = this,
      height = me.virtualScrollHeight,
      heightInPx = `${height}px`;

    me._verticalScrollHeight = height;
    me.verticalScroller.style.height = heightInPx;
    me.virtualScrollHeightDirty = false;

    if (me.autoHeight) {
      me.bodyContainer.style.height = heightInPx;
      me._bodyHeight = height;
      me._bodyRectangle = Rectangle.client(me.bodyContainer);
    }

    me.refreshVirtualScrollbars();
  }

  //endregion

  //region Scroll & virtual rendering

  set scrolling(scrolling) {
    this._scrolling = scrolling;
    this.bodyContainer.classList[scrolling ? 'add' : 'remove']('b-scrolling');
  }

  get scrolling() {
    return this._scrolling;
  }

  /**
   * Responds to request from RowManager to adjust scroll position. Happens when jumping to a scroll position with
   * variable row height.
   * @param {Number} bottomMostRowY
   * @private
   * @category Scrolling
   */
  onRowManagerRequestScrollChange({ bottom }) {
    this.scrollable.y = bottom - this.bodyHeight;
  }

  /**
   * Scroll syncing for normal headers & grid + triggers virtual rendering for vertical scroll
   * @private
   * @fires scroll
   * @category Scrolling
   */
  initScroll() {
    const me = this;
    // This method may be called early, before render calls it, so ensure that it's
    // only executed once.
    if (!me.scrollInitialized) {
      let scrollTop,
        onScroll = me.createOnFrame(() => {
          me._scrollTop = scrollTop = me.scrollable.y;

          if (!me.scrolling) {
            me.scrolling = true;
            me.eachSubGrid((s) => (s.suspendResizeMonitor = true));
          }

          me.rowManager.updateRenderedRows(scrollTop);

          /**
           * Grid has scrolled vertically
           * @event scroll
           * @param {Grid.view.Grid} grid
           * @param {Number} scrollTop
           */
          me.trigger('scroll', { scrollTop });
        });

      me.scrollInitialized = true;

      me.scrollable.on({
        scroll: onScroll,
        scrollend() {
          me.scrolling = false;
          me.eachSubGrid((s) => (s.suspendResizeMonitor = false));
        }
      });

      me.callEachSubGrid('initScroll');
    }
  }

  // TODO: rename to scrollRecordIntoView? Or have an alias?
  /**
   * Scrolls a row into view. If row isn't rendered it tries to calculate position
   * @param {Common.data.Model|String|Number} recordOrId Record or record id
   * @param {Object} [options] How to scroll.
   * @param {String} [options.column] Field name or ID of the column, or the Column instance to scroll to.
   * @param {String} [options.block] How far to scroll the element: `start/end/center/nearest`.
   * @param {Number} [options.edgeOffset] edgeOffset A margin around the element or rectangle to bring into view.
   * @param {Boolean|Number} [options.animate] Set to `true` to animate the scroll, or the number of milliseconds to animate over.
   * @param {Boolean} [options.highlight] Set to `true` to highlight the element when it is in view.
   * @category Scrolling
   * @returns {Promise} A promise which resolves when the specified row has been scrolled into view.
   */
  scrollRowIntoView(recordOrId, options = defaultScrollOptions$2) {
    const me = this,
      blockPosition = options.block || 'nearest',
      rowManager = me.rowManager;

    recordOrId = me.store.getById(recordOrId);

    if (recordOrId) {
      // check that record is "displayable", not filtered out or hidden by collapse
      if (me.store.indexOf(recordOrId) === -1) {
        return resolvedPromise;
      }

      let scroller = me.scrollable,
        recordRect = me.getRecordCoords(recordOrId);

      const scrollerRect = Rectangle.from(scroller.element);

      // If it was calculated from the index, update the rendered rowScrollMode
      // and scroll to the actual element. Note that this should only be necessary
      // for variableRowHeight.
      // But to "make the tests green", this is a workaround for a buffered rendering
      // bug when teleporting scroll. It does not render the rows at their correct
      // positions. Please do not try to "fix" this. I will do it. NGW
      if (recordRect.virtual) {
        const virtualBlock = recordRect.block;

        // Scroll the calculated position to the center of the scrollingViewport
        // and then update the rendered block while asking the RowManager to
        // display the required recordOrId.
        scroller.scrollIntoView(recordRect, {
          block: 'center'
        });
        rowManager.scrollTargetRecordId = recordOrId;
        rowManager.updateRenderedRows(scroller.y, true);
        recordRect = me.getRecordCoords(recordOrId);
        rowManager.lastScrollTop = scroller.y;

        if (recordRect.virtual) {
          // bail out to not get caught in infinite loop, since code above is cut out of bundle
          // eslint-disable-next-line no-useless-return,no-unreachable
          return resolvedPromise;
        }

        const innerOptions =
          blockPosition !== 'nearest'
            ? options
            : {
                block: virtualBlock
              };

        // Scroll the target just less than append/prepend buffer height out of view so that the animation looks good
        if (options.animate) {
          // Do not fire scroll events during this scroll sequence - it's a purely cosmetic operation.
          // We are scrolling the desired row out of view merely to *animate scroll* it to the requested position.
          scroller.suspendEvents();

          // Scroll to its final position
          if (blockPosition === 'end' || (blockPosition === 'nearest' && virtualBlock === 'end')) {
            scroller.y -= scrollerRect.bottom - recordRect.bottom;
          } else if (blockPosition === 'start' || (blockPosition === 'nearest' && virtualBlock === 'start')) {
            scroller.y += recordRect.y - scrollerRect.y;
          }

          // Ensure rendered block is correct at that position
          rowManager.updateRenderedRows(scroller.y, false, true);

          // Scroll away from final position to enable a cosmetic scroll to final position
          if (virtualBlock === 'end') {
            scroller.y -= rowManager.appendRowBuffer * rowManager.rowHeight - 1;
          } else {
            scroller.y += rowManager.prependRowBuffer * rowManager.rowHeight - 1;
          }

          // The row will still be rendered, so scroll it using the scroller directly
          const result = scroller.scrollIntoView(
            me.getRecordCoords(recordOrId),
            Object.assign({}, options, innerOptions)
          );

          // Now we're at the required position, resume events
          result.then(() => scroller.resumeEvents());

          return result;
        } else {
          return me.scrollRowIntoView(recordOrId, Object.assign({}, options, innerOptions));
        }
      } else {
        let { column } = options;

        if (column) {
          if (typeof column === 'string') {
            column = me.columns.getById(column) || me.columns.get(column);
          }

          if (column) {
            // If we are targetting a column, we must use the scroller of that column's SubGrid
            scroller = me.getSubGridFromColumn(column).scrollable;

            const cellRect = Rectangle.from(rowManager.getRowFor(recordOrId).getCell(column.id));

            recordRect.x = cellRect.x;
            recordRect.width = cellRect.width;
          }
        }
        return scroller.scrollIntoView(recordRect, options);
      }
    }
  }

  /**
   * Scrolls a column into view (if it is not already)
   * @param {Grid.column.Column|String|Number} column Column name (data) or column index or actual column object.
   * @param {Object} [options] How to scroll.
   * @param {String} [options.block] How far to scroll the element: `start/end/center/nearest`.
   * @param {Number} [options.edgeOffset] edgeOffset A margin around the element or rectangle to bring into view.
   * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
   * or the number of milliseconds to animate over, or an animation config object.
   * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
   * @param {String} [options.animate.easing] The name of an easing function.
   * @param {Boolean} [options.highlight] Set to `true` to highlight the element when it is in view.
   * @param {Boolean} [options.focus] Set to `true` to focus the element when it is in view.
   * @returns {Promise} If the column exists, a promise which is resolved when the column header element has been scrolled into view.
   * @category Scrolling
   */
  scrollColumnIntoView(column, options) {
    column =
      column instanceof Column
        ? column
        : this.columns.get(column) || this.columns.getById(column) || this.columns.getAt(column);

    return this.getSubGridFromColumn(column).scrollColumnIntoView(column, options);
  }

  // TODO The API { id: recordId, column: 'columnName' } is not clear: id has to be renamed to `record` or `recordId` to be self-explanatory;
  /**
   * Scrolls a cell into view (if it is not already)
   * @param {Object} cellContext Cell selector { id: recordId, column: 'columnName' }
   * @category Scrolling
   */
  scrollCellIntoView(cellContext, options) {
    return this.scrollRowIntoView(
      cellContext.id,
      Object.assign(
        {
          column: cellContext.columnId
        },
        options
      )
    );
  }

  /**
   * Scroll all the way down
   * @returns {Promise} A promise which resolves when the bottom is reached.
   * @category Scrolling
   */
  scrollToBottom(options) {
    // triggers scroll to last record. not using current scroller height because we do not know if it is correct
    return this.scrollRowIntoView(this.store.last, options);
  }

  /**
   * Scroll all the way up
   * @returns {Promise} A promise which resolves when the top is reached.
   * @category Scrolling
   */
  scrollToTop(options) {
    return this.scrollable.scrollBy(0, -this.scrollable.y, options);
  }

  /**
   * Store scroll state (scrollTop for entire grid and scrollLeft per sub grid)
   * @returns {{scrollTop: (*|string|number), scrollLeft: {}}}
   * @category Scrolling
   */
  storeScroll() {
    const me = this,
      state = (me.storedScrollState = {
        scrollTop: me.scrollable.y,
        scrollLeft: {}
      });

    // TODO: Implement special multi-element Scroller subclass for Grids which
    // encapsulates the x axis only Scrollers of all its SubGrids.
    me.eachSubGrid((subGrid) => {
      state.scrollLeft[subGrid.region] = subGrid.scrollable.x;
    });

    return state;
  }

  /**
   * Restore scroll state. If state is not specified, restores the last stored state.
   * @param state Scroll state, optional
   * @category Scrolling
   */
  restoreScroll(state = this.storedScrollState) {
    const me = this;

    // TODO: Implement special multi-element Scroller subclass for Grids which
    // encapsulates the x axis only Scrollers of all its SubGrids.
    me.eachSubGrid((subGrid) => {
      subGrid.scrollable.x = state.scrollLeft[subGrid.region];
    });

    me.scrollable.y = state.scrollTop;
  }

  //endregion

  //region Theme & measuring

  /**
   * Creates a fake subgrid with one row and mesaures its height. Result is used as rowHeight.
   * @private
   */
  measureRowHeight() {
    const me = this,
      // Create a fake subgrid with one row, since styling for row is specified on .b-grid-subgrid .b-grid-row
      rowMeasureElement = DomHelper.createElement({
        tag: 'div',
        // TODO: should either get correct widgetClassList or query features for measure classes
        className: 'b-grid ' + (me.features.stripe ? 'b-stripe' : ''),
        style: 'position: absolute; visibility: hidden',
        html: '<div class="b-grid-subgrid"><div class="b-grid-row"></div></div>',
        parent: document.getElementById(me.appendTo) || document.body
      });

    // Use style height or default height from config.
    // Not using clientHeight since it will have some value even if no height specified in CSS
    const rowEl = rowMeasureElement.firstElementChild.firstElementChild,
      styleHeight = parseInt(DomHelper.getStyleValue(rowEl, 'height')),
      borderTop = parseInt(DomHelper.getStyleValue(rowEl, 'border-top-width')),
      borderBottom = parseInt(DomHelper.getStyleValue(rowEl, 'border-bottom-width'));

    // Change rowHeight if specified in styling, also remember that value to replace later if theme changes and
    // user has not explicitly set some other height
    if (me.rowHeight == null || me.rowHeight === me._rowHeightFromStyle) {
      me.rowHeight = !isNaN(styleHeight) && styleHeight ? styleHeight : me.defaultRowHeight;
      me._rowHeightFromStyle = me.rowHeight;
    }

    // this measurement will be added to rowHeight during rendering, to get correct cell height
    me._rowBorderHeight = borderTop + borderBottom;

    me._isRowMeasured = true;

    rowMeasureElement.remove();

    // There is a ticket about measuring the actual first row instead:
    // https://app.assembla.com/spaces/bryntum/tickets/5735-measure-first-real-rendered-row-for-rowheight/details
  }

  /**
   * Handler for global theme change event (triggered by shared.js). Remeasures row height.
   * @private
   */
  onThemeChange({ theme }) {
    this.measureRowHeight();
    this.trigger('theme', { theme });
  }

  //endregion

  //region Rendering of rows

  /**
   * Triggers a render of records to all row elements. Call after changing order, grouping etc to reflect changes
   * visually. Preserves scroll.
   * @category Rendering
   */
  refreshRows(returnToTop = false) {
    this.element.classList.add('b-notransition');

    if (returnToTop) {
      this.rowManager.returnToTop();
    } else {
      this.rowManager.refresh();
    }

    this.element.classList.remove('b-notransition');
  }

  /**
   * Triggers a render of all the cells in a column.
   * @param {Grid.column.Column} column
   * @category Rendering
   */
  refreshColumn(column) {
    const field = column.field;

    this.rowManager.forEach((row) => {
      const cell = row.getCell(field);

      row.renderCell(cell);
    });
  }
  //endregion

  //region Render the grid

  /**
   * Recalculates virtual scrollbars widths and scrollWidth
   * @private
   */
  refreshVirtualScrollbars() {
    const { scrollBarWidth } = DomHelper;

    if (scrollBarWidth) {
      const me = this,
        { headerContainer, footerContainer, virtualScrollers } = me,
        hasVerticalOverflow = me.virtualScrollHeight > me.bodyHeight, //bodyContainer.scrollHeight > bodyContainer.clientHeight,
        // We need to ask each subGrid if it has horizontal overflow.
        // If any do, we show the virtual scroller, otherwise we hide it.
        hasHorizontalOverflow = Object.values(me.subGrids).some((subGrid) => subGrid.overflowingHorizontally);

      if (hasHorizontalOverflow) {
        virtualScrollers.classList.remove('b-hide-display');
      } else {
        virtualScrollers.classList.add('b-hide-display');
      }

      if (hasVerticalOverflow) {
        if (!headerContainer.classList.contains('b-grid-vertical-overflow')) {
          headerContainer.classList.add('b-grid-vertical-overflow');
        }
      } else {
        headerContainer.classList.remove('b-grid-vertical-overflow');
      }

      // can get called before headers are rendered. headers might also be hidden (such as in docs)
      const lastHeaderScroller = headerContainer.querySelector('.b-grid-header-scroller:last-child');
      if (lastHeaderScroller && hasVerticalOverflow) {
        const headerBorderWidth = parseInt(DomHelper.getStyleValue(lastHeaderScroller, 'border-right-width'));
        // Add a style to pad the header-container to clear the grid's vertical scrollbar
        // TODO: regions part of calculation is to compensate for 1px off with third region, but it should be solvable using CSS. Not finding how though...
        headerContainer.style.paddingRight =
          scrollBarWidth - headerBorderWidth + (me.regions.length > 2 ? 1 : 0) + 'px';
        footerContainer.style.paddingRight = `${scrollBarWidth}px`;
      } else {
        headerContainer.style.paddingRight = '0';
        footerContainer.style.paddingRight = '0';
      }
    }
  }

  onContentChange() {
    const me = this,
      rowManager = me.rowManager;

    if (me.isVisible) {
      const contentHeight = Math.max(rowManager.totalHeight, rowManager.bottomRow ? rowManager.bottomRow.bottom : 0);

      me.paintListener = null;
      // cache to avoid recalculations in the middle of rendering code (RowManger#getRecordCoords())
      me._bodyRectangle = Rectangle.client(me.bodyContainer);
      me._bodyHeight = me.autoHeight ? contentHeight : me.bodyContainer.offsetHeight;
      me.refreshTotalHeight(contentHeight);
      me.callEachSubGrid('refreshFakeScroll');
    }
    // If not visible, this operation MUST be done when we become visible.
    // This is announced by the paint event which is triggered when a Widget
    // really gains visibility, ie is shown or rendered, or it's not hidden,
    // and a hidden/non-rendered ancestor is shown or rendered.
    // See Widget#triggerPaint.
    else if (!me.paintListener) {
      me.paintListener = me.on({
        paint: 'onContentChange',
        once: true,
        thisObj: me
      });
    }
  }

  /**
   * Called after headers have been rendered to the headerContainer.
   * This does not do anything, it's just for Features to hook in to.
   * @param {HTMLElement} headerContainer DOM element which contains the headers.
   * @param {HTMLElement} element Grid element
   * @private
   * @category Rendering
   */
  renderHeader(headerContainer, element) {}

  /**
   * Called after footers have been rendered to the footerContainer.
   * This does not do anything, it's just for Features to hook in to.
   * @param {HTMLElement} footerContainer DOM element which contains the footers.
   * @param {HTMLElement} element Grid element
   * @private
   * @category Rendering
   */
  renderFooter(footerContainer, element) {}

  suspendRefresh() {
    this.refreshSuspended++;
  }

  resumeRefresh(trigger) {
    if (this.refreshSuspended && !--this.refreshSuspended) {
      if (trigger) {
        this.refreshRows();
      }
    }
  }

  /**
   * Rerenders all grid rows, completely replacing all row elements with new ones
   * @category Rendering
   */
  renderRows(keepScroll = true, returnToTop = false) {
    const me = this,
      scrollState = keepScroll && me.storeScroll();

    if (me.refreshSuspended) {
      return;
    }

    /**
     * Grid rows are about to be rendered
     * @event beforeRenderRows
     * @param {Grid.view.Grid} grid
     */
    me.trigger('beforeRenderRows');
    me.renderingRows = true;

    // This allows us to do things like disable animations on a refresh
    me.element.classList.add('b-grid-refreshing');

    // remove all row elements from dom (sets innerHTML = '')
    me.callEachSubGrid('clearRows');

    if (returnToTop) {
      me.scrollable.y = 0;
    }
    me.rowManager.reinitialize(returnToTop);

    me.renderingRows = false;
    me.onContentChange();

    if (keepScroll) {
      me.restoreScroll(scrollState);
    }

    me.element.classList.remove('b-grid-refreshing');
  }

  /**
   * Rerenders the grids rows, headers and footers, completely replacing all row elements with new ones
   * @category Rendering
   */
  // TODO: Make render call this fn, not very DRY currently
  renderContents() {
    const me = this,
      element = me.appendTo,
      headerContainer = me.headerContainer,
      footerContainer = me.footerContainer;

    me.emptyCache();

    // columns will be "drawn" on render anyway, bail out
    if (!me.rendered) return;

    // reset measured header height, to make next call to get headerHeight measure it
    me._headerHeight = null;

    me.callEachSubGrid('refreshHeader', headerContainer);
    me.callEachSubGrid('refreshFooter', footerContainer);

    // Note that these are hook methods for features to plug in to. They do not do anything.
    me.renderHeader(headerContainer, element);
    me.renderFooter(footerContainer, element);

    me.fixSizes();
    me.renderRows(false);
  }

  // Render rows etc. on first paint, to make sure Grids element has been laid out
  onPaint() {
    const me = this,
      { element, headerContainer, bodyContainer, footerContainer } = me;

    if (me.rendered) {
      return;
    }

    // apply any responsive configs before rendering columns and rows
    me.updateResponsive(me.width, 0);

    let maxDepth = 0;

    // Cached, updated on resize. Used by RowManager and by the subgrids upon their render
    me._bodyRectangle = Rectangle.client(me.bodyContainer);

    me.eachSubGrid((subGrid) => {
      subGrid.render(me.verticalScroller);
    });

    // Note that these are hook methods for features to plug in to. They do not do anything.
    // SubGrids take care of their own rendering.
    me.renderHeader(headerContainer, element);
    me.renderFooter(footerContainer, element);

    if (me.autoHeight) {
      me._bodyHeight = me.rowManager.initWithHeight(
        element.offsetHeight - headerContainer.offsetHeight - footerContainer.offsetHeight,
        true
      );
      bodyContainer.style.height = me.bodyHeight + 'px';
    } else {
      me._bodyHeight = me.bodyContainer.offsetHeight;
      me.rowManager.initWithHeight(me._bodyHeight, true);
    }

    me.eachSubGrid((subGrid) => {
      if (subGrid.header.maxDepth > maxDepth) {
        maxDepth = subGrid.header.maxDepth;
      }
    });

    headerContainer.dataset.maxDepth = maxDepth;

    me.fixSizes();

    me.renderRows(false);

    me.initScroll();

    me.initInternalEvents();

    me.rendered = true;
  }

  render(target) {
    const me = this;

    // When displayed inside one of our containers, require a size to be considered visible. Ensures it is painted
    // on display when for example in a tab
    me.requireSize = Boolean(me.owner);

    super.render(target);

    // Sanity check that main element has been given some sizing styles, unless autoHeight is used in which case
    // it will be sized programmatically instead
    if (!me.autoHeight && me.headerContainer.offsetHeight && !me.bodyContainer.offsetHeight) {
      console.warn('Grid element not sized correctly, please check your CSS styles and review how you size the widget');
    }
  }

  //endregion

  // region Masking

  /**
   * Show a load mask with a spinner and the specified message. When using an AjaxStore masking and unmasking is
   * handled automatically, but if you are loading data in other ways you can call this function manually when your
   * load starts.
   * ```
   * myLoadFunction() {
   *   // Show mask before initiating loading
   *   grid.maskBody('Loading data');
   *   // Your custom loading code
   *   load.then(() => {
   *      // Hide the mask when loading is finished
   *      grid.unmaskBody();
   *   });
   * }
   * ```
   * @param {String} loadMask Message to show next to the spinner
   * @returns {Common.widget.Mask}
   */
  maskBody(loadMask) {
    const me = this;

    if (!me.bodyContainer) {
      return;
    }

    // remove any existing mask
    me.unmaskBody();

    me.activeMask = WidgetHelper.mask(me.bodyContainer, loadMask);

    return me.activeMask;
  }

  /**
   * Hide the load mask.
   */
  unmaskBody() {
    const me = this;

    me.loadmaskHideTimer && me.clearTimeout(me.loadmaskHideTimer);
    me.loadmaskHideTimer = null;

    me.activeMask && me.activeMask.destroy();
    me.activeMask = null;
  }

  // endregion

  get isAnimating() {
    return this._animating;
  }

  set isAnimating(value) {
    const me = this;
    if (me.rendered && value !== me.isAnimating) {
      if (value) {
        me.element.classList.add('b-animating');
      } else {
        me.element.classList.remove('b-animating');
      }
      me._animating = value;
    }
  }
}

Grid._$name = 'Grid';
BryntumWidgetAdapterRegister.register('grid', Grid);

VersionHelper.setVersion('grid', '2.2.3');

/**
 * @module Grid/view/TreeGrid
 */

/**
 * A TreeGrid, a Tree combined with a Grid. Must be configured with exactly one {@link Grid.column.TreeColumn} (`type: tree`), but can also have an
 * arbitrary number of other columns. Most features that can be used with Grid also works with TreeGrid, with the
 * exception of the Group feature.
 * @extends Grid/view/Grid
 *
 * @classtype treegrid
 * @externalexample grid/TreeGrid.js
 */
class TreeGrid extends Grid {
  //region Plugged in functions / inherited configs

  /**
   * Store that holds records to display in the TreeGrid, or a store config object.
   * If you supply a Store, make sure it is configured with `tree : true` to handle tree data.
   * A store will be created if none is specified
   * @config {Common.data.Store|Object} store
   * @default
   */

  /**
   * Collapse an expanded node or expand a collapsed. Optionally forcing a certain state.
   *
   * @function toggleCollapse
   * @param {String|Number|Common.data.Model} idOrRecord Record (the node itself) or id of a node to toggle
   * @param {Boolean} [collapse] Force collapse (true) or expand (false)
   * @param {Boolean} [skipRefresh] Set to true to not refresh rows (if calling in batch)
   * @returns {Promise}
   * @category Feature shortcuts
   */

  /**
   * Collapse a single node.
   *
   * @function collapse
   * @param {String|Number|Common.data.Model} idOrRecord Record (the node itself) or id of a node to collapse
   * @returns {Promise}
   * @category Feature shortcuts
   */

  /**
   * Expand a single node.
   *
   * @function expand
   * @param {String|Number|Common.data.Model} idOrRecord Record (the node itself) or id of a node to expand
   * @returns {Promise}
   * @category Feature shortcuts
   */

  /**
   * Expands parent nodes to make this node "visible".
   *
   * @function expandTo
   * @param {String|Number|Common.data.Model} idOrRecord Record (the node itself) or id of a node
   * @returns {Promise}
   * @category Feature shortcuts
   */

  //endregion

  //region Store

  /**
   * Get/set the store used by this TreeGrid. Accepts a config or a Store. If assigning an already existing Store,
   * it must be configured with `tree: true`
   * @property {Common.data.Store|Object}
   */
  set store(store) {
    if (store && !store.tree) {
      // existing store instance, not much we can do about it
      if (store instanceof Store) {
        throw new Error('TreeGrid requires a Store configured with tree : true');
      }
      // store config, enable tree
      else {
        store.tree = true;
      }
    }

    super.store = store;
  }

  get store() {
    return super.store;
  }

  //endregion
}

TreeGrid._$name = 'TreeGrid';
BryntumWidgetAdapterRegister.register('treegrid', TreeGrid);

/**
 * @module Scheduler/crud/transport/AjaxTransport
 */

/**
 * Implements data transferring functional that can be used for {@link Scheduler.crud.AbstractCrudManager} super classing.
 * Uses the fetch API for transport, https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
 *
 * @example
 * // create a new CrudManager using AJAX as a transport system and JSON for encoding
 * class MyCrudManager extends AjaxTransport(JsonEncode(AbstractCrudManager)) {}
 *
 * @abstract
 * @mixin
 */
var AjaxTransport = (Target) =>
  class AjaxTransport extends (Target || Base) {
    /**
     * Configuration of the AJAX requests used to communicate with a server-side.
     * An object where you can set the following possible properties:
     * @config {Object} transport
     * @property {Object} transport.load Load requests configuration:
     * @property {String} transport.load.url URL to request for data loading.
     * @property {String} [transport.load.method='POST'] HTTP method to be used for load requests.
     * @property {String} [transport.load.paramName] Name of parameter in which a packet will be transfered. If not specified then a packet will be transfered in a request body (default).
     * @property {Object} [transport.load.params] Extra load request params if needed.
     * @property {Object} [transport.load.requestConfig] Ajax request config. Can be used instead of above `url`, `method`, `params`:
     *
     * ```javascript
     * transport   : {
     *     load    : {
     *         requestConfig : {
     *             url             : 'http://some-url',
     *             method          : 'GET',
     *             // get rid of cache-buster parameter
     *             disableCaching  : false,
     *             // extra request parameters
     *             params          : {
     *                 foo         : 'bar'
     *             },
     *             // custom request headers
     *             headers         : {
     *                 ...
     *             }
     *         }
     *     }
     * }
     * ```
     *
     * @property {Object} transport.sync Sync requests configuration:
     * @property {String} transport.sync.url URL to request for data persisting.
     * @property {String} [transport.sync.method='POST'] HTTP method to be used for sync requests.
     * @property {String} [transport.sync.paramName] Name of parameter in which a packet will be transfered. If not specified then a packet will be transfered in a request body (default).
     * @property {Object} [transport.sync.params] Extra sync request params if needed.
     * @property {Object} [transport.sync.requestConfig] Ajax request config. Can be used instead of above `url`, `method`, `params`:
     *
     * ```javascript
     * transport   : {
     *     sync    : {
     *         requestConfig : {
     *             url             : 'http://some-url',
     *             method          : 'GET',
     *             // get rid of cache-buster parameter
     *             disableCaching  : false,
     *             // extra request parameters
     *             params          : {
     *                 foo         : 'bar'
     *             },
     *             // custom request headers
     *             headers         : {
     *                 ...
     *             }
     *         }
     *     }
     * }
     * ```
     */

    static get defaultMethod() {
      return {
        load: 'GET',
        sync: 'POST'
      };
    }

    /**
     * Cancels a sent request.
     * @param {Promise} requestPromise The Promise object wrapping the Request to be cancelled.
     * The _requestPromise_ is the return value returned from the corresponding {@link #function-sendRequest} call.
     */
    cancelRequest(requestPromise) {
      requestPromise.abort();
    }

    /**
     * Sends request to the server.
     * @param {Object} request The request configuration object having following properties:
     * @param {String} request.data The encoded request.
     * @param {String} request.type The request type. Either `load` or `sync`.
     * @param {Function} request.success A function to be started on successful request transferring.
     * @param {String} request.success.rawResponse `Response` object returned by the [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
     * @param {Function} request.failure A function to be started on request transfer failure.
     * @param {String} request.failure.rawResponse `Response` object returned by the [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
     * @param {Object} request.thisObj `this` reference for the above `success` and `failure` functions.
     * @return {Promise} The fetch Promise object.
     * @fires beforesend
     */
    sendRequest(config) {
      let me = this,
        pack = config.data,
        packCfg = me.transport[config.type] || {},
        paramName = packCfg.paramName,
        params = Object.assign({}, packCfg.params),
        method = packCfg.method || AjaxTransport.defaultMethod[config.type];

      let requestConfig = Object.assign(
        {
          url: packCfg.url,
          method: method,
          params: params
        },
        packCfg.requestConfig
      );

      // if no param name specified then we'll transfer package in the request body
      if (!paramName) {
        // TODO: get rid of this legacy code in the next major release
        // ..here we should simply make: requestConfig.body = pack
        requestConfig.jsonData = pack;
        // ..otherwise we use parameter
      } else {
        requestConfig.params = requestConfig.params || {};
        requestConfig.params[paramName] = pack;
      }

      /**
       * Fires before a request is sent to the server.
       *
       * ```javascript
       * crudManager.on('beforesend', function (crud, params, requestType) {
       *     // let's set "sync" request parameters
       *     if (requestType == 'sync') {
       *         // dynamically depending on "flag" value
       *         if (flag) {
       *             params.foo = 'bar';
       *         } else {
       *             params.foo = 'smth';
       *         }
       *     }
       * });
       * ```
       * @event beforesend
       * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
       * @param {Object} params Request params
       * @param {String} requestType Request type (`load`/`sync`)
       * @param {Object} requestConfig Configuration object for Ajax request call
       */
      me.trigger('beforeSend', { params, type: config.type, requestConfig, config });

      const responseOptions = {
          method,
          headers: requestConfig.headers,
          queryParams: params,
          body: method === 'HEAD' || method === 'GET' ? undefined : requestConfig.jsonData
        },
        ajaxPromise = AjaxHelper.fetch(requestConfig.url, responseOptions);

      ajaxPromise.then((response) => {
        if (response.ok) {
          config.success && config.success.call(config.thisObj || me, response, responseOptions);
        } else {
          config.failure && config.failure.call(config.thisObj || me, response, responseOptions);
        }
      });

      return ajaxPromise;
    }
  };

/**
 * @module Scheduler/crud/AbstractCrudManagerMixin
 */

const storeSortFn = function(lhs, rhs, sortProperty) {
    // TODO: get rid of these StoreDescriptors. Just use Stores.
    if (lhs.store) {
      lhs = lhs.store;
    }
    if (rhs.store) {
      rhs = rhs.store;
    }

    lhs = lhs[sortProperty] || 0;
    rhs = rhs[sortProperty] || 0;
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  },
  // Sorter function to keep stores in loadPriority order
  storeLoadSortFn = function(lhs, rhs) {
    return storeSortFn(lhs, rhs, 'loadPriority');
  },
  // Sorter function to keep stores in syncPriority order
  storeSyncSortFn = function(lhs, rhs) {
    return storeSortFn(lhs, rhs, 'syncPriority');
  },
  nullFn$1 = () => {};

/**
 * An abstract mixin that supplies most of the CrudManager functionality.
 * It implements basic mechanisms of collecting stores to organize batch communication with a server.
 * Yet it does not contain methods related to _data transfer_ nor _encoding_.
 * These methods are to be provided in sub-classes.
 * Out of the box there are mixins implementing {@link Scheduler.crud.transport.AjaxTransport support of AJAX for data transferring}
 * and {@link Scheduler.crud.encoder.JsonEncoder JSON for data encoding system}.
 * For example this is how we make a model that will implement CrudManager protocol and use AJAX/JSON to pass the dada to the server:
 *
 * ```javascript
 * class SystemSettings extends JsonEncode(AjaxTransport(AbstractCrudManagerMixin(Model))) {
 *     ...
 * }
 * ```
 *
 * ## Data transfer and encoding methods
 *
 * These are methods that must be provided by subclasses of this class:
 *
 * - {@link #function-sendRequest sendRequest}
 * - {@link #function-cancelRequest cancelRequest}
 * - {@link #function-encode encode}
 * - {@link #function-decode decode}
 *
 * @mixin
 * @abstract
 */
var AbstractCrudManagerMixin = (Target) =>
  class AbstractCrudManagerMixin extends Target {
    //region Default config

    static get crudManagerDefaultConfig() {
      // static get defaultConfig() {
      return {
        // overrideCrudStoreLoad : false,

        /**
         * The server revision stamp.
         * The _revision stamp_ is a number which should be incremented after each server-side change.
         * This property reflects the current version of the data retrieved from the server and gets updated after each {@link #function-load} and {@link #function-sync} call.
         * @property {Number}
         * @readonly
         */
        crudRevision: null,

        /**
         * A list of registered stores whose server communication will be collected into a single batch.
         * Each store is represented by a _store descriptor_, an object having following structure:
         * @member {Object[]} crudStores
         * @property {String} stores.storeId Unique store identifier.
         * @property {Common.data.Store} stores.store Store itself.
         * @property {String} [stores.phantomIdField] Set this if store model has a predefined field to keep phantom record identifier.
         * @property {String} [stores.idField] id field name, if it's not specified then class will try to get it from a store model.
         */

        /**
         * Sets the list of stores controlled by the CRUD manager.
         * Store can be provided by itself, its storeId or an object having the following structure:
         * @property {String} stores.storeId Unique store identifier. Under this name the store related requests/responses will be sent.
         * @property {Common.data.Store} stores.store The store itself.
         * @property {String} [stores.phantomIdField] Set this if the store model has a predefined field to keep phantom record identifier.
         * @property {String} [stores.idField] id field name, if it's not specified then class will try to get it from a store model.
         * @config {Common.data.Store[]|String[]|Object[]}
         */
        crudStores: [],

        /**
         * Name of a store property to retrieve store identifiers from.
         * Store identifier is used as a container name holding corresponding store data while transferring them to/from the server.
         * By default `storeId` property is used. And in case a container identifier has to differ this config can be used:
         *
         * ```javascript
         * class CatStore extends Store {
         *     // storeId is "meow" but for sending/receiving store data
         *     // we want have "cats" container in JSON, so we create a new property "storeIdForCrud"
         *     storeId          : 'meow',
         *     storeIdForCrud   : 'cats'
         * });
         *
         * class MyCrudManager extends CrudManager {
         *     ...
         *     crudStores           : ['meow'],
         *     // crud manager will get store identifier from "storeIdForCrud" property
         *     storeIdProperty  : 'storeIdForCrud'
         * });
         * ```
         * The `storeIdProperty` property can also be specified directly on a store:
         *
         * ```javascript
         * class CatStore extends Store {
         *     // storeId is "meow" but for sending/receiving store data
         *     // we want have "cats" container in JSON
         *     storeId          : 'meow',
         *     // so we create a new property "storeIdForCrud"..
         *     storeIdForCrud  : 'cats',
         *     // and point CrudManager to use it as the store identifier source
         *     storeIdProperty  : 'storeIdForCrud'
         * });
         *
         * class DogStore extends Store {
         *     // storeId is "dogs" and it will be used as a container name for the store data
         *     storeId          : 'dogs'
         * });
         *
         * class MyCrudManager extends CrudManager {
         *     ...
         *     crudStores           : ['meow', 'dogs']
         * });
         * ```
         * @config {String}
         */
        storeIdProperty: 'storeId',

        // TODO: no support for remote filtering yet
        // /**
        //  * The name of the 'filter' parameter to send in a load request.
        //  * @config {String}
        //  * @default
        //  */
        crudFilterParam: 'filter',

        /**
         * Sends request to the server.
         * @function sendRequest
         * @param {Object} request The request to send. An object having following properties:
         * @param {String} request.data {@link #function-encode Encoded} request.
         * @param {String} request.type Request type, can be either `load` or `sync`
         * @param {Function} request.success Callback to be started on successful request transferring
         * @param {Function} request.failure Callback to be started on request transfer failure
         * @param {Object} request.thisObj `this` reference for the above `success` and `failure` callbacks
         * @return {Promise} The request promise.
         * @abstract
         */

        /**
         * Cancels request to the server.
         * @function cancelRequest
         * @param {Object} request The request to cancel (a value returned by corresponding {@link #function-sendRequest} call).
         * @abstract
         */

        /**
         * Encodes request to the server.
         * @function encode
         * @param {Object} request The request to encode.
         * @returns {String} The encoded request.
         * @abstract
         */

        /**
         * Decodes response from the server.
         * @function decode
         * @param {String} response The response to decode.
         * @returns {Object} The decoded response.
         * @abstract
         */

        transport: {},

        /**
         * When `true` forces the CRUD manager to process responses depending on their `type` attribute.
         * So `load` request may be responded with `sync` response for example.
         * Can be used for smart server logic allowing the server to decide when it's better to respond with a complete data set (`load` response)
         * or it's enough to return just a delta (`sync` response).
         * @config {Boolean}
         * @default
         */
        trackResponseType: false,

        /**
         * Field name to be used to transfer a phantom record identifier.
         * @config {String}
         * @default
         */
        phantomIdField: '$PhantomId',

        /**
         * `true` to automatically call {@link #function-load} method after creation.
         * @config {Boolean}
         * @default
         */
        autoLoad: false,

        /**
         * The timeout in milliseconds to wait before persisting changes to the server.
         * Used when {@link #config-autoSync} is set to `true`.
         * @config {Number}
         * @default
         */
        autoSyncTimeout: 100,

        /**
         * `true` to automatically persist store changes after edits are made in any of the stores monitored.
         * Please note that sync request will not be invoked immediately but only after {@link #config-autoSyncTimeout} interval.
         * @config {Boolean}
         * @default
         */
        autoSync: false,

        /**
         * `True` to reset identifiers (defined by `idField` config) of phantom records before submitting them to the server.
         * @config {Boolean}
         * @default
         */
        resetIdsBeforeSync: true,

        /**
         * @member {Object[]} syncApplySequence
         * An array of stores presenting an alternative sync responses apply order.
         * Each store is represented by a _store descriptor_, an object having following structure:
         * @property {String} syncApplySequence.storeId Unique store identifier.
         * @property {Common.data.Store} syncApplySequence.store Store itself.
         * @property {String} [syncApplySequence.phantomIdField] Set this if store model has a predefined field to keep phantom record identifier.
         * @property {String} [syncApplySequence.idField] id field name, if it's not specified then class will try to get it from a store model.
         */

        /**
         * An array of store identifiers sets an alternative sync responses apply order.
         * By default the order in which sync responses are applied to the stores is the same as they registered in.
         * But in case of some tricky dependencies between stores this order can be changed:
         *
         *```javascript
         * class MyCrudManager extends CrudManager {
         *     // register stores (they will be loaded in the same order: 'store1' then 'store2' and finally 'store3')
         *     crudStores : ['store1', 'store2', 'store3'],
         *     // but we apply changes from server to them in an opposite order
         *     syncApplySequence : ['store3', 'store2', 'store1']
         * });
         *```
         * @config {String[]}
         */
        syncApplySequence: [],

        /**
         * true to write all fields from the record to the server. If set to false it will only send the fields that
         * were modified. Note that any fields that have `persist` set to false will still be ignored while those
         * with `critical` set to true will be included.
         * @config {Boolean}
         * @default
         */
        writeAllFields: false,

        crudIgnoreUpdates: 0,

        // Flag that shows if crud manager performed successful load request
        crudLoaded: false,

        createMissingRecords: false,
        autoSyncTimerId: null,

        applyingLoadResponse: false,
        applyingSyncResponse: false,

        callOnFunctions: true
      };
    }

    //endregion

    //region Init

    construct(config = {}) {
      this._requestId = 0;
      this.activeRequests = {};
      this.crudStoresIndex = {};

      this._crudManagerConfig = config;

      super.construct(config);
    }

    applyCrudManagerMixinConfig(config) {
      const cfg = this.splitCrudManagerConfig(config);

      if (cfg.crudStores) {
        this.crudStores = cfg.crudStores;
        delete cfg.crudStores;
      }

      Object.assign(this, cfg);
    }

    afterConfigure() {
      if (!this.initialConfig) {
        this.applyCrudManagerMixinConfig(this._crudManagerConfig);
      }
    }

    splitCrudManagerConfig(config) {
      // debugger
      let result = Object.assign({}, this.constructor.crudManagerDefaultConfig);
      // let result = Object.assign({}, this.constructor.defaultConfig);

      for (let cfg in config) {
        if (cfg in result) {
          result[cfg] = config[cfg];
          delete config[cfg];
        }
      }

      return result;
    }

    afterConstruct() {
      super.afterConstruct();

      if (this.autoLoad) {
        this.load().catch((e) => {});
      }
    }

    //endregion

    //region Store descriptors & index

    /**
     * Returns a registered store descriptor.
     * @param {String|Common.data.Store} storeId The store identifier or registered store instance.
     * @returns {Object} The descriptor of the store.
     */
    getStoreDescriptor(storeId) {
      if (!storeId) return null;

      if (storeId instanceof Store) return this.crudStores.find((storeDesc) => storeDesc.store === storeId);

      if (typeof storeId === 'object') return this.crudStoresIndex[storeId.storeId];

      return this.crudStoresIndex[storeId] || this.getStoreDescriptor(Store.getStore(storeId));
    }

    fillStoreDescriptor(descriptor) {
      let store = descriptor.store,
        storeIdProperty = store.storeIdProperty || this.storeIdProperty,
        model = store.modelClass && store.modelClass.prototype;

      !descriptor.storeId && (descriptor.storeId = store[storeIdProperty]);
      !descriptor.idField && (descriptor.idField = model.idField);
      !descriptor.phantomIdField && (descriptor.phantomIdField = model && model.phantomIdField);
      !('writeAllFields' in descriptor) && (descriptor.writeAllFields = store.writeAllFields); // TODO: PORT support for writeAllFields

      return descriptor;
    }

    updateCrudStoreIndex() {
      const crudStoresIndex = (this.crudStoresIndex = {});

      this.crudStores.forEach((store) => store.storeId && (crudStoresIndex[store.storeId] = store));
    }

    //endregion

    //region Store collection (add, remove, get & iterate)

    /**
     * Returns a registered store.
     * @param {String} storeId Store identifier.
     * @returns {Common.data.Store} Found store instance.
     */
    getCrudStore(storeId) {
      const storeInfo = this.getStoreDescriptor(storeId);
      return storeInfo && storeInfo.store;
    }

    forEachCrudStore(fn, thisObj = this) {
      if (!fn) return;

      this.crudStores.every((store) => fn.call(thisObj, store.store, store.storeId, store) !== false);
    }

    set crudStores(stores) {
      this._crudStores = [];

      this.addCrudStore(stores);

      // Ensure preconfigured stores stay stable at the start of the array when
      // addPrioritizedStore attempts to insert in order. Only featured gantt/scheduler stores
      // must participate in the ordering. If they were configured in, they must not move.
      for (let store of this._crudStores) {
        store.loadPriority = store.syncPriority = 0;
      }
    }

    get crudStores() {
      return this._crudStores;
    }

    set syncApplySequence(stores) {
      this._syncApplySequence = [];

      this.addStoreToApplySequence(stores);
    }

    get syncApplySequence() {
      return this._syncApplySequence;
    }

    /**
     * Adds a store to the collection.
     *
     *```javascript
     * // append stores to the end of collection
     * crudManager.addCrudStore([
     *     store1,
     *     // storeId
     *     'bar',
     *     // store descriptor
     *     {
     *         storeId : 'foo',
     *         store   : store3
     *     },
     *     {
     *         storeId         : 'bar',
     *         store           : store4,
     *         // to write all fields of modified records
     *         writeAllFields  : true
     *     }
     * ]);
     *```
     *
     * **Note:** Order in which stores are kept in the collection is very essential sometimes.
     * Exactly in this order the loaded data will be put into each store.
     * @param {Common.data.Store|String|Object|Common.data.Store[]|String[]|Object[]} store
     * A store or list of stores. Each store might be specified by its instance, `storeId` or _descriptor_.
     * The _store descriptor_ is an object having following properties:
     * @param {String} store.storeId The store identifier that will be used as a key in requests.
     * @param {Common.data.Store} store.store The store itself.
     * @param {String} [store.idField] The idField of the store. If not specified will be taken from the store model.
     * @param {String} [store.phantomIdField] The field holding unique Ids of phantom records (if store has such model).
     * @param {Boolean} [store.writeAllFields] Set to true to write all fields from modified records
     * @param {Number} [position] The relative position of the store. If `fromStore` is specified the this position will be taken relative to it.
     * If not specified then store(s) will be appended to the end of collection.
     * Otherwise it will be just a position in stores collection.
     *
     * ```javascript
     * // insert stores store4, store5 to the start of collection
     * crudManager.addCrudStore([ store4, store5 ], 0);
     * ```
     *
     * @param {String|Common.data.Store|Object} [fromStore] The store relative to which position should be calculated. Can be defined as a store identifier, instance or descriptor (the result of {@link #function-getStoreDescriptor} call).
     *
     * ```javascript
     * // insert store6 just before a store having storeId equal to 'foo'
     * crudManager.addCrudStore(store6, 0, 'foo');
     *
     * // insert store7 just after store3 store
     * crudManager.addCrudStore(store7, 1, store3);
     * ```
     */
    addCrudStore(store, position, fromStore) {
      if (!store) return;

      if (!Array.isArray(store)) store = [store];

      if (!store.length) return;

      const me = this,
        data = [];

      // loop over list of stores to be added
      store.forEach((storeInfo) => {
        // if store instance provided
        if (storeInfo instanceof Store) {
          storeInfo = { store: storeInfo };
        } else if (typeof storeInfo === 'object') {
          // normalize sub-stores (if any)
          if (storeInfo.stores) {
            if (!Array.isArray(storeInfo.stores)) storeInfo.stores = [storeInfo.stores];

            storeInfo.stores.forEach((subStore, j) => {
              let subStoreInfo = subStore;

              if (typeof subStore === 'string') {
                subStoreInfo = { storeId: subStore };
              }

              // keep reference to the "master" store descriptor
              subStoreInfo.masterStoreInfo = storeInfo;

              storeInfo.stores[j] = subStoreInfo;
            });
          }

          // if it's a store identifier
        } else {
          storeInfo = { store: Store.getStore(storeInfo) };
        }

        data.push(me.fillStoreDescriptor(storeInfo));

        // if the store has "setCrudManager" hook - use it
        if (storeInfo.store.setCrudManager) {
          storeInfo.store.setCrudManager(me);

          // otherwise decorate the store w/ "crudManager" property
        } else {
          storeInfo.store.crudManager = me;
        }

        // Prevent AjaxStores from performing their own CRUD operations
        if (me.overrideCrudStoreLoad && storeInfo.store.load) {
          storeInfo.store.load = storeInfo.store.commit = () => {};
        }

        // listen to store changes
        me.bindCrudStoreListeners(storeInfo.store);
      });

      // if no position specified then append stores to the end
      if (typeof position === 'undefined') {
        me.crudStores.push.apply(me.crudStores, data);
        // if position specified
      } else {
        let pos = position;
        // if specified the store relative to which we should insert new one(-s)
        if (fromStore) {
          if (fromStore instanceof Store || typeof fromStore !== 'object') fromStore = me.getStoreDescriptor(fromStore);
          // get its position
          pos += me.crudStores.indexOf(fromStore);
        }
        // insert new store(-s)
        //me.crudStores.splice.apply(me.crudStores, [].concat([pos, 0], data));
        me.crudStores.splice(pos, 0, ...data);
      }

      me.updateCrudStoreIndex();
    }

    // Adds configured scheduler stores to the store collection ensuring correct order
    // unless they're already registered.
    addPrioritizedStore(store) {
      const me = this;

      if (!me.hasCrudStore(store)) {
        this.addCrudStore(store, ArrayHelper.findInsertionIndex(store, me.crudStores, storeLoadSortFn));
      }
      if (!me.hasApplySequenceStore(store)) {
        this.addStoreToApplySequence(
          store,
          ArrayHelper.findInsertionIndex(store, me.syncApplySequence, storeSyncSortFn)
        );
      }
    }

    hasCrudStore(store) {
      return this.crudStores.some((s) => s === store || s.store === store || s.storeId === store);
    }

    /**
     * Removes a store from collection. If the store was registered in alternative sync sequence list
     * it will be removed from there as well.
     *
     * ```javascript
     *    // remove store having storeId equal to "foo"
     *    crudManager.removeCrudStore("foo");
     *
     *    // remove store3
     *    crudManager.removeCrudStore(store3);
     * ```
     *
     * @param {Object|String|Common.data.Store} store The store to remove. Either the store descriptor, store identifier or store itself.
     */
    removeCrudStore(store) {
      const me = this,
        stores = me.crudStores;

      for (let i = 0, l = stores.length; i < l; i++) {
        const s = stores[i];
        if (s === store || s.store === store || s.storeId === store) {
          // unbind store listeners
          me.unbindCrudStoreListeners(s.store);

          delete me.crudStoresIndex[s.storeId];
          stores.splice(i, 1);
          if (me.syncApplySequence) {
            me.removeStoreFromApplySequence(store);
          }

          break;
        }
      }
    }

    //endregion

    //region Store listeners

    bindCrudStoreListeners(store, un) {
      const me = this,
        listeners = {
          update: me.onCrudStoreChange, //me.onStoreUpdate,
          removeall: me.onCrudStoreChange,
          detachable: true,
          thisObj: me
        };

      // TODO: destroying a store should remove listeners from it (should be default behaviour in Events)

      Object.assign(listeners, {
        add: me.onCrudStoreChange,
        remove: me.onCrudStoreChange
      });

      store.crudDetatcher = store.on(listeners);
    }

    unbindCrudStoreListeners(store) {
      store.crudDetatcher && store.crudDetatcher();
    }

    //endregion

    //region Apply sequence

    /**
     * Adds a store to the alternative sync responses apply sequence.
     * By default the order in which sync responses are applied to the stores is the same as they registered in.
     * But this order can be changes either on construction step using {@link #config-syncApplySequence} option
     * or but calling this method.
     *
     * **Please note**, that if the sequence was not initialized before this method call then
     * you will have to do it yourself like this for example:
     *
     *    ```javascript
     *    // alternative sequence was not set for this crud manager
     *    // so let's fill it with existing stores keeping the same order
     *    crudManager.addStoreToApplySequence(crudManager.crudStores);
     *
     *    // and now we can add our new store
     *
     *    // we will load its data last
     *    crudManager.addCrudStore(someNewStore);
     *    // but changes to it will be applied first
     *    crudManager.addStoreToApplySequence(someNewStore, 0);
     *    ```
     * add registered stores to the sequence along with the store(s) you want to add
     *
     * @param {Common.data.Store|Object|Common.data.Store[]|Object[]} store The store to add or its _descriptor_ (or array of stores or descriptors).
     * Where _store descriptor_ is an object having following properties:
     * @param {String} store.storeId The store identifier that will be used as a key in requests.
     * @param {Common.data.Store} store.store The store itself.
     * @param {String} [store.idField] The idField of the store. If not specified will be taken from the store model.
     * @param {String} [store.phantomIdField] The field holding unique Ids of phantom records (if store has such model).

     * @param {Number} [position] The relative position of the store. If `fromStore` is specified the this position will be taken relative to it.
     * If not specified then store(s) will be appended to the end of collection.
     * Otherwise it will be just a position in stores collection.
     *
     *    ```javascript
     *    // insert stores store4, store5 to the start of sequence
     *    crudManager.addStoreToApplySequence([ store4, store5 ], 0);
     *    ```
     * @param {String|Common.data.Store|object} [fromStore] The store relative to which position should be calculated. Can be defined as a store identifier, instance or its descriptor (the result of {@link #function-getStoreDescriptor} call).
     *
     *    ```javascript
     *    // insert store6 just before a store having storeId equal to 'foo'
     *    crudManager.addStoreToApplySequence(store6, 0, 'foo');
     *
     *    // insert store7 just after store3 store
     *    crudManager.addStoreToApplySequence(store7, 1, store3);
     *    ```
     */
    addStoreToApplySequence(store, position, fromStore) {
      if (!store) return;

      if (!Array.isArray(store)) store = [store];

      const me = this,
        // loop over list of stores to add
        data = store.reduce((collection, store) => {
          let s = me.getStoreDescriptor(store);
          if (s) collection.push(s);
          return collection;
        }, []);

      // if no position specified then append stores to the end
      if (typeof position === 'undefined') {
        me.syncApplySequence.push.apply(me.syncApplySequence, data);

        // if position specified
      } else {
        let pos = position;
        // if specified the store relative to which we should insert new one(-s)
        if (fromStore) {
          if (fromStore instanceof Store || typeof fromStore !== 'object') fromStore = me.getStoreDescriptor(fromStore);
          // get its position
          pos += me.syncApplySequence.indexOf(fromStore);
        }
        // insert new store(-s)
        //me.syncApplySequence.splice.apply(me.syncApplySequence, [].concat([pos, 0], data));
        me.syncApplySequence.splice(pos, 0, ...data);
      }
    }

    /**
     * Removes a store from the alternative sync sequence.
     *
     *    ```javascript
     *    // remove store having storeId equal to "foo"
     *    crudManager.removeCrudStore("foo");
     *
     *    // remove store3
     *    crudManager.removeCrudStore(store3);
     *    ```
     *
     * @param {Object|String|Common.data.Store} store The store to remove. Either the store descriptor, store identifier or store itself.
     */
    removeStoreFromApplySequence(store) {
      const index = this.syncApplySequence.findIndex((s) => s === store || s.store === store || s.storeId === store);
      if (index > -1) this.syncApplySequence.splice(index, 1);
    }

    hasApplySequenceStore(store) {
      return this.syncApplySequence.some((s) => s === store || s.store === store || s.storeId === store);
    }

    //endregion

    //region Events

    // onNodeRemove(oldParent) {
    //     var treeStore = oldParent && oldParent.getTreeStore();
    //     // "noderemove" event is fired too early and getRemovedRecords() don't not have the removed node yet
    //     // so we wait till tree store "endupdate" event and only then invoke "onCrudStoreChange" method
    //     treeStore && treeStore.on('endupdate', this.onCrudStoreChange, this, { once : true });
    // }

    // onStoreUpdate(store, record, operation, fields) {
    //     if ((!store.isTreeStore || record !== store.getRoot())) {
    //         // If only a single field was changed, make sure it's a persistable field to avoid full scan of the store
    //         // Collapsing/expanding a tree node will trigger this behavior otherwise
    //         var isSingleNonPersistField = fields && fields.length === 1 && record.getField(fields[0]) && !record.getField(fields[0]).persist;
    //
    //         if (!isSingleNonPersistField) {
    //             this.onCrudStoreChange();
    //         }
    //     }
    // }

    // onTreeStoreInsertOrAppend(parent, child) {
    //     if (!child.isRoot()) {
    //         this.onCrudStoreChange();
    //     }
    // }

    onCrudStoreChange() {
      const me = this;

      if (me.crudIgnoreUpdates) return;

      /**
       * Fires when any record in a registered stores is changed.
       * ```javascript
       *     crudManager.on('hasChanges', function (crud) {
       *         // enable persist changes button when some store gets changed
       *         saveButton.enable();
       *     });
       * ```
       * @event crudStoreHasChanges
       * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
       */

      if (me.crudStoreHasChanges()) {
        me.trigger('hasChanges');

        if (me.autoSync) {
          // add deferred call if it's not scheduled yet
          if (!me.autoSyncTimerId) {
            me.autoSyncTimerId = setTimeout(() => {
              me.autoSyncTimerId = null;
              me.sync();
            }, me.autoSyncTimeout);
          }
        }
      } else {
        me.trigger('noChanges');
      }
    }

    async internalOnResponse(requestType, responseText, responseOptions, options) {
      // reset last requested package ID
      const me = this;

      me.activeRequests[requestType] = null;

      let response = responseText ? me.decode(responseText) : null;

      if (!response || !response.success) {
        /**
         * Fires when a request fails.
         * @event requestfail
         * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager instance.
         * @param {String} requestType The request type (`sync` or `load`).
         * @param {Object} response The decoded server response object.
         * @param {Object} responseOptions The response options.
         */
        me.trigger('requestFail', { requestType, response, responseOptions });
        /**
         * Fires when a {@link #function-load load request} fails.
         * @event loadFail
         * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager instance.
         * @param {Object} response The decoded server response object.
         * @param {Object} responseOptions The response options.
         * @params {Object} options Options provided to the {@link #function-load} method.
         */
        /**
         * Fires when a {@link #function-sync sync request} fails.
         * @event syncFail
         * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager instance.
         * @param {Object} response The decoded server response object.
         * @param {Object} responseOptions The response options.
         */
        me.trigger(requestType + 'Fail', { response, responseOptions, options });

        me.warn('CrudManager: ' + requestType + ' failed, please inspect the server response');

        return response;
      }

      /**
       * Fires before server response gets applied to the stores. Return `false` to prevent data applying.
       * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
       * @event beforeresponseapply
       * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
       * @param {String} requestType The request type (`sync` or `load`).
       * @param {Object} response The decoded server response object.
       */
      /**
       * Fires before loaded data get applied to the stores. Return `false` to prevent data applying.
       * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
       * @event beforeloadapply
       * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
       * @param {Object} response The decoded server response object.
       * @param {Object} options Options provided to the {@link #function-load} method.
       */
      /**
       * Fires before sync response data get applied to the stores. Return `false` to prevent data applying.
       * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
       * @event beforesyncapply
       * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
       * @param {Object} response The decoded server response object.
       */
      if (
        me.trigger('beforeResponseApply', { requestType, response }) !== false &&
        me.trigger('before' + StringHelper.capitalizeFirstLetter(requestType) + 'Apply', {
          response,
          options
        }) !== false
      ) {
        me.crudRevision = response.revision;

        await me.applyResponse(requestType, response, options);

        /**
         * Fires on successful request completion after data gets applied to the stores.
         * @event requestdone
         * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
         * @param {String} requestType The request type (`sync` or `load`).
         * @param {Object} response The decoded server response object.
         * @param {Object} responseOptions The server response options.
         */
        me.trigger('requestDone', { requestType, response, responseOptions });
        /**
         * Fires on successful {@link #function-load load request} completion after data gets loaded to the stores.
         * @event load
         * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
         * @param {Object} response The decoded server response object.
         * @param {Object} responseOptions The server response options.
         * @params {Object} options Options provided to the {@link #load} method.
         */
        /**
         * Fires on successful {@link #function-sync sync request} completion.
         * @event sync
         * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
         * @param {Object} response The decoded server response object.
         * @param {Object} responseOptions The server response options.
         */
        me.trigger(requestType, { response, responseOptions, options });

        if (requestType === 'load' || !me.crudStoreHasChanges()) {
          /**
           * Fires when registered stores get into state when they don't have any
           * not persisted change. This happens after {@link #function-load load} or {@link #function-sync sync} request
           * completion. Or this may happen after a record update which turns its fields back to their original state.
           *
           * ```javascript
           *     crudManager.on('nochanges', function (crud) {
           *         // disable persist changes button when there is no changes
           *         saveButton.disable();
           *     });
           * ```
           *
           * @event nochanges
           * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
           */
          me.trigger('noChanges');
        }
      }

      return response;
    }

    async internalOnLoad(responseText, responseOptions, options) {
      // Successful load request, mark crud manager as loaded
      this.crudLoaded = true;

      return this.internalOnResponse('load', responseText, responseOptions, options);
    }

    async internalOnSync(responseText, responseOptions, options) {
      return this.internalOnResponse('sync', responseText, responseOptions, options);
    }

    //endregion

    //region Changes tracking

    suspendChangesTracking() {
      this.crudIgnoreUpdates++;
    }

    resumeChangesTracking(triggerCheck) {
      if (this.crudIgnoreUpdates && !--this.crudIgnoreUpdates) {
        if (triggerCheck) {
          this.onCrudStoreChange();
        }
      }
    }

    /**
     * Returns `true` if any of registered stores (or some particular store) has non persisted changes.
     *
     *    ```javascript
     *    // if we have any unsaved changes
     *    if (crudManager.crudStoreHasChanges()) {
     *        // persist them
     *        crudManager.sync();
     *    // otherwise
     *    } else {
     *        alert("There are no unsaved changes...");
     *    }
     *    ```
     *
     * @param {String|Common.data.Store} [storeId] The store identifier or store instance to check changes for.
     * If not specified then will check changes for all of the registered stores.
     * @returns {Boolean} `true` if there are not persisted changes.
     */
    crudStoreHasChanges(storeId) {
      if (storeId) {
        let store = this.getCrudStore(storeId);
        return store && this.isCrudStoreDirty(store);
      }

      return this.crudStores.some(this.isCrudStoreDirty);

      // for (var i = 0, l = this.crudStores.length; i < l; i++) {
      //     if (this.isCrudStoreDirty(this.crudStores[i].store)) return true;
      // }
      //
      // return false;
    }

    isCrudStoreDirty(store) {
      return store.store.changes != null;
    }

    //endregion

    //region Load

    emitCrudStoreEvents(stores, eventName) {
      const event = { action: 'read' + eventName };

      for (let store of this.crudStores) {
        if (stores.includes(store.storeId)) {
          store.store.trigger(eventName, event);
        }
      }
    }

    getLoadPackage(options) {
      const pack = {
          type: 'load',
          requestId: this.requestId
        },
        stores = this.crudStores,
        optionsCopy = Object.assign({}, options);

      pack.stores = stores.map((store) => {
        let //filterParam = store.filterParam || store.store.filterParam || this.crudFilterParam,
          opts = optionsCopy && optionsCopy[store.storeId],
          pageSize = store.pageSize || (store.store && store.store.pageSize);

        // TODO: PORT currently no support for remote filters
        // if the store uses remote filtering
        // if (store.store.remoteFilter && filterParam) {
        //
        //     opts = opts || {};
        //
        //     var filters = [];
        //
        //     store.store.getFilters().each(function(f) {
        //         filters.push(f.serialize());
        //     });
        //
        //     // put filters info into the package
        //     opts[filterParam] = filters;
        // }

        // TODO: PORT currently no support for paging
        if (opts || pageSize) {
          const params = Object.assign(
            {
              storeId: store.storeId,
              page: 1,
              pageSize: pageSize
            },
            opts
          );

          store.currentPage = params.page;

          // Remove from common request options
          if (opts) {
            delete optionsCopy[store.storeId];
          }

          return params;
        }

        return store.storeId;
      });

      // Apply common request options
      Object.assign(pack, optionsCopy);

      return pack;
    }

    loadCrudStore(store, data, options, storeDesc) {
      const rows = data && data.rows;

      if ((options && options.append) || data.append) {
        store.add(rows);
      } else {
        store.data = rows;
      }

      store.trigger('load', { source: store, data: rows });
    }

    loadDataToCrudStore(storeDesc, data, options) {
      let me = this,
        store = storeDesc.store,
        // nested stores list
        subStores = storeDesc.stores,
        idField = storeDesc.idField || 'id', //model && model.meta.idField || 'id',
        isTree = store.tree,
        subData,
        rows = data && data.rows;

      store.__loading = true;

      //TODO: PORT meta data on store?
      // apply server provided meta data to the store
      // if (metaData) {
      //     if (store.applyMetaData) {
      //         store.applyMetaData(metaData);
      //     } else {
      //         store.metaData = metaData;
      //     }
      // }

      if (rows) {
        if (subStores) {
          subData = me.getSubStoresData(rows, subStores, idField, isTree);
        }

        me.loadCrudStore(store, data, options, storeDesc);

        if (subData) {
          // load sub-stores as well (if we have them)
          subData.forEach((sub) => {
            me.loadDataToCrudStore(
              Object.assign(
                {
                  store: store.getById(sub.id).get(sub.storeDesc.storeId) // TODO: PORT have to check what this does
                },
                sub.storeDesc
              ),
              sub.data
            );
          });
        }
      }

      store.__loading = false;
    }

    loadCrudManagerData(response, options = {}) {
      // we don't want reacting on store changes during loading of them
      this.suspendChangesTracking();

      // we load data to the stores in the order they're kept in this.stores array
      this.crudStores.forEach((storeDesc) => {
        const storeId = storeDesc.storeId,
          data = response[storeId];

        if (data) {
          this.loadDataToCrudStore(storeDesc, data, options[storeId]);
        }
      });

      this.resumeChangesTracking();
    }

    /**
     * Returns true if the crud manager is currently loading data
     * @property {Boolean}
     * @readonly
     * @category CRUD
     */
    get isCrudManagerLoading() {
      return Boolean(this.activeRequests.load || this.applyingLoadResponse);
    }

    /**
     * Loads data to the stores registered in the crud manager. For example:
     *
     * ```javascript
     * crudManager.load(
     *     // here are request parameters
     *     {
     *         store1 : { append : true, page : 3, smth : 'foo' },
     *         store2 : { page : 2, bar : '!!!' }
     *     }
     * ).then(
     *     () => alert('OMG! It works!'),
     *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)
     * );
     * ```
     *
     * ** Note: ** If there is an incomplete load request in progress then system will try to cancel it by calling {@link #function-cancelRequest}.
     * @param {Object} options The request parameters. This argument can be omitted like this:
     *
     * ```javascript
     * crudManager.load().then(
     *     () => alert('OMG! It works!'),
     *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)
     * );
     * ```
     *
     * When presented it should be an object where keys are store Ids and values are, in turn, objects
     * of parameters related to the corresponding store. And these parameters will be transferred with a load request.
     *
     * ```javascript
     * {
     *     store1 : { page : 3, append : true, smth : 'foo' },
     *     store2 : { page : 2, bar : '!!!' }
     * },
     * ```
     *
     * Additionally for flat stores `append: true` can be specified to add loaded records to the existing records, default is to remove corresponding store's existing records first.
     * **Please note** that for delta loading you can also use an {@link #config-trackResponseType alternative approach}.
     * @returns {Promise} Promise, which is resolved if request was successful.
     * Both the resolve and reject functions are passed a `state` object. State object has following structure:
     *
     *     {
     *         cancelled   : Boolean, // **optional** flag, which is present when promise was rejected
     *         rawResponse : String, // raw response from ajax request, either response xml or text
     *         response    : Object, // processed response in form of object
     *         options     : Object  // options, passed to load request
     *     }
     *
     * If promise was rejected by {@link #event-beforeload} event, `state` object will have structure:
     *
     *     {
     *         cancelled : true
     *     }
     *
     */
    load(options) {
      const me = this,
        pack = me.getLoadPackage(options);

      return new Promise((resolve, reject) => {
        /**
         * Fires before {@link #function-load load request} is sent. Return `false` to cancel load request.
         * @event beforeload
         * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
         * @param {Object} request The request object.
         */
        if (me.trigger('beforeLoad', { pack }) !== false) {
          // if another load request is in progress let's cancel it
          if (me.activeRequests.load) {
            me.cancelRequest(me.activeRequests.load.desc);

            me.trigger('loadCanceled', { pack });
          }

          me.emitCrudStoreEvents(pack.stores, 'loadStart');

          me.activeRequests.load = {
            options,
            pack,
            resolve,
            reject,
            id: pack.requestId,
            desc: me.sendRequest({
              data: me.encode(pack),
              type: 'load',
              success: me.onLoadSuccess,
              failure: me.onLoadFailure,
              thisObj: me
            })
          };
        } else {
          /**
           * Fired after {@link #function-load load request} was canceled by some {@link #event-beforeload} listener
           * or due to incomplete prior load request.
           * @event loadcanceled
           * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
           * @param {Object} request The request object.
           */
          me.trigger('loadCanceled', { pack });
          reject({ cancelled: true });
        }
      });
    }

    async onLoadSuccess(rawResponse, responseOptions) {
      let responseText = '';

      const request = this.activeRequests.load,
        { options } = request;

      await rawResponse
        .text()
        .then((value) => (responseText = value))
        .catch(nullFn$1);

      const response = await this.internalOnLoad(responseText, responseOptions, options);

      this.emitCrudStoreEvents(request.pack.stores, 'afterRequest');

      if (!response || !response.success) {
        request.reject({ cancelled: false, response, rawResponse, options });
      } else {
        request.resolve({ response, rawResponse, options });
      }
    }

    async onLoadFailure(rawResponse, responseOptions) {
      let responseText = '';

      const request = this.activeRequests.load,
        { options } = request;

      await rawResponse
        .text()
        .then((value) => (responseText = value))
        .catch(nullFn$1);

      const response = await this.internalOnLoad(responseText, responseOptions, options);

      this.emitCrudStoreEvents(request.pack.stores, 'afterRequest');

      request.reject({ cancelled: false, response, rawResponse, options });
    }

    getSubStoresData(rows, subStores, idField, isTree) {
      if (!rows) return;

      let result = [];

      function processRow(row, subStores) {
        subStores.forEach((subStore) => {
          const storeId = subStore.storeId;

          // if row contains data for this sub-store
          if (row[storeId]) {
            // keep them for the later loading
            result.push({
              id: row[idField],
              storeDesc: subStore,
              data: row[storeId]
            });
            // and remove reference from the row
            delete row[storeId];
          }
        });
      }

      // if it's a TreeStore
      if (isTree) {
        // loop over nodes
        rows.forEach((row) => {
          processRow(row, subStores);

          // also let's grab sub-stores from node children
          const childrenSubData = this.getSubStoresData(row.children, subStores, idField, true);
          if (childrenSubData) {
            result = result.concat(childrenSubData);
          }
        });
        // if it's a "flat" store
      } else {
        rows.forEach((row) => processRow(row, subStores));
      }

      return result;
    }

    //endregion

    //region Changes (prepare, process, get)

    prepareAdded(list, phantomIdField, stores) {
      return list
        .filter((record) => record.isValid)
        .map((record) => {
          const data = Object.assign(record.persistableData, {
            [phantomIdField]: record.id
          });

          if (this.resetIdsBeforeSync) delete data[record.constructor.idField];

          // if the store has embedded ones
          if (stores) {
            this.processSubStores(record, data, stores);
          }

          return data;
        });
    }

    prepareUpdated(list, stores, storeInfo) {
      let writeAllFields = storeInfo.writeAllFields || (storeInfo.writeAllFields !== false && this.writeAllFields);

      // TODO: root node included into store.modified
      // need to get rid of it since we don't persist it
      if (storeInfo.store.tree) {
        const rootNode = storeInfo.store.rootNode;
        list = list.filter((record) => record !== rootNode);
      }

      return list
        .filter((record) => record.isValid)
        .reduce((data, record) => {
          let recordData;

          // write all fields
          if (writeAllFields) {
            recordData = record.persistableData;
            recordData[record.constructor.idField] = record.id;
          } else {
            recordData = record.modifications;
            recordData[record.constructor.idField] = record.id;

            // TODO: PORT critical fields
            // critical fields should always be presented
            // const criticalFields = record.getCriticalFields();
            //
            // for (var j = 0; j < criticalFields.length; j++) {
            //     field = criticalFields[j];
            //
            //     if (field.serialize) {
            //         data[field.getName()] = field.serialize(record.get(field.getName()), record);
            //     } else {
            //         data[field.getName()] = record.get(field.getName());
            //     }
            // }
          }

          // if the store has embedded ones
          if (stores) {
            this.processSubStores(record, recordData, stores);
          }

          const persistableFields = Object.keys(recordData);

          if (persistableFields.length > 1 || persistableFields[0] !== record.constructor.idField) {
            data.push(recordData);
          }

          return data;
        }, []);
    }

    prepareRemoved(list) {
      return list.map((record) => ({ [record.constructor.idField]: record.id }));
    }

    processSubStores(record, data, stores) {
      stores.forEach((store) => {
        const id = store.storeId,
          subStore = record.get(id);
        // if embedded store is assigned to the record
        if (subStore) {
          // let's collect its changes as well
          let changes = this.getCrudStoreChanges(Object.assign({ store: subStore }, store));

          if (changes) {
            data[id] = Object.assign(changes, { $store: true });
          } else {
            delete data[id];
          }
        } else {
          delete data[id];
        }
      });
    }

    getCrudStoreChanges(store, phantomIdField = store.phantomIdField || this.phantomIdField) {
      let s = store.store,
        added = s.added.values,
        updated = s.modified.values,
        removed = s.removed.values,
        // sub-stores
        stores = store.stores,
        result;

      if (added.length) added = this.prepareAdded(added, phantomIdField, stores);
      if (updated.length) updated = this.prepareUpdated(updated, stores, store);
      if (removed.length) removed = this.prepareRemoved(removed);

      // if this store has changes
      if (added.length || updated.length || removed.length) {
        result = {};

        if (added.length) result.added = added;
        if (updated.length) result.updated = updated;
        if (removed.length) result.removed = removed;
      }

      return result;
    }

    getChangeSetPackage() {
      let pack = {
          type: 'sync',
          requestId: this.requestId,
          revision: this.crudRevision
        },
        found = 0;

      this.crudStores.forEach((store) => {
        const changes = this.getCrudStoreChanges(store);
        if (changes) {
          found++;
          pack[store.storeId] = changes;
        }
      });

      return found ? pack : null;
    }

    //endregion

    //region Apply

    applyChangesToRecord(record, rawChanges, stores, store) {
      const me = this,
        modelClass = record.constructor,
        { fieldDataSourceMap } = modelClass,
        recProto = modelClass.prototype,
        changes = {},
        data = record.data,
        done = {
          [me.phantomIdField]: true
        };

      let hasChanges;

      // if this store has sub-stores assigned to some fields
      if (stores) {
        // then first we apply changes to that stores
        stores.forEach((store) => {
          const name = store.storeId;

          if (rawChanges.hasOwnProperty(name)) {
            // remember that we processed this field
            done[name] = true;

            const subStore = record.get(name);
            if (subStore) {
              me.applyChangesToStore(Object.assign({ store: subStore }, store), rawChanges[name]);
            } else {
              console.log("Can't find store for the response sub-package");
            }
          }
        });
      }

      // Collect the changes into a change set for field names.
      for (const dataSource in rawChanges) {
        if (rawChanges.hasOwnProperty(dataSource) && !done[dataSource]) {
          const field = fieldDataSourceMap[dataSource],
            propName = field ? field.name : dataSource,
            value = modelClass.processField(propName, rawChanges[dataSource]),
            oldValue = dataSource in recProto ? record[propName] : ObjectHelper.getPath(data, dataSource);

          if (!ObjectHelper.isEqual(oldValue, value)) {
            hasChanges = true;
            changes[propName] = value;
          }
        }
      }

      if (hasChanges) {
        me.suspendChangesTracking();

        // Set each field seterately until https://app.assembla.com/spaces/bryntum/tickets/9123is fixed.
        for (const fieldName in changes) {
          record[fieldName] = changes[fieldName];
        }

        // TODO: Re-enable record.set when https://app.assembla.com/spaces/bryntum/tickets/9123 is fixed.
        // Set fields one go
        // record.set(changes);
        me.resumeChangesTracking();

        // Clear changes only for the passed record,
        // not descendant nodes.
        // TODO: they *might* also be genuinely new
        // so might have to stay.
        record.clearChanges(true, false);
      }
    }

    applyRemovals(store, removed, context) {
      let removedStash = store.removed,
        findByIdFn = context.findByIdFn,
        removeRecordFn = context.removeRecordFn,
        applied = 0;

      removed.forEach((remove) => {
        let done = false,
          id = remove.id;

        // just remove the record from the removed stash
        if (removedStash.includes(remove)) {
          removedStash.remove(remove);
          done = true;
          // number of removals applied
          applied++;
        }

        // if responded removed record isn`t found in store.removed
        // probably don't removed on the client side yet (server driven removal)
        if (!done) {
          let record = findByIdFn(id);

          if (record) {
            this.suspendChangesTracking();

            removeRecordFn(record);

            removedStash.remove(record);
            // number of removals applied
            applied++;

            this.resumeChangesTracking();
          } else {
            console.log("Can't find record to remove from the response package");
          }
        }
      });

      return applied;
    }

    getApplyChangesToStoreHelpers(store) {
      // if it's a tree store
      if (store.tree) {
        return {
          findByPhantomFn: (id) => store.getById(id),
          findByIdFn: (id) => store.getById(id),
          // TODO: need to support parentIdProperty
          addRecordFn: (data) => {
            const parent = (data.parentId && store.getById(data.parentId)) || store.rootNode;

            return parent.appendChild(data);
          },
          removeRecordFn: (record) => record.remove()
        };

        // plain store
      } else {
        return {
          findByPhantomFn: (id) => store.getById(id),
          findByIdFn: (id) => store.getById(id),
          addRecordFn: (data) => store.add(data)[0],
          removeRecordFn: (record) => store.remove(record)
        };
      }
    }

    async applyChangesToStore(storeDesc, storeResponse) {
      const me = this,
        phantomIdField = storeDesc.phantomIdField || me.phantomIdField,
        idField = storeDesc.idField || 'id',
        store = storeDesc.store,
        { findByPhantomFn, findByIdFn, addRecordFn, removeRecordFn } = me.getApplyChangesToStoreHelpers(store),
        { rows, removed } = storeResponse;

      // process added/updated records
      if (rows) {
        // sub-stores
        const stores = storeDesc.stores;

        rows.forEach((data) => {
          const phantomId = data[phantomIdField],
            id = data[idField];

          let record = null;

          // if phantomId is provided then we will use it to find added record
          if (phantomId != null && phantomId != null) {
            record = findByPhantomFn(phantomId);
          }
          // if id is provided then we will use it to find updated record
          else if (idField) {
            record = findByIdFn(id);
          }

          if (record) {
            me.applyChangesToRecord(record, data, stores, store);
          } else {
            me.suspendChangesTracking();

            // create new record in the store
            record = addRecordFn(data);

            me.resumeChangesTracking();

            record.clearChanges();
          }
        });
      }

      // process removed records
      if (
        removed &&
        me.applyRemovals(store, removed, {
          idField,
          findByIdFn,
          removeRecordFn
        })
      ) {
        store.trigger('dataChanged', { source: store });
      }
    }

    async applySyncResponse(response) {
      const me = this,
        // we apply received changes to the stores in the order they're kept in either this.syncApplySequence or this.stores array
        stores = me.syncApplySequence.length ? me.syncApplySequence : me.crudStores;

      me.applyingSyncResponse = true;

      stores.forEach(async (store) => {
        const storeResponse = response[store.storeId];
        if (storeResponse) {
          await me.applyChangesToStore(store, storeResponse);
        }
      });

      me.applyingSyncResponse = false;
    }

    async applyLoadResponse(response, options) {
      this.applyingLoadResponse = true;

      this.loadCrudManagerData(response, options);

      this.applyingLoadResponse = false;
    }

    async applyResponse(requestType, response, options) {
      // in trackResponseType we check response type before deciding how to react on the response
      if (this.trackResponseType) {
        requestType = response.type || requestType;
      }

      switch (requestType) {
        case 'load':
          await this.applyLoadResponse(response, options);
          break;
        case 'sync':
          await this.applySyncResponse(response);
          break;
      }
    }

    //endregion

    /**
     * Generates unique request identifier.
     * @internal
     * @template
     * @return {Number} The request identifier.
     */
    get requestId() {
      return Date.now() + '' + this._requestId++;
    }

    /**
     * Persists changes made on the registered stores to the server. Usage:
     *
     * ```javascript
     * // persist and run a callback on request completion
     * crud.sync().then(
     *     () => console.log("Changes saved..."),
     *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)
     * );
     * ```
     *
     * ** Note: ** If there is an incomplete sync request in progress then system will queue the call and delay it until previous request completion.
     * In this case {@link #event-syncdelayed} event will be fired.
     *
     * ** Note: ** Please take a look at {@link #config-autoSync} config. This option allows to persist changes automatically after any data modification.
     * @returns {Promise} Promise, which is resolved if request was successful.
     * Both the resolve and reject functions are passed a `state` object. State object has following structure:
     *
     *     {
     *         cancelled   : Boolean, // **optional** flag, which is present when promise was rejected
     *         rawResponse : String, // raw response from ajax request, either response xml or text
     *         response    : Object, // processed response in form of object
     *     }
     *
     * If promise was rejected by {@link #event-beforesync} event, `state` object will have structure:
     *
     *     {
     *         cancelled : true
     *     }
     *
     */
    sync() {
      const me = this;

      if (me.activeRequests.sync) {
        // let's delay this call and start it only after server response
        /**
         * Fires after {@link #function-sync sync request} was delayed due to incomplete previous one.
         * @event syncdelayed
         * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
         * @param {Object} arguments The arguments of {@link #function-sync} call.
         */
        me.trigger('syncDelayed');

        // Queue sync request after current one
        return (me.activeSyncPromise = me.activeSyncPromise.then(
          () => me.sync(),
          () => me.sync()
        ));
      }

      // Store current requrest promise. While this one is pending, all following sync requests will create chain
      // of sequential promises
      return (me.activeSyncPromise = new Promise((resolve, reject) => {
        // get current changes set package
        const pack = me.getChangeSetPackage();

        // if no data to persist we resolve immediately
        if (!pack) {
          resolve(null);
          return;
        }

        /**
         * Fires before {@link #function-sync sync request} is sent. Return `false` to cancel sync request.
         *
         * ```javascript
         *     crudManager.on('beforesync', function() {
         *        // cannot persist changes before at least one record is added
         *        // to the `someStore` store
         *        if (!someStore.getCount()) return false;
         *     });
         * ```
         * @event beforesync
         * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
         * @param {Object} request The request object.
         */
        if (me.trigger('beforeSync', { pack }) !== false) {
          // keep active request details
          me.activeRequests.sync = {
            pack,
            resolve,
            reject,
            id: pack.requestId,
            desc: me.sendRequest({
              data: me.encode(pack),
              type: 'sync',
              success: me.onSyncSuccess,
              failure: me.onSyncFailure,
              thisObj: me
            })
          };
        } else {
          // if this sync was canceled let's fire event about it
          /**
           * Fires after {@link #function-sync sync request} was canceled by some {@link #event-beforesync} listener.
           * @event synccanceled
           * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
           * @param {Object} request The request object.
           */
          me.trigger('syncCanceled', { pack });
          reject({ cancelled: true });
        }
      }));
    }

    async onSyncSuccess(rawResponse, responseOptions) {
      let responseText = '';

      await rawResponse
        .text()
        .then((value) => (responseText = value))
        .catch(nullFn$1);

      const request = this.activeRequests.sync,
        response = await this.internalOnSync(responseText, responseOptions);

      if (!response || !response.success) {
        request.reject({ cancelled: false, response, rawResponse, request });
      } else {
        request.resolve({ response, rawResponse, request });
      }
    }

    async onSyncFailure(rawResponse, responseOptions) {
      let responseText = '';

      await rawResponse
        .text()
        .then((value) => (responseText = value))
        .catch(nullFn$1);

      const request = this.activeRequests.sync,
        response = await this.internalOnSync(responseText, responseOptions);

      request.reject({ cancelled: false, response, rawResponse, request });
    }

    /**
     * Commits all records changes of all the registered stores.
     */
    commitCrudStores() {
      this.crudStores.forEach((store) => store.store.commit());
    }

    /**
     * Rejects all records changes on all stores and re-insert any records that were removed locally. Any phantom records will be removed.
     */
    rejectCrudStores() {
      this.crudStores.forEach((store) => store.store.clearChanges());
    }

    warn() {
      if ('console' in window) {
        let c = console;
        c.log && c.log.apply && c.log.apply(c, arguments);
      }
    }

    /**
     * Removes all stores and cancels active requests.
     */
    doDestroy() {
      const me = this;

      me.activeRequests.load && me.cancelRequest(me.activeRequests.load.desc);
      me.activeRequests.sync && me.cancelRequest(me.activeRequests.sync.desc);

      while (me.crudStores.length > 0) {
        me.removeCrudStore(me.crudStores[0]);
      }

      clearTimeout(me.autoSyncTimerId);

      me.destroyed = true;
    }

    // set crudRevision(value) {
    //     debugger
    //     this._crudRevision = value;
    // }

    // get crudRevision() {
    //     return this._crudRevision;
    // }
  };

/**
 * @module Scheduler/crud/AbstractCrudManager
 */

/**
 * This is an abstract class serving as the base for the {@link Scheduler.data.CrudManager} class.
 * It implements basic mechanisms to organize batch communication with a server.
 * Yet it does not contain methods related to _data transfer_ nor _encoding_.
 * These methods are to be provided in sub-classes by consuming the appropriate mixins.
 *
 * For example, this is how the class can be used to implement an JSON encoding system:
 *
 * ```javascript
 * // let's make new CrudManager using AJAX as a transport system and JSON for encoding
 * class MyCrudManager extends JsonEncode(AjaxTransport(AbstractCrudManager)) {
 *
 * }
 * ```
 *
 * ## Data transfer and encoding methods
 * These are methods that must be provided by subclasses of this class:
 *
 * - [#sendRequest](#Scheduler/crud/AbstractCrudManagerMixin#function-sendRequest)
 * - [#cancelRequest](#Scheduler/crud/AbstractCrudManagerMixin#function-cancelRequest)
 * - [#encode](#Scheduler/crud/AbstractCrudManagerMixin#function-encode)
 * - [#decode](#Scheduler/crud/AbstractCrudManagerMixin#function-decode)
 *
 * @extends Common/Base
 * @mixes Common/mixin/Events
 * @mixes Scheduler/crud/AbstractCrudManagerMixin
 * @abstract
 */
class AbstractCrudManager extends AbstractCrudManagerMixin(Events(Base)) {
  //region Default config

  /**
   * The server revision stamp.
   * The _revision stamp_ is a number which should be incremented after each server-side change.
   * This property reflects the current version of the data retrieved from the server and gets updated after each {@link Scheduler/crud/AbstractCrudManagerMixin#function-load} and {@link Scheduler/crud/AbstractCrudManagerMixin#function-sync} call.
   * @property {Number} revision
   * @readonly
   */
  get revision() {
    return this.crudRevision;
  }

  set revision(value) {
    this.crudRevision = value;
  }

  static get defaultConfig() {
    // debugger
    return Object.assign({}, this.crudManagerDefaultConfig, {
      overrideCrudStoreLoad: true,

      /**
       * Sets the list of stores controlled by the CRUD manager.
       * Store can be provided by itself, its storeId or an object having the following structure:
       * @property {String} stores.storeId Unique store identifier. Under this name the store related requests/responses will be sent.
       * @property {Common.data.Store} stores.store The store itself.
       * @property {String} [stores.phantomIdField] Set this if the store model has a predefined field to keep phantom record identifier.
       * @property {String} [stores.idField] id field name, if it's not specified then class will try to get it from a store model.
       * @config {Common.data.Store[]|String[]|Object[]}
       */
      stores: null

      /**
       * Encodes request to the server.
       * @function encode
       * @param {Object} request The request to encode.
       * @returns {String} The encoded request.
       * @abstract
       */

      /**
       * Decodes response from the server.
       * @function decode
       * @param {String} response The response to decode.
       * @returns {Object} The decoded response.
       * @abstract
       */
    });
  }

  //endregion

  //region Init

  construct(config = {}) {
    if (config.stores) {
      config.crudStores = config.stores;
      delete config.stores;
    }

    super.construct(config);
  }

  //endregion

  //region Store collection (add, remove, get & iterate)

  set stores(stores) {
    // debugger
    if (stores !== this.crudStores) {
      this.crudStores = stores;
    }
  }

  /**
   * A list of registered stores whose server communication will be collected into a single batch.
   * Each store is represented by a _store descriptor_, an object having following structure:
   * @member {Object[]} stores
   * @property {String} stores.storeId Unique store identifier.
   * @property {Common.data.Store} stores.store Store itself.
   * @property {String} [stores.phantomIdField] Set this if store model has a predefined field to keep phantom record identifier.
   * @property {String} [stores.idField] id field name, if it's not specified then class will try to get it from a store model.
   */
  get stores() {
    return this.crudStores;
  }

  //endregion

  /**
   * Returns true if the crud manager is currently loading data
   * @property {Boolean}
   * @readonly
   * @category CRUD
   */
  get isLoading() {
    return this.isCrudManagerLoading;
  }

  /**
   * Commits all records changes of all the registered stores.
   */
  commit() {
    this.commitCrudStores();
  }

  /**
   * Rejects all records changes on all stores and re-insert any records that were removed locally. Any phantom records will be removed.
   */
  reject() {
    this.rejectCrudStores();
  }

  /**
   * Adds a store to the collection.
   *
   *```javascript
   * // append stores to the end of collection
   * crudManager.addStore([
   *     store1,
   *     // storeId
   *     'bar',
   *     // store descriptor
   *     {
   *         storeId : 'foo',
   *         store   : store3
   *     },
   *     {
   *         storeId         : 'bar',
   *         store           : store4,
   *         // to write all fields of modified records
   *         writeAllFields  : true
   *     }
   * ]);
   *```
   *
   * **Note:** Order in which stores are kept in the collection is very essential sometimes.
   * Exactly in this order the loaded data will be put into each store.
   * @param {Common.data.Store|String|Object|Common.data.Store[]|String[]|Object[]} store
   * A store or list of stores. Each store might be specified by its instance, `storeId` or _descriptor_.
   * The _store descriptor_ is an object having following properties:
   * @param {String} store.storeId The store identifier that will be used as a key in requests.
   * @param {Common.data.Store} store.store The store itself.
   * @param {String} [store.idField] The idField of the store. If not specified will be taken from the store model.
   * @param {String} [store.phantomIdField] The field holding unique Ids of phantom records (if store has such model).
   * @param {Boolean} [store.writeAllFields] Set to true to write all fields from modified records
   * @param {Number} [position] The relative position of the store. If `fromStore` is specified the this position will be taken relative to it.
   * If not specified then store(s) will be appended to the end of collection.
   * Otherwise it will be just a position in stores collection.
   *
   * ```javascript
   * // insert stores store4, store5 to the start of collection
   * crudManager.addStore([ store4, store5 ], 0);
   * ```
   *
   * @param {String|Common.data.Store|Object} [fromStore] The store relative to which position should be calculated. Can be defined as a store identifier, instance or descriptor (the result of {@link Scheduler/crud/AbstractCrudManagerMixin#function-getStoreDescriptor} call).
   *
   * ```javascript
   * // insert store6 just before a store having storeId equal to 'foo'
   * crudManager.addStore(store6, 0, 'foo');
   *
   * // insert store7 just after store3 store
   * crudManager.addStore(store7, 1, store3);
   * ```
   */
  addStore(...args) {
    return this.addCrudStore(...args);
  }

  removeStore(...args) {
    return this.removeCrudStore(...args);
  }

  getStore(...args) {
    return this.getCrudStore(...args);
  }

  hasChanges(...args) {
    return this.crudStoreHasChanges(...args);
  }

  loadData(...args) {
    return this.loadCrudManagerData(...args);
  }
}
AbstractCrudManager._$name = 'AbstractCrudManager';

/**
 * @module Scheduler/crud/encoder/JsonEncoder
 */

/**
 * Implements data encoding functional that should be mixed to a {@link Scheduler.crud.AbstractCrudManager} sub-class.
 * Uses _JSON_ as an encoding system.
 *
 * @example
 * // create a new CrudManager using AJAX as a transport system and JSON for encoding
 * class MyCrudManager extends JsonEncode(AjaxTransport(AbstractCrudManager)) {}
 *
 * @mixin
 */
var JsonEncoder = (Target) =>
  class JsonEncoder extends (Target || Base) {
    //format  : 'json',

    /**
     * Encodes an request object to _JSON_ encoded string. If encoding fails (due to circular structure), it returns null.
     * @param {Object} request The request to encode.
     * @returns {String} The encoded request.
     */
    encode(requestConfig) {
      return StringHelper.safeJsonStringify(requestConfig);
    }

    /**
     * Decodes (parses) a _JSON_ response string to an object. If parsing fails, it returns null.
     * @param {String} responseText The response text to decode.
     * @returns {Object} The decoded response.
     */
    decode(responseText) {
      return StringHelper.safeJsonParse(responseText);
    }
  };

/**
 * @module Scheduler/model/AssignmentModel
 */

/**
 * This class represent a single assignment of a resource to an event in scheduler.
 * It is a subclass of {@link Common.data.Model} class.
 * Please refer to the documentation for that class to become familiar with the base interface of this class.
 *
 * An Assignment has the following fields:
 * - `id` - The id of the assignment
 * - `resourceId` - The id of the resource assigned
 * - `eventId` - The id of the event to which the resource is assigned
 *
 * The data source for these fields can be customized by subclassing this class.
 *
 * @extends Common/data/Model
 */
class AssignmentModel extends Model {
  //region Fields
  static get fields() {
    return [
      /**
       * Id for the resource assigned
       * @field {String|Number} resourceId
       */
      { name: 'resourceId' },

      /**
       * Id for the event assigned
       * @field {String|Number} eventId
       */
      { name: 'eventId' }
    ];
  }

  static get relationConfig() {
    return [
      /**
       * Resource assigned
       * @member {Scheduler.model.ResourceModel} resource
       */
      { relationName: 'resource', fieldName: 'resourceId', store: 'resourceStore', collectionName: 'assignments' },

      /**
       * Event assigned
       * @member {Scheduler.model.EventModel} event
       */
      { relationName: 'event', fieldName: 'eventId', store: 'eventStore', collectionName: 'assignments' }
    ];
  }
  //endregion

  //region Stores

  /**
   * Returns an assigment store this assignment is part of. Assignment must be part of an assigment store
   * to be able to retrieve it.
   *
   * @return {Scheduler.data.AssignmentStore}
   */
  get assignmentStore() {
    return this.stores && this.stores[0];
  }

  /**
   * Returns an event store this assignment uses as default event store. Assignment must be part
   * of an assignment store to be able to retrieve default event store.
   *
   * @return {Scheduler.data.EventStore}
   */
  get eventStore() {
    const { assignmentStore } = this;
    return assignmentStore && assignmentStore.eventStore;
  }

  /**
   * Returns a resource store this assignment uses as default resource store. Assignment must be part
   * of an assignment store to be able to retrieve default resource store.
   *
   * @return {Scheduler.data.ResourceStore}
   */
  get resourceStore() {
    const { eventStore } = this;
    return eventStore && eventStore.resourceStore;
  }

  //endregion

  //region Event & resource

  /**
   * Convenience property to get the name of the associated event.
   * @property {String}
   * @readonly
   */
  get eventName() {
    return this.event && this.event.name;
  }

  /**
   * Convenience property to get the name of the associated resource.
   * @property {String}
   * @readonly
   */
  get resourceName() {
    return this.resource && this.resource.name;
  }

  // /**
  //  * Returns an event associated with this assignment.
  //  *
  //  * @privateparam  {Scheduler.data.EventStore} [eventStore]
  //  * @return {Scheduler.model.TimeSpan} Event instance
  //  */
  // getEvent(eventStore = this.eventStore) {
  //     // removed assignment will not have "this.joined" so we are providing a way to get an event via provided
  //     // event store
  //     return eventStore && eventStore.getById(this.eventId);
  // }

  /**
   * Returns the resource associated with this assignment.
   *
   * @privateparam {Scheduler.data.ResourceStore} [resourceStore]
   * @return {Scheduler.model.ResourceModel} Instance of resource
   */
  getResource(resourceStore = this.resourceStore) {
    // removed assignment will not have "this.joined" so we are providing a way to get a resource via provided
    // resource store
    return resourceStore && resourceStore.getById(this.resourceId);
  }

  // /**
  //  * Convenience method to get a name of the associated event.
  //  *
  //  * @privateparam  {Scheduler.data.EventStore} [eventStore]
  //  * @return {String} name
  //  */
  // getEventName(eventStore) {
  //     const evnt = this.getEvent(eventStore);
  //     return evnt && evnt.name || '';
  // }

  // /**
  //  * Convenience method to get a name of the associated resource.
  //  *
  //  * @privateparam {Scheduler.data.ResourceStore} [resourceStore]
  //  * @return {String} name
  //  */
  // getResourceName(resourceStore) {
  //     const resource = this.getResource(resourceStore);
  //     return resource && resource.name || '';
  // }

  //endregion

  // Convenience getter to not have to check `instanceof AssignmentModel`
  get isAssignment() {
    return true;
  }

  /**
   * Returns true if the Assignment can be persisted (e.g. task and resource are not 'phantoms')
   *
   * @return {Boolean} true if this model can be persisted to server.
   */
  get isPersistable() {
    const { event, resource } = this;

    return this.isValid && !event.hasGeneratedId && !resource.hasGeneratedId;
  }

  get isValid() {
    return this.resource != null && this.event != null;
  }

  fullCopy() {
    // NOT IMPLEMENTED
    //return this.copy.apply(this, arguments);
    throw new Error('Not implemented');
  }

  // private
  get eventResourceCompositeKey() {
    return AssignmentModel.makeAssignmentEventResourceCompositeKey(this.eventId, this.resourceId);
  }

  static makeAssignmentEventResourceCompositeKey(eventId, resourceId) {
    return `event(${eventId})-resource(${resourceId})`;
  }
}

AssignmentModel.exposeProperties();
AssignmentModel._$name = 'AssignmentModel';

/**
 * @module Scheduler/data/AssignmentStore
 */

/**
 * A class representing a collection of assignments between events in the {@link Scheduler.data.EventStore} and resources
 * in the {@link Scheduler.data.ResourceStore}.
 *
 * Contains a collection of {@link Scheduler.model.AssignmentModel} records.
 *
 * @extends Common/data/Store
 */
class AssignmentStore extends AjaxStore {
  static get defaultConfig() {
    return {
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 300,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 300,

      modelClass: AssignmentModel
    };
  }

  //region Init & destroy

  doDestroy() {
    const me = this;
    me.eventStoreDetacher && me.eventStoreDetacher();
    me.resourceStoreDetacher && me.resourceStoreDetacher();
    super.doDestroy();
  }

  //endregion

  //region Stores

  /**
   * Get/set the associated event store instance.  Usually it is configured automatically, by the event store itself.
   *
   * @param {Scheduler.data.EventStore}
   */
  get eventStore() {
    return this._eventStore;
  }

  set eventStore(eventStore) {
    const me = this,
      oldStore = me._eventStore;

    me._eventStore = eventStore || null;

    me.attachToEventStore(me._eventStore);

    if ((oldStore || eventStore) && oldStore !== eventStore) {
      /**
       * Fires when new event store is set via {@link #property-eventStore} method.
       * @event eventstorechange
       * @param {Scheduler.data.AssignmentStore} this
       * @param {Scheduler.data.EventStore} newEventStore
       * @param {Scheduler.data.EventStore} oldEventStore
       */
      me.trigger('eventStoreChange', { newEventStore: eventStore, oldEventStore: oldStore });
    }
  }

  attachToEventStore(eventStore) {
    const me = this;

    me.eventStoreDetacher && me.eventStoreDetacher();

    if (eventStore) {
      me.eventStoreDetacher = eventStore.on({
        remove: me.onEventRemove,
        resourcestorechange: me.onEventStoreResourceStoreChange,
        thisObj: me,
        prio: 200 // higher then in cache, we need those handlers to do their job before cache update
      });
    }

    // If store is assigned after configuration we need to init relations
    if (!me.isConfiguring) {
      me.initRelations(true);
    }

    me.attachToResourceStore(eventStore && eventStore.resourceStore);
  }

  attachToResourceStore(resourceStore) {
    const me = this;

    me.resourceStore = resourceStore;

    me.resourceStoreDetacher && me.resourceStoreDetacher();

    if (resourceStore) {
      me.resourceStoreDetacher = resourceStore.on({
        remove: me.onResourceRemove,
        removeAll: me.onResourceRemoveAll,
        thisObj: me,
        prio: 200 // higher then in cache
      });

      // If store is assigned after configuration we need to init relations
      if (!me.isConfiguring) {
        me.initRelations(true);
      }
    }
  }

  onEventStoreResourceStoreChange({ newResourceStore }) {
    this.attachToResourceStore(newResourceStore);
  }

  //endregion

  //region Event & resource events

  // TODO: We have no isMove in our stores
  onEventRemove({ records, isMove, isCollapse }) {
    if (!isMove && !isCollapse) {
      const assignments = [];

      records.forEach((record) => {
        // traversing in a flat structure will only call fn on self, no need to handle tree case differently
        record.traverse((eventRecord) => {
          assignments.push(...eventRecord.assignments);
        });
      });

      // Flag that remove is caused by removing events, to prevent getting stuck in removal loop in SchedulerStores
      this.isRemovingEvent = true;
      assignments.length && this.remove(assignments);
      this.isRemovingEvent = false;
    }
  }

  // TODO: We have no isMove in our stores
  onResourceRemove({ records, isMove, isCollapse }) {
    if (!isMove && !isCollapse) {
      const assignments = [];

      records.forEach((record) => {
        // traversing in a flat structure will only call fn on self, no need to handle tree case differently
        record.traverse((resourceRecord) => {
          assignments.push(...resourceRecord.assignments);
        });
      });

      // TODO: Make resource removal behaviour configurable
      assignments.length && this.remove(assignments);
    }
  }

  onResourceRemoveAll() {
    // TODO: Make resource removal behaviour configurable
    this.removeAll();
  }

  //endregion

  //region Mapping

  /**
   * Maps over event assignments.
   *
   * @param {Scheduler.model.EventModel} event
   * @param {Function} [fn]
   * @param {Function} [filterFn]
   * @return {Array}
   */
  mapAssignmentsForEvent(event, fn, filterFn) {
    const me = this,
      fnSet = Boolean(fn),
      filterFnSet = Boolean(filterFn),
      eventId = Model.asId(event),
      assignmentCache = me.relationCache.event && me.relationCache.event[eventId];

    if (!assignmentCache) return [];

    fn = fn || ((a) => a);
    filterFn = filterFn || (() => true);

    if (fnSet || filterFnSet) {
      return assignmentCache.reduce((result, assignment) => {
        const mapResult = fn(assignment);

        if (filterFn(mapResult)) {
          //result = result.concat([mapResult]);
          result.push(mapResult);
        }

        return result;
      }, []);
    }

    return assignmentCache;
  }

  /**
   * Maps over resource assignments.
   *
   * @param {Scheduler.model.ResourceModel|Number|String} resource
   * @param {Function} [fn]
   * @param {Function} [filterFn]
   * @return {Scheduler.model.ResourceModel[]}
   */
  mapAssignmentsForResource(resource, fn, filterFn) {
    const me = this,
      fnSet = Boolean(fn),
      filterFnSet = Boolean(filterFn),
      resourceId = Model.asId(resource),
      assignmentCache = me.relationCache.resource && me.relationCache.resource[resourceId];

    if (!assignmentCache) return [];

    fn = fn || ((a) => a);
    filterFn = filterFn || (() => true);

    if (fnSet || filterFnSet) {
      return assignmentCache.reduce((result, assignment) => {
        const mapResult = fn(assignment);

        if (filterFn(mapResult)) {
          //result = result.concat([mapResult]);
          result.push(mapResult);
        }

        return result;
      }, []);
    }

    return assignmentCache;
  }

  /**
   * Returns all assignments for a given event.
   *
   * @param {Scheduler.model.TimeSpan} event
   * @return {Scheduler.model.AssignmentModel[]}
   */
  getAssignmentsForEvent(event) {
    return event.assignments;
  }

  /**
   * Removes all assignments for given event
   *
   * @param {Scheduler.model.TimeSpan|Object} event
   */
  removeAssignmentsForEvent(event) {
    return this.remove(event.assignments);
  }

  /**
   * Returns all assignments for a given resource.
   *
   * @param {Scheduler.model.ResourceModel|Object} event
   * @return {Scheduler.model.TimeSpan[]}
   */
  getAssignmentsForResource(resource) {
    return this.mapAssignmentsForResource(resource);
  }

  /**
   * Removes all assignments for given resource
   *
   * @param {Scheduler.model.ResourceModel|*} resource
   */
  removeAssignmentsForResource(resource) {
    this.remove(this.getAssignmentsForResource(resource));
  }

  /**
   * Returns all resources assigned to an event.
   *
   * @param {Scheduler.model.EventModel} event
   * @return {Scheduler.model.ResourceModel[]}
   */
  getResourcesForEvent(event) {
    const me = this;

    // TODO: cache event -> resource
    //if (!me.relationCache.events) return []; //return me.eventResourceCache.get(event);

    return me.mapAssignmentsForEvent(
      event,
      (assignment) => assignment.resource,
      (resource) => Boolean(resource)
    );
  }

  /**
   * Returns all events assigned to a resource
   *
   * @param {Scheduler.model.ResourceModel|*} resource
   * @return {Scheduler.model.TimeSpan[]}
   */
  getEventsForResource(resource) {
    const me = this;

    //if (me.resourceEventsCache) return me.resourceEventsCache.get(resource);

    return me.mapAssignmentsForResource(
      resource,
      (assignment) => assignment.event,
      (event) => !!event
    );
  }

  /**
   * Creates and adds assignment record(s) for a given event and resource.
   *
   * @param {Scheduler.model.TimeSpan|*} event
   * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} resource The resource(s) to assign to the event
   * @privateparam {Function} [assignmentSetupFn]
   * @privateparam {Boolean} [removeExistingAssignments] true to first remove existing assignments
   * @return {Scheduler.model.AssignmentModel[]} An array with the created assignment(s)
   */
  assignEventToResource(event, resource, assignmentSetupFn = (o) => o, removeExistingAssignments = false) {
    const me = this,
      resources = Array.isArray(resource) ? resource : [resource];

    let assignments = [];

    me.beginBatch();

    if (removeExistingAssignments) {
      me.removeAssignmentsForEvent(event);
    }

    resources.forEach((resource) => {
      if (!me.isEventAssignedToResource(event, resource)) {
        let assignment = new me.modelClass({
          eventId: Model.asId(event),
          resourceId: Model.asId(resource)
        });

        assignment = assignmentSetupFn(assignment);

        assignments.push(assignment);
      }
    });

    assignments = me.add(assignments);
    me.endBatch();

    return assignments;
  }

  /**
   * Removes assignment record for a given event and resource.
   *
   * @param {Scheduler.model.TimeSpan|String|Number} event
   * @param {Scheduler.model.ResourceModel|String|Number} [resource] The resource to unassign the event from. If omitted, all resources of the events will be unassigned
   * @return {Scheduler.model.AssignmentModel|Scheduler.model.AssignmentModel[]}
   */
  unassignEventFromResource(event, resource) {
    const me = this;

    if (!resource) return me.removeAssignmentsForEvent(event);

    if (me.isEventAssignedToResource(event, resource)) {
      const assignment = me.getAssignmentForEventAndResource(event, resource);
      me.remove(assignment);
      return assignment;
    }

    return null;
  }

  /**
   * Checks whether an event is assigned to a resource.
   *
   * @param {Scheduler.model.EventModel|String|Number} event Event record or id
   * @param {Scheduler.model.ResourceModel|String|Number} resource Resource record or id
   * @return {Boolean}
   */
  isEventAssignedToResource(event, resource) {
    const me = this,
      records = me.getResourcesForEvent(event),
      resourceId = Model.asId(resource);

    // noinspection EqualityComparisonWithCoercionJS
    return records.some((res) => res.id == resourceId);
  }

  /**
   * Returns an assignment record for a given event and resource
   *
   * @param {Scheduler.model.EventModel|String|Number} event The event or its id
   * @param {Scheduler.model.ResourceModel|String|Number} resource The resource or its id
   * @return {Scheduler.model.AssignmentModel}
   */
  getAssignmentForEventAndResource(event, resource) {
    const me = this;

    event = me.eventStore.getById(event);
    resource = me.resourceStore.getById(resource);

    //const key = me.modelClass.makeAssignmentEventResourceCompositeKey(event, resource);

    //TODO: PORT key map
    //return me.records.find(a => key == me.modelClass.makeAssignmentEventResourceCompositeKey(a.eventId, a.resourceId));

    // noinspection EqualityComparisonWithCoercionJS
    return me.records.find((assignment) => assignment.event == event && assignment.resource == resource);
  }

  //endregion
}
AssignmentStore._$name = 'AssignmentStore';

/**
 * @module Scheduler/model/CalendarDayModel
 */

/**
 * A model representing a single day in the calendar. Depending on the `type` field, day may be a concrete day per se (2012/01/01),
 * a certain weekday (all Thursdays), or an override for all certain weekdays in the timeframe
 * (all Fridays between 2012/01/01 - 2012/01/15, inclusive).
 *
 * A collection of CalendarDayModel instances to be provided for the {@link Scheduler.data.Calendar calendar}
 *
 * @extends Common/data/Model
 */
class CalendarDayModel extends Model {
  static get fields() {
    return [
      /**
       * The id of the date. Can be an arbitrary unique value, assigned by the server
       * @field {String|Number} id
       */

      /**
       * The date for this day in the ISO 8601 format. Any time information in this field will be cleared. If this
       * instance represents a weekday or week override, this field will be ignored.
       * @field {String|Date} date
       */
      {
        name: 'date',
        type: 'date',
        format: 'YYYY-MM-DD',
        persist: true
      },

      /**
       * The index of the week day (0 - Sunday, 1 - Monday and so on) if this instance contains information about the week day (applicable for `WEEKDAY` and `WEEKDAYOVERRIDE`).
       * Should be set to -1 for the "main" instance of the week overrides.
       * @field {Number} weekday
       */
      { name: 'weekday', type: 'int' },

      /**
       * The start date of the timespan for week day override.
       * @field {Date} overrideStartDate
       */
      {
        name: 'overrideStartDate',
        type: 'date',
        dateFormat: 'YYYY-MM-DD'
      },

      /**
       * The end date of the timespan for week day override.
       * @field {Date} overrideEndDate
       */
      {
        name: 'overrideEndDate',
        type: 'date',
        dateFormat: 'YYYY-MM-DD'
      },

      /**
       * The type of this calendar day. Can be one of the following `DAY`, `WEEKDAY`, `WEEKDAYOVERRIDE`:
       * - Default value is `DAY` meaning this day represents a "real" day in the calendar (2012/01/01 for example) and contains availability information for that particular day only.
       * The date is stored in the `Date` field.
       * - The `WEEKDAY` value means calendar day contains information about all weekdays with the index, given in the `Weekday` field (0 - Sunday, 1 - Monday and so on).
       * For example - all Fridays. `Date` field is ignored.
       * - <p>The `WEEKDAYOVERRIDE` value means calendar day contains information about all weekdays within certain timespan. For example - all Fridays between 2012/01/01 - 2012/01/15.
       * Week day index should be stored in the `Weekday` field again, beginning of the timespan - in the `OverrideStartDate` field and the end of timespan - in the `OverrideEndDate`.
       * </p>
       * <p>
       * A single day instance contains the override for a single week day. So, to define overrides for several days (Monday and Tuesday for example) - add an additional instance
       * to the calendar with the same `Name/OverrideStartDate/OverrideEndDate` values. There's no need to define an override for every weekday - if some day is not defined - the
       * default availability will be used.
       * </p>
       * <p>
       * * **Note** Every week override should also have a "main" calendar day instance, representing the override itself. It should have the same
       * values for `Name/OverrideStartDate/OverrideEndDate` fields and -1 for `Weekday`. Also, the timespans of all week overrides should not intersect.
       * </p>
       * <p>
       * To avoid manual creation of week overrides you can use the calendar API (for example, {@link Scheduler.data.Calendar#function-addNonStandardWeek addNonStandardWeek},
       * {@link Scheduler.data.Calendar#function-removeNonStandardWeek removeNonStandardWeek} methods).
       * </p>
       * @field {String} type
       * @default 'DAY'
       */
      {
        name: 'type',
        defaultValue: 'DAY' // 'DAY', 'WEEKDAY', 'WEEKDAYOVERRIDE'
      },

      /**
       * Optional boolean flag, allowing you to specify exceptions - working days which falls on weekends. Default value is `false`. **Please note**, that simply setting this
       * field to "true" is not enough - you also need to specify the exact hours that are available for work with the `Availability` field (see below).
       * @field {Boolean} isWorkingDay
       * @default false
       */
      { name: 'isWorkingDay', type: 'boolean', defaultValue: false },

      /**
       * Optional name of the CSS class, which can be used by various plugins working with weekends and holidays.
       * Default value is `gnt-holiday` If a holiday lasts for several days, then all days should have the same
       * `cls` value.
       * @field {String} cls
       */
      {
        name: 'cls' //,
        //defaultValue : 'b-sch-nonworkingtime'
      },

      /**
       * Optional name of the day (holiday name for example)
       * @field {String} name
       */
      { name: 'name' },

      /**
       * Availability information for this day. Should be an array of strings or objects, containing the hourly
       * availability for this day. Strings should have the following format:
       * ```javascript
       * // two working intervals
       * [ '08:00-12:00', '13:00-17:00' ]
       *
       * // whole 24 hours are available
       * [ '00:00-24:00' ]
       * ```
       * Objects:
       * ```
       * [{
       *    startTime       : new Date(0, 0, 0, 8),
       *    endTime         : new Date(0, 0, 0, 12)
       * }]
       * ```
       * **Please note**, that this field overrides `isWorkingDay` - for example, a day with
       * "isWorkingDay : false" and "Availability : [ '08:00-12:00' ]" - will be considered a working day.
       * @field {String[]|Object[]} availability
       */
      {
        name: 'availability',
        persist: true //,
        // convert : function(value, record) {
        //     if (value) {
        //         return typeof value === 'string' ? [value] : value;
        //     } else {
        //         return [];
        //     }
        // }
      }
    ];
  }

  set date(date) {
    if (date) date = DateHelper.startOf(date, 'day');

    this.set('date', date);
  }

  get date() {
    return this.get('date');
  }

  /**
   * Clears the date for this day
   */
  clearDate() {
    this.set('date', null);
  }

  // needed since you cannot override setter only
  get availability() {
    return this.get('availability');
  }

  set availability(intervals) {
    // clear cache
    this.availabilityCache = null;

    this.set('availability', this.stringifyIntervals(intervals));

    // to trigger the `verifyAvailability`
    this.getAvailability();
  }

  /**
   * This method returns the availability for this day. By default it will decode an array of strings '08:00-12:00' to
   * an array of objects like:
   * ```javascript
   * {
   *    startTime       : new Date(0, 0, 0, 8),
   *    endTime         : new Date(0, 0, 0, 12)
   * }
   * ```
   * You can pass the "asString" flag to disable that and just return strings.
   *
   * @param {Boolean} asString Whether to just return an array of strings, instead of objects.
   * @return {Object[]|String[]} Array of objects with "startTime", "endTime" properties.
   */
  getAvailability(asString) {
    const me = this;

    // Return the raw availability array with strings
    if (asString) return me.get('availability');

    if (me.availabilityCache) return me.availabilityCache;

    const parsed = me.get('availability').map((value) => (typeof value === 'string' ? me.parseInterval(value) : value));

    me.verifyAvailability(parsed);

    return (me.availabilityCache = parsed);
  }

  verifyAvailability(intervals) {
    const me = this;

    intervals.sort((a, b) => a.startTime - b.startTime);

    intervals.forEach((interval, i) => {
      if (interval.startTime > interval.endTime) {
        throw new Error(
          `Start time ${DateHelper.format(interval.startTime, 'HH:mm')} is greater than end time ${DateHelper.format(
            interval.endTime,
            'HH:mm'
          )}`
        );
      }

      if (i > 0 && intervals[i - 1].endTime > interval.startTime) {
        throw new Error(
          `Availability intervals should not intersect: [${me.stringifyInterval(
            intervals[i - 1]
          )}] and [${me.stringifyInterval(interval)}]`
        );
      }
    });
  }

  //prependZero(value) {
  //    return value < 10 ? '0' + value : value;
  //}

  stringifyInterval(interval) {
    const startTime = interval.startTime,
      endTime = interval.endTime;

    return DateHelper.format(startTime, 'HH:mm') + '-' + DateHelper.format(endTime, 'HH:mm');

    //return this.prependZero(startTime.getHours()) + ':' + this.prependZero(startTime.getMinutes()) + '-' +
    //    (endTime.getDate() == 1 ? 24 : this.prependZero(endTime.getHours())) + ':' + this.prependZero(endTime.getMinutes());
  }

  stringifyIntervals(intervals) {
    const me = this;

    return intervals.map((interval) => (typeof interval === 'string' ? interval : me.stringifyInterval(interval)));
  }

  parseInterval(string) {
    const match = /(\d\d):(\d\d)-(\d\d):(\d\d)/.exec(string);

    if (!match)
      throw new Error(`Invalid format for availability string: ${String}. It should have exact format: hh:mm-hh:mm`);

    return {
      startTime: new Date(0, 0, 0, match[1], match[2]),
      endTime: new Date(0, 0, 0, match[3], match[4])
    };
  }

  /**
   * Returns the total length of all availability intervals for this day in hours.
   *
   * @property {Number}
   * @readonly
   */
  get totalHours() {
    return this.getTotalMS() / 1000 / 60 / 60;
  }

  /**
   * Returns the total length of all availability intervals for this day in milliseconds.
   *
   * @property {Number}
   * @readonly
   */
  get totalMS() {
    return this.getAvailability().reduce((totalMS, interval) => (totalMS += interval.endTime - interval.startTime), 0);
  }

  /**
   * Adds a new availability interval to this day. Both arguments should have the same format.
   *
   * @param {Date|String} startTime Start time of the interval. Can be a Date object (new Date(0, 0, 0, 8)) or just a plain string: '08'
   * @param {Date|String} endTime End time of the interval. Can be a Date object (new Date(0, 0, 0, 12)) or just a plain string: '12'
   */
  addAvailabilityInterval(startTime, endTime) {
    let interval;

    if (startTime instanceof Date) {
      interval = {
        startTime: startTime,
        endTime: endTime
      };
    } else {
      interval = this.parseInterval(startTime + (endTime ? '-' + endTime : ''));
    }

    const intervals = this.getAvailability().concat(interval);

    this.verifyAvailability(intervals);

    this.setAvailability(intervals);
  }

  /**
   * Removes the availability interval by its index.
   *
   * @param {Number} index Ordinal position of the interval to be removed
   */
  removeAvailabilityInterval(index) {
    const intervals = this.getAvailability();

    intervals.splice(index, 1);

    this.setAvailability(intervals);
  }

  /**
   * Applies the availability intervals to a concrete day. For example the availability intervals [ '08:00-12:00', '13:00-17:00' ],
   * applied to a day 2012/01/01 will return the following result:
   * ```javascript
   * [
   * {
   *     startDate       : new Date(2012, 0, 1, 8),
   *     endDate         : new Date(2012, 0, 1, 12)
   * },
   * {
   *     startDate       : new Date(2012, 0, 1, 13),
   *     endDate         : new Date(2012, 0, 1, 17)
   * }
   * ]
   * ```
   * @param {Date} timeDate The date to apply the intervals to
   * @returns {Object[]} Array of objects with "startDate / endDate" properties.
   */
  getAvailabilityIntervalsFor(timeDate) {
    timeDate = typeof timeDate === 'number' ? new Date(timeDate) : timeDate;

    const year = timeDate.getFullYear(),
      month = timeDate.getMonth(),
      date = timeDate.getDate();

    return this.getAvailability().map((interval) => {
      const endDate = interval.endTime.getDate();

      return {
        startDate: new Date(year, month, date, interval.startTime.getHours(), interval.startTime.getMinutes()),
        endDate: new Date(
          year,
          month,
          date + (endDate == 1 ? 1 : 0),
          interval.endTime.getHours(),
          interval.endTime.getMinutes()
        )
      };
    });
  }

  /**
   * Returns the earliest available time for the given date. If this day has no availability intervals it returns `null`.
   *
   * @param {Date} timeDate The date to get the earliest availability time for.
   * @return {Date}
   */
  getAvailabilityStartFor(timeDate) {
    const intervals = this.getAvailabilityIntervalsFor(timeDate);

    if (!intervals.length) return null;

    return intervals[0].startDate;
  }

  /**
   * Returns the latest available time for the given date. If this day has no availability intervals, it returns `null`.
   *
   * @param {Date} timeDate The date to get the latest availability time for.
   * @return {Date}
   */
  getAvailabilityEndFor(timeDate) {
    const intervals = this.getAvailabilityIntervalsFor(timeDate);

    if (!intervals.length) return null;

    return intervals[intervals.length - 1].endDate;
  }
}
CalendarDayModel._$name = 'CalendarDayModel';

/**
 * @module Scheduler/model/TimeSpan
 */

/**
 * This class represent a simple date range. It is being used in various subclasses and plugins which operate on date ranges.
 *
 * Its a subclass of  {@link Common.data.Model}.
 * Please refer to documentation of those classes to become familar with the base interface of this class.
 *
 * A TimeSpan has the following fields:
 *
 * - `startDate`    - start date of the task in the ISO 8601 format
 * - `endDate`      - end date of the task in the ISO 8601 format (not inclusive)
 * - `duration`     - duration, time between start date and end date
 * - `durationUnit` - unit used to express the duration
 * - `name`         - an optional name of the range
 * - `cls`          - an optional CSS class to be associated with the range.
 *
 * The data source of any field can be customized in the subclass. Please refer to {@link Common.data.Model} for details. To specify
 * another date format:
 *
 * ```javascript
 * class MyTimeSpan extends TimeSpan {
 *   static get fields() {
 *      { name: 'startDate', type: 'date', dateFormat: 'DD/MM/YY' }
 *   }
 * }
 * ```
 *
 * @extends Common/data/Model
 */
class TimeSpan extends Model {
  //region Field definitions

  static get fields() {
    return [
      /**
       * The start date of a time span (or Event / Task). Uses ISO 8601 date format by default (1962-06-17T09:21:34.125Z). To specify another
       * format, subclass TimeSpan and change the dateFormat
       * @field {String|Date} startDate
       */
      { name: 'startDate', type: 'date', dateFormat: 'YYYY-MM-DDTHH:mm:ssZ' },

      /**
       * The end date of a time span (or Event / Task). Uses ISO 8601 date format by default (1962-06-17T09:21:34.125Z). To specify another
       * format, subclass TimeSpan and change the dateFormat
       * @field {String|Date} endDate
       */
      { name: 'endDate', type: 'date', dateFormat: 'YYYY-MM-DDTHH:mm:ssZ' },

      /**
       * The numeric part of the timespans duration (the number of units).
       * @field {Number} duration
       */
      { name: 'duration', type: 'number', allowNull: true },

      /**
       * The unit part of the TimeSpan duration, defaults to "d" (days). Valid values are:
       *
       * - "ms" (milliseconds)
       * - "s" (seconds)
       * - "m" (minutes)
       * - "h" (hours)
       * - "d" (days)
       * - "w" (weeks)
       * - "M" (months)
       * - "y" (years)
       *
       * This field is readonly after creation, to change durationUnit use #setDuration().
       * @field {String} durationUnit
       */
      {
        name: 'durationUnit',
        type: 'string',
        defaultValue: 'd'
      },

      {
        name: 'fullDuration'
      },

      /**
       * An encapsulation of the CSS classes to add to the rendered time span element.
       * @field {Common.helper.util.DomClassList|String} cls
       *
       * This may be accessed as a string, but for granular control of adding and
       * removing individual classes, it is recommended to use the
       * {@link Common.helper.util.DomClassList DomClassList} API.
       */
      {
        name: 'cls',
        defaultValue: ''
      },

      /**
       * A CSS style string (applied to `style.cssText`) or object (applied to `style`)
       * ```
       * record.style = 'color: red;font-weight: 800';
       * ```
       *
       * @field {String} style
       */
      {
        name: 'style',
        type: 'object'
      },

      /**
       * The name of the time span (or Event / Task)
       * @field {String} name
       */
      { name: 'name', type: 'string' }
    ];
  }

  //endregion

  //region Init

  afterConstruct() {
    super.afterConstruct();

    // This should probably be a property setter of some mandatory config, then we would not need an afterConfigure implementation.
    this.normalize();
  }

  normalize() {
    const me = this,
      { startDate, endDate, duration, durationUnit } = me,
      hasDuration = duration != null;

    // need to calculate duration (checking first since seemed most likely to happen)
    if (startDate && endDate && !hasDuration) {
      me.setData('duration', DateHelper.diff(startDate, endDate, durationUnit, true));
    }
    // need to calculate endDate?
    else if (startDate && !endDate && hasDuration) {
      me.setData('endDate', DateHelper.add(startDate, duration, durationUnit));
    }
    // need to calculate startDate
    else if (!startDate && endDate && hasDuration) {
      me.setData('startDate', DateHelper.add(endDate, -duration, durationUnit));
    }

    this.clearCachedValues();
  }

  //endregion

  //region Getters & Setters

  get cls() {
    if (!this._cls) {
      this._cls = new DomClassList(super.get('cls'));
    }
    return this._cls;
  }

  set cls(cls) {
    const me = this;

    if (me._cls) {
      me._cls.value = cls;
    } else {
      me._cls = new DomClassList(cls);
    }
    me.set('cls', me._cls.value);
  }

  get startDate() {
    return this.get('startDate');
  }

  set startDate(date) {
    this.setStartDate(date);
  }

  get endDate() {
    return this.get('endDate');
  }

  set endDate(date) {
    this.setEndDate(date);
  }

  get duration() {
    return this.get('duration');
  }

  set duration(duration) {
    this.setDuration(duration, this.durationUnit);
  }

  get durationUnit() {
    return this.get('durationUnit');
  }

  /**
   * Sets duration and durationUnit in one go. Only allowed way to change durationUnit, the durationUnit field is
   * readonly after creation
   * @param {Number} duration Duration value
   * @param {String} durationUnit Unit for specified duration value, see {@link #field-durationUnit} for valid values
   */
  setDuration(duration, durationUnit = this.durationUnit) {
    // Must be a number
    duration = parseFloat(duration);

    const toSet = {
      duration,
      durationUnit
    };

    if (this.startDate) {
      toSet.endDate = DateHelper.add(this.startDate, duration, durationUnit);
    } else if (this.endDate) {
      toSet.startDate = DateHelper.add(this.endDate, -duration, durationUnit);
    }

    this.set(toSet);
  }

  /**
   * Property which encapsulates the duration's magnitude and units.
   */
  get fullDuration() {
    return {
      unit: this.durationUnit,
      magnitude: this.duration
    };
  }

  set fullDuration(duration) {
    if (typeof duration === 'string') {
      duration = DateHelper.parseDuration(duration, true, this.durationUnit);
    }

    this.setDuration(duration.magnitude, duration.unit);
  }

  /**
   * Sets the range start date
   *
   * @param {Date} date The new start date
   * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the event), `false` to change the duration ("resize" the event).
   * Defaults to `true`
   */
  setStartDate(date, keepDuration = true) {
    const me = this,
      toSet = {
        startDate: date
      };

    if (date) {
      let calcEndDate;

      if (keepDuration) {
        calcEndDate = me.duration != null;
      } else {
        if (me.endDate) {
          toSet.duration = DateHelper.diff(date, me.endDate, me.durationUnit, true);

          if (toSet.duration < 0) throw new Error('Negative duration');
        } else {
          calcEndDate = this.duration != null;
        }
      }

      if (calcEndDate) {
        toSet.endDate = DateHelper.add(date, me.duration, me.durationUnit);
      }
    } else {
      toSet.duration = null;
    }

    me.set(toSet);
  }

  /**
   * Sets the range end date
   *
   * @param {Date} date The new end date
   * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the event), `false` to change the duration ("resize" the event).
   * Defaults to `false`
   */
  setEndDate(date, keepDuration = false) {
    const me = this,
      toSet = {
        endDate: date
      };

    if (date) {
      let calcStartDate;

      if (keepDuration === true) {
        calcStartDate = me.duration != null;
      } else {
        if (me.startDate) {
          toSet.duration = DateHelper.diff(me.startDate, date, me.durationUnit, true);

          if (toSet.duration < 0) throw new Error('Negative duration');
        } else {
          calcStartDate = this.duration != null;
        }
      }

      if (calcStartDate) {
        toSet.startDate = DateHelper.add(date, -me.duration, me.durationUnit);
      }
    }

    me.set(toSet);
  }

  /**
   * Sets the event start and end dates
   *
   * @param {Date} start The new start date
   * @param {Date} end The new end date
   */
  setStartEndDate(start, end) {
    this.set({
      startDate: start,
      endDate: end
    });
  }

  /**
   * Returns an array of dates in this range. If the range starts/ends not at the beginning of day, the whole day will be included.
   * @return {Date[]}
   */
  get dates() {
    const dates = [],
      startDate = DateHelper.startOf(this.startDate, 'day'),
      endDate = this.endDate;

    for (let date = startDate; date < endDate; date = DateHelper.add(date, 1, 'day')) {
      dates.push(date);
    }

    return dates;
  }

  /**
   * Returns the duration of this Event in milliseconds.
   * @private
   */
  get durationMS() {
    if (this.endDate && this.startDate) {
      return this.endDateMS - this.startDateMS;
    } else {
      return DateHelper.asMilliseconds(this.duration || 0, this.durationUnit);
    }
  }

  // Caching isMilestone, startDate and endDate ms conversion since it costs a bit during rendering
  clearCachedValues() {
    this._startDateMS = null;
    this._endDateMS = null;
    this._isMilestone = null;
  }

  get endDateMS() {
    const me = this;

    if (!me._endDateMS) {
      me._endDateMS = me.endDate && me.endDate.getTime();
    }

    return me._endDateMS;
  }

  get startDateMS() {
    const me = this;

    if (!me._startDateMS) {
      me._startDateMS = me.startDate && me.startDate.getTime();
    }

    return me._startDateMS;
  }

  get isMilestone() {
    const me = this;

    if (!me._isMilestone) {
      me._isMilestone = me.endDateMS === me.startDateMS;
    }

    return me._isMilestone;
  }

  inSetNormalize(field) {
    if (typeof field !== 'string') {
      // If user is updating multiple properties in one go using an object, we help out
      // by filling out missing schedule related data
      field = Object.assign({}, field);

      if ('duration' in field) {
        if (field.startDate && !field.endDate) {
          field.endDate = DateHelper.add(
            field.startDate,
            field.duration,
            field.durationUnit || this.durationUnit,
            true,
            true
          );
        }

        if (!field.startDate && field.endDate) {
          field.startDate = DateHelper.add(
            field.endDate,
            -field.duration,
            field.durationUnit || this.durationUnit,
            true,
            true
          );
        }
      } else if (field.startDate && field.endDate) {
        field.duration = DateHelper.diff(field.startDate, field.endDate, field.durationUnit || this.durationUnit, true);
      }
      return field;
    }
  }

  inSet(field, value, silent, fromRelationUpdate) {
    this.clearCachedValues();
    field = this.inSetNormalize(field) || field;
    return super.inSet(field, value, silent, fromRelationUpdate);
  }

  //endregion

  //region Iteration

  /**
   * Iterates over the {@link #property-dates}
   * @param {Function} func The function to call for each date
   * @param {Object} thisObj `this` reference for the function
   */
  forEachDate(func, thisObj) {
    return this.dates.forEach(func.bind(thisObj));
  }

  //endregion

  /**
   * Checks if the range record has both start and end dates set and start <= end
   *
   * @return {Boolean}
   */
  get isScheduled() {
    const me = this;
    return Boolean(me.startDate && me.endDate && me.hasValidDates);
  }

  // Simple check if end date is greater than start date
  get isValid() {
    let me = this,
      result = true; //super.isValid(),

    if (result) {
      let start = me.startDate,
        end = me.endDate;
      result = !start || !end || end - start >= 0;
    }

    return result;
  }

  // Simple check if just end date is greater than start date
  get hasValidDates() {
    let me = this,
      start = me.startDateMS,
      end = me.endDateMS;

    return !start || !end || end - start >= 0;
  }

  /**
   * Shift the dates for the date range by the passed amount and unit
   * @param {String} unit The unit to shift by, see {@Common.helper.DateHelper} for more information on valid formats.
   * @param {Number} amount The amount to shift
   */
  shift(amount, unit = this.durationUnit) {
    // TODO REMOVE FOR 2.0
    if (typeof amount === 'string') {
      const u = amount;

      amount = unit;
      unit = u;
    }

    this.setStartDate(DateHelper.add(this.startDate, amount, unit, true), true);
  }

  /**
   * Returns the WBS code of this model (only relevant when it's part of a tree store).
   * @return {String} The WBS code string
   * @private
   */
  get wbsCode() {
    return this.indexPath.join('.');
  }

  fullCopy() {
    //NOT PORTED

    return this.copy.apply(this, arguments);
  }

  intersects(timeSpan) {
    return this.intersectsRange(timeSpan.startDate, timeSpan.endDate);
  }

  intersectsRange(start, end) {
    let myStart = this.startDate,
      myEnd = this.endDate;

    return myStart && myEnd && DateHelper.intersectSpans(myStart, myEnd, start, end);
  }

  /**
   * Splits this event into two pieces at the desired position.
   *
   * @param {Number} splitPoint A number greater than 0 and less than 1, indicating how this event will be split. 0.5 means cut it in half
   * @return {Scheduler.model.TimeSpan} The newly created split section of the timespan
   */
  split(splitPoint = 0.5) {
    const me = this,
      clone = this.copy(),
      eventStore = me.firstStore,
      assignmentStore = eventStore && eventStore.assignmentStore,
      ownNewDuration = me.duration * splitPoint,
      cloneDuration = me.duration - ownNewDuration;

    if (splitPoint <= 0 || splitPoint >= 1) {
      throw new Error('Split point must be > 0 and < 1');
    }

    me.duration = ownNewDuration;
    clone.startDate = me.endDate;
    clone.duration = cloneDuration;

    if (eventStore) {
      eventStore.add(clone);
    }

    if (assignmentStore) {
      assignmentStore.add(
        me.assignments.map((assignment) => {
          const clonedData = Object.assign({}, assignment.data, { eventId: clone.id });
          delete clonedData.id;

          return clonedData;
        })
      );
    }

    return clone;
  }
}
TimeSpan._$name = 'TimeSpan';

/**
 * @module Scheduler/data/Calendar
 */

/**
 * A class representing a customizable calendar with weekends, holidays and availability information for any day.
 * Internally, it's just a subclass of the AjaxStore class which should be loaded with a collection
 * of {@link Scheduler.model.CalendarDayModel} instances. Additionally, calendars may have parent-child relations,
 * allowing "child" calendars to "inherit" all special dates from its "parent" and add its own.
 * See {@link #property-parent} property for details.
 *
 * A calendar can be instantiated like this:
 * ```
 * let calendar = new Scheduler.data.Calendar({
 *     data : [
 *         {
 *             date            : new Date(2010, 0, 13),
 *             cls             : 'national-holiday'
 *         },
 *         {
 *             date            : new Date(2010, 1, 1),
 *             cls             : 'company-holiday'
 *         },
 *         {
 *             date            : new Date(2010, 0, 16),
 *             isWorkingDay    : true
 *         }
 *     ]
 * });
 * ```
 * Please refer to the {@link Scheduler.model.CalendarDayModel} class to learn the data model used for the calendar.
 */
class Calendar extends AjaxStore {
  static get defaultConfig() {
    return {
      modelClass: CalendarDayModel,

      /**
       * Number of days per month. Will be used when converting the big duration units like month/year to days.
       *
       * @config {Number}
       * @default
       */
      daysPerMonth: 30,

      /**
       * Number of days per week. Will be used when converting the duration in weeks to days.
       *
       * @config {Number}
       * @default
       */
      daysPerWeek: 7,

      /**
       * Number of hours per day. Will be used when converting the duration in days to hours.
       *
       * **Please note**, that this config is used for duration conversion and not anything else. If you need to change
       * the number of working hours in the day, update the {@link #config-defaultAvailability}
       *
       * @config {Number}
       * @default
       */
      hoursPerDay: 24,

      unitsInMs: null,

      defaultNonWorkingTimeCssCls: 'b-nonworkingtime',

      /**
       * Setting this option to `true` will treat *all* days as working days. Default value is `false`.
       * @config {Boolean}
       * @default
       */
      weekendsAreWorkdays: false,

      /**
       * The index of the first day in a weekend, 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on. '
       * Default value is 6 - Saturday
       * @config {Number}
       * @default
       */
      weekendFirstDay: 6,

      /**
       * The index of the second day in weekend, 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.
       * Default value is 0 - Sunday
       * @config {Number}
       * @default
       */
      weekendSecondDay: 0,

      holidaysCache: null,
      availabilityIntervalsCache: null,
      daysIndex: null,

      // a "cached" array of WEEKDAY days
      weekAvailability: null,

      // the "very default" availability array, calculated based on `defaultAvailability` property
      defaultWeekAvailability: null,

      nonStandardWeeksByStartDate: null,
      nonStandardWeeksStartDates: null,

      /**
       * The unique id for the calendar. Providing a `calendarId` will register this calendar in the calendars
       * registry and it can be retrieved later with {@link #function-getCalendar-static}. Generally only required if want to use
       * {@link #property-parent parent-child relations} between the calendars, or assign this calendar to a particular
       * task or resource.
       *
       * @config {String}
       */
      calendarId: null,

      /**
       * The parent calendar. Can be provided as the calendar id or calendar instance itself. If this property is
       * provided or set with {@link #property-parent} property, this calendar becomes a "child" of the specified
       * calendar. This means that it will "inherit" all day overrides, week days and week day overrides from its
       * "parent". In the same time, special days, defined in this calendar take priority over the ones from the
       * "parent".
       *
       * You can use this feature if you'd like to create a single "main" calendar for the whole project, and then
       * allow some task or resource to have slightly different calendar (with an additional day off for example).
       * You will not have to re-create all special days in the calendar of such task/resource - just set the
       * "main" calendar as a "parent" for it.
       *
       * @config {String|Scheduler.data.Calendar}
       */
      parent: null,

      /**
       * The array of default availability intervals (in the format of the
       * `Availability` field in the {@link Scheduler.model.CalendarDayModel}) for each working weekday (Monday-Friday). Defaults
       * to whole day (00-24) for backward compatibility.
       * @config {String[]}
       * @default
       */
      defaultAvailability: ['00:00-24:00'],

      /**
       * The name of this calendar
       * @config {String}
       */
      name: null,

      suspendCacheUpdate: 0,

      /**
       * Maximum number of days to search for calendar availability intervals.
       * Used in various calculations requiring to respect working time.
       * In these cases the system iterates through the working time day by day. This option determines the maximum distance
       * to iterate. Prevents against infinite loop in case of wrong calendar configuration.
       * @config {Number}
       * @default
       */
      availabilitySearchLimit: 1825 //5*365
    };
  }

  /**
   * Returns an array of all registered calendars.
   *
   * @return {Scheduler.data.Calendar[]}
   */
  static get allCalendars() {
    return (Store.stores || []).filter((store) => store instanceof Calendar);
  }

  /**
   * Get/set the calendarId of the current calendar, also registers it in the calendar registry.
   * @property {String}
   */
  get calendarId() {
    return this._calendarId;
  }

  /**
   * Sets the {@link #property-parent} for this calendar. Pass `null` to remove the parent.
   *
   * @param {String|Scheduler.data.Calendar} parentOrId String with {@link #config-calendarId} value or calendar instance itself.
   */
  set parent(parentOrId) {
    const me = this,
      parent = Calendar.getCalendar(parentOrId);

    if (parentOrId && !parent) throw new Error('Invalid parent specified for the calendar');

    if (me.parent != parent) {
      const listeners = {
        calendarchange: me.clearCache,
        destroy: me.onParentDestroy,
        thisObj: me
      };

      const oldParent = me.parent;

      if (oldParent) oldParent.un(listeners);

      me._parent = parent;

      if (parent) parent.on(listeners);

      me.params = Object.assign(me.params || {}, { parentId: parent ? parent.calendarId : null });

      me.clearCache();

      /**
       * Triggered when a calender is assigned to a new parent calendar.
       * @event parentChange
       *
       * @param {Scheduler.data.Calendar} source The calendar which parent has changed
       * @param {Scheduler.data.Calendar} newParent The new parent of this calendar (can be `null` if parent is being removed)
       * @param {Scheduler.data.Calendar} oldParent The old parent of this calendar (can be `null` if there was no parent)
       */
      me.trigger('parentChange', { newParent: parent, oldParent });
    }
  }

  construct(config) {
    const me = this;

    super.construct(config);

    // TODO: This will be from static get properties() when https://app.assembla.com/spaces/bryntum/tickets/5165 is done
    me.unitsInMs = {
      MILLI: 1,
      SECOND: 1000,
      MINUTE: 60 * 1000,
      HOUR: 60 * 60 * 1000,
      DAY: me.hoursPerDay * 60 * 60 * 1000,
      WEEK: me.daysPerWeek * me.hoursPerDay * 60 * 60 * 1000,
      MONTH: me.daysPerMonth * me.hoursPerDay * 60 * 60 * 1000,
      QUARTER: 3 * me.daysPerMonth * 24 * 60 * 60 * 1000,
      YEAR: 4 * 3 * me.daysPerMonth * 24 * 60 * 60 * 1000
    };

    me.defaultWeekAvailability = me.getDefaultWeekAvailability();

    // traditional "on-demand" caching seems to be not so efficient for calendar (in theory)
    // calculating any cached property, like, "weekAvailability" or "nonStandardWeeksStartDates" will require full calendar scan each time
    // so we update ALL cached values on any CRUD operations
    me.on({
      // TODO ignore changes of "name/cls" field?
      change: me.clearCache,
      thisObj: me
    });

    me.clearCache();
  }

  /**
   * Returns the registered calendar with the given id.
   *
   * @param {String} id The calendar id
   * @return {Scheduler.data.Calendar}
   */
  static getCalendar(id) {
    if (id instanceof Calendar) return id;

    return Store.getStore(id);
  }

  set calendarId(id) {
    const me = this;

    me._calendarId = id;

    if (id != null) {
      me.storeId = 'GNT_CALENDAR:' + id;
    } else {
      me.storeId = null;
    }

    me.params = Object.assign(me.params || {}, { calendarId: id });
  }

  getDefaultWeekAvailability() {
    let availability = this.defaultAvailability,
      weekendFirstDay = this.weekendFirstDay,
      weekendSecondDay = this.weekendSecondDay,
      res = [];

    for (let i = 0; i < 7; i++) {
      res.push(
        this.weekendsAreWorkdays || (i != weekendFirstDay && i != weekendSecondDay)
          ? new this.modelClass({
              type: 'WEEKDAY',
              weekday: i,
              availability: (availability && availability.slice()) || [],
              isWorkingDay: true
            })
          : new this.modelClass({ type: 'WEEKDAY', weekday: i, availability: [] })
      );
    }

    return res;
  }

  /**
   * Destroys all registered calendars.
   *
   * @return {Scheduler.data.Calendar[]}
   */
  removeAll() {
    Calendar.allCalendars.forEach((calendar) => {
      calendar.storeId = null; //unregisters from Store map
      calendar.destroy();
    });
  }

  /**
   * Returns `true` or `false` depending whether the given time span intersects with one of the defined week day overrides.
   *
   * @param {Date} startDate The start date of the time span
   * @param {Date} endDate The end date of the time span
   *
   * @return {Boolean}
   */
  intersectsWithCurrentWeeks(startDate, endDate) {
    let result = false;

    this.forEachNonStandardWeek((week) => {
      const weekStartDate = week.startDate,
        weekEndDate = week.endDate;

      if (
        (weekStartDate <= startDate && startDate < weekEndDate) ||
        (weekStartDate < endDate && endDate <= weekEndDate)
      ) {
        result = true;

        // stop the iteration
        return false;
      }
    });

    return result;
  }

  // will scan through all calendar days in the store and save references to special ones to the properties, for speedup
  clearCache() {
    const me = this;

    if (me.suspendCacheUpdate > 0) return;

    me.holidaysCache = {};
    me.availabilityIntervalsCache = {};

    const daysIndex = (me.daysIndex = {}),
      weekAvailability = (me.weekAvailability = []),
      nonStandardWeeksStartDates = (me.nonStandardWeeksStartDates = []),
      nonStandardWeeksByStartDate = (me.nonStandardWeeksByStartDate = {});

    me.forEach(function(calendarDay) {
      // backward compat
      let id = calendarDay.id,
        overrideMatch = /^(\d)-(\d\d\d\d\/\d\d\/\d\d)-(\d\d\d\d\/\d\d\/\d\d)$/.exec(id),
        weekDayMatch = /^WEEKDAY:(\d+)$/.exec(id),
        type = calendarDay.type,
        weekDay = calendarDay.weekday;

      if (type == 'WEEKDAYOVERRIDE' || overrideMatch) {
        let startDate, endDate;

        if (type == 'WEEKDAYOVERRIDE') {
          startDate = calendarDay.overrideStartDate;
          endDate = calendarDay.overrideEndDate;
        }

        // backward compat
        if (overrideMatch) {
          startDate = DateHelper.parse(overrideMatch[2], 'YYYY/MM/DD');
          endDate = DateHelper.parse(overrideMatch[3], 'YYYY/MM/DD');
          weekDay = overrideMatch[1];
        }

        // allow partially defined days - they will not be included in calculations
        if (startDate && endDate && weekDay != null) {
          const startDateNum = startDate - 0;

          if (!nonStandardWeeksByStartDate[startDateNum]) {
            nonStandardWeeksByStartDate[startDateNum] = {
              startDate: new Date(startDate),
              endDate: new Date(endDate),
              name: calendarDay.getName(),
              weekAvailability: [],
              // main day representing the week override itself - for example for overrides w/o any re-defined availability
              mainDay: null
            };

            nonStandardWeeksStartDates.push(startDateNum);
          }

          if (weekDay >= 0) {
            nonStandardWeeksByStartDate[startDateNum].weekAvailability[weekDay] = calendarDay;
          } else {
            nonStandardWeeksByStartDate[startDateNum].mainDay = calendarDay;
          }
        }
      } else if (type == 'WEEKDAY' || weekDayMatch) {
        if (weekDayMatch) weekDay = weekDayMatch[1];

        // again - only fully defined records will be taken into account
        if (weekDay != null) {
          if (weekDay < 0 || weekDay > 6) {
            throw new Error('Incorrect week day index');
          }

          weekAvailability[weekDay] = calendarDay;
        }
      } else {
        const date = calendarDay.date;

        if (date) daysIndex[date - 0] = calendarDay;
      }
    });

    // Numeric sort, can't use default JS sort which is string based
    nonStandardWeeksStartDates.sort((a, b) => a - b);

    /**
     * Triggered on changes to the calendar.
     * @event calendarChange
     * @param {Scheduler.data.Calendar} source
     */
    me.trigger('calendarChange');
  }

  /**
   * Adds a week day override ("non-standard" week) to the calendar. As a reminder, week day override consists from up to 7 days,
   * that re-defines the default week days availability only within certain time span.
   *
   * @param {Date} startDate The start date of the time span
   * @param {Date} endDate The end date of the time span
   * @param {Scheduler.model.CalendarDayModel[]|String[]} weekAvailability The array indexed from 0 to 7, containing items for week days.
   * Index 0 corresponds to Sunday, 1 to Monday, etc. Some items can be not defined or set to `null`, indicating that override does not
   * change this week day. Item can be - an instance of {@link Scheduler.model.CalendarDayModel} (only `Availability` field needs to be set), or
   * an array of strings, defining the availability (see the description of the `Availability` field in the {@link Scheduler.model.CalendarDayModel}).
   * @param {String} name The name of this week day override
   */
  addNonStandardWeek(startDate, endDate, weekAvailability, name) {
    startDate = DateHelper.clearTime(startDate);
    endDate = DateHelper.clearTime(endDate);

    if (this.intersectsWithCurrentWeeks(startDate, endDate)) {
      throw new Error('Can not add intersecting week');
    }

    const DayModel = this.modelClass,
      days = [];

    weekAvailability.forEach((day, index) => {
      if (day instanceof CalendarDayModel) {
        day.type = 'WEEKDAYOVERRIDE';
        day.overrideStartDate = startDate;
        day.overrideEndDate = endDate;
        day.weekday = index;
        day.name = name || 'Week override';

        days.push(day);
      } else if (Array.isArray(day)) {
        const newDay = new DayModel();

        newDay.type = 'WEEKDAYOVERRIDE';
        newDay.overrideStartDate = startDate;
        newDay.overrideEndDate = endDate;
        newDay.weekday = index;
        newDay.name = name || 'Week override';
        newDay.setAvailability(day);

        days.push(newDay);
      }
    });

    const mainDay = new DayModel();

    mainDay.type = 'WEEKDAYOVERRIDE';
    mainDay.overrideStartDate = startDate;
    mainDay.overrideEndDate = endDate;
    mainDay.weekday = -1;
    mainDay.name = name || 'Week override';

    days.push(mainDay);

    this.add(days);
  }

  /**
   * Returns an object describing a week day override ("non-standard" week), that starts at the given date or `null` if there's no any.
   *
   * @param {Date} startDate The start date of the week day override
   *
   * @return {Object} An object with the following properties
   * @return {Object} return.name A "Name" field of the week days in the override
   * @return {Date} return.startDate An "OverrideStartDate" field of the week days in the override
   * @return {Date} return.endDate An "OverrideEndDate" field of the week days in the override
   * @return {Scheduler.model.CalendarDayModel[]} return.weekAvailability An array with the week days, defined by this override. May be filled only partially if
   * week day override does not contain all days.
   * @return {Scheduler.model.CalendarDayModel} return.mainDay A "main" day instance for this override
   */
  getNonStandardWeekByStartDate(startDate) {
    return this.nonStandardWeeksByStartDate[DateHelper.clearTime(startDate) - 0] || null;
  }

  /**
   * Removes all calendar day instances, that forms a week day override ("non-standard" week) with the given start date.
   *
   * @param {Date} startDate The start date of the week day override
   */
  removeNonStandardWeek(startDate) {
    startDate = DateHelper.clearTime(startDate) - 0;

    const week = this.getNonStandardWeekByStartDate(startDate);

    if (!week) return;

    this.remove(ArrayHelper.clean(week.weekAvailability).concat(week.mainDay));
  }

  /**
   * Returns an object describing a week day override ("non-standard" week), that contains the given date or `null` if there's no any.
   *
   * @param {Date} timeDate The date that falls within some of the week day overrides
   *
   * @return {Object} An object describing week day override. See {@link #function-getNonStandardWeekByStartDate} method for details.
   */
  getNonStandardWeekByDate(timeDate) {
    timeDate = DateHelper.clearTime(timeDate) - 0;

    const nonStandardWeeksStartDates = this.nonStandardWeeksStartDates,
      nonStandardWeeksByStartDate = this.nonStandardWeeksByStartDate;

    for (let i = 0; i < nonStandardWeeksStartDates.length; i++) {
      const week = nonStandardWeeksByStartDate[nonStandardWeeksStartDates[i]];

      // since `nonStandardWeeksStartDates` are sorted inc and week overrides do not intersect
      // we can shorcut in this case
      if (week.startDate > timeDate) break;

      if (week.startDate <= timeDate && timeDate <= week.endDate) {
        return week;
      }
    }

    return null;
  }

  /**
   * Updates the default availability information based on the value provided.
   *
   * @param {Boolean} value true if weekends should be regarded as working time.
   */
  setWeekendsAreWorkDays(value) {
    const me = this;

    if (value !== me.weekendsAreWorkdays) {
      me.weekendsAreWorkdays = value;

      // Must generate new defaultWeekAvailability
      me.defaultWeekAvailability = me.getDefaultWeekAvailability();

      me.clearCache();
    }
  }

  /**
   * Returns true if weekends are regarded as working time.
   *
   * @return {Boolean} true if weekends should be regarded as working time.
   */
  areWeekendsWorkDays() {
    return this.weekendsAreWorkdays;
  }

  /**
   * Iterator for each week day override, defined in this calendar.
   *
   * @param {Function} func The function to call for each override. It will receive a single argument - object, describing the override.
   * See {@link #function-getNonStandardWeekByStartDate} for details. Returning `false` from the function stops the iterator.
   * @param {Object} thisObj `this` reference for the function
   *
   * @return {Boolean} `false` if any of the function calls have returned `false`
   */
  forEachNonStandardWeek(func, thisObj) {
    const me = this,
      nonStandardWeeksStartDates = this.nonStandardWeeksStartDates,
      nonStandardWeeksByStartDate = this.nonStandardWeeksByStartDate;

    for (let i = 0; i < nonStandardWeeksStartDates.length; i++) {
      if (func.call(thisObj || me, nonStandardWeeksByStartDate[nonStandardWeeksStartDates[i]]) === false) return false;
    }
  }

  /**
   * Returns a corresponding {@link Scheduler.model.CalendarDayModel} instance for the given date. First, this method checks for {@link #function-getOverrideDay day overrides}
   * (either in this or parent calendars), then for week days (again, in this or parent calendars) and finally fallbacks to the
   * calendar day with the {@link #config-defaultAvailability} availability.
   *
   * @param {Date} timeDate A date (can contain time portion which will be ignored)
   *
   * @return {Scheduler.model.CalendarDayModel}
   */
  getCalendarDay(timeDate) {
    timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;

    return (
      this.getOverrideDay(timeDate) ||
      this.getWeekDay(timeDate.getDay(), timeDate) ||
      this.getDefaultCalendarDay(timeDate.getDay())
    );
  }

  /**
   * Returns a day override corresponding to the given date (possibly found in the parent calendars) or `null` if the given date
   * has no overrides in this calendar and all its parents.
   *
   * @param {Date} timeDate The date to check for day overrides for
   * @return {Scheduler.model.CalendarDayModel}
   */
  getOverrideDay(timeDate) {
    return this.getOwnCalendarDay(timeDate) || (this.parent && this.parent.getOverrideDay(timeDate)) || null;
  }

  /**
   * Returns an "own" day override corresponding to the given date. That is - day override defined in the current calendar only.
   *
   * @param {Date} timeDate The date to check for day overrides for
   * @return {Scheduler.model.CalendarDayModel}
   */
  getOwnCalendarDay(timeDate) {
    timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;

    return this.daysIndex[DateHelper.clearTime(timeDate) - 0];
  }

  /**
   * Returns a "special" week day corresponding to the given date. Under "special" week day we mean a calendar day with the `Type = WEEKDAY` or `WEEKDAYOVERRIDE`.
   * See the {@link Scheduler.model.CalendarDayModel} class for details. If the concrete date is given as 2nd argument, this method will
   * first check for any week overrides passing on it.
   *
   * If not found in current calendar, this method will consult parent. If no "special" week day found neither in this calendar, no parents - it returns `null`.
   *
   * @param {Number} weekDayIndex The index of the week day to retrieve (0-Sunday, 1-Monday, etc)
   * @param {Date} [timeDate] The date for which the week day is being retrieved.
   * @return {Scheduler.model.CalendarDayModel}
   */
  getWeekDay(weekDayIndex, timeDate) {
    // if 2nd argument is provided then try to search in non-standard weeks first
    if (timeDate) {
      const week = this.getNonStandardWeekByDate(timeDate);

      if (week && week.weekAvailability[weekDayIndex]) return week.weekAvailability[weekDayIndex];
    }

    return (
      this.weekAvailability[weekDayIndex] || (this.parent && this.parent.getWeekDay(weekDayIndex, timeDate)) || null
    );
  }

  /**
   * Returns a boolean indicating whether a passed date falls on the weekend or holiday.
   *
   * @param {Date} timeDate A given date (can contain time portion)
   *
   * @return {Boolean}
   */
  isHoliday(timeDate) {
    const secondsSinceEpoch = timeDate - 0,
      holidaysCache = this.holidaysCache;

    if (holidaysCache[secondsSinceEpoch] != null) {
      return holidaysCache[secondsSinceEpoch];
    }

    timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;

    const day = this.getCalendarDay(timeDate);

    if (!day) throw new Error("Can't find day for " + timeDate);

    return (holidaysCache[secondsSinceEpoch] = !day.isWorkingDay);
  }

  /**
   * Returns a "default" calendar day instance, corresponding to the one, generated from {@link #config-defaultAvailability}. By default all working days in the week
   * corresponds to the day with {@link #config-defaultAvailability} set in the `Availability` field and non-working days has empty `Availability`.
   *
   * @param {Number} weekDayIndex The index of the "default" week day to retrieve (0-Sunday, 1-Monday, etc)
   * @return {Scheduler.model.CalendarDayModel}
   */
  getDefaultCalendarDay(weekDayIndex) {
    if (!this.hasOwnProperty('defaultAvailability') && !this.hasOwnProperty('weekendsAreWorkdays') && this.parent) {
      return this.parent.getDefaultCalendarDay(weekDayIndex);
    }

    return this.defaultWeekAvailability[weekDayIndex];
  }

  /**
   * Returns a boolean indicating whether a passed date is a working day.
   *
   * @param {Date} date A given date (can contain time portion which will be ignored)
   *
   * @return {Boolean}
   */
  isWorkingDay(date) {
    return !this.isHoliday(date);
  }

  /**
   * Returns `true` if given date passes on the weekend and `false` otherwise. Weekend days can be re-defined with the {@link #config-weekendFirstDay} and {@link #config-weekendSecondDay} options.
   *
   * @param {Date} timeDate The date to check
   * @return {Boolean}
   */
  isWeekend(timeDate) {
    const dayIndex = timeDate.getDay();
    return dayIndex === this.weekendFirstDay || dayIndex === this.weekendSecondDay;
  }

  /**
   * Convert the duration given in milliseconds to a given unit. Uses the {@link #config-daysPerMonth} configuration option.
   *
   * @param {Number} durationInMs Duration in milliseconds
   * @param {String} unit Duration unit to which the duration should be converted
   *
   * @return {Number} converted value
   */
  convertMSDurationToUnit(durationInMs, unit) {
    return durationInMs / this.unitsInMs[DateHelper.getUnitByName(unit)];
  }

  /**
   * Convert the duration given in some unit to milliseconds. Uses the {@link #config-daysPerMonth} configuration option.
   *
   * @param {Number} durationInMs
   * @param {String} unit
   *
   * @return {Number} converted value
   */
  convertDurationToMs(duration, unit) {
    return duration * this.unitsInMs[DateHelper.getUnitByName(unit)];
  }

  /**
   * This an iterator that passes through the all availability intervals (working time intervals) in the given date range.
   *
   * For example if the default availability in this calendar is [ '09:00-13:00', '14:00-18:00' ] and this function is called, like this:
   *
   *      calendar.forEachAvailabilityInterval(
   *           //             midnight  Friday                 midnight Tuesday
   *          { startDate : new Date(2013, 1, 8), endDate : new Date(2013, 1, 12) },
   *          function (startDate, endDate) { ... }
   *      )
   * then the provided function will be called 4 times with the following arguments:
   *
   *      startDate : new Date(2013, 1, 8, 9),    endDate : new Date(2013, 1, 8, 13)
   *      startDate : new Date(2013, 1, 8, 14),   endDate : new Date(2013, 1, 8, 18)
   *      startDate : new Date(2013, 1, 11, 9),   endDate : new Date(2013, 1, 11, 13)
   *      startDate : new Date(2013, 1, 11, 14),  endDate : new Date(2013, 1, 11, 18)
   *
   *
   * @param {Object} options An object with the following properties:
   * @param {Date} options.startDate A start date of the date range. Can be omitted, if `isForward` flag is set to `false`. In this case iterator
   * will not stop until the call to `func` will return `false`.
   * @param {Date} options.endDate An end date of the date range. Can be omitted, if `isForward` flag is set to `true`. In this case iterator
   * will not stop until the call to `func` will return `false`.
   * @param {Boolean} [options.isForward=true] A flag, defining the direction, this iterator advances in. If set to `true` iterations
   * will start from the `startDate` option and will advance in date increasing direction. If set to `false` iterations will start from the `endDate`
   * option and will advance in date decreasing direction.
   * @param {Function} func A function to call for each availability interval, in the given date range. It receives 2 arguments - the start date
   * of the availability interval and the end date.
   * @param {Object} thisObj `this` reference for the function
   *
   * @return {Boolean} `false` if any of the calls to `func` has returned `false`
   */
  forEachAvailabilityInterval(options, func, thisObj) {
    thisObj = thisObj || this;
    let me = this,
      startDate = options.startDate,
      endDate = options.endDate,
      // isForward by default
      isForward = options.isForward !== false;

    if (isForward ? !startDate : !endDate) {
      throw new Error('At least `startDate` or `endDate` is required, depending from the `isForward` option');
    }

    let cursorDate = new Date(isForward ? startDate : endDate),
      DATE = DateHelper;

    // if no boundary we still have to specify some limit
    if (isForward) {
      if (!endDate) {
        endDate = DATE.add(startDate, options.availabilitySearchLimit || me.availabilitySearchLimit || 5 * 365, 'day');
      }
    } else {
      if (!startDate) {
        startDate = DATE.add(
          endDate,
          -(options.availabilitySearchLimit || me.availabilitySearchLimit || 5 * 365),
          'day'
        );
      }
    }

    // the clearTime() method is called a lot during this method (like 200k times for 2k tasks project)
    // sometimes w/o real need for it since we always advance to the next day's boundary
    // this optimization brings it down to ~10k, ~10% speed up
    let noNeedToClearTime = false;

    while (isForward ? cursorDate < endDate : cursorDate > startDate) {
      // - 1 for backward direction ensures that we are checking correct day,
      // since the endDate is not inclusive - 02/10/2012 means the end of 02/09/2012
      // for backward direction we always clear time, because intervals are cached by the beginning of the day
      let intervals = me.getAvailabilityIntervalsFor(
        cursorDate - (isForward ? 0 : 1),
        isForward ? noNeedToClearTime : false
      );

      // the order of processing is different for forward / backward processing
      for (
        let i = isForward ? 0 : intervals.length - 1;
        isForward ? i < intervals.length : i >= 0;
        isForward ? i++ : i--
      ) {
        let interval = intervals[i],
          intervalStartDate = interval.startDate,
          intervalEndDate = interval.endDate;

        // availability interval is out of [ startDate, endDate )
        if (intervalStartDate >= endDate || intervalEndDate <= startDate) continue;

        let countingFrom = intervalStartDate < startDate ? startDate : intervalStartDate,
          countingTill = intervalEndDate > endDate ? endDate : intervalEndDate;

        if (func.call(thisObj, countingFrom, countingTill) === false) return false;
      }

      cursorDate = isForward
        ? DATE.getStartOfNextDay(cursorDate, false, noNeedToClearTime)
        : DATE.getEndOfPreviousDay(cursorDate, noNeedToClearTime);

      noNeedToClearTime = true;
    }
  }

  /**
   * Calculate the duration in the given `unit` between 2 dates, taking into account the availability/holidays information (non-working time will be excluded from the duration).
   *
   * @param {Date} startDate The start date
   * @param {Date} endDate The end date
   * @param {String} unit One of the units used by DateHelper
   *
   * @return {Number} Working time duration between given dates.
   */
  calculateDuration(startDate, endDate, unit) {
    let duration = 0;

    this.forEachAvailabilityInterval(
      {
        startDate: startDate,
        endDate: endDate
      },
      (intervalStartDate, intervalEndDate) => {
        let dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();

        duration += intervalEndDate - intervalStartDate + dstDiff * 60 * 1000;
      }
    );

    return this.convertMSDurationToUnit(duration, unit);
  }

  /**
   * Returns an array of ranges for non-working days between `startDate` and `endDate`. For example normally, given a
   * full month, it will return an array of 4 `Scheduler.model.TimeSpan` instances, containing ranges for the
   * weekends. If a holiday lasts for several days and all {@link Scheduler.model.CalendarDayModel} instances have
   * the same `cls` value then all days will be combined into a single range.
   *
   * @param {Date} startDate - A start date of the timeframe to extract the holidays from
   * @param {Date} endDate - An end date of the timeframe to extract the holidays from
   *
   * @return {Scheduler.model.TimeSpan[]}
   */
  getHolidaysRanges(startDate, endDate, includeWeekends) {
    if (startDate > endDate) {
      throw new Error("startDate can't be bigger than endDate");
    }

    startDate = DateHelper.clearTime(startDate);
    endDate = DateHelper.clearTime(endDate);

    let ranges = [],
      currentRange,
      date;

    for (date = startDate; date < endDate; date = DateHelper.getNext(date, 'day', 1)) {
      if (this.isHoliday(date) || (this.weekendsAreWorkdays && includeWeekends && this.isWeekend(date))) {
        const day = this.getCalendarDay(date),
          cssClass = (day && day.cls) || this.defaultNonWorkingTimeCssCls,
          nextDate = DateHelper.getNext(date, 'day', 1);

        // starts new range
        if (!currentRange) {
          currentRange = new TimeSpan({
            startDate: date,
            endDate: nextDate,
            cls: cssClass
          });
        } else {
          // checks if the range is still the same
          if (currentRange.cls.isEqual(cssClass)) {
            currentRange.endDate = nextDate;
          } else {
            ranges.push(currentRange);

            currentRange = new TimeSpan({
              startDate: date,
              endDate: nextDate,
              cls: cssClass
            });
          }
        }
      } else {
        if (currentRange) {
          ranges.push(currentRange);
          currentRange = null;
        }
      }
    }

    if (currentRange) {
      ranges.push(currentRange);
    }

    return ranges;
  }

  /**
   * Calculate the end date for the given start date and duration, taking into account the availability/holidays information (non-working time will not be counted as duration).
   *
   * @param {Date} startDate The start date
   * @param {Number} duration The "pure" duration (w/o any non-working time).
   * @param {String} unit One of the units of the {@link Common.helper.DateHelper} class.
   *
   * @return {Date} The end date
   */
  calculateEndDate(startDate, duration, unit) {
    // if duration is 0 - return the same date
    if (!duration) {
      return new Date(startDate);
    }

    let DATE = DateHelper,
      endDate;

    duration = this.convertDurationToMs(duration, unit);

    let startFrom =
      // milestone case, which we don't want to re-schedule to the next business days
      // milestones should start/end in the same day as its incoming dependency
      duration === 0 && DATE.clearTime(startDate, true) - startDate === 0 ? DATE.add(startDate, -1, 'day') : startDate;

    this.forEachAvailabilityInterval({ startDate: startFrom }, function(intervalStartDate, intervalEndDate) {
      let diff = intervalEndDate - intervalStartDate,
        dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();

      if (diff >= duration) {
        endDate = new Date(intervalStartDate - 0 + duration);

        return false;
      } else {
        duration -= diff + dstDiff * 60 * 1000;
      }
    });

    return endDate;
  }

  /**
   * This method starts from the given `date` and moves forward/backward in time (depending from the `isForward` flag) skiping the non-working time.
   * It returns the nearest edge of the first working time interval it encounters. If the given `date` falls on the working time, then `date` itself is returned.
   *
   * For example, if this function is called with some Saturday as `date` and `isForward` flag is set, it will return the earliest working hours on following Monday.
   * If `isForward` flag will be set to `false` - it will return the latest working hours on previous Friday.
   *
   * @param {Date} date A date (presumably falling on the non-working time).
   * @param {Boolean} isForward Pass `true` to skip the non-working time in forward direction, `false` - in backward
   *
   * @return {Date} Nearest working date.
   */
  skipNonWorkingTime(date, isForward) {
    let found = false;
    // reseting the date to the earliest availability interval
    this.forEachAvailabilityInterval(
      isForward ? { startDate: date } : { endDate: date, isForward: false },

      (intervalStartDate, intervalEndDate) => {
        date = isForward ? intervalStartDate : intervalEndDate;
        found = true;

        return false;
      }
    );

    if (!found)
      throw new Error(
        'skipNonWorkingTime: Cannot skip non-working time, please ensure that this calendar has any working period of time specified'
      );

    return new Date(date);
  }

  /**
   * Calculate the start date for the given end date and duration, taking into account the availability/holidays information (non-working time will not be counted as duration).
   *
   * @param {Date} endDate The end date
   * @param {Number} duration The "pure" duration (w/o any non-working time).
   * @param {String} unit One of the units of the {@link Common.helper.DateHelper} class.
   *
   * @return {Date} The start date
   */
  calculateStartDate(endDate, duration, unit) {
    // if duration is 0 - return the same date
    if (!duration) {
      return new Date(endDate);
    }

    let startDate;

    duration = this.convertDurationToMs(duration, unit);

    this.forEachAvailabilityInterval(
      {
        endDate: endDate,
        isForward: false
      },
      (intervalStartDate, intervalEndDate) => {
        const diff = intervalEndDate - intervalStartDate;

        if (diff >= duration) {
          startDate = new Date(intervalEndDate - duration);

          return false;
        } else {
          duration -= diff;
        }
      }
    );

    return startDate;
  }

  /**
   * This method starts from the given `date` and moves forward/backward in time (depending from the `duration` argument).
   * It stops as soon as it skips the amount of *working* time defined by the `duration` and `unit` arguments. Skipped non-working time simply will not
   * be counted.
   *
   * **Note** that this method behaves differently from the {@link #function-skipNonWorkingTime} - that method stops as soon as it encounters the non-working time.
   * This method stops as soon as it accumulate enough skipped working time.
   *
   * @param {Date} date A starting point
   * @param {Number} duration The duration of the working time. To skip working time in backward direction pass a negative value.
   * @param {String} unit One of the units of the {@link Common.helper.DateHelper} class.
   *
   * @return {Date}
   */
  skipWorkingTime(date, duration, unit) {
    return duration >= 0 ? this.calculateEndDate(date, duration, unit) : this.calculateStartDate(date, -duration, unit);
  }

  isChildOf(calendar) {
    let parent = this,
      found = false;

    while (parent && !found) {
      found = parent === calendar;
      parent = parent.parent;
    }

    return found;
  }

  getParentableCalendars() {
    const me = this,
      calendars = Calendar.getAllCalendars();

    return calendars.reduce((result, calendar) => {
      if (calendar !== me && !calendar.isChildOf(me)) {
        result.push({ id: calendar.calendarId, name: calendar.name || calendar.calendarId });
      }
      return result;
    }, []);
  }

  get parent() {
    return this._parent;
  }

  /**
     * Returns the availability intervals of a specific day. Potentially can consult a parent calendar.
     *
     * @param {Date|Number} timeDate A date or timestamp
     * @return {Object[]} Array of objects, like:

     {
         startDate       : new Date(...),
         endDate         : new Date(...)
     }
     */
  getAvailabilityIntervalsFor(timeDate, noNeedToClearTime) {
    if (noNeedToClearTime) {
      timeDate = timeDate.valueOf();
    } else if (timeDate instanceof Date) {
      timeDate = new Date(timeDate.getFullYear(), timeDate.getMonth(), timeDate.getDate()).valueOf();
    } else {
      timeDate = DateHelper.clearTime(new Date(timeDate)).valueOf();
    }

    return (this.availabilityIntervalsCache[timeDate] =
      this.availabilityIntervalsCache[timeDate] || this.getCalendarDay(timeDate).getAvailabilityIntervalsFor(timeDate));
  }

  onParentDestroy() {
    this.parent = null;
  }

  isAvailabilityIntersected(withCalendar, startDate, endDate) {
    let ownWeekDay, ownAvailability, testWeekDay, testAvailability;

    // first let's try to find overlapping of weeks (check daily intervals)
    // loop over week days
    for (let i = 0; i < 7; i++) {
      ownWeekDay = this.getWeekDay(i) || this.getDefaultCalendarDay(i);
      testWeekDay = withCalendar.getWeekDay(i) || withCalendar.getDefaultCalendarDay(i);

      if (!ownWeekDay || !testWeekDay) continue;

      // get daily intervals
      ownAvailability = ownWeekDay.getAvailability();
      testAvailability = testWeekDay.getAvailability();

      // loop over intervals to find overlapping
      for (let j = 0, l = ownAvailability.length; j < l; j++) {
        for (let k = 0, ll = testAvailability.length; k < ll; k++) {
          if (
            testAvailability[k].startTime < ownAvailability[j].endTime &&
            testAvailability[k].endTime > ownAvailability[j].startTime
          ) {
            return true;
          }
        }
      }
    }

    let result = false;

    this.forEachNonStandardWeek((week) => {
      if (week.startDate >= endDate) return false;

      if (startDate < week.endDate) {
        result = true;
        // stop the iteration
        return false;
      }
    });

    return result;
  }
}
Calendar._$name = 'Calendar';

/**
 * @module Scheduler/data/mixin/ResourceStoreMixin
 */

/**
 * This is a mixin for the ResourceStore functionality. It is consumed by the {@link Scheduler.data.ResourceStore}.
 *
 * @mixin
 */
var ResourceStoreMixin = (Target) =>
  class ResourceStoreMixin extends (Target || Base) {
    /**
     * Get/set the associated event store instance
     *
     * @property {Scheduler.data.EventStore}
     */
    get eventStore() {
      return this._eventStore;
    }

    set eventStore(eventStore) {
      const me = this;

      if (me._eventStore !== eventStore) {
        const oldStore = me._eventStore;
        me._eventStore = eventStore || null;

        if (eventStore && !eventStore.resourceStore) {
          eventStore.resourceStore = me;
        }

        /**
         * Fires when new event store is set via {@link #property-eventStore} method.
         * @event eventstorechange
         * @param {Scheduler.data.ResourceStore}   this
         * @param {Scheduler.data.EventStore} newEventStore
         * @param {Scheduler.data.EventStore} oldEventStore
         */
        me.trigger('eventStoreChange', { newEventStore: eventStore, oldEventStore: oldStore });
      }
    }

    getScheduledEventsInTimeSpan(start, end, eventStore = this.eventStore) {
      // TODO: PORT check if correct
      return this.reduce((events, resource) => {
        events.concat(
          eventStore.getEventsForResource(resource).reduce((events, event) => {
            if (event.intersectsRange(start, end)) events.push(event);
          })
        );
      });
    }
  };

/**
 * @module Scheduler/model/ResourceModel
 */

/**
 * This class represent a single Resource in the scheduler chart. It's a subclass of  {@link Common.data.Model}.
 * Please refer to the documentation for that class to become familiar with the base interface of the resource.
 *
 * A Resource has only 2 mandatory fields - `id` and `name`. If you want to add more fields with meta data describing your resources then you should subclass this class:
 *
 * ```javascript
 * class MyResource extends ResourceModel {
 *
 *   static get fields() {
 *     [
 *       // `Id` and `Name` fields are already provided by the superclass
 *       { name: 'company', type : 'string' }
 *     ];
 *   }
 *
 *   getCompany() {
 *     return this.company;
 *   }
 *   ...
 * });
 * ```
 * If you want to use other names in your data for the id and name fields you can configure them as seen below:
 * ```javascript
 * class MyResource extends ResourceModel {
 *
 *   static get fields() {
 *     return [
 *        { name: 'name', dataSource: 'userName' }
 *     ];
 *   },
 *   ...
 * });
 * ```
 * Please refer to {@link Common.data.Model} for details.
 *
 * @extends Grid/data/GridRowModel
 */
class ResourceModel extends GridRowModel {
  //region Fields

  static get fields() {
    return [
      /**
       * Unique identifier
       * @field {String|Number} id
       */

      /**
       * Get or set resource name
       * @field {String} name
       */
      { name: 'name', type: 'string', persist: true },

      /**
       * Controls the primary color used for events assigned to this resource. Can be overridden per event using
       * {@link Scheduler/model/EventModel#field-eventColor}
       * @field {String} eventColor
       */
      'eventColor',

      /**
       * Controls the style used for events assigned to this resource. Can be overridden per event using
       * {@link Scheduler/model/EventModel#field-eventStyle}
       * @field {String} eventStyle
       */
      'eventStyle',

      /**
       * Image URL, used by `ResourceInfoColumn` and vertical modes `ResourceHeader` to display a miniature image
       * for the resource.
       * @field {String} imageUrl
       */
      'imageUrl'
    ];
  }

  // ResoureModel#assignments is created by a relation defined in AssignmentModel
  /**
   * Returns all assignments for the resource. Resource must be part of the store for this method to work.
   * @member {Scheduler.model.AssignmentModel[]} assignments
   */

  //endregion

  //region Stores

  /**
   * Returns a resource store this resource is part of. Resource must be part
   * of a resource store to be able to retrieve resource store.
   *
   * @return {Scheduler.data.ResourceStore}
   * @readonly
   */
  get resourceStore() {
    return this.stores && this.stores[0];
  }

  /**
   * Returns an event store this resource uses as default. Resource must be part
   * of a resource store to be able to retrieve event store.
   *
   * @return {Scheduler.data.EventStore}
   * @readonly
   */
  get eventStore() {
    const resourceStore = this.resourceStore;
    // TODO: this.parentNode... is not ported
    return (resourceStore && resourceStore.eventStore) || (this.parentNode && this.parentNode.eventStore);
  }

  /**
   * Returns as assignment store this resources uses as default. Resource must be part
   * of a resource store to be able to retrieve default assignment store.
   *
   * @return {Scheduler.data.AssignmentStore}
   * @readonly
   */
  get assignmentStore() {
    const eventStore = this.eventStore;
    return eventStore && eventStore.assignmentStore;
  }

  //endregion

  //region Getters

  /**
   * Get associated events
   * @returns {Scheduler.model.EventModel[]}
   * @readonly
   */
  get events() {
    // Cannot use relation here, since it wont work in mult assignment
    // TODO: Investigate making relations handle many-to-many using intermediate store? To have it cached
    return this.eventStore && this.eventStore.getEventsForResource(this);
  }

  // /**
  //  * Returns all assignments for the resource. Resource must be part of the store for this method to work.
  //  *
  //  * @return {Scheduler.model.AssignmentModel[]}
  //  * @readonly
  //  */
  // get assignments() {
  //     const me         = this,
  //         eventStore = me.eventStore;
  //
  //     return eventStore && eventStore.getAssignmentsForResource(me);
  // }

  /**
   * Returns an array of events, associated with this resource
   *
   * @param {Scheduler.data.EventStore} eventStore (optional) The event store to get events for (if a resource is bound to multiple stores)
   * @return {Scheduler.model.TimeSpan[]}
   */
  // TODO: Needed?
  getEvents(eventStore = this.eventStore) {
    return (eventStore && eventStore.getEventsForResource(this)) || [];
  }

  /**
   * Returns true if the Resource can be persisted.
   * In a flat store resource is always considered to be persistable, in a tree store resource is considered to
   * be persitable if it's parent node is persistable.
   *
   * @return {Boolean} true if this model can be persisted to server.
   * @readonly
   */
  get isPersistable() {
    const parent = this.parentNode;
    // TODO: not ported yet
    return !parent || !parent.phantom || (parent.isRoot && parent.isRoot());
  }

  //endregion

  /**
   * Returns true if this resource model is above the passed resource model
   * @param {Scheduler.model.ResourceModel} otherResource
   * @returns {Boolean}
   */
  isAbove(otherResource) {
    let me = this,
      store = me.resourceStore,
      current,
      myAncestors,
      otherAncestors,
      commonAncestorsLength,
      lastCommonAncestor;

    if (me === otherResource) return false;

    if (store.tree) {
      //TODO: not ported

      // Getting self ancestors this node including
      current = me;
      myAncestors = [];
      while (current) {
        myAncestors.push(current);
        current = current.parentNode;
      }

      // Getting other ancestors other node including
      current = otherResource;
      otherAncestors = [];
      while (current) {
        otherAncestors.push(current);
        current = current.parentNode;
      }

      // Getting common ancestors sequence length
      commonAncestorsLength = 0;
      while (
        commonAncestorsLength < myAncestors.length - 1 &&
        commonAncestorsLength < otherAncestors.length - 1 &&
        myAncestors[commonAncestorsLength] == otherAncestors[commonAncestorsLength]
      ) {
        ++commonAncestorsLength;
      }

      // Getting last common ancesstor
      lastCommonAncestor = myAncestors[commonAncestorsLength];

      // Here the next ancestor in myAncestors and next ancesstor in otherAncestors are siblings and
      // thus designate which node is above
      me = myAncestors[commonAncestorsLength + 1];
      otherResource = otherAncestors[commonAncestorsLength + 1];

      return lastCommonAncestor.indexOf(me) < lastCommonAncestor.indexOf(otherResource);
    }

    return store.indexOf(me) < store.indexOf(otherResource);
  }

  /**
   * Unassigns this Resource from all its Events
   */
  unassignAll(removingResource) {
    this.events && this.events.slice().forEach((event) => event.unassign(this, removingResource));
  }
}

ResourceModel.exposeProperties();
ResourceModel._$name = 'ResourceModel';

/**
 * @module Scheduler/data/ResourceStore
 */

/**
 * This is a class holding the collection the {@link Scheduler.model.ResourceModel resources} to be rendered into a
 * {@link Scheduler.view.Scheduler scheduler}.
 *
 * @mixes Scheduler/data/mixin/ResourceStoreMixin
 * @extends Common/data/AjaxStore
 */
class ResourceStore extends ResourceStoreMixin(AjaxStore) {
  static get defaultConfig() {
    return {
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 200,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 100,
      modelClass: ResourceModel,
      storeId: 'resources',
      autoTree: true
    };
  }

  construct(config) {
    super.construct(config);

    if (this.modelClass !== ResourceModel && !(this.modelClass.prototype instanceof ResourceModel)) {
      throw new Error('Model for ResourceStore must subclass ResourceModel');
    }
  }

  remove(recordsOrIds) {
    recordsOrIds = Array.isArray(recordsOrIds) ? recordsOrIds : [recordsOrIds];

    for (let r of recordsOrIds) {
      const record = this.getById(r);
      // Unassign flagged as part of removal, to let UI make intelligent (?) decisions about what to update
      record.unassignAll(true);
    }

    super.remove(recordsOrIds);
  }

  removeAll() {
    this.traverse((resourceRecord) => resourceRecord.unassignAll(true));

    super.removeAll();
  }
}
ResourceStore._$name = 'ResourceStore';

/**
 * @module Scheduler/data/util/ModelPersistencyManager
 */

/**
 * This class manages model persistency, it listens to model stores' beforesync event and removes all non persistable
 * records from sync operation. The logic has meaning only for CRUD-less sync operations.
 *
 * @private
 */
class ModelPersistencyManager extends Base {
  // region Event attachers

  set eventStore(newEventStore) {
    const me = this;

    me.eventStoreDetacher && me.eventStoreDetacher();
    me._eventStore = newEventStore;

    if (newEventStore && newEventStore.autoCommit) {
      me.eventStoreDetacher = newEventStore.on({
        beforecommit: me.onEventStoreBeforeSync,
        thisObj: me,
        detachable: true,
        // Just in case
        prio: 100
      });
    }
  }

  get eventStore() {
    return this._eventStore;
  }

  set resourceStore(newResourceStore) {
    const me = this;

    me.resourceStoreDetacher && me.resourceStoreDetacher();
    me._resourceStore = newResourceStore;

    if (newResourceStore && newResourceStore.autoCommit) {
      me.resourceStoreDetacher = newResourceStore.on({
        beforecommit: me.onResourceStoreBeforeSync,
        thisObj: me,
        detachable: true,
        // Just in case
        prio: 100
      });
    }
  }

  get resourceStore() {
    return this._resourceStore;
  }

  set assignmentStore(newAssignmentStore) {
    const me = this;

    me.assignmentStoreDetacher && me.assignmentStoreDetacher();
    me._assignmentStore = newAssignmentStore;

    if (newAssignmentStore && newAssignmentStore.autoSync) {
      me.assignmentStoreDetacher = newAssignmentStore.on({
        beforecommit: me.onAssignmentStoreBeforeSync,
        thisObj: me,
        detachable: true,
        // Just in case
        prio: 100
      });
    }
  }

  get assignmentStore() {
    return this._assignmentStore;
  }

  set dependencyStore(newDependencyStore) {
    const me = this;

    me.dependencyStoreDetacher && me.dependencyStoreDetacher();
    me._dependencyStore = newDependencyStore;

    if (newDependencyStore && newDependencyStore.autoSync) {
      me.dependencyStoreDetacher = newDependencyStore.on({
        beforecommit: me.onDependencyStoreBeforeSync,
        thisObj: me,
        detachable: true,
        // Just in case
        prio: 100
      });
    }
  }

  get dependencyStore() {
    return this._dependencyStore;
  }

  // endregion

  // region Event handlers

  onEventStoreBeforeSync({ changes }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }

  onResourceStoreBeforeSync({ changes }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }

  onAssignmentStoreBeforeSync({ changes }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }

  onDependencyStoreBeforeSync({ changes }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }

  // endregion

  // region Management rules

  removeNonPersistableRecordsToCreate(changes) {
    let recordsToCreate = changes.added || [],
      r,
      i;

    // We remove from the array we iterate thus we iterate from end to start
    for (i = recordsToCreate.length - 1; i >= 0; --i) {
      r = recordsToCreate[i];
      if (!r.isPersistable) {
        recordsToCreate.splice(recordsToCreate.indexOf(r), 1);
      }
    }

    // Prevent empty create request
    if (recordsToCreate.length === 0) {
      changes.added.length = 0;
    }
  }

  shallContinueSync(options) {
    return Boolean(
      (options.added && options.added.length > 0) ||
        (options.modified && options.modified.length > 0) ||
        (options.removed && options.removed.length > 0)
    );
  }

  // endregion
}
ModelPersistencyManager._$name = 'ModelPersistencyManager';

// TODO: PORT Make getters/setters?

/**
 * @module Scheduler/data/mixin/EventStoreMixin
 */

const validResourceIdTypes = {
  string: 1,
  number: 1
};

/**
 * This is a mixin, containing functionality related to managing events.
 *
 * It is consumed by the regular {@link Scheduler.data.EventStore} class and the Gantt `TaskStore` classes
 * to allow data sharing between a Gantt chart and a Scheduler.
 *
 * @mixin
 */
var EventStoreMixin = (Target) =>
  class EventStoreMixin extends (Target || Base) {
    // doDestroy() {
    //      this.modelPersistencyManager.destroy();
    // }

    //endregion

    //region Connected stores (Resource, Assigment & Dependency)

    /**
     * Get/set the resource store for this store
     * @property {Scheduler.data.ResourceStore}
     */
    get resourceStore() {
      return this._resourceStore;
    }

    set resourceStore(resourceStore) {
      const me = this,
        oldStore = me._resourceStore;

      if (oldStore) {
        oldStore.eventStore = null;
        if (me.modelPersistencyManager) me.modelPersistencyManager.resourceStore = null;
      }

      me._resourceStore = resourceStore || null;

      if (resourceStore) {
        if (me.modelPersistencyManager) me.modelPersistencyManager.resourceStore = me._resourceStore;
        resourceStore.eventStore = me;
      }

      // If store is assigned after configuration we need to init relations
      if (!me.isConfiguring) {
        me.initRelations(true);
      }

      if ((oldStore || resourceStore) && oldStore !== resourceStore) {
        /**
         * Fires when new resource store is set via {@link #property-resourceStore} setter.
         * @event resourcestorechange
         * @param {Scheduler.data.EventStore}         this
         * @param {Scheduler.data.ResourceStore} newResourceStore
         * @param {Scheduler.data.ResourceStore} oldResourceStore
         */
        me.trigger('resourceStoreChange', { newResourceStore: resourceStore, oldResourceStore: oldStore });
      }
    }

    /**
     * Get/set assignment store this event store is using by default
     * @property {Scheduler.data.AssignmentStore}
     */
    get assignmentStore() {
      return this._assignmentStore;
    }

    set assignmentStore(assignmentStore) {
      const me = this,
        oldStore = me._assignmentStore;

      if (oldStore) {
        oldStore.eventStore = null;
        if (me.modelPersistencyManager) me.modelPersistencyManager.assignmentStore = null;
      }

      me._assignmentStore = assignmentStore || null;

      if (assignmentStore) {
        if (me.modelPersistencyManager) me.modelPersistencyManager.assignmentStore = me._assignmentStore;
        assignmentStore.eventStore = me;
      }

      // If store is assigned after configuration we need to init relations
      if (!me.isConfiguring) {
        me.initRelations(true);
      }

      if ((oldStore || assignmentStore) && oldStore !== assignmentStore) {
        /**
         * Fires when new assignment store is set via {@link #property-assignmentStore} setter.
         * @event assignmentStoreChange
         * @param {Scheduler.data.EventStore}           this
         * @param {Scheduler.data.AssignmentStore} newAssignmentStore
         * @param {Scheduler.data.AssignmentStore} oldAssignmentStore
         */
        me.trigger('assignmentStoreChange', { newAssignmentStore: assignmentStore, oldAssignmentStore: oldStore });
      }
    }

    /**
     * Get/set a dependecy store instance this event store is associated with
     * Get/set a dependecy store instance this event store is associated with
     * @property {Scheduler.data.DependencyStore}
     */
    get dependencyStore() {
      return this._dependencyStore;
    }

    set dependencyStore(dependencyStore) {
      const me = this,
        oldStore = me._dependencyStore;

      if (oldStore) {
        oldStore.eventStore = null;
        if (me.modelPersistencyManager) me.modelPersistencyManager.dependencyStore = null;
      }

      me._dependencyStore = dependencyStore || null;

      if (me._dependencyStore) {
        if (me.modelPersistencyManager) me.modelPersistencyManager.dependencyStore = me._dependencyStore;
        me._dependencyStore.eventStore = me;
      }

      if ((oldStore || dependencyStore) && oldStore !== dependencyStore) {
        /**
         * Fires when new dependency store is set via {@link #property-dependencyStore} setter.
         * @event dependencystorechange
         * @param {Scheduler.data.EventStore}           this
         * @param {Scheduler.data.DependencyStore} newDependencyStore
         * @param {Scheduler.data.DependencyStore} oldDependencyStore
         */
        me.trigger('dependencyStoreChange', { newDependencyStore: dependencyStore, oldDependencyStore: oldStore });
      }
    }

    /**
     * Provide assignment store to enable multiple connections between events and resources
     * @config {Scheduler.data.AssignmentStore} assignmentStore
     */

    //endregion

    //region Init & destroy

    construct(config) {
      const me = this;

      super.construct(config);

      Object.assign(me, {
        isEventStore: true,
        autoTree: true,
        modelPersistencyManager: me.createModelPersistencyManager()
      });
    }

    /**
     * Creates and returns model persistency manager
     *
     * @return {Scheduler.data.util.ModelPersistencyManager}
     * @internal
     */
    createModelPersistencyManager() {
      const me = this;
      return new ModelPersistencyManager({
        eventStore: me,
        resourceStore: me.resourceStore,
        assignmentStore: me.assignmentStore,
        dependencyStore: me.dependencyStore
      });
    }

    //endregion

    //region Events records, iteration etc.

    /**
     * Returns events between the supplied start and end date
     * @param {Date} start The start date
     * @param {Date} end The end date
     * @param {Boolean} allowPartial false to only include events that start and end inside of the span
     * @param {Boolean} onlyAssigned true to only include events that are assigned to a resource
     * @return {Scheduler.model.EventModel[]} the events
     * @category Events
     */
    getEventsInTimeSpan(start, end, allowPartial = true, onlyAssigned = false) {
      const events = [];

      this.forEachScheduledEvent((event, eventStart, eventEnd) => {
        if (
          (allowPartial && DateHelper.intersectSpans(eventStart, eventEnd, start, end)) ||
          (!allowPartial && eventStart - start >= 0 && end - eventEnd >= 0)
        ) {
          if (!onlyAssigned || event.resources.length > 0) {
            events.push(event);
          }
        }
      });

      return events;
    }

    /**
     * Returns all events that starts on the specified day.
     * @param start Start date
     * @returns {Scheduler.model.EventModel[]} Events starting on specified day
     * @category Events
     */
    getEventsByStartDate(start) {
      const events = [];

      this.forEachScheduledEvent((event, eventStart, eventEnd) => {
        if (DateHelper.isEqual(eventStart, start, 'day')) {
          events.push(event);
        }
      });

      return events;
    }

    /**
     * Calls the supplied iterator function once for every scheduled event, providing these arguments
     * - event : the event record
     * - startDate : the event start date
     * - endDate : the event end date
     *
     * Returning false cancels the iteration.
     *
     * @param {Function} fn iterator function
     * @param {Object} thisObj `this` reference for the function
     * @category Events
     */
    forEachScheduledEvent(fn, thisObj = this) {
      this.forEach((event) => {
        const eventStart = event.startDate,
          eventEnd = event.endDate;

        if (eventStart && eventEnd) return fn.call(thisObj, event, eventStart, eventEnd);
      });
    }

    /**
     * Returns an object defining the earliest start date and the latest end date of all the events in the store.
     *
     * @return {Object} An object with 'start' and 'end' Date properties (or null values if data is missing).
     * @category Events
     */
    getTotalTimeSpan() {
      let earliest = new Date(9999, 0, 1),
        latest = new Date(0);

      this.forEach((r) => {
        if (r.startDate) earliest = DateHelper.min(r.startDate, earliest);
        if (r.endDate) latest = DateHelper.max(r.endDate, latest);
      });

      // TODO: this will fail in programs designed to work with events in the past (after Jan 1, 1970)
      earliest = earliest < new Date(9999, 0, 1) ? earliest : null;
      latest = latest > new Date(0) ? latest : null;

      // keep last calculated value to be able to track total timespan changes
      return (this.lastTotalTimeSpan = {
        startDate: earliest || null,
        endDate: latest || earliest || null
      });
    }

    /**
     * Checks if given event record is persistable.
     * In case assignment store is used to assign events to resources and vise versa event is considered to be always
     * persistable. Otherwise backward compatible logic is used, i.e. event is considered to be persistable when
     * resources it's assigned to are not phantom.
     *
     * @param {Scheduler.model.EventModel} event
     * @return {Boolean}
     * @category Events
     */
    isEventPersistable(event) {
      let me = this,
        assignmentStore = me.assignmentStore;

      if (!assignmentStore) return !event.resource.hasGeneratedId; //!event.resources.some(resource => resource.hasGeneratedId);

      return true;
    }

    //endregion

    //region Resource

    /**
     * Checks if a date range is allocated or not for a given resource.
     * @param {Date} start The start date
     * @param {Date} end The end date
     * @param {Scheduler.model.EventModel} excludeEvent An event to exclude from the check (or null)
     * @param {Scheduler.model.ResourceModel} resource The resource
     * @return {Boolean} True if the timespan is available for the resource
     * @category Resource
     */
    isDateRangeAvailable(start, end, excludeEvent, resource) {
      if (excludeEvent instanceof AssignmentModel) {
        const currentEvent = excludeEvent.event,
          resources = currentEvent.resources,
          allEvents = new Set(resource.events);

        resources.forEach((resource) => {
          resource.events.forEach((e) => allEvents.add(e));
        });

        allEvents.delete(currentEvent);

        return !Array.from(allEvents).some((ev) => DateHelper.intersectSpans(start, end, ev.startDate, ev.endDate));
      }
      return !this.getEventsForResource(resource).some(
        (ev) => !(excludeEvent === ev || !DateHelper.intersectSpans(start, end, ev.startDate, ev.endDate))
      );
    }

    /**
     * Filters the events associated with a resource, based on the function provided. An array will be returned for those
     * events where the passed function returns true.
     * @param {Scheduler.model.ResourceModel} resource
     * @param {Function} fn The function
     * @param {Object} [thisObj] `this` reference for the function
     * @return {Scheduler.model.EventModel[]} the events in the time span
     * @private
     * @category Resource
     */
    filterEventsForResource(resource, fn, thisObj = this) {
      // `getEvents` method of the resource will use either `indexByResource` or perform a full scan of the event store
      return resource.getEvents(this).filter(fn.bind(thisObj));
    }

    // This method provides a way for the store to append a new record, and the consuming class has to implement it
    // since Store and TreeStore don't share the add API.
    //append(record) {
    //    throw 'Must be implemented by consuming class';
    //}

    /**
     * Returns all resources assigned to an event.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @return {Scheduler.model.ResourceModel[]}
     * @category Resource
     */
    getResourcesForEvent(event) {
      if (this.assignmentStore) {
        return this.assignmentStore.getResourcesForEvent(event);
      }

      event = this.getById(event);

      return event.resource && !event.resource.placeHolder ? [event.resource] : [];
    }

    /**
     * Returns all events assigned to a resource
     *
     * @param {Scheduler.model.ResourceModel|String|Number} resource Resource or resource id
     * @return {Scheduler.model.EventModel[]}
     * @category Resource
     */
    getEventsForResource(resource) {
      const me = this,
        assignmentStore = me.assignmentStore;

      if (assignmentStore) {
        return assignmentStore.getEventsForResource(resource);
      }

      // *not* if (!['string', 'number'].includes(typeof resource))
      // Always avoid array iteration. It was only two, but it's the principle.
      // Also a constant expression should be declared at module level,
      // otherwise it becomes collectable garbage on each invocation.
      if (!validResourceIdTypes[typeof resource]) {
        resource = resource.id;
      }

      // Could be changed to use resource.events, but that would require getting model by id. This way is a bit faster
      const cache = me.relationCache.resource && me.relationCache.resource[resource];
      // Slice to be safe from outside manipulation of the array
      return cache ? cache.slice() : [];
    }

    //endregion

    //region Assignment

    /**
     * Returns all assignments for a given event.
     * Works only if {@link #property-assignmentStore} is defined, otherwise returns an empty array.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @return {Scheduler.model.AssignmentModel[]}
     * @category Assignment
     */
    getAssignmentsForEvent(event) {
      return (this.assignmentStore && this.assignmentStore.getAssignmentsForEvent(event)) || [];
    }

    /**
     * Returns all assignments for a given resource.
     * Works only if {@link #property-assignmentStore} is defined, otherwise returns an empty array.
     *
     * @param {Scheduler.model.ResourceModel|String|Number} resource
     * @return {Scheduler.model.AssignmentModel[]}
     * @category Assignment
     */
    getAssignmentsForResource(resource) {
      return (this.assignmentStore && this.assignmentStore.getAssignmentsForResource(resource)) || [];
    }

    /**
     * Creates and adds assignment record for a given event and a resource.
     *
     * @param {Scheduler.model.EventModel|String|number} event
     * @param {Scheduler.model.ResourceModel|String|number|Scheduler.model.ResourceModel[]|String[]|number[]} resource The resource(s) to assign to the event
     * @privateparam {Boolean} [removeExistingAssignments] true to first remove existing assignments
     * @category Assignment
     */
    assignEventToResource(event, resource, removeExistingAssignments = false) {
      const me = this,
        assignmentStore = me.assignmentStore;

      if (assignmentStore) {
        assignmentStore.assignEventToResource(event, resource, undefined, removeExistingAssignments);
      } else {
        event = me.getById(event);

        if (Array.isArray(resource)) {
          resource = resource[0];
        }

        resource = resource instanceof ResourceModel ? resource.id : resource; // resource id might be 0 thus we use ? operator

        if (event) {
          event.resourceId = resource;
        }
      }
    }

    /**
     * Removes assignment record for a given event and a resource.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @param {Scheduler.model.ResourceModel|String|Number} resource
     * @category Assignment
     */
    unassignEventFromResource(event, resource) {
      const me = this,
        assignmentStore = me.assignmentStore;

      if (assignmentStore) {
        assignmentStore.unassignEventFromResource(event, resource);
      } else {
        event = me.getById(event);
        resource = resource instanceof ResourceModel ? resource.id : resource; // resource id might be 0 thus we use ? operator
        if (event && event.resourceId == resource) {
          event.resourceId = null;
        }
      }
    }

    /**
     * Reassigns an event from an old resource to a new resource
     *
     * @param {Scheduler.model.EventModel}    event    An event or id of the event to reassign
     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} oldResource A resource or id to unassign from
     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} newResource A resource or id to assign to
     * @category Assignment
     */
    reassignEventFromResourceToResource(event, oldResource, newResource) {
      const me = this,
        assignmentStore = me.assignmentStore,
        newResourceId = Model.asId(newResource),
        oldResourceId = Model.asId(oldResource);

      if (assignmentStore) {
        const assignment = assignmentStore.getAssignmentForEventAndResource(event, oldResource);

        if (assignment) {
          assignment.resourceId = newResourceId;
        } else {
          assignmentStore.assignEventToResource(event, newResource);
        }
      } else {
        event = me.getById(event);
        if (event.resourceId == oldResourceId) {
          event.resourceId = newResourceId;
        }
      }
    }

    /**
     * Checks whether an event is assigned to a resource.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @param {Scheduler.model.ResourceModel|String|Number} resource
     * @return {Boolean}
     * @category Assignment
     */
    isEventAssignedToResource(event, resource) {
      let me = this,
        assignmentStore = me.assignmentStore;

      if (assignmentStore) return assignmentStore.isEventAssignedToResource(event, resource);

      event = me.getById(event);
      resource = Model.asId(resource);
      return (event && event.resourceId == resource) || false;
    }

    /**
     * Removes all assignments for given event
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @category Assignment
     */
    removeAssignmentsForEvent(event) {
      let me = this,
        assignmentStore = me.assignmentStore;

      if (assignmentStore) {
        assignmentStore.removeAssignmentsForEvent(event);
      } else {
        event = me.getById(event);
        if (event) event.resourceId = null; // This will update resource events cache via 'update' event
      }
    }

    /**
     * Removes all assignments for given resource
     *
     * @param {Scheduler.model.ResourceModel|String|Number} resource
     * @category Assignment
     */
    removeAssignmentsForResource(resource) {
      const me = this,
        assignmentStore = me.assignmentStore,
        resourceStore = me.resourceStore;

      if (assignmentStore) {
        assignmentStore.removeAssignmentsForResource(resource);
      } else if (resourceStore) {
        resource = resourceStore.getById(resource);

        // TODO: change to use model cache
        //resource && me.resourceEventsCache.get(resource).forEach(event => {
        //    event.resourceId = null; // This will update resource events cache via 'update' event
        //});
      } else {
        resource = Model.asId(resource); // resource id might be 0 thus we use ? operator
        me.forEach((event) => event.resourceId == resource && (event.resourceId = null));
      }
    }

    //endregion
  };

/**
 * @module Scheduler/model/EventModel
 */

/**
 * This class represent a single event in your schedule. It is a subclass of the {@link Scheduler.model.TimeSpan}, which is in turn subclass of {@link Common.data.Model}.
 * Please refer to documentation of that class to become familiar with the base interface of the event.
 *
 * The Event model has a few predefined fields as seen below. If you want to add new fields or change the options for the existing fields,
 * you can do that by subclassing this class (see example below).
 *
 * Subclassing the Event model class
 * --------------------
 * ```
 * class MyEvent extends EventModel {
 *
 *     static get fields() {
 *         return [
 *            // Add new field
 *            { name: 'myField', type : 'number', defaultValue : 0 }
 *         ];
 *     },
 *
 *     myCheckMethod() {
 *         return this.myField > 0
 *     },
 *
 *     ...
 * });
 * ```
 * If you in your data want to use other names for the startDate, endDate, resourceId and name fields you can configure
 * them as seen below:
 * ```
 * class MyEvent extends EventModel {
 *
 *     static get fields() {
 *         return [
 *            { name: 'startDate', dataSource 'taskStart', type: 'date', format: 'YYYY-MM-DD' },
 *            { name: 'endDate', dataSource 'taskEnd', type: 'date', format: 'YYYY-MM-DD' },
 *            { name: 'resourceId', dataSource 'userId' },
 *            { name: 'name', dataSource 'taskTitle' },
 *         ];
 *     },
 *     ...
 * });
 * ```
 * Please refer to {@link Common.data.Model} for additional details.
 *
 * @extends Scheduler/model/TimeSpan
 */
class EventModel extends TimeSpan {
  //region Fields

  // TODO: handle persist? defaultValue?
  static get fields() {
    return [
      /**
       * The unique identifier of a task (mandatory)
       * @field {String|Number} id
       */

      /**
       * CSS class specifying an icon to apply to the event
       * @field {String} iconCls
       */
      { name: 'iconCls' },

      /**
       * Id of the resource this event is associated with (only usable for single assignments)
       * @field {String|Number} resourceId
       */
      { name: 'resourceId' },

      /**
       * Specify false to prevent the event from being dragged (if EventDrag feature is used)
       * @field {Boolean} draggable
       * @default true
       */
      { name: 'draggable', type: 'boolean', persist: false, defaultValue: true }, // true or false

      /**
       * Specify false to prevent the event from being resized (if EventResize feature is used). You can also
       * specify 'start' or 'end' to only allow resizing in one direction
       * @field {boolean|String} resizable
       * @default true
       */
      { name: 'resizable', persist: false, defaultValue: true }, // true, false, 'start' or 'end'

      /**
       * Controls this events appearance, see {@link Scheduler.view.mixin.TimelineEventRendering#config-eventStyle} for available
       * options.
       * @field {String} eventStyle
       */
      'eventStyle',

      /**
       * Controls the primary color of the event, defaults to using current themes default event color. What the color
       * affects is decided by {@link #field-eventStyle}
       * @field {String} eventColor
       */
      'eventColor',

      /**
       * Width (in px) to use for this milestone when using Scheduler#milestoneLayoutMode 'data'.
       * @field {Number} milestoneWidth
       */
      'milestoneWidth'
    ];
  }

  // EventModel#assignments is created by a relation defined in AssignmentModel
  /**
   * Returns all assignments for the event. Event must be part of the store for this method to work.
   * @member {Scheduler.model.AssignmentModel[]} assignments
   */

  /**
   * Returns the assigned resource. Only valid when not using an AssignmentStore (single assignment)
   * @member {Scheduler.model.ResourceModel} resource
   */

  static get relationConfig() {
    return [{ relationName: 'resource', fieldName: 'resourceId', store: 'resourceStore', collectionName: 'events' }];
  }

  //endregion

  //region Stores

  /**
   * Returns the event store this event is part of.
   *
   * @return {Scheduler.data.EventStore}
   * @readonly
   */
  get eventStore() {
    const me = this;

    if (!me._eventStore) {
      me._eventStore = me.stores && me.stores.find((s) => s.isEventStore);
    }
    return me._eventStore;
  }

  /**
   * Returns the resource store this event uses as its default resource store. Event must be part
   * of an event store to be able to retrieve default resource store.
   *
   * @return {Scheduler.data.ResourceStore}
   * @readonly
   */
  get resourceStore() {
    const eventStore = this.eventStore;
    return eventStore && eventStore.resourceStore;
  }

  /**
   * Returns the assigment store this event uses as its default assignment store. Event must be part
   * of an event store to be able to retrieve default assignment store.
   *
   * @return {Scheduler.data.AssignmentStore}
   * @readonly
   */
  get assignmentStore() {
    const eventStore = this.eventStore;
    return eventStore && eventStore.assignmentStore;
  }

  //endregion

  //region Resources

  /**
   * Returns all resources assigned to an event.
   *
   * @return {Scheduler.model.ResourceModel[]}
   * @readonly
   */
  get resources() {
    return (this.eventStore && this.eventStore.getResourcesForEvent(this)) || [];
  }

  /**
   * Iterate over all associated resources
   * @private
   */
  forEachResource(fn, thisObj = this) {
    for (let resource of this.resources) {
      if (fn.call(thisObj, resource) === false) return;
    }
  }

  /**
   * Returns either the resource associated with this event (when called w/o `resourceId`) or resource
   * with specified id.
   *
   * @param {String} resourceId (optional)
   * @return {Scheduler.model.ResourceModel}
   */
  getResource(resourceId = this.resourceId) {
    let me = this,
      eventStore = me.eventStore,
      resourceStore = eventStore && eventStore.resourceStore;

    if (eventStore && resourceId) {
      let result = eventStore.getResourcesForEvent(me);

      if (result.length == 1) return result[0];

      if (result.length > 1)
        throw new Error(
          'Event::getResource() is not applicable for events with multiple assignments, please use Event::resources instead.'
        );

      return null;
    }

    if (resourceStore) return resourceStore ? resourceStore.getById(resourceId) : null;
  }

  /**
   * Sets the resource which the event should belong to.
   *
   * @param {Scheduler.model.ResourceModel|String|Number} resource The new resource
   */
  // set resource(resource) {
  //     const me         = this,
  //           eventStore = me.eventStore;
  //
  //     eventStore && eventStore.removeAssignmentsForEvent(me);
  //
  //     me.assign(resource);
  // }

  //endregion

  //region Is

  // Used internally to differentiate between Event and ResourceTimeRange
  get isEvent() {
    return true;
  }

  /**
   * Returns true if event can be drag and dropped
   * @return {Boolean} The draggable state for the event.
   * @readonly
   */
  get isDraggable() {
    return this.draggable;
  }

  /**
   * Returns true if event can be resized, but can additionally return 'start' or 'end' indicating how this event can be resized.
   * @return {*} true, false, 'start' or 'end'
   * @readonly
   */
  get isResizable() {
    return !this.isMilestone && this.resizable;
  }

  /**
   * Returns false if a linked resource is a phantom record, i.e. it's not persisted in the database.
   *
   * @return {Boolean} true if persistable
   * @readonly
   */
  get isPersistable() {
    const me = this,
      eventStore = me.eventStore;
    return eventStore && eventStore.isEventPersistable(me);
  }

  //endregion

  //region Assignment

  /**'
   * Assigns this event to the specified resource.
   *
   * @param {Scheduler.model.ResourceModel|String|Number} resource A new resource for this event, either as a full Resource record or an id (or an array of such).
   */
  assign(resource) {
    const me = this,
      eventStore = me.eventStore;

    resource = Model.asId(resource);

    if (eventStore) {
      eventStore.assignEventToResource(me, resource);
    } else {
      me.resourceId = resource;
    }
  }

  /**
   * Unassigns this event from the specified resource
   *
   * @param {Scheduler.model.ResourceModel|String|Number|Array} [resource] The resource to unassign from.
   */
  unassign(resource, removingResource) {
    const me = this,
      eventStore = me.eventStore;

    resource = Model.asId(resource);

    // If unassigned is caused by removing the resource the UI should be able to find out to not do extra redraws etc.
    me.meta.removingResource = removingResource;

    if (eventStore) {
      eventStore.unassignEventFromResource(me, resource);
    } else if (me.resourceId == resource) {
      me.resourceId = null;
    }

    me.meta.removingResource = null;
  }

  /**
   * Reassigns an event from an old resource to a new resource
   *
   * @param {Scheduler.model.ResourceModel|String|Number} oldResourceId A resource to unassign from or its id
   * @param {Scheduler.model.ResourceModel|String|Number} newResourceId A resource to assign to or its id
   */
  reassign(oldResourceId, newResourceId) {
    const me = this,
      eventStore = me.eventStore;

    oldResourceId = Model.asId(oldResourceId);
    newResourceId = Model.asId(newResourceId);

    if (eventStore) {
      eventStore.reassignEventFromResourceToResource(me, oldResourceId, newResourceId);
    } else {
      me.resourceId = newResourceId;
    }
  }

  /**
   * Returns true if this event is assigned to a certain resource.
   *
   * @param {Scheduler.model.ResourceModel|String|Number} resource The resource to query for
   * @return {Boolean}
   */
  isAssignedTo(resource) {
    let me = this,
      eventStore = me.eventStore;

    resource = Model.asId(resource);

    if (eventStore) return eventStore.isEventAssignedToResource(me, resource);

    return me.resourceId == resource;
  }

  //endregion
}

EventModel.exposeProperties();
EventModel._$name = 'EventModel';

/**
 * @module Scheduler/data/EventStore
 */

/**
 * This is a class holding all the {@link Scheduler.model.EventModel events} to be rendered into a {@link Scheduler.view.Scheduler Scheduler}.
 * This class only accepts a model class inheriting from {@link Scheduler.model.EventModel}.
 *
 * @mixes Scheduler/data/mixin/EventStoreMixin
 * @extends Common/data/AjaxStore
 */
class EventStore extends EventStoreMixin(AjaxStore) {
  static get defaultConfig() {
    return {
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 100,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 200,
      modelClass: EventModel,
      storeId: 'events'
    };
  }

  construct(config) {
    super.construct(config, true);

    if (this.modelClass !== EventModel && !(this.modelClass.prototype instanceof EventModel)) {
      throw new Error('The model for the EventStore must subclass EventModel');
    }
  }

  /**
   * Appends a new record to the store
   * @param {Scheduler.model.EventModel} record The record to append to the store
   */
  append(record) {
    this.add(record);
  }
}
EventStore._$name = 'EventStore';

/**
 * @module Scheduler/model/DependencyBaseModel
 */

const canonicalDependencyTypes = ['SS', 'SF', 'FS', 'FF'];

/**
 * Base class used for both Ext Scheduler and Ext Gantt. Not intended to be used directly
 *
 * @extends Common/data/Model
 */
class DependencyBaseModel extends Model {
  //region Fields

  /**
   * An enumerable object, containing names for the dependency types integer constants.
   * - 0 StartToStart
   * - 1 StartToEnd
   * - 2 EndToStart
   * - 3 EndToEnd
   * @property {Object}
   * @readonly
   */
  static get Type() {
    return {
      StartToStart: 0,
      StartToEnd: 1,
      EndToStart: 2,
      EndToEnd: 3
    };
  }

  static get fields() {
    return [
      // 3 mandatory fields

      /**
       * From event, id of source event
       * @field {String|number} from
       */
      { name: 'from' },

      /**
       * To event, id of target event
       * @field {String|number} to
       */
      { name: 'to' },

      /**
       * Dependency type, see static property Type
       * @field {Number} type
       * @default 2
       */
      { name: 'type', type: 'int', defaultValue: 2 },

      /**
       * CSS class to apply to lines drawn for the dependency
       * @field {String} cls
       */
      { name: 'cls', defaultValue: '' },

      /**
       * Bidirectional, drawn with arrows in both directions
       * @field {Boolean} bidirectional
       */
      { name: 'bidirectional', type: 'boolean' },

      /**
       * Start side on source (top, left, bottom, right)
       * @field {String} fromSide
       */
      { name: 'fromSide', type: 'string' },

      /**
       * End side on target (top, left, bottom, right)
       * @field {String} toSide
       */
      { name: 'toSide', type: 'string' },

      /**
       * The magnitude of this dependency's lag (the number of units).
       * @field {Number} lag
       */
      { name: 'lag', type: 'number', allowNull: true, defaultValue: 0 },

      /**
       * The units of this dependency's lag, defaults to "d" (days). Valid values are:
       *
       * - "ms" (milliseconds)
       * - "s" (seconds)
       * - "m" (minutes)
       * - "h" (hours)
       * - "d" (days)
       * - "w" (weeks)
       * - "M" (months)
       * - "y" (years)
       *
       * This field is readonly after creation, to change lagUnit use #setlag().
       * @field {String} lagUnit
       */
      {
        name: 'lagUnit',
        type: 'string',
        defaultValue: 'd'
      }

      //{ name : 'highlighted', type : 'string', persist : false }
    ];
  }

  static get relationConfig() {
    return [
      { relationName: 'sourceEvent', fieldName: 'from', store: 'eventStore', collectionName: 'successors' },
      { relationName: 'targetEvent', fieldName: 'to', store: 'eventStore', collectionName: 'predecessors' }
    ];
  }

  //endregion

  //region Init

  construct(data) {
    super.construct(...arguments);

    if (data) {
      // Allow passing in event instances too
      if (data.from && data.from instanceof TimeSpan) {
        this.setSourceEvent(data.from);
        delete data.from;
      }

      if (data.to && data.to instanceof TimeSpan) {
        this.setTargetEvent(data.to);
        delete data.to;
      }
    }
  }

  //endregion

  get eventStore() {
    return this.stores[0].eventStore;
  }

  /**
   * Alias to dependency type, but when set resets {@link #field-fromSide} {@link #field-toSide} to null as well.
   *
   * @property {Number}
   */
  get hardType() {
    return this.getHardType();
  }

  set hardType(type) {
    this.setHardType(type);
  }

  /**
   * Returns dependency hard type, see {@link #property-hardType}.
   *
   * @return {Number}
   */
  getHardType() {
    return this.get('type');
  }

  /**
   * Sets dependency {@link #field-type} and resets {@link #field-fromSide} and {@link #field-toSide} to null.
   *
   * @param {Number} type
   */
  setHardType(type) {
    let result;

    if (type !== this.getHardType()) {
      result = this.set({
        type,
        fromSide: null,
        toSide: null
      });
    }

    return result;
  }

  get lag() {
    return this.get('lag');
  }

  set lag(lag) {
    if (typeof lag === 'number') {
      this.set({
        lag
      });
    } else {
      this.setLag(lag);
    }
  }

  /**
   * Sets lag and lagUnit in one go. Only allowed way to change lagUnit, the lagUnit field is
   * readonly after creation
   * @param {Number|String|Object} lag The lag value. May be just a numeric magnitude, or a full string descriptor eg '1d'
   * @param {String} [lagUnit] Unit for numeric lag value, see {@link #field-lagUnit} for valid values
   */
  setLag(lag, lagUnit) {
    // Either they're only setting the magnitude
    // or, if it's a string, parse the full duration.
    if (arguments.length === 1) {
      if (typeof lag === 'number') {
        this.lag = lag;
      } else {
        lag = DateHelper.parseDuration(lag);
        this.set({
          lag: lag.magnitude,
          lagUnit: lag.unit
        });
      }
      return;
    }

    // Must be a number
    lag = parseFloat(lag);

    this.set({
      lag,
      lagUnit
    });
  }

  getLag() {
    if (this.lag) {
      return `${this.lag < 0 ? '-' : '+'}${Math.abs(this.lag)}${DateHelper.getShortNameOfUnit(this.lagUnit)}`;
    }
    return '';
  }

  /**
   * Property which encapsulates the lag's magnitude and units.
   * An object which contains two properties:
   * - magnitude : [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number) The magnitude of the duration.
   * - unit : [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) The unit in which the duration is measured, eg `'d'` for days.
   * @property {Object}
   */
  get fullLag() {
    return {
      unit: this.lagUnit,
      magnitude: this.lag
    };
  }

  set fullLag(lag) {
    if (typeof lag === 'string') {
      this.setLag(lag);
    } else {
      this.setLag(lag.magnitude, lag.unit);
    }
  }

  /**
   * Gets/sets the source event of the dependency
   *
   * @property {Scheduler.model.EventModel}
   */
  set sourceEvent(event) {
    this.from = event.id;
  }

  /**
   * Gets/sets the target event of the dependency
   *
   * @property {Scheduler.model.EventModel}
   */
  set targetEvent(event) {
    this.to = event.id;
  }

  /**
   * Returns true if the linked events have been persisted (e.g. neither of them are 'phantoms')
   *
   * @property {Boolean}
   * @readonly
   */
  get isPersistable() {
    const me = this,
      source = me.getSourceEvent(),
      target = me.getTargetEvent();

    return source && !source.hasGeneratedId && target && !target.hasGeneratedId;
  }

  /**
   * Returns the source event of the dependency
   *
   * @return {Scheduler.model.EventModel} The source event of this dependency
   */
  getSourceEvent(eventStore = this.eventStore) {
    return eventStore.getById(this.from);
  }

  /**
   * Gets/sets the dependency type
   *
   * @property {Number}
   */

  /**
   * Gets/sets the name of field holding the CSS class for each rendered dependency element
   *
   * @property {String} cls
   */

  /**
   * Returns the target event of the dependency
   *
   * @return {Scheduler.model.EventModel} The target event of this dependency
   */
  getTargetEvent(eventStore = this.eventStore) {
    return eventStore.getById(this.to);
  }

  getDateRange(doNotNormalize = false) {
    const sourceTask = this.sourceEvent,
      targetTask = this.targetEvent;

    if (sourceTask && targetTask && sourceTask.isScheduled && targetTask.isScheduled) {
      let Type = DependencyBaseModel.Type,
        sourceDate,
        targetDate;

      switch (this.type) {
        case Type.StartToStart:
          sourceDate = sourceTask.startDate;
          targetDate = targetTask.startDate;
          break;

        case Type.StartToEnd:
          sourceDate = sourceTask.startDate;
          targetDate = targetTask.endDate;
          break;

        case Type.EndToEnd:
          sourceDate = sourceTask.endDate;
          targetDate = targetTask.endDate;
          break;

        case Type.EndToStart:
          sourceDate = sourceTask.endDate;
          targetDate = targetTask.startDate;
          break;
      }

      return {
        start: doNotNormalize ? sourceDate : DateHelper.min(sourceDate, targetDate),
        end: doNotNormalize ? targetDate : DateHelper.max(sourceDate, targetDate)
      };
    }

    return null;
  }

  /**
   * Applies given CSS class to dependency, the value doesn't persist
   *
   * @param {String} cls
   */
  highlight(cls) {
    const me = this,
      h = me.highlighted ? me.highlighted.split(' ') : [];

    if (!h.includes(cls)) me.highlighted = h.concat(cls).join(' ');
  }

  /**
   * Removes given CSS class from dependency if applied, the value doesn't persist
   *
   * @param {String} cls
   */
  unhighlight(cls) {
    const me = this,
      highlighted = me.highlighted;

    if (highlighted) {
      const h = highlighted.split(' '),
        idx = h.findIndex((i) => i === cls);

      if (idx >= 0) {
        h.splice(idx, 1);
        me.highlighted = h.join(' ');
      }
    }
  }

  /**
   * Checks if the given CSS class is applied to dependency.
   *
   * @param {String} cls
   * @return {Boolean}
   */
  isHighlightedWith(cls) {
    const me = this,
      highlighted = me.highlighted;

    return highlighted && highlighted.split(' ').includes(cls);
  }

  getConnectorString(raw) {
    const rawValue = canonicalDependencyTypes[this.type];

    if (raw) {
      return rawValue;
    }

    // FS => empty string; it's the default
    if (this.type === DependencyBaseModel.Type.EndToStart) {
      return '';
    }

    const locale = LocaleManagerSingelton.locale;

    // See if there is a local version of SS, SF or FF
    if (locale) {
      const localized = locale.Scheduler && locale.Scheduler[rawValue];
      if (localized) {
        return localized;
      }
    }

    return rawValue;
  }

  toString() {
    return `${this.from}${this.getConnectorString()}${this.getLag()}`;
  }

  /**
   * Returns `true` if the dependency is valid. Has valid type and both source and target ids set and not links to itself.
   *
   * @return {Boolean}
   * @typings ignore
   */
  isValid(taskStore) {
    const { from, to, type } = this;

    return typeof type === 'number' && from && from !== '' && to != null && to !== '' && from !== to;
  }
}

DependencyBaseModel.exposeProperties();
DependencyBaseModel._$name = 'DependencyBaseModel';

/**
 * @module Scheduler/model/DependencyModel
 */

/**
 * This class represents a single Dependency between two events. It is a subclass of the {@link Scheduler.model.DependencyBaseModel}
 * class, which in its turn subclasses {@link Common.data.Model}.
 * Please refer to documentation of those classes to become familiar with the base interface of this class.
 *
 * A Dependency has the following fields:
 *
 * - `id` - The id of the dependency itself
 * - `from` - The id of the event at which the dependency starts
 * - `to` - The id of the event at which the dependency ends
 * - `cls` - A CSS class that will be applied to each rendered dependency DOM element
 * - `type` - An integer constant representing the type of the dependency:
 *   - 0 - start-to-start dependency
 *   - 1 - start-to-end dependency
 *   - 2 - end-to-start dependency
 *   - 3 - end-to-end dependency
 * - `bidirectional` - A boolean indicating if a dependency goes both directions (default false)
 *
 * Subclassing the Dependency class
 * --------------------
 *
 * The name of any fields data source can be customized in the subclass, see the example below. Please also refer to {@link Common.data.Model}
 * for details.
 * @example
 * class MyDependency extends DependencyModel {
 *       static get fields() {
 *           return [
 *               { name: 'to', dataSource: 'targetId' },
 *               { name: 'from', dataSource: 'sourceId' }
 *           ]);
 *       }
 *
 *       ...
 *  }
 *
 * @extends Scheduler/model/DependencyBaseModel
 */
class DependencyModel extends DependencyBaseModel {
  // Determines the type of dependency based on fromSide and toSide
  // TODO: Check with vertical orientation
  getTypeFromSides(fromSide, toSide, rtl) {
    const types = DependencyBaseModel.Type,
      startSide = rtl ? 'right' : 'left',
      endSide = rtl ? 'left' : 'right';

    if (fromSide === startSide) {
      return toSide === startSide ? types.StartToStart : types.StartToEnd;
    }

    return toSide === endSide ? types.EndToEnd : types.EndToStart;
  }
}

DependencyModel.exposeProperties();
DependencyModel._$name = 'DependencyModel';

// @tag dependencies

/**
 * @module Scheduler/data/DependencyStore
 */

/**
 * A class representing a collection of dependencies between events in the {@link Scheduler.data.EventStore}.
 * Contains a collection of {@link Scheduler.model.DependencyModel} records.
 *
 * @extends Common/data/AjaxStore
 */
class DependencyStore extends AjaxStore {
  static get defaultConfig() {
    return {
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 400,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 400,
      modelClass: DependencyModel,
      storeId: 'dependencies'
    };
  }

  //region Init & destroy

  doDestroy() {
    const me = this;
    me.eventStoreDetacher && me.eventStoreDetacher();
    super.doDestroy();
  }

  //endregion

  //region Stores

  /**
   * Get/set the associated event store instance.
   *
   * @property {Scheduler.data.EventStore}
   */
  get eventStore() {
    return this._eventStore;
  }

  set eventStore(eventStore) {
    const me = this,
      oldStore = me._eventStore;

    me._eventStore = eventStore;

    if (eventStore) {
      me.attachToEventStore(eventStore);

      // If store is assigned after configuration we need to init relations
      if (!me.isConfiguring) {
        me.initRelations(true);
      }
    }

    if ((oldStore || eventStore) && oldStore !== eventStore) {
      /**
       * Fires when a new event store is set via the {@link #property-eventStore} property.
       * @event eventstorechange
       * @param {Scheduler.data.DependencyStore} this
       * @param {Scheduler.data.EventStore} newEventStore
       * @param {Scheduler.data.EventStore} oldEventStore
       */
      me.trigger('eventStoreChange', { newEventStore: eventStore, oldEventStore: oldStore });
    }
  }

  attachToEventStore(eventStore) {
    const me = this;

    me.eventStoreDetacher && me.eventStoreDetacher();

    me.eventStoreDetacher = eventStore.on({
      remove: me.onEventRemove,
      thisObj: me,
      detachable: true
    });
  }

  //endregion

  onEventRemove({ records, isMove = false, isCollapse = false }) {
    if (!isMove && !isCollapse) {
      records.forEach((record) => {
        // traversing in a flat structure will only call fn on self, no need to handle tree case differently
        record.traverse((eventRecord) => this.removeEventDependencies(eventRecord, false));
      });
    }
  }

  // TODO: document
  reduceEventDependencies(event, reduceFn, result, flat = true, depsGetterFn) {
    // const me       = this,
    //     relation = me.relationCache;

    depsGetterFn =
      depsGetterFn ||
      ((event) => {
        return this.getEventDependencies(event);

        // const eventId      = DependencyModel.asId(event),
        //     sourceEvents = (relation.sourceEvent && relation.sourceEvent[eventId]) || [],
        //     targetEvents = (relation.targetEvent && relation.targetEvent[eventId]) || [];
        //
        // return sourceEvents.concat(targetEvents);

        // return me.eventDependencyCache.get(event, () =>
        //     // Full scan, but cache makes everything possible to avoid it
        //     me.records.filter(dependency =>
        //         dependency.to == eventId || dependency.from == eventId
        //     )
        // );
      });

    event = Array.isArray(event) ? event : [event];

    event.reduce((result, event) => {
      if (event.children && !flat) {
        event.traverse((evt) => {
          result = depsGetterFn(evt).reduce(reduceFn, result);
        });
      } else {
        result = depsGetterFn(event).reduce(reduceFn, result);
      }
    }, result);

    return result;
  }

  // TODO: document
  reduceEventPredecessors(event, reduceFn, result, flat) {
    const me = this;

    return me.reduceEventDependencies(event, reduceFn, result, flat, (evt) => {
      // const eventId = Model.asId(evt);
      // return me.eventDependencyCache.getPredecessors(evt, () =>
      //     // Full scan, but cache makes everything possible to avoid it
      //     me.records.filter(dependency =>
      //         dependency.to == eventId
      //     )
      // );
    });
  }

  // TODO: document
  reduceEventSuccessors(event, reduceFn, result, flat) {
    const me = this;

    return me.reduceEventDependencies(event, reduceFn, result, flat, (evt) => {
      // const eventId = Model.asId(evt);
      // return me.eventDependencyCache.getSuccessors(evt, () =>
      //     // Full scan, but cache makes everything possible to avoid it
      //     me.records.filter(dependency =>
      //         dependency.getSourceId() == eventId
      //     )
      // );
    });
  }

  // TODO: document
  mapEventDependencies(event, fn, filterFn, flat, depsGetterFn) {
    return this.reduceEventDependencies(
      event,
      (result, dependency) => {
        filterFn(dependency) && result.push(dependency);
        return result;
      },
      [],
      flat,
      depsGetterFn
    );
  }

  // TODO: document
  mapEventPredecessors(event, fn, filterFn, flat) {
    return this.reduceEventPredecessors(
      event,
      (result, dependency) => {
        filterFn(dependency) && result.push(dependency);
        return result;
      },
      [],
      flat
    );
  }

  // TODO: document
  mapEventSuccessors(event, fn, filterFn, flat) {
    return this.reduceEventSuccessors(
      event,
      (result, dependency) => {
        filterFn(dependency) && result.push(dependency);
        return result;
      },
      [],
      flat
    );
  }

  /**
   * Returns all dependencies for a certain event (both incoming and outgoing)
   *
   * @param {Scheduler.model.EventModel} event
   * @param {Boolean} [flat]
   * @return {Scheduler.model.DependencyModel[]}
   */
  getEventDependencies(event, flat = false) {
    return [].concat(event.predecessors || [], event.successors || []);
  }

  /**
   * Returns all incoming dependencies of the given event
   *
   * @param {Scheduler.model.EventModel} event
   * @param {Boolean} [flat]
   * @return {Scheduler.model.DependencyModel[]}
   */
  getEventPredecessors(event, flat = false) {
    //return this.mapEventPredecessors(event, o => o, o => true, flat);
    return event.predecessors;
  }

  /**
   * Returns all outcoming dependencies of a event
   *
   * @param {Scheduler.model.EventModel} event
   * @param {Boolean} [flat]
   * @return {Scheduler.model.DependencyModel[]}
   */
  getEventSuccessors(event, flat = false) {
    //return this.mapEventSuccessors(event, o => o, o => true, flat);
    return event.successors;
  }

  getUnique(array) {
    return [...new Set(array)];
  }

  // TODO: document
  removeEventDependencies(event, flat) {
    const me = this,
      dependencies = me.getEventDependencies(event, flat);

    dependencies.length && me.remove(me.getUnique(dependencies));
  }

  // TODO: document
  removeEventPredecessors(event, flat) {
    const me = this,
      dependencies = me.getEventPredecessors(event, flat);

    dependencies.length && me.remove(me.getUnique(dependencies));
  }

  // TODO: document
  removeEventSuccessors(event, flat) {
    const me = this,
      dependencies = me.getEventSuccessors(event, flat);

    dependencies.length && me.remove(me.getUnique(dependencies));
  }

  getBySourceTargetId(key) {
    //TODO: in original code this uses a keymap
    return this.records.find((r) => (key = DependencyStore.makeDependencySourceTargetCompositeKey(r.from, r.to)));
  }

  /**
   * Returns dependency model instance linking tasks with given ids. The dependency can be forward (from 1st
   * task to 2nd) or backward (from 2nd to 1st).
   *
   * @param {Scheduler.model.EventModel|String} sourceEvent 1st event
   * @param {Scheduler.model.EventModel|String} targetEvent 2nd event
   * @return {Scheduler.model.DependencyModel}
   */
  getDependencyForSourceAndTargetEvents(sourceEvent, targetEvent) {
    // NOTE: In case this will not work switch to cache get and linear search
    const me = this;

    sourceEvent = Model.asId(sourceEvent);
    targetEvent = Model.asId(targetEvent);

    return me.getBySourceTargetId(DependencyStore.makeDependencySourceTargetCompositeKey(sourceEvent, targetEvent));
  }

  /**
   * Returns a dependency model instance linking given events if such dependency exists in the store.
   * The dependency can be forward (from 1st event to 2nd) or backward (from 2nd to 1st).
   *
   * @param {Scheduler.model.EventModel|String} sourceEvent
   * @param {Scheduler.model.EventModel|String} targetEvent
   * @return {Scheduler.model.DependencyModel}
   */
  getEventsLinkingDependency(sourceEvent, targetEvent) {
    const me = this;
    return (
      me.getDependencyForSourceAndTargetEvents(sourceEvent, targetEvent) ||
      me.getDependencyForSourceAndTargetEvents(targetEvent, sourceEvent)
    );
  }

  /**
   * Validation method used to validate a dependency. Override and return `true` to indicate that an
   * existing dependency (or a new dependency being created) between two tasks is valid.
   *
   * @param {Scheduler.model.DependencyModel|Number|String} dependencyOrFromId The dependency model or from event id
   * @param {Number|String} [toId] To event id if the first parameter is not a dependency model instance
   * @param {Number} [type] Dependency {@link Scheduler.model.DependencyBaseModel#property-Type-static}  if the first parameter is not a dependency model instance.
   * @return {Boolean}
   */
  isValidDependency(dependencyOrFromId, toId, type) {
    if (arguments.length === 1) {
      type = dependencyOrFromId.type;
      toId = dependencyOrFromId.to;
      dependencyOrFromId = dependencyOrFromId.from;
    }

    return dependencyOrFromId != null && toId != null && dependencyOrFromId !== toId;
  }

  /**
   * Returns all dependencies highlighted with the given CSS class
   *
   * @param {String} cls
   * @return {Scheduler.model.DependencyBaseModel[]}
   */
  getHighlightedDependencies(cls) {
    return this.records.reduce((result, dep) => {
      if (dep.isHighlightedWith(cls)) result.push(dep);
      return result;
    }, []);
  }

  static makeDependencySourceTargetCompositeKey(from, to) {
    return `source(${from})-target(${to})`;
  }

  //region Product neutral

  getTimeSpanDependencies(record) {
    return this.getEventDependencies(record);
  }

  //endregion
}
DependencyStore._$name = 'DependencyStore';

/**
 * @module Scheduler/data/CrudManager
 */

/**
 * The Crud Manager (or "CM") is a class implementing centralized loading and saving of data in multiple stores.
 * Loading the stores and saving all changes is done using one ajax request. This class uses AJAX as a transport
 * mechanism and JSON as the data encoding format.
 *
 * ## Scheduler stores
 *
 * The class supports Scheduler specific stores (namely: resource, event and assignment stores).
 * For these stores, the CM has separate configs ({@link #config-resourceStore}, {@link #config-eventStore},
 * {@link #config-assignmentStore}) to register them. The class can also grab them from the task store (this behavior
 * can be changed using {@link #config-addRelatedStores} config).
 *
 * ```javascript
 * let crudManager = new CrudManager({
 *   autoLoad        : true,
 *   resourceStore   : resourceStore,
 *   eventStore      : eventStore,
 *   assignmentStore : assignmentStore,
 *   transport       : {
 *     load    : {
 *       url     : 'php/read.php'
 *     },
 *     sync    : {
 *       url     : 'php/save.php'
 *     }
 *   }
 * });
 * ```
 *
 * ## AJAX request configuration
 *
 * To configure AJAX request parameters please take a look at the
 * {@link Scheduler.crud.transport.AjaxTransport AjaxTransport} docs.
 *
 * ```javascript
 * var crudManager = new CrudManager({
 *     autoLoad        : true,
 *     resourceStore   : resourceStore,
 *     eventStore      : eventStore,
 *     assignmentStore : assignmentStore,
 *     transport       : {
 *         load    : {
 *             url         : 'php/read.php',
 *             // use GET request
 *             method      : 'GET',
 *             // pass request JSON in "rq" parameter
 *             paramName   : 'rq',
 *             // extra HTTP request parameters
 *             params      : {
 *                 foo     : 'bar'
 *             }
 *         },
 *         sync    : {
 *             url     : 'php/save.php'
 *         }
 *     }
 * });
 * ```
 *
 * ## Load order
 *
 * The CM is aware of the proper load order for Scheduler specific stores so you don't need to worry about it.
 * If you provide any extra stores (using {@link Scheduler.crud.AbstractCrudManager#config-stores} config) they will be
 * added to the start of collection before the Scheduler specific stores.
 * If you a different load order, you should use {@link Scheduler.crud.AbstractCrudManager#function-addStore} method to
 * register your store:
 *
 * ```javascript
 * var crudManager = new CrudManager({
 *   resourceStore   : resourceStore,
 *   eventStore      : eventStore,
 *   assignmentStore : assignmentStore,
 *   // extra user defined stores will get to the start of collection
 *   // so they will be loaded first
 *   stores          : [ store1, store2 ],
 *   transport       : {
 *     load    : {
 *       url     : 'php/read.php'
 *     },
 *     sync    : {
 *       url     : 'php/save.php'
 *     }
 *   }
 * });
 *
 * // append store3 to the end so it will be loaded last
 * crudManager.addStore(store3);
 *
 * // now when we registered all the stores let's load them
 * crudManager.load();
 * ```
 *
 * ## Features
 * The Crud Manager can automatically add Scheduler feature stores to the tracked collection.
 * For example, it tracks TimeRanges {@link Scheduler.feature.TimeRanges#config-store}.
 * You can receive a tracked store by its id:
 * ```javascript
 * let timeRangesStore = crudManager.getStore('timeRanges');
 * ```
 *
 * @mixes Scheduler/crud/encoder/JsonEncoder
 * @mixes Scheduler/crud/transport/AjaxTransport
 * @extends Scheduler/crud/AbstractCrudManager
 */

class CrudManager extends JsonEncoder(AjaxTransport(AbstractCrudManager)) {
  //region Config

  static get defaultConfig() {
    return {
      resourceStoreClass: ResourceStore,
      eventStoreClass: EventStore,
      assignmentStoreClass: AssignmentStore,
      dependencyStoreClass: DependencyStore,

      /**
       * A store with resources (or its descriptor).
       * @config {Scheduler.data.ResourceStore|Object}
       */
      resourceStore: {},

      /**
       * A store with events (or its descriptor).
       *
       * ```
       * crudManager : {
       *      eventStore {
       *          storeClass : MyEventStore
       *      }
       * }
       * ```
       * @config {Scheduler.data.EventStore|Object}
       */
      eventStore: {},

      /**
       * A store with assignments (or its descriptor).
       * @config {Scheduler.data.AssignmentStore|Object}
       */
      assignmentStore: null,

      /**
       * A store with dependencies (or its descriptor).
       * @config {Scheduler.data.DependencyStore|Object}
       */
      dependencyStore: null,

      /**
       * When set to `true` this class will try to get the {@link #config-resourceStore} and {@link #config-assignmentStore} stores from
       * the specified {@link #config-eventStore} instance.
       * @config {Boolean}
       */
      addRelatedStores: true
    };
  }

  //endregion

  construct(config = {}) {
    if (config.scheduler) {
      this.scheduler = config.scheduler;

      // The effects of this class's initialization are so wide ranging that they may need to
      // access the Scheduler's CrudManager, so ensure it's available immediately.
      this.scheduler._crudManager = this;
    }

    super.construct(config);
  }

  afterConstruct() {
    const me = this,
      scheduler = me.scheduler;

    if (scheduler) {
      // Inject the scheduler stores into the Scheduler.
      // The resourceStore becomes the primary store.
      if (scheduler.isVertical || (scheduler.isHorizontal && !scheduler.store)) {
        scheduler.resourceStore = me.resourceStore;
        scheduler.eventStore = me.eventStore;
      }

      // Features self initialize if not already initialized.
      // This must be done after the _crudManager is assigned because it may access this.crudManager
      // to get its eventStore.
      const { dependencies, timeRanges, resourceTimeRanges } = scheduler.features;

      // Special handling of dependency store
      if (dependencies) {
        me.dependencyStore = dependencies.store;
      }

      if (timeRanges) {
        me.addCrudStore(timeRanges.store);
        me._timeRangesStore = timeRanges.store;
      }

      if (resourceTimeRanges) {
        me.addCrudStore(resourceTimeRanges.store);
        me._timeRangesStore = resourceTimeRanges.store;
      }
    }

    super.afterConstruct();
  }

  //region Stores

  /**
   * Returns store associated with timeRanges feature, if feature is enabled.
   * @property {Common.data.Store}
   * @readonly
   */
  get timeRangesStore() {
    return this._timeRangesStore;
  }

  // Adds configured scheduler stores to the store collection ensuring correct order
  // unless they're already registered.
  addFeaturedStore(store) {
    this.addPrioritizedStore(store);
  }

  static getEventStoreInfo(eventStore, config) {
    if (!(eventStore instanceof EventStore)) {
      if (typeof eventStore === 'string') {
        eventStore = Store.getStore(eventStore);
      } else {
        eventStore = eventStore.store;
      }
    }
    let result = {},
      assignmentStore = config.assignmentStore,
      resourceStore = config.resourceStore,
      dependencyStore = config.dependencyStore;

    !assignmentStore && (result.assignmentStore = eventStore.assignmentStore);
    !resourceStore && (result.resourceStore = eventStore.resourceStore);
    !dependencyStore && (result.dependencyStore = eventStore.dependencyStore);

    return result;
  }

  /**
   * Get/set the resource store bound to the CRUD manager.
   * @property {Scheduler.data.ResourceStore}
   */
  get resourceStore() {
    return this._resourceStore && this._resourceStore.store;
  }

  set resourceStore(store) {
    const me = this;

    me.setFeaturedStore('_resourceStore', store, me.resourceStoreClass);

    me.eventStore.resourceStore = me._resourceStore && me._resourceStore.store;
  }

  /**
   * Get/set the event store bound to the CRUD manager.
   * @property {Scheduler.data.EventStore}
   */
  get eventStore() {
    return this._eventStore && this._eventStore.store;
  }

  set eventStore(store) {
    const me = this;

    me.setFeaturedStore('_eventStore', store, me.eventStoreClass);

    store = me._eventStore && me._eventStore.store;

    // If we're configuring, retrieve stores registered on the provided taskStore
    if (me.isConfiguring && store && me.addRelatedStores !== false) {
      let extracted = CrudManager.getEventStoreInfo(store, me.initialConfig),
        assignmentStore = extracted.assignmentStore,
        resourceStore = extracted.resourceStore,
        dependencyStore = extracted.dependencyStore;

      if (assignmentStore) {
        me.assignmentStore = assignmentStore;
      }
      if (resourceStore) {
        me.resourceStore = resourceStore;
      }
      if (dependencyStore) {
        me.dependencyStore = dependencyStore;
      }
    }
  }

  /**
   * Get/set the assignment store bound to the CRUD manager.
   * @property {Scheduler.data.AssignmentStore}
   */
  get assignmentStore() {
    return this._assignmentStore && this._assignmentStore.store;
  }

  set assignmentStore(store) {
    this.setFeaturedStore('_assignmentStore', store, this.assignmentStoreClass);
  }

  /**
   * Get/set the dependency store bound to the CRUD manager.
   * @property {Scheduler.data.DependencyStore}
   */
  get dependencyStore() {
    return this._dependencyStore && this._dependencyStore.store;
  }

  set dependencyStore(store) {
    this.setFeaturedStore('_dependencyStore', store, this.dependencyStoreClass);
  }

  setFeaturedStore(property, store, storeClass) {
    const me = this,
      oldStore = me[property];

    store = Store.getStore(store, (store && store.storeClass) || storeClass);

    if (oldStore) {
      me.removeStore(oldStore);
    }

    me[property] = (store && { store }) || null;

    me.addFeaturedStore(me[property]);

    return me[property];
  }

  //endregion
}
CrudManager._$name = 'CrudManager';

/**
 * @module Scheduler/model/ResourceTimeRangeModel
 */

/**
 * This class represent a single resource time range in your schedule. To style
 * the rendered elements, use the {@link Scheduler.model.TimeSpan#field-cls cls} field of the `TimeSpan` class, or use the {@link #field-timeRangeColor} field.
 *
 * @extends Scheduler/model/TimeSpan
 */
class ResourceTimeRangeModel extends TimeSpan {
  //region Fields

  static get fields() {
    return [
      /**
       * Id of the resource this time range is associated with
       * @field {String|Number} resourceId
       */
      'resourceId',

      /**
       * Controls this time ranges primary color, defaults to using current themes default time range color.
       * @field {String} timeRangeColor
       */
      'timeRangeColor'
    ];
  }

  static get relationConfig() {
    return [
      /**
       * The associated resource, retrieved using a relation to a ResourceStore determined by the value assigned
       * to `resourceId`. The relation also lets you access all time ranges on a resource through
       * `ResourceModel#timeRanges`.
       * @property {Scheduler.model.ResourceModel} resource
       */
      {
        relationName: 'resource',
        fieldName: 'resourceId',
        store: 'resourceStore',
        collectionName: 'timeRanges',
        nullFieldOnRemove: true
      }
    ];
  }

  //endregion

  // Used internally to differentiate between Event and ResourceTimeRange
  get isResourceTimeRange() {
    return true;
  }

  // To match EventModel API
  get resources() {
    return [this.resource];
  }
}
ResourceTimeRangeModel._$name = 'ResourceTimeRangeModel';

/**
 * @module Scheduler/data/ResourceTimeRangeStore
 */

/**
 * A class representing a collection of resource time ranges.
 * Contains a collection of {@link Scheduler.model.ResourceTimeRangeModel} records.
 *
 * @extends Common/data/AjaxStore
 */
class ResourceTimeRangeStore extends AjaxStore {
  static get defaultConfig() {
    return {
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 500,

      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 500,

      /**
       * This store should be linked to a ResourceStore to link the time ranges to resources
       * @config {Scheduler.data.ResourceStore}
       */
      resourceStore: null,

      modelClass: ResourceTimeRangeModel,
      storeId: 'resourceTimeRanges'
    };
  }

  set resourceStore(store) {
    this._resourceStore = store;

    // If store is assigned after configuration we need to init relations
    if (!this.isConfiguring) {
      this.initRelations(true);
    }
  }

  get resourceStore() {
    return this._resourceStore;
  }

  // Matching signature in EventStore to allow reusage of SchedulerStores#onInternalEventStoreChange()
  getResourcesForEvent(resourceTimeRange) {
    return [resourceTimeRange.resource];
  }
}
ResourceTimeRangeStore._$name = 'ResourceTimeRangeStore';

const clonedConfigs = [
  'rowHeight',
  'tickWidth',
  'tickHeight',
  'displayDateFormat',
  'shiftUnit',
  'shiftIncrement',
  'defaultSpan',
  'timeResolution',
  'columnLinesFor',
  'headerConfig'
];

/**
 * @module Scheduler/preset/ViewPreset
 */

/**
 * Not used directly, but the properties below are rather provided inline as seen in the source of {@link Scheduler.preset.PresetManager}. This class is just provided for documentation purposes.
 *
 * A sample preset looks like:
 * ```javascript
 * hourAndDay : {
 *   tickWidth           : 60,       // Time column width in horizontal mode
 *   tickHeight          : 30,       // Time column height in vertical mode
 *
 *   displayDateFormat   : 'HH:mm',  // Controls how dates will be displayed in tooltips etc
 *
 *   shiftIncrement      : 1,        // Controls how much time to skip when calling shiftNext and shiftPrevious.
 *   shiftUnit           : 'day',    // Valid values are 'millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'.
 *   defaultSpan         : 12,       // By default, if no end date is supplied to a view it will show 12 hours
 *
 *   timeResolution      : {         // Dates will be snapped to this resolution
 *     unit        : 'minute',       // Valid values are 'millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'.
 *     increment   : 15
 *   },
 *
 *   headerConfig        : {         // This defines your header, you must include a 'middle' object, and top/bottom are optional.
 *     middle : {                    // For each row you can define 'unit', 'increment', 'dateFormat', 'renderer', 'align', and 'thisObj'
 *       unit        : 'hour',
 *       dateFormat  : 'HH:mm'
 *     },
 *     top    : {
 *       unit        : 'day',
 *       dateFormat  : 'ddd DD/MM'
 *     }
 *   },
 *
 *   columnLinesFor      : 'middle'  // Defines header level column lines will be drawn for
 * }
 * ```
 * See the {@link Scheduler.preset.PresetManager} for the list of available presets.
 *
 * ## Duration units
 *
 * There are a number of configs for duration units ({@link #config-shiftUnit} or `unit` in {@link #config-timeResolution}, {@link #config-headerConfig} configs).
 *
 * When registering a preset using {@link Scheduler.preset.PresetManager#function-registerPreset-static} method you can provide their values using short constants names ('day', 'week' etc.):
 * ```javascript
 * PresetManager.registerPreset('hour', {
 *   displayDateFormat : 'HH:mm',
 *   shiftIncrement    : 1,
 *   shiftUnit         : 'day',
 *   tickWidth         : 150,
 *   timeResolution    : {
 *     unit      : 'minute',
 *     increment : 5
 *   },
 *   headerConfig      : {
 *     middle : {
 *       unit       : 'hour',
 *       dateFormat : 'HH:mm'
 *     },
 *     top    : {
 *       unit       : 'day',
 *       dateFormat : 'ddd DD/MM'
 *     }
 *   }
 * });
 * ```
 */
class ViewPreset extends Base {
  static get defaultConfig() {
    return {
      /**
       * The name of the preset by which it is registered in the Manager
       * @config {String}
       */
      name: null,

      /**
       * The height of the row in horizontal orientation
       * @config {Number}
       * @default
       */
      rowHeight: 24,

      /**
       * The width of the time tick column in horizontal orientation
       * @config {Number}
       * @default
       */
      tickWidth: 50,

      /**
       * The height of the time tick column in vertical orientation
       * @config {Number}
       * @default
       */
      tickHeight: 50,

      /**
       * Defines how dates will be formatted in tooltips etc
       * @config {String}
       * @default
       */
      displayDateFormat: 'HH:mm',

      /**
       * The unit to shift when calling shiftNext/shiftPrevious to navigate in the chart.
       * Valid values are "millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year".
       * @config {String}
       * @default
       */
      shiftUnit: 'hour',

      /**
       * The amount to shift (in shiftUnits)
       * @config {Number}
       * @default
       */
      shiftIncrement: 1,

      /**
       * The amount of time to show by default in a view (in the unit defined by the middle header)
       * @config {Number}
       * @default
       */
      defaultSpan: 12,

      /**
       * An object containing a unit identifier and an increment variable. Example:
       * ```javascript
       * timeResolution : {
       *   unit      : "hour",  //Valid values are "millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year".
       *   increment : 1
       * }
       * ```
       * @config {Object}
       */
      timeResolution: null,

      /**
       * An object containing one or more {@link Scheduler.preset.ViewPresetHeaderRow} rows defining how your headers shall be composed.
       * Your 'main' unit should be the middle header unit. This object can contain "bottom", "middle" and "top" header definitions. The 'middle' header is mandatory.
       * @config {Object}
       */
      headerConfig: null,

      /**
       * Defines the header level that the column lines will be drawn for. See {@link Scheduler.feature.ColumnLines}
       * @config {String}
       * @default
       */
      columnLinesFor: 'middle',

      // internal properties
      _headers: null,

      /**
       * The viewPreset to use and extend when the preset is passed as a config object.
       * @config {String}
       */
      ptype: ''
    };
  }

  construct(config) {
    super.construct(config);
    this.normalizeUnits();
  }

  normalizeUnits() {
    const me = this,
      { timeResolution, headerConfig } = me;

    // Make sure date "unit" constant specified in the preset are resolved
    Object.keys(headerConfig).forEach((o) => {
      headerConfig[o].unit = DateHelper.normalizeUnit(headerConfig[o].unit);
      if (headerConfig[o].splitUnit) {
        headerConfig[o].splitUnit = DateHelper.normalizeUnit(headerConfig[o].splitUnit);
      }
    });

    if (timeResolution) {
      timeResolution.unit = DateHelper.normalizeUnit(timeResolution.unit);
    }

    if (me.shiftUnit) {
      me.shiftUnit = DateHelper.normalizeUnit(me.shiftUnit);
    }
  }

  get headers() {
    const me = this;

    if (!me._headers) {
      const headers = (me._headers = []),
        { top, middle, bottom } = me.headerConfig;

      top && headers.push(top);
      middle && headers.push(middle);
      bottom && headers.push(bottom);
    }

    return me._headers;
  }

  get mainHeader() {
    return this.headerConfig.middle;
  }

  get bottomHeader() {
    return this.headers[this.headers.length - 1];
  }

  clone() {
    const config = {};

    clonedConfigs.forEach((name) => {
      config[name] = this[name];
    });

    return new ViewPreset(config);
  }

  get isValid() {
    const me = this,
      ownKeys = {};

    let valid = true;

    // Make sure all date "unit" constants are valid
    Object.keys(me.headerConfig).forEach((o) => {
      ownKeys[o] = true;
      valid = valid && Boolean(DateHelper.normalizeUnit(me.headerConfig[o].unit));
    });

    if (!(me.columnLinesFor in ownKeys)) {
      me.columnLinesFor = 'middle';
    }

    if (me.timeResolution) {
      valid = valid && DateHelper.normalizeUnit(me.timeResolution.unit);
    }

    if (me.shiftUnit) {
      valid = valid && DateHelper.normalizeUnit(me.shiftUnit);
    }

    return valid;
  }
}
ViewPreset._$name = 'ViewPreset';

// eslint-disable-next-line import/no-named-default

//TODO: break presets out to own files

/**
 * @module Scheduler/preset/PresetManager
 */

/**
 * Provides a registry of the possible view presets that any instance of Scheduler can use.
 *
 * See the {@link Scheduler.preset.ViewPreset} and {@link Scheduler.preset.ViewPresetHeaderRow} classes for a description of the view preset properties.
 *
 * Available presets are:
 *
 * - `secondAndMinute` - creates 2 level header - minute and seconds within it:
 * {@inlineexample scheduler/viewpresets/secondAndMinute.js}
 * - `minuteAndHour` - creates 2 level header - hour and minutes within it:
 * {@inlineexample scheduler/viewpresets/minuteAndHour.js}
 * - `hourAndDay` - creates 2 level header - day and hours within it:
 * {@inlineexample scheduler/viewpresets/hourAndDay.js}
 * - `dayAndWeek` - creates 2 level header - week and days within it:
 * {@inlineexample scheduler/viewpresets/dayAndWeek.js}
 * - `weekAndDay` - just like `dayAndWeek` but with different formatting:
 * {@inlineexample scheduler/viewpresets/weekAndDay.js}
 * - `weekAndDayLetter` - creates 2 level header - with weeks and day letters within it:
 * {@inlineexample scheduler/viewpresets/weekAndDayLetter.js}
 * - `weekAndMonth` - creates 2 level header - month and weeks within it:
 * {@inlineexample scheduler/viewpresets/weekAndMonth.js}
 * - `weekDateAndMonth` - creates 2 level header - month and weeks within it (weeks shown by first day only):
 * {@inlineexample scheduler/viewpresets/weekDateAndMonth.js}
 * - `monthAndYear` - creates 2 level header - year and months within it:
 * {@inlineexample scheduler/viewpresets/monthAndYear.js}
 * - `year` - creates 2 level header - year and quarters within it:
 * {@inlineexample scheduler/viewpresets/year.js}
 * - `manyYears` - creates 2 level header - 5-years and year within it:
 * {@inlineexample scheduler/viewpresets/manyYears.js}
 *
 * You can register your own preset with the {@link #function-registerPreset-static} call or pass a preset configuration in the scheduler panel.
 * @singleton
 */
class PresetManager extends Localizable() {
  static get defaultPresets() {
    return {
      secondAndMinute: {
        tickWidth: 30, // Time column width
        tickHeight: 40,
        displayDateFormat: 'll LTS', // Controls how dates will be displayed in tooltips etc
        shiftIncrement: 10, // Controls how much time to skip when calling shiftNext and shiftPrevious.
        shiftUnit: 'minute', // Valid values are "millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year".
        defaultSpan: 24, // By default, if no end date is supplied to a view it will show 24 hours
        timeResolution: {
          // Dates will be snapped to this resolution
          unit: 'second', // Valid values are "millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year".
          increment: 5
        },
        // This defines your header, you must include a "middle" object, top/bottom are optional.
        // For each row you can define "unit", "increment", "dateFormat", "renderer", "align", and "thisObj"
        headerConfig: {
          middle: {
            unit: 'second',
            increment: 10,
            dateFormat: 'ss'
          },
          top: {
            unit: 'minute',
            dateFormat: 'llll'
          }
        }
      },
      minuteAndHour: {
        tickWidth: 100, // Time column width
        tickHeight: 60,
        displayDateFormat: 'll LT', // Controls how dates will be displayed in tooltips etc
        shiftIncrement: 1, // Controls how much time to skip when calling shiftNext and shiftPrevious.
        shiftUnit: 'hour', // Valid values are "MILLI", "SECOND", "minute", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
        defaultSpan: 24, // By default, if no end date is supplied to a view it will show 24 hours
        timeResolution: {
          // Dates will be snapped to this resolution
          unit: 'minute', // Valid values are "MILLI", "SECOND", "minute", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
          increment: 30
        },
        // This defines your header, you must include a "middle" object, top/bottom are optional.
        // For each row you can define "unit", "increment", "dateFormat", "renderer", "align", and "thisObj"
        headerConfig: {
          middle: {
            unit: 'minute',
            increment: '30',
            dateFormat: 'mm'
          },
          top: {
            unit: 'hour',
            dateFormat: 'ddd MM/DD, hA'
          }
        }
      },
      hourAndDay: {
        tickWidth: 70,
        tickHeight: 40,
        displayDateFormat: 'll LT',
        shiftIncrement: 1,
        shiftUnit: 'day',
        defaultSpan: 24,
        timeResolution: {
          unit: 'minute',
          increment: 30
        },
        headerConfig: {
          middle: {
            unit: 'hour',
            dateFormat: 'LT'
          },
          top: {
            unit: 'day',
            dateFormat: 'ddd DD/MM' //Mon 01/10
          }
        }
      },
      dayAndWeek: {
        tickWidth: 100,
        tickHeight: 80,
        displayDateFormat: 'll LT',
        shiftUnit: 'day',
        shiftIncrement: 1,
        defaultSpan: 5,
        timeResolution: {
          unit: 'hour',
          increment: 1
        },
        headerConfig: {
          middle: {
            unit: 'day',
            dateFormat: 'dd DD'
          },
          top: {
            unit: 'week',
            renderer(start) {
              return DateHelper.getShortNameOfUnit('week') + '.' + DateHelper.format(start, 'WW MMM YYYY');
            }
          }
        }
      },
      weekAndDay: {
        tickWidth: 100,
        tickHeight: 80,
        displayDateFormat: 'll hh:mm A',
        shiftUnit: 'week',
        shiftIncrement: 1,
        defaultSpan: 1,
        timeResolution: {
          unit: 'day',
          increment: 1
        },
        columnLinesFor: 'bottom',
        headerConfig: {
          bottom: {
            unit: 'day',
            increment: 1,
            dateFormat: 'DD MMM'
          },
          middle: {
            unit: 'week',
            dateFormat: 'YYYY MMMM DD' // 2017 January 01
          }
        }
      },
      weekAndMonth: {
        tickWidth: 100,
        tickHeight: 105,
        displayDateFormat: 'll',
        shiftUnit: 'week',
        shiftIncrement: 5,
        defaultSpan: 6,
        timeResolution: {
          unit: 'day',
          increment: 1
        },
        headerConfig: {
          middle: {
            unit: 'week',
            dateFormat: 'DD MMM'
          },
          top: {
            unit: 'month',
            dateFormat: 'MMM YYYY' //Jan 2017
          }
        }
      },
      monthAndYear: {
        tickWidth: 110,
        tickHeight: 110,
        displayDateFormat: 'll',
        shiftIncrement: 3,
        shiftUnit: 'month',
        defaultSpan: 12,
        timeResolution: {
          unit: 'day',
          increment: 1
        },
        headerConfig: {
          middle: {
            unit: 'month',
            dateFormat: 'MMM YYYY' //Jan 2017
          },
          top: {
            unit: 'year',
            dateFormat: 'YYYY' //2017
          }
        }
      },
      year: {
        tickWidth: 100,
        tickHeight: 100,
        resourceColumnWidth: 100,
        displayDateFormat: 'll',
        shiftUnit: 'year',
        shiftIncrement: 1,
        defaultSpan: 1,
        timeResolution: {
          unit: 'month',
          increment: 1
        },
        headerConfig: {
          middle: {
            unit: 'quarter',
            renderer(start, end, cfg) {
              return DateHelper.getShortNameOfUnit('quarter').toUpperCase() + (Math.floor(start.getMonth() / 3) + 1);
            }
          },
          top: {
            unit: 'year',
            dateFormat: 'YYYY'
          }
        }
      },
      manyYears: {
        tickWidth: 50,
        tickHeight: 50,
        displayDateFormat: 'll',
        shiftUnit: 'year',
        shiftIncrement: 1,
        defaultSpan: 1,
        timeResolution: {
          unit: 'year',
          increment: 1
        },
        columnLinesFor: 'bottom',
        headerConfig: {
          middle: {
            unit: 'year',
            dateFormat: 'YYYY',
            increment: 5
          },
          // smallest zoom level looked back
          // we have to specify increments here since 'increment' in zoomLevel affects only bottom header
          bottom: {
            unit: 'year',
            dateFormat: 'YY',
            increment: 1
          }
        }
      },
      weekAndDayLetter: {
        tickWidth: 20,
        tickHeight: 50,
        displayDateFormat: 'll',
        shiftUnit: 'week',
        shiftIncrement: 1,
        defaultSpan: 10,
        timeResolution: {
          unit: 'day',
          increment: 1
        },
        columnLinesFor: 'bottom',
        headerConfig: {
          bottom: {
            unit: 'day',
            renderer(start) {
              return DateHelper.format(start, 'dd').substring(0, 1);
            },
            verticalColumnWidth: 25
          },
          middle: {
            unit: 'week',
            dateFormat: 'ddd DD MMM YYYY', // Mon 01 Jan 2017
            verticalColumnWidth: 115
          }
        }
      },
      weekDateAndMonth: {
        tickWidth: 30,
        tickHeight: 40,
        displayDateFormat: 'll',
        shiftUnit: 'week',
        shiftIncrement: 1,
        defaultSpan: 10,
        timeResolution: {
          unit: 'day',
          increment: 1
        },
        headerConfig: {
          middle: {
            unit: 'week',
            dateFormat: 'DD'
          },
          top: {
            unit: 'month',
            dateFormat: 'YYYY MMMM'
          }
        }
      },
      day: {
        displayDateFormat: 'LT',
        shiftIncrement: 1,
        shiftUnit: 'day',
        defaultSpan: 1,
        timeResolution: {
          unit: 'minute',
          increment: 30
        },
        columnLinesFor: 'bottom',
        headerConfig: {
          bottom: {
            unit: 'hour',
            renderer(value) {
              return `
                                <div class="b-sch-calendarcolumn-ct"><span class="b-sch-calendarcolumn-hours">${DateHelper.format(
                                  value,
                                  'HH'
                                )}</span>
                                <span class="b-sch-calendarcolumn-minutes">${DateHelper.format(
                                  value,
                                  'mm'
                                )}</span></div>
                            `;
            }
          },
          middle: {
            unit: 'day',
            dateFormat: 'ddd DD/MM', // Mon 01/02
            splitUnit: 'day'
          }
        }
      },
      week: {
        displayDateFormat: 'LT',
        shiftIncrement: 1,
        shiftUnit: 'week',
        defaultSpan: 24,
        timeResolution: {
          unit: 'minute',
          increment: 30
        },
        columnLinesFor: 'bottom',
        headerConfig: {
          bottom: {
            unit: 'hour',
            dateFormat: 'LT', // will be overridden by renderer
            renderer(value) {
              return `
                                <div class="sch-calendarcolumn-ct">
                                <span class="sch-calendarcolumn-hours">${DateHelper.format(value, 'HH')}</span>
                                <span class="sch-calendarcolumn-minutes">${DateHelper.format(value, 'mm')}</span>
                                </div>
                            `;
            }
          },
          middle: {
            unit: 'week',
            dateFormat: 'D d',
            splitUnit: 'day'
          }
        }
      }
    };
  }

  static onLocalized() {
    const me = this;

    if (me.presets) {
      Object.values(me.presets).forEach((preset) => {
        const locale = me.L(preset.name);
        if (locale) {
          locale.displayDateFormat && (preset.displayDateFormat = locale.displayDateFormat);
          locale.middleDateFormat && (preset.headerConfig.middle.dateFormat = locale.middleDateFormat);
          locale.topDateFormat && (preset.headerConfig.top.dateFormat = locale.topDateFormat);
          locale.bottomDateFormat && (preset.headerConfig.bottom.dateFormat = locale.bottomDateFormat);
        }
      });
    }
  }

  /**
   * Registers a new view preset to be used by any scheduler grid or tree on the page.
   * @param {String} name The unique name identifying this preset
   * @param {Object} config The configuration properties of the view preset (see {@link Scheduler.preset.ViewPreset} for more information)
   */
  static registerPreset(name, config) {
    config.name = name;

    let preset = new ViewPreset(config);

    if (!this.presets) this.presets = {};

    if (preset.isValid) {
      //if (this.containsKey(name)) this.removeAtKey(name);
      //this.add(name, preset);
      this.presets[name] = preset;
    } else {
      throw new Error('Invalid preset, please check your configuration');
    }
  }

  /**
   * Fetches a view preset from the global cache
   * @param {String|Object} preset The preset of the preset or a preset config object
   * @return {Object} The view preset, see {@link Scheduler.preset.ViewPreset} for more information
   */
  static getPreset(preset) {
    if (typeof preset === 'string') {
      preset = this.presets[preset];
    } else if (!(preset instanceof ViewPreset)) {
      preset = new ViewPreset(preset);
    }
    return preset;
  }

  /**
   * Applies preset customizations or fetches a preset view preset using its name.
   * @param {String|Object} presetOrName Name of a predefined preset or a preset config object
   * @returns {Scheduler.preset.ViewPreset} Resulting ViewPreset instance
   */
  static normalizePreset(presetOrName) {
    let me = this,
      preset = presetOrName;

    if (!(preset instanceof ViewPreset)) {
      if (typeof preset === 'string') {
        preset = me.getPreset(preset);
        if (!preset) {
          throw new Error('You must define a valid view preset. See PresetManager for reference');
        }
      } else if (typeof preset === 'object') {
        let registeredPreset = preset.name && me.getPreset(preset.name);
        if (registeredPreset) {
          // TODO: detangle this
          preset = new ViewPreset(Object.assign(registeredPreset.config, preset));
        } else {
          let name = preset.name || 'preset' + Object.keys(me.presets).length;
          me.registerPreset(name, preset);
          preset = me.getPreset(name);
        }
      } else {
        throw new Error('Invalid preset, specify a preset name or config object');
      }
    }

    return preset;
  }

  /**
   * Deletes a view preset
   * @param {String} name The name of the preset
   */
  static deletePreset(name) {
    delete this.presets[name];
    //this.removeAtKey(name);
  }

  static registerDefaults() {
    const me = this,
      presets = me.defaultPresets;

    for (let presetName in presets) {
      me.registerPreset(presetName, presets[presetName]);
    }
  }
}

LocaleManagerSingelton.on('locale', PresetManager.onLocalized.bind(PresetManager));

PresetManager.registerDefaults();
// Apply any already loaded locale
PresetManager.onLocalized();
PresetManager._$name = 'PresetManager';

/**
 * @module Scheduler/data/TimeAxis
 */

/**
 * A class representing the time axis of the scheduler. The scheduler timescale is based on the ticks generated by this class.
 * This is a pure "data" (model) representation of the time axis and has no UI elements.
 *
 * The time axis can be {@link #config-continuous} or not. In continuous mode, each timespan starts where the previous ended, and in non-continuous mode
 * there can be gaps between the ticks.
 * A non-continuous time axis can be used when want to filter out certain periods of time (like weekends) from the time axis.
 *
 * To create a non-continuos time axis you have 2 options. First, you can create a time axis containing only the time spans of interest.
 * To do that, subclass this class and override the {@link #function-generateTicks} method.
 *
 * The other alternative is to call the {@link #function-filterBy} method, passing a function to it which should return `false` if the time tick should be filtered out.
 * Calling {@link Common.data.mixin.StoreFilter#function-clearFilters} will return you to a full time axis.
 *
 * @extends Common/data/Store
 */
class TimeAxis extends Store {
  //region Events

  /**
   * Fires before the timeaxis is about to be reconfigured (e.g. new start/end date or unit/increment). Return false to abort the operation.
   * @event beforereconfigure
   * @param {Scheduler.data.TimeAxis} source The time axis instance
   * @param {Date} startDate The new time axis start date
   * @param {Date} endDate The new time axis end date
   */

  /**
   * Event that is triggered when we end reconfiguring and everything UI-related should be done
   * @event endreconfigure
   * @private
   */

  /**
   * Fires when the timeaxis has been reconfigured (e.g. new start/end date or unit/increment)
   * @event reconfigure
   * @param {Scheduler.data.TimeAxis} source The time axis instance
   */

  /**
   * Fires if all the ticks in the timeaxis are filtered out. After firing the filter is cleared to return the time
   * axis to a valid state.
   * @event invalidFilter
   * @param {Scheduler.data.TimeAxis} source The time axis instance
   */

  //endregion

  //region Default config

  static get defaultConfig() {
    return {
      modelClass: TimeSpan,

      /**
       * Set to false if the timeline is not continuous, e.g. the next timespan does not start where the previous ended (for example skipping weekends etc).
       * @config {Boolean}
       * @default
       */
      continuous: true,

      originalContinuous: null,

      /**
       * Include only certain hours or days in the time axis (makes it `continuous : false`). Accepts and object
       * with `day` and `hour` properties:
       * ```
       * const scheduler = new Scheduler({
       *     timeAxis : {
       *         include : {
       *              // Do not display hours after 17 or before 9 (only display 9 - 17). The `to´ value is not
       *              // included in the time axis
       *              hour : {
       *                  from : 9,
       *                  to   : 17
       *              },
       *              // Do not display sunday or saturday
       *              day : [0, 6]
       *         }
       *     }
       * }
       * ```
       * In most cases we recommend that you use Scheduler's workingTime config instead. It is easier to use and
       * makes sure all parts of the Scheduler gets updated.
       * @config {Object}
       */
      include: null,

      /**
       * Automatically adjust the timespan when generating ticks with {@link #function-generateTicks} according to
       * the `viewPreset` configuration. Setting this to false may lead to shifting time/date of ticks.
       * @config {Boolean}
       * @default
       */
      autoAdjust: true,

      unit: null,
      increment: null,
      resolutionUnit: null,
      resolutionIncrement: null,

      weekStartDay: null,

      mainUnit: null,
      shiftUnit: null,

      shiftIncrement: 1,

      //isConfigured : false,

      // in case of `autoAdjust : false`, the 1st and last ticks can be truncated, containing only part of the normal tick
      // these dates will contain adjusted start/end (like if the tick has not been truncated)
      adjustedStart: null,
      adjustedEnd: null,
      // the visible position in the first tick, can actually be > 1 because the adjustment is done by the `mainUnit`
      visibleTickStart: null,
      // the visible position in the first tick, is always ticks count - 1 < value <= ticks count, in case of autoAdjust, always = ticks count
      visibleTickEnd: null,

      // name of the current preset
      //_presetName : null,
      defaultSpan: 1,

      tickCache: {},

      viewPreset: null
    };
  }

  //endregion

  //region Init

  // private
  construct(config) {
    const me = this;

    // TODO: maybe not needed
    me.generateTicksValidatorFn = () => true;

    super.construct(config);

    me.originalContinuous = me.continuous;

    me.on({
      change: ({ action }) => {
        // If the change was due to filtering, there will be a refresh event
        // arriving next, so do not reconfigure
        if (action !== 'filter') {
          me.trigger('reconfigure', { supressRefresh: false });
        }
      },
      refresh: () => me.trigger('reconfigure', { supressRefresh: false }),
      endreconfigure: (event) => me.trigger('reconfigure', event)
    });

    if (me.startDate) {
      me.internalOnReconfigure();
      me.trigger('reconfigure');
    } else if (me.viewPreset) {
      const range = me.getAdjustedDates(new Date());
      me.startDate = range.startDate;
      me.endDate = range.endDate;
    }
  }

  //endregion

  //region Configuration (reconfigure & consumePreset)

  /**
   * Reconfigures the time axis based on the config object supplied and generates the new 'ticks'.
   * @param {Object} config
   * @param {Boolean} [suppressRefresh]
   * @private
   */
  reconfigure(config, suppressRefresh = false, preventThrow = false) {
    const me = this,
      normalized = me.getAdjustedDates(config.startDate, config.endDate);

    if (
      me.trigger('beforeReconfigure', { startDate: normalized.startDate, endDate: normalized.endDate, config }) !==
      false
    ) {
      me.trigger('beginReconfigure');

      me._configuredStartDate = config.startDate;
      me._configuredEndDate = config.endDate;

      Object.assign(me, config);

      if (me.internalOnReconfigure(preventThrow) === false) {
        return false;
      }

      me.trigger('endReconfigure', { suppressRefresh, config });
    }
  }

  internalOnReconfigure(preventThrow = false) {
    const me = this;

    me.isConfigured = true;

    const adjusted = me.getAdjustedDates(me.startDate, me.endDate, true),
      normalized = me.getAdjustedDates(me.startDate, me.endDate),
      start = normalized.startDate,
      end = normalized.endDate;

    if (start >= end) {
      throw new Error(
        `Invalid start/end dates. Start date must less than end date. Start date: ${start}. End date: ${end}.`
      );
    }

    const unit = me.unit,
      increment = me.increment || 1,
      ticks = me.generateTicks(start, end, unit, increment);

    // Suspending to be able to detect an invalid filter
    me.suspendEvents();
    me.data = ticks;

    const { count } = me;

    if (count === 0) {
      if (preventThrow) {
        me.resumeEvents();
        return false;
      }
      throw new Error('Invalid time axis configuration or filter, please check your input data.');
    }

    // start date is cached, update it to fill after generated ticks
    me.startDate = me.first.startDate;

    me.resumeEvents();

    let checkEnd = me.last.endDate;

    if (me.isContinuous) {
      me.adjustedStart = adjusted.startDate;
      me.adjustedEnd = DateHelper.getNext(
        count > 1 ? ticks[count - 1].startDate : adjusted.startDate,
        unit,
        increment,
        me.weekStartDay
      );
    } else {
      me.adjustedStart = me.startDate;
      me.adjustedEnd = checkEnd;
    }

    // if visibleTickStart > 1 this means some tick is fully outside of the view - we are not interested in it and want to
    // drop it and adjust "adjustedStart" accordingly
    do {
      // TODO this has to use more sophisticated formula to take into account that months for example can be expressed in ms consistenly
      me.visibleTickStart = (me.startDate - me.adjustedStart) / (DateHelper.asMilliseconds(unit) * increment);

      // TODO: Changed from round to floor which seems to work, but this is not needed in ExtScheduler. Need to step and see what is different
      if (me.autoAdjust) me.visibleTickStart = Math.floor(me.visibleTickStart);

      if (me.visibleTickStart >= 1)
        me.adjustedStart = DateHelper.getNext(me.adjustedStart, unit, increment, me.weekStartDay);
    } while (me.visibleTickStart >= 1);

    do {
      me.visibleTickEnd = count - (me.adjustedEnd - checkEnd) / (DateHelper.asMilliseconds(unit) * increment);

      if (count - me.visibleTickEnd >= 1)
        me.adjustedEnd = DateHelper.getNext(me.adjustedEnd, unit, -1, me.weekStartDay);
    } while (count - me.visibleTickEnd >= 1);

    me.updateTickCache(true);
  }

  /**
   * Get/set currently used preset
   * @property {Scheduler.preset.ViewPreset}
   */
  get viewPreset() {
    return this._viewPreset;
  }

  set viewPreset(viewPreset) {
    const me = this,
      preset = PresetManager.getPreset(viewPreset);

    me._viewPreset = preset;

    Object.assign(me, {
      unit: preset.bottomHeader.unit,
      increment: preset.bottomHeader.increment || 1,

      resolutionUnit: preset.timeResolution.unit,
      resolutionIncrement: preset.timeResolution.increment,

      mainUnit: preset.mainHeader.unit,
      shiftUnit: preset.shiftUnit,
      shiftIncrement: preset.shiftIncrement || 1,

      defaultSpan: preset.defaultSpan || 1,
      presetName: preset.name,

      // Weekview columns are updated upon 'datachanged' event on this object.
      // We have to pass headerConfig in order to render them correctly (timeAxisViewModel is incorrect in required time)
      headerConfig: preset.headerConfig
    });
  }

  //endregion

  //region Getters & setters

  // private
  get resolution() {
    return {
      unit: this.resolutionUnit,
      increment: this.resolutionIncrement
    };
  }

  // private
  set resolution(resolution) {
    this.resolutionUnit = resolution.unit;
    this.resolutionIncrement = resolution.increment;
  }

  get resolutionUnit() {
    return this._resolutionUnit;
  }

  set resolutionUnit(resolutionUnit) {
    this._resolutionUnit = resolutionUnit;
  }

  get resolutionIncrement() {
    return this._resolutionIncrement;
  }

  set resolutionIncrement(resolutionIncrement) {
    this._resolutionIncrement = resolutionIncrement || 1;
  }

  set mainUnit(mainUnit) {
    this._mainUnit = mainUnit;
  }

  get mainUnit() {
    return this._mainUnit;
  }

  set shiftUnit(shiftUnit) {
    this._shiftUnit = shiftUnit;
  }

  // private
  get shiftUnit() {
    return this._shiftUnit || this._mainUnit;
  }

  set shiftIncrement(shiftIncrement) {
    this._shiftIncrement = shiftIncrement;
  }

  // private
  get shiftIncrement() {
    return this._shiftIncrement || 1;
  }

  set unit(unit) {
    this._unit = unit;
  }

  // private
  get unit() {
    return this._unit;
  }

  set increment(increment) {
    this._increment = increment;
  }

  // private
  get increment() {
    return this._increment;
  }

  get defaultSpan() {
    return this._defaultSpan;
  }

  set defaultSpan(defaultSpan) {
    this._defaultSpan = defaultSpan;
  }

  //endregion

  //region Timespan & resolution

  /**
   * Changes the time axis timespan to the supplied start and end dates.
   * @param {Date} newStartDate The new start date
   * @param {Date} newEndDate The new end date
   */
  setTimeSpan(newStartDate, newEndDate, preventThrow = false) {
    const me = this,
      { startDate, endDate } = me.getAdjustedDates(newStartDate, newEndDate);

    if (me.startDate - startDate !== 0 || me.endDate - endDate !== 0) {
      return me.reconfigure(
        {
          startDate,
          endDate
        },
        false,
        preventThrow
      );
    }
  }

  /**
   * Moves the time axis by the passed amount and unit.
   *
   * NOTE: When using a filtered TimeAxis the result of `shift()` cannot be guaranteed, it might shift into a
   * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.
   * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly
   * instead.
   *
   * @param {Number} amount The number of units to jump
   * @param {String} [unit] The unit (Day, Week etc)
   */
  shift(amount, unit = this.shiftUnit) {
    const me = this;

    let { startDate, endDate } = me;

    // Use unfiltered start and end dates when shifting a filtered time axis, to lessen risk of messing it up.
    // Still not guaranteed to work though
    if (me.isFiltered) {
      startDate = me.allRecords[0].startDate;
      endDate = me.allRecords[me.allCount - 1].endDate;
    }

    // Hack for filtered time axis, for example if weekend is filtered out and you shiftPrev() day from monday
    let tries = 0;
    do {
      startDate = DateHelper.add(startDate, amount, unit);
      endDate = DateHelper.add(endDate, amount, unit);
    } while (tries++ < 100 && me.setTimeSpan(startDate, endDate, true) === false);
  }

  /**
     * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement`
     * config of the current view preset.
     *
     * NOTE: When using a filtered TimeAxis the result of `shiftNext()` cannot be guaranteed, it might shift into a
     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.
     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly
     * instead.

     *
     * @param {Number} [amount] The number of units to jump forward
     */
  shiftNext(amount = this.shiftIncrement) {
    this.shift(amount);
  }

  /**
     * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` config of the current view preset.
     *
     * NOTE: When using a filtered TimeAxis the result of `shiftPrev()` cannot be guaranteed, it might shift into a
     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.
     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly
     * instead.

     *
     * @param {Number} [amount] The number of units to jump backward
     */
  shiftPrevious(amount = this.shiftIncrement) {
    this.shift(-amount);
  }

  //endregion

  //region Filter & continous

  /**
   * Filter the time axis by a function. The passed function will be called with each tick in time axis.
   * If the function returns true, the 'tick' is included otherwise it is filtered. If all ticks are filtered out
   * the time axis is considered invalid, triggering `invalidFilter` and then removing the filter.
   * @param {Function} fn The function to be called, it will receive an object with startDate/endDate properties, and 'index' of the tick.
   * @param {Object} [thisObj] `this` reference for the function
   */
  filterBy(fn, thisObj = this) {
    const me = this;

    me.filters.clear();

    super.filterBy((tick, index) => fn.call(thisObj, tick.data, index));

    if (me.count === 0) {
      me.trigger('invalidFilter');
      me.clearFilters();
    }
  }

  triggerFilterEvent(event) {
    const me = this;

    if (!event.filters.count) {
      me.continuous = me.originalContinuous;
    } else {
      me.continuous = false;
    }

    // Filters has been applied (or cleared) but listeners are not informed yet, update tick cache to have start and
    // end dates correct when later redrawing events & header
    me.updateTickCache();

    super.triggerFilterEvent(event);
  }

  /**
   * Returns `true` if the time axis is continuous (will return `false` when filtered)
   * @return {Boolean}
   */
  get isContinuous() {
    return this.continuous !== false && !this.filtered;
  }

  //endregion

  //region Dates

  getAdjustedDates(startDate, endDate, forceAdjust = false) {
    const me = this;

    startDate = startDate || me.startDate;
    endDate = endDate || DateHelper.add(startDate, me.defaultSpan, me.mainUnit);

    return me.autoAdjust || forceAdjust
      ? {
          startDate: me.floorDate(startDate, false, me.autoAdjust ? me.mainUnit : me.unit, 1),
          endDate: me.ceilDate(endDate, false, me.autoAdjust ? me.mainUnit : me.unit, 1)
        }
      : {
          startDate: startDate,
          endDate: endDate
        };
  }

  /**
   * Method to get the current start date of the time axis.
   * @property {Date}
   */
  get startDate() {
    // TODO: added _start as caching, might mess something up when reconfiguring? change here if tests fail
    return this._start || (this.first ? new Date(this.first.startDate) : null);
  }

  set startDate(start) {
    this._start = DateHelper.parse(start);
  }

  /**
   * Method to get a the current end date of the time axis
   * @property {Date}
   */
  get endDate() {
    return this._end || (this.last ? new Date(this.last.endDate) : null);
  }

  set endDate(end) {
    if (end) this._end = DateHelper.parse(end);
  }

  // used in performance critical code for comparisons
  get startMS() {
    return this._startMS;
  }

  // used in performance critical code for comparisons
  get endMS() {
    return this._endMS;
  }

  // Floors a date and optionally snaps it to one of the following resolutions:
  // 1. 'resolutionUnit'. If param 'resolutionUnit' is passed, the date will simply be floored to this unit.
  // 2. If resolutionUnit is not passed: If date should be snapped relative to the timeaxis start date,
  // the resolutionUnit of the timeAxis will be used, or the timeAxis 'mainUnit' will be used to snap the date
  //
  // returns a copy of the original date
  // private
  floorDate(date, relativeToStart, resolutionUnit, incr) {
    relativeToStart = relativeToStart !== false;

    const me = this,
      relativeTo = relativeToStart ? DateHelper.clone(me.startDate) : null,
      increment = incr || me.resolutionIncrement,
      unit = resolutionUnit || (relativeToStart ? me.resolutionUnit : me.mainUnit),
      snap = (value, increment) => Math.floor(value / increment) * increment;

    if (relativeToStart) {
      const snappedDuration = snap(DateHelper.diff(relativeTo, date, unit), increment);
      // TODO: used to be small unit multipled with factor (minute = seconds, minutes * 60)
      return DateHelper.add(relativeTo, snappedDuration, unit);
    }

    let dt = DateHelper.clone(date);

    if (unit === 'week') {
      let day = dt.getDay() || 7,
        startDay = me.weekStartDay || 7;

      dt = DateHelper.add(
        DateHelper.startOf(dt, 'day'),
        day >= startDay ? startDay - day : -(7 - startDay + day),
        'day'
      );

      // Watch out for Brazil DST craziness (see test 028_timeaxis_dst.t.js)
      if (dt.getDay() !== startDay && dt.getHours() === 23) {
        dt = DateHelper.add(dt, 1, 'hour');
      }
    } else {
      // removes "smaller" units from date (for example minutes; removes seconds and milliseconds)
      dt = DateHelper.startOf(dt, unit);

      // day and year are 1-based so need to make additional adjustments
      let modifier = ['day', 'year'].includes(unit) ? 1 : 0,
        useUnit = unit === 'day' ? 'date' : unit,
        snappedValue = snap(DateHelper.get(dt, useUnit) - modifier, increment) + modifier;

      dt = DateHelper.set(dt, useUnit, snappedValue);
    }

    return dt;
  }

  /**
   * Rounds the date to nearest unit increment
   * @private
   */
  roundDate(date, relativeTo) {
    let me = this,
      dt = DateHelper.clone(date),
      increment = me.resolutionIncrement || 1;

    relativeTo = DateHelper.clone(relativeTo || me.startDate);

    switch (me.resolutionUnit) {
      case 'week':
        DateHelper.startOf(dt, 'day');

        let distanceToWeekStartDay = dt.getDay() - me.weekStartDay,
          toAdd;

        if (distanceToWeekStartDay < 0) {
          distanceToWeekStartDay = 7 + distanceToWeekStartDay;
        }

        if (Math.round(distanceToWeekStartDay / 7) === 1) {
          toAdd = 7 - distanceToWeekStartDay;
        } else {
          toAdd = -distanceToWeekStartDay;
        }

        return DateHelper.add(dt, toAdd, 'day');

      case 'month':
        let nbrMonths =
            DateHelper.as('month', DateHelper.diff(relativeTo, dt)) + dt.getDay() / DateHelper.daysInMonth(dt),
          snappedMonths = Math.round(nbrMonths / increment) * increment;
        return DateHelper.add(relativeTo, snappedMonths, 'month');

      case 'quarter':
        DateHelper.startOf(dt, 'month');
        return DateHelper.add(dt, 'month', 3 - (dt.getMonth() % 3));

      default:
        const duration = DateHelper.as(me.resolutionUnit, DateHelper.diff(relativeTo, dt)),
          // Need to find the difference of timezone offsets between relativeTo and original dates. 0 if timezone offsets are the same.
          offset = DateHelper.as(me.resolutionUnit, relativeTo.getTimezoneOffset() - dt.getTimezoneOffset(), 'minute'),
          // Need to add the offset to the whole duration, so the divided value will take DST into account
          snappedDuration = Math.round((duration + offset) / increment) * increment;

        // TODO: used to add one res unit lower * factor, minutes = add seconds, minutes * 60
        // Now when the round is done, we need to subtract the offset, so the result also will take DST into account
        return DateHelper.add(relativeTo, snappedDuration - offset, me.resolutionUnit);
    }
  }

  // private
  ceilDate(date, relativeToStart, resolutionUnit, increment) {
    const me = this;

    relativeToStart = relativeToStart !== false;
    increment = increment || (relativeToStart ? this.resolutionIncrement : 1);

    let dt = DateHelper.clone(date),
      doCall = false,
      unit = resolutionUnit || (relativeToStart ? me.resolutionUnit : me.mainUnit);

    switch (unit) {
      case 'minute':
        doCall = !DateHelper.isStartOf(dt, 'minute');
        break;
      case 'hour':
        doCall = !DateHelper.isStartOf(dt, 'hour');
        break;

      case 'day':
      case 'date':
        doCall = !DateHelper.isStartOf(dt, 'day');
        break;

      case 'week':
        dt = DateHelper.startOf(dt, 'day');
        doCall = dt.getDay() !== me.weekStartDay || !DateHelper.isEqual(dt, date);
        break;

      case 'month':
        dt = DateHelper.startOf(dt, 'day');
        doCall = dt.getDate() !== 1 || !DateHelper.isEqual(dt, date);
        break;

      case 'quarter':
        dt = DateHelper.startOf(dt, 'day');
        doCall = dt.getMonth() % 3 !== 0 || dt.getDate() !== 1 || !DateHelper.isEqual(dt, date);
        break;

      case 'year':
        dt = DateHelper.startOf(dt, 'day');
        doCall = dt.getMonth() !== 0 || dt.getDate() !== 1 || !DateHelper.isEqual(dt, date);
        break;
    }

    if (doCall) return DateHelper.getNext(dt, unit, increment, me.weekStartDay);

    return dt;
  }

  //endregion

  //region Ticks

  get include() {
    return this._include;
  }

  set include(include) {
    const me = this;

    me._include = include;
    me.continuous = !include;

    if (!me.isConfiguring) {
      me.startDate = me._configuredStartDate;
      me.endDate = me._configuredEndDate;
      me.internalOnReconfigure();
      me.trigger('includeChange');
    }
  }

  // Check if a certain date is included based on timeAxis.include rules
  processExclusion(startDate, endDate, unit) {
    const { include } = this;

    if (include) {
      return Object.entries(include).some(([includeUnit, rule]) => {
        if (!rule) {
          return false;
        }

        const { from, to } = rule;

        // Including the closest smaller unit with a { from, to} rule should affect start & end of the
        // generated tick. Currently only works for days or smaller.
        if (DateHelper.compareUnits('day', unit) >= 0 && DateHelper.getLargerUnit(includeUnit) === unit) {
          if (from) {
            DateHelper.set(startDate, includeUnit, from);
          }

          if (to) {
            let stepUnit = unit;
            // Stepping back base on date, not day
            if (unit === 'day') {
              stepUnit = 'date';
            }
            // Since endDate is not inclusive it points to the next day etc.
            // Turns for example 2019-01-10T00:00 -> 2019-01-09T18:00
            DateHelper.set(endDate, {
              [stepUnit]: DateHelper.get(endDate, stepUnit) - 1,
              [includeUnit]: to
            });
          }
        }

        // "Greater" unit being included? Then we need to care about it
        // (for example excluding day will also affect hour, minute etc)
        if (DateHelper.compareUnits(includeUnit, unit) >= 0) {
          const datePart = includeUnit === 'day' ? startDate.getDay() : DateHelper.get(startDate, includeUnit);

          if ((from && datePart < from) || (to && datePart >= to)) {
            return true;
          }
        }
      });
    }

    return false;
  }

  // Calculate constants used for exclusion when scaling within larger ticks
  initExclusion() {
    Object.entries(this.include).forEach(([unit, rule]) => {
      if (rule) {
        const { from, to } = rule;

        // For example for hour:
        // 1. Get the next bigger unit -> day, get ratio -> 24
        // 2. to 20 - from 8 = 12 hours visible each day. lengthFactor 24 / 12 = 2 means that each hour used
        // needs to represent 2 hours when drawn (to stretch)
        // |    ████    | -> |  ████████  |
        rule.lengthFactor = DateHelper.getUnitToBaseUnitRatio(unit, DateHelper.getLargerUnit(unit)) / (to - from);
        // TODO: Since `to` is exclusive this should be the correct one... but cannot get it to work throughout
        rule.lengthFactorExcl =
          DateHelper.getUnitToBaseUnitRatio(unit, DateHelper.getLargerUnit(unit)) / (to - from - 1);

        // Calculate weighted center to stretch around |   ██x█ |
        rule.center = from + from / (rule.lengthFactor - 1);
      }
    });
  }

  /**
   * Method generating the ticks for this time axis. Should return an array of ticks. Each tick is an object of the following structure:
   * ```
   * {
   *    startDate : ..., // start date
   *    endDate   : ...  // end date
   * }
   * ```
   * Take notice, that this function either has to be called with `start`/`end` parameters, or create those variables.
   *
   * @param {Date} axisStartDate The start date of the interval
   * @param {Date} axisEndDate The end date of the interval
   * @param {String} unit The unit of the time axis
   * @param {Number} increment The increment for the unit specified.
   * @return {Array} ticks The ticks representing the time axis
   */
  generateTicks(axisStartDate, axisEndDate, unit = this.unit, increment = this.increment) {
    const me = this,
      ticks = [],
      usesExclusion = Boolean(me.include);

    let intervalEnd,
      tickEnd,
      isExcluded,
      dstDiff = 0,
      { startDate, endDate } = me.getAdjustedDates(axisStartDate, axisEndDate);

    me.tickCache = {};

    if (usesExclusion) {
      me.initExclusion();
    }

    while (startDate < endDate) {
      intervalEnd = DateHelper.getNext(startDate, unit, increment, me.weekStartDay);

      if (!me.autoAdjust && intervalEnd > endDate) {
        intervalEnd = endDate;
      }

      // Handle hourly increments crossing DST boundaries to keep the timescale looking correct
      // Only do this for HOUR resolution currently, and only handle it once per tick generation.
      if (unit === 'hour' && increment > 1 && ticks.length > 0 && dstDiff === 0) {
        const prev = ticks[ticks.length - 1];

        dstDiff = ((prev.startDate.getHours() + increment) % 24) - prev.endDate.getHours();

        if (dstDiff !== 0) {
          // A DST boundary was crossed in previous tick, adjust this tick to keep timeaxis "symmetric".
          intervalEnd = DateHelper.add(intervalEnd, dstDiff, 'hour');
        }
      }

      isExcluded = false;

      if (usesExclusion) {
        tickEnd = new Date(intervalEnd.getTime());
        isExcluded = me.processExclusion(startDate, intervalEnd, unit);
      } else {
        tickEnd = intervalEnd;
      }

      if (me.generateTicksValidatorFn(startDate) && !isExcluded) {
        ticks.push({
          startDate,
          endDate: intervalEnd
        });
        me.tickCache[startDate.getTime()] = ticks.length - 1;
      }

      startDate = tickEnd;
    }

    return ticks;
  }

  get visibleTickTimeSpan() {
    const me = this;
    return me.isContinuous ? me.visibleTickEnd - me.visibleTickStart : me.count;
  }

  /**
   * Gets a tick "coordinate" representing the date position on the time scale. Returns -1 if the date is not part of the time axis.
   * @param {Date} date the date
   * @return {Number} the tick position on the scale or -1 if the date is not part of the time axis
   */
  getTickFromDate(date) {
    const me = this,
      ticks = me.records;

    let begin = 0,
      end = ticks.length - 1,
      middle,
      tick,
      tickStart,
      tickEnd;

    // Quickly eliminate out of range dates or if we have not been set up with a time range yet
    if (!ticks.length || date < ticks[0].startDate || date > ticks[end].endDate) {
      return -1;
    }
    if (me.isContinuous) {
      // TODO: This is the code from ExtScheduler, it is a calculation without iteration so it should perform better,
      //  we should consider using it...
      // if (date - ticks[0].startDate === 0) return this.visibleTickStart;
      // if (date - ticks[end].endDate === 0) return this.visibleTickEnd;
      //
      // const { adjustedStart, adjustedEnd }     = this;
      //
      // let tickIndex       = Math.floor(ticks.length * (date - adjustedStart) / (adjustedEnd - adjustedStart));
      //
      // // for the date == adjustedEnd case
      // if (tickIndex > end) {
      //     tickIndex = end;
      // }
      //
      // const tickStart           = tickIndex === 0 ? adjustedStart : ticks[tickIndex].startDate;
      // const tickEnd             = tickIndex === end ? adjustedEnd : ticks[tickIndex].endDate;
      //
      // tick                = tickIndex + (date - tickStart) / (tickEnd - tickStart);
      //
      // // in case of `autoAdjust : false` the actual visible timespan starts not from 0 tick coordinate, but
      // // from `visibleTickStart` coordinate, this check generally repeats the "quick bailout" check in the begining of the method,
      // // but still
      // if (tick < this.visibleTickStart || tick > this.visibleTickEnd) {
      //     return -1;
      // }
      //
      // return tick;
      // Chop tick cache in half until we find a match
      while (begin < end) {
        middle = (begin + end + 1) >> 1;
        if (date > ticks[middle].endDate) {
          begin = middle + 1;
        } else if (date < ticks[middle].startDate) {
          end = middle - 1;
        } else {
          begin = middle;
        }
      }
      tick = ticks[begin];
      tickStart = tick.startDate;
      tickEnd = tick.endDate;

      // Part way though, calculate the fraction
      if (date > tickStart) {
        begin += (date - tickStart) / (tickEnd - tickStart);
      }
      return Math.min(Math.max(begin, me.visibleTickStart), me.visibleTickEnd);
    } else {
      for (let i = 0; i <= end; i++) {
        tickEnd = ticks[i].endDate;

        if (date <= tickEnd) {
          tickStart = ticks[i].startDate;

          // date < tickStart can occur in filtered case
          tick = i + (date > tickStart ? (date - tickStart) / (tickEnd - tickStart) : 0);

          return tick;
        }
      }
    }
  }

  /**
   * Gets the time represented by a tick "coordinate".
   * @param {Number} tick the tick "coordinate"
   * @param {String} [roundingMethod] The rounding method to use
   * @return {Date} The date to represented by the tick "coordinate", or null if invalid.
   */
  getDateFromTick(tick, roundingMethod) {
    const me = this;

    if (tick === me.visibleTickEnd) {
      return me.endDate;
    }

    const wholeTick = Math.floor(tick),
      fraction = tick - wholeTick,
      t = me.getAt(wholeTick);

    if (!t) {
      return null;
    }

    let start = wholeTick === 0 ? me.adjustedStart : t.startDate,
      // if we've filtered timeaxis using filterBy, then we cannot trust to adjustedEnd property and should use tick end
      end = wholeTick === me.count - 1 && me.isContinuous ? me.adjustedEnd : t.endDate,
      date = DateHelper.add(start, fraction * (end - start), 'millisecond');

    if (roundingMethod) {
      date = me[roundingMethod + 'Date'](date);
    }

    return date;
  }

  /**
   * Returns the ticks of the timeaxis in an array of objects with a "start" and "end" date.
   * @return {Object[]} the ticks on the scale
   */
  get ticks() {
    return this.records;
  }

  /**
   * Caches ticks and start/end dates for faster processing during rendering of events.
   * @private
   */
  updateTickCache(onlyStartEnd = false) {
    const me = this;

    if (me.count) {
      me._start = me.first.startDate;
      me._end = me.last.endDate;
      me._startMS = me.startDate.getTime();
      me._endMS = me.endDate.getTime();
    } else {
      me._start = me._end = me._startMs = me._endMS = null;
    }

    // onlyStartEnd is true prior to clearing filters, to get start and end dates correctly during that process.
    // No point in filling tickCache yet in that case, it will be done after the filters are cleared
    if (!onlyStartEnd) {
      me.tickCache = {};
      me.forEach((tick, i) => (me.tickCache[tick.startDate.getTime()] = i));
    }
  }

  //endregion

  //region Axis

  /**
   * Returns true if the passed date is inside the span of the current time axis.
   * @param {Date} date The date to query for
   * @return {Boolean} true if the date is part of the timeaxis
   */
  dateInAxis(date, inclusiveEnd = false) {
    const me = this,
      axisStart = me.startDate,
      axisEnd = me.endDate;

    // Date is between axis start/end and axis is not continuous - need to perform better lookup
    if (me.isContinuous) {
      return inclusiveEnd
        ? DateHelper.betweenLesserEqual(date, axisStart, axisEnd)
        : DateHelper.betweenLesser(date, axisStart, axisEnd);
    } else {
      let length = me.getCount(),
        tickStart,
        tickEnd,
        tick;

      for (let i = 0; i < length; i++) {
        tick = me.getAt(i);
        tickStart = tick.startDate;
        tickEnd = tick.endDate;

        if ((inclusiveEnd && date <= tickEnd) || (!inclusiveEnd && date < tickEnd)) {
          return date >= tickStart;
        }
      }
    }

    return false;
  }

  /**
   * Returns true if the passed timespan is part of the current time axis (in whole or partially).
   * @param {Date} start The start date
   * @param {Date} end The end date
   * @return {Boolean} true if the timespan is part of the timeaxis
   */
  timeSpanInAxis(start, end) {
    const me = this;

    if (end.getTime() === start.getTime()) {
      return this.dateInAxis(start, true);
    }

    if (me.isContinuous) {
      return DateHelper.intersectSpans(start, end, me.startDate, me.endDate);
    }

    return (start < me.startDate && end > me.endDate) || me.getTickFromDate(start) !== me.getTickFromDate(end);
  }

  // Accepts a TimeSpan model (uses its cached MS values to be a bit faster during rendering)
  isTimeSpanInAxis(timeSpan) {
    const me = this,
      startMS = timeSpan.startDateMS,
      endMS = timeSpan.endDateMS;

    // only consider fully scheduled ranges
    if (!startMS || !endMS) return false;

    if (endMS === startMS) {
      return this.dateInAxis(timeSpan.startDate, true);
    }

    if (me.isContinuous) {
      return endMS > me.startMS && startMS < me.endMS;
    }

    return (
      (startMS < me.startMS && endMS > me.endMS) ||
      me.getTickFromDate(timeSpan.startDate) !== me.getTickFromDate(timeSpan.endDate)
    );
  }

  //endregion

  //region Iteration

  /**
   * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
   * @internal
   * @param {String} unit The unit to use when iterating over the timespan
   * @param {Number} increment The increment to use when iterating over the timespan
   * @param {Function} iteratorFn The function to call
   * @param {Object} [thisObj] `this` reference for the function
   */
  forEachAuxInterval(unit, increment = 1, iteratorFn, thisObj = this) {
    let end = this.endDate,
      dt = this.startDate,
      i = 0,
      intervalEnd;

    if (dt > end) throw new Error('Invalid time axis configuration');

    while (dt < end) {
      intervalEnd = DateHelper.min(DateHelper.getNext(dt, unit, increment, this.weekStartDay), end);
      iteratorFn.call(thisObj, dt, intervalEnd, i);
      dt = intervalEnd;
      i++;
    }
  }

  //endregion
}
TimeAxis._$name = 'TimeAxis';

/**
 * @module Scheduler/feature/ColumnLines
 */

/**
 * Displays column lines for ticks, with a thicker line for each major tick. If this feature is disabled, no lines are shown.
 * If it's enabled, line are shown for the tick level which is set in current ViewPreset. Please see {@link Scheduler.preset.ViewPreset#config-columnLinesFor} config for details.
 *
 * The lines are drawn to a canvas,
 * converted to an image and used as background in the schedulers background canvas. In certain scenarios, major column
 * lines are drawn as divs.
 *
 * The color and style of the lines are determined by extracting the values for `border-left-color` and
 * `border-left-style` (solid, dashed or dotted are supported) from the css rules for `.b-column-line` and
 * `.b-column-line-major`.
 *
 * This feature is **enabled** by default
 *
 * @extends Common/mixin/InstancePlugin
 * @demo basic
 * @externalexample scheduler/ColumnLines.js
 */
class ColumnLines extends InstancePlugin {
  //region Config

  static get properties() {
    return {
      tickColor: '#e6e6e6',
      majorTickColor: '#999',
      tickStyle: 'solid',
      majorTickStyle: 'solid'
    };
  }

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      after: ['render', 'updateCanvasSize']
    };
  }

  //endregion

  //region Init & destroy

  construct(client, config) {
    const me = this;

    client.useBackgroundCanvas = true;

    super.construct(client, config);

    me.timeAxisViewModel = client.timeAxisViewModel;

    client.on({
      theme: 'onThemeChange',
      thisObj: me
    });
  }

  doDestroy() {
    this.timeAxisViewModelDetatcher && this.timeAxisViewModelDetatcher();
    super.doDestroy();
  }

  //endregion

  //region Draw

  /**
   * Reads lines colors from temporary element
   * @private
   */
  getColorsFromCSS() {
    const me = this;

    // Create two fake column lines. But only do it once per app.
    if (!me.GotColors) {
      const element = DomHelper.createElement({
          style: 'position: absolute; visibility: hidden',
          html: '<div class="b-column-line"></div><div class="b-column-line-major"></div>',
          parent: document.body
        }),
        tickColor = DomHelper.getStyleValue(element.firstElementChild, 'border-left-color'),
        majorColor = DomHelper.getStyleValue(element.lastElementChild, 'border-left-color'),
        tickStyle = DomHelper.getStyleValue(element.firstElementChild, 'border-left-style'),
        majorTickStyle = DomHelper.getStyleValue(element.lastElementChild, 'border-left-style');

      if (tickColor) {
        me.tickColor = tickColor;
      }

      if (majorColor) {
        me.majorTickColor = majorColor;
      }

      if (tickStyle) {
        me.tickStyle = tickStyle;
      }

      if (majorTickStyle) {
        me.majorTickStyle = majorTickStyle;
      }

      element.remove();
      me.GotColors = true;
    }
  }

  onThemeChange() {
    this.GotColors = false;
    this.render();
  }

  /**
   * Draw lines when scheduler/gantt is rendered.
   * @private
   */
  render() {
    this.getColorsFromCSS();
    this.drawLines();
  }

  /**
   * Draw column lines to a offscreen canvas, convert to base64 and use as background image.
   * @private
   */
  drawLines() {
    // Early bailout for timeaxis without start date
    if (!this.client.timeAxis.startDate) {
      return;
    }

    // We cannot rely on timeAxisViewModel because rendered header may not include full top header.
    // This means we should generate whole top level tick and then iterate over ticks, calculating lines position
    // depending on header config
    const me = this,
      { client } = me,
      { timeAxis } = client,
      axisStart = timeAxis.startDate,
      viewModel = client.timeAxisViewModel,
      tickSize = viewModel.tickSize,
      element = client.backgroundCanvas,
      canvas = document.createElement('canvas'),
      ctx = canvas.getContext('2d'),
      linesForLevel = viewModel.columnLinesFor,
      // header to draw lines for
      targetHeader = viewModel.headerConfig[linesForLevel],
      headers = viewModel.headers,
      // header which is used to draw major lines
      upperHeader = headers[headers.indexOf(targetHeader) - 1] || headers[0],
      // header defining ticks
      lowerHeader = headers[headers.length - 1],
      // when unit is year we should use 1 as increment
      startDate = timeAxis.floorDate(
        axisStart,
        false,
        upperHeader.unit,
        upperHeader.unit === 'year' ? 1 : upperHeader.increment || 1
      ),
      endDate = DateHelper.getNext(startDate, upperHeader.unit, upperHeader.increment || 1, timeAxis.weekStartDay),
      // we rendered one upper header and need to calculate how many ticks fit in it
      ticksInHeader =
        Math.round(DateHelper.getDurationInUnit(startDate, endDate, lowerHeader.unit)) / (lowerHeader.increment || 1),
      nbrLinesToDraw =
        Math.round(DateHelper.getDurationInUnit(startDate, endDate, targetHeader.unit)) / (targetHeader.increment || 1),
      // shows how many ticks should we skip before drawing next line
      ratio = ticksInHeader / nbrLinesToDraw;

    if (client.isHorizontal) {
      if (axisStart) {
        const doUnitsAlign = headers.length > 1 && DateHelper.doesUnitsAlign(upperHeader.unit, targetHeader.unit),
          offsetDate = doUnitsAlign
            ? startDate
            : timeAxis.floorDate(axisStart, false, targetHeader.unit, targetHeader.increment),
          // TODO: isContinuous check solved the issue I was seeing but not very generic
          offset = !timeAxis.isContinuous
            ? 0
            : (DateHelper.getDurationInUnit(offsetDate, axisStart, lowerHeader.unit, true) / timeAxis.increment) *
              tickSize,
          // this is position from left side of the canvas to draw first line, otherwi
          startPos = 10,
          height = 20;

        DomHelper.removeEachSelector(element, '.b-column-line-major');

        let isMajor = false,
          majorHeaderIsRegular = true;

        if (
          targetHeader !== upperHeader &&
          doUnitsAlign &&
          lowerHeader.unit === 'day' &&
          DateHelper.compareUnits(upperHeader.unit, 'month') !== -1
        ) {
          // This condition means, that major lines are irregular, e.g. when lower level is days and upper is
          // months. Since months have different duration, we cannot safely repeat images
          majorHeaderIsRegular = false;
          timeAxis.forEachAuxInterval(upperHeader.unit, upperHeader.increment, (start, end) => {
            DomHelper.append(element, {
              tag: 'div',
              className: 'b-column-line-major',
              style: `left:${viewModel.getPositionFromDate(end) - 1}px;`
            });
          });
        }

        // hack for FF to not crash when trying to create too wide canvas.
        canvas.width = Math.min(ticksInHeader * 2 * tickSize, 32767);
        canvas.height = height;
        ctx.translate(-0.5, -0.5);
        ctx.lineWidth = 2;

        for (let i = 0; i < nbrLinesToDraw; i++) {
          // Only first interval may be major
          if (i === 0) {
            // Filtered time axis should not have any major lines
            isMajor = upperHeader !== targetHeader && doUnitsAlign && majorHeaderIsRegular && timeAxis.isContinuous;
          } else {
            isMajor = false;
          }

          const tickStyle = (isMajor && me.majorTickStyle) || (!isMajor && me.tickStyle);
          if (tickStyle !== 'solid') {
            switch (tickStyle) {
              case 'dashed':
                ctx.setLineDash([6, 4]);
                break;
              case 'dotted':
                ctx.setLineDash([2, 3]);
                break;
            }
          }

          ctx.beginPath();
          ctx.strokeStyle = isMajor ? me.majorTickColor : me.tickColor;

          // draw ticks
          ctx.moveTo(i * ratio * tickSize * 2 + startPos - 1, 0);
          ctx.lineTo(i * ratio * tickSize * 2 + startPos - 1, height + 2);
          ctx.stroke();
        }

        // use as background image
        element.style.backgroundImage = `url(${canvas.toDataURL()})`;
        element.style.backgroundSize = `${canvas.width / 2}px`;
        element.style.backgroundPositionX = `${-(startPos / 2 + offset)}px`;
      }
    } else {
      // hack for FF to not crash when trying to create too wide canvas.
      canvas.width = client.timeAxisColumn.resourceColumns.columnWidth * 2;
      canvas.height = 2;
      ctx.translate(-0.5, -0.5);
      ctx.lineWidth = 2;

      if (axisStart) {
        DomHelper.removeEachSelector(element, '.b-column-line-major');

        // Major lines always as divs to not get so large image
        if (targetHeader !== upperHeader) {
          timeAxis.forEachAuxInterval(upperHeader.unit, upperHeader.increment, (start, end) => {
            DomHelper.append(element, {
              tag: 'div',
              className: 'b-column-line-major',
              style: `top:${viewModel.getPositionFromDate(end) - 1}px;`
            });
          });
        }

        if (me.tickStyle !== 'solid') {
          switch (me.tickStyle) {
            case 'dashed':
              ctx.setLineDash([6, 4]);
              break;
            case 'dotted':
              ctx.setLineDash([2, 3]);
              break;
          }
        }

        const height = ratio * tickSize * 2;

        canvas.height = height;

        ctx.beginPath();
        ctx.strokeStyle = me.tickColor;
        ctx.lineWidth = 2;

        // draw ticks
        ctx.moveTo(0, height - 1);
        ctx.lineTo(canvas.width + 2, height - 1);
        ctx.stroke();
      }

      ctx.beginPath();
      ctx.strokeStyle = me.tickColor;

      // draw ticks
      ctx.moveTo(canvas.width - 1, 0);
      ctx.lineTo(canvas.width - 1, canvas.height + 2);
      ctx.stroke();

      // use as background image
      element.style.backgroundImage = `url(${canvas.toDataURL()})`;
      element.style.backgroundSize = `${canvas.width / 2}px`;
      element.style.backgroundPositionX = '0';
    }
  }

  //endregion

  //region Events

  /**
   * Redraw lines when time axis changes.
   * @private
   */
  updateCanvasSize() {
    this.drawLines();
  }

  //endregion
}

ColumnLines._$name = 'ColumnLines';
GridFeatureManager.registerFeature(ColumnLines, true, ['Scheduler', 'Gantt']);

/**
 * @module Scheduler/feature/mixin/DependencyCreation
 */

/**
 * Mixin for Dependencies feature that handles dependency creation (drag & drop from terminals which are shown on hover).
 * @mixin
 */
var DependencyCreation = (Target) =>
  class DependencyCreation extends Delayable(Target || Base) {
    //region Config

    static get defaultConfig() {
      return {
        /**
         * `false` to not show a tooltip while creating a dependency
         * @config {Boolean}
         * @default
         */
        showCreationTooltip: true,

        /**
         * A tooltip config object that will be applied to the dependency creation tooltip
         * @config {Object}
         */
        creationTooltip: null,

        /**
         * CSS class used for terminals
         * @config {String}
         * @default
         */
        terminalCls: 'b-sch-terminal',

        /**
         * Where (at events borders) to display terminals
         * @config {String[]}
         * @default
         */
        terminalSides: ['left', 'top', 'right', 'bottom'],

        /**
         * Set to `false` to not allow creating dependencies
         * @config {Boolean}
         * @default
         */
        allowCreate: true
      };
    }

    //endregion

    //region Init & destroy

    construct(view, config) {
      super.construct(view, config);

      const me = this;

      me.view = view;
      me.eventName = view.scheduledEventName;

      me.view.on('readOnly', () => me.updateCreateListeners());

      me.updateCreateListeners();
    }

    doDestroy() {
      const me = this;

      me.listenersDetacher && me.listenersDetacher();
      me.abort();
      me.creationTooltip && me.creationTooltip.destroy();

      super.doDestroy();
    }

    updateCreateListeners() {
      const me = this;

      if (!me.view) {
        return;
      }

      me.listenersDetacher && me.listenersDetacher();
      me.listenersDetacher = null;

      if (me.isCreateAllowed) {
        me.listenersDetacher = me.view.on({
          [`${me.eventName}mouseenter`]: me.onTimeSpanMouseEnter,
          [`${me.eventName}mouseleave`]: me.onTimeSpanMouseLeave,
          thisObj: me
        });
      }
    }

    set allowCreate(value) {
      this._allowCreate = value;

      this.updateCreateListeners();
    }

    get allowCreate() {
      return this._allowCreate;
    }

    get isCreateAllowed() {
      return this.allowCreate && !this.view.readOnly && !this.disabled;
    }
    //endregion

    //region Events

    /**
     * Show terminals when mouse enters event/task element
     * @private
     */
    onTimeSpanMouseEnter(event) {
      const record = event[`${this.eventName}Record`],
        element = event[`${this.eventName}Element`];
      this.showTerminals(record, DomHelper.down(element, event.source.eventInnerSelector));
    }

    /**
     * Hide terminals when mouse leaves event/task element
     * @private
     */
    onTimeSpanMouseLeave(event) {
      const me = this,
        element = event[`${me.eventName}Element`];

      if (!me.creationData || !DomHelper.isDescendant(element, me.creationData.sourceTerminal.parentElement)) {
        me.hideTerminals(element);
      }
    }

    /**
     * Remove hover styling when mouse leaves terminal. Also hides terminals when mouse leaves one it and not creating a dependency.
     * @private
     */
    onTerminalMouseOut(event) {
      const me = this,
        el = DomHelper.up(event.target, me.view.eventSelector);

      if (
        !DomHelper.isDescendant(el, me.showingTerminalsFor) &&
        (!me.creationData || el !== me.creationData.sourceTerminal.parentElement)
      ) {
        me.hideTerminals(el);
        me.view.unhover(event);
      }
    }

    /**
     * Start creating a dependency when mouse is pressed over terminal
     * @private
     */
    onTerminalMouseDown(event) {
      // ignore non-left button clicks
      if (event.button === 0) {
        const me = this,
          view = me.view,
          timeAxisSubGridElement = view.timeAxisSubGridElement,
          terminal = event.target,
          element = terminal.parentElement.closest(view.eventSelector),
          viewBounds = Rectangle.from(view.element, document.body);

        event.preventDefault();
        event.stopPropagation();

        me.creationData = {
          source: view.resolveTimeSpanRecord(element),
          sourceTerminal: terminal,
          startPoint: Rectangle.from(terminal, timeAxisSubGridElement).center,
          startX: event.pageX - viewBounds.x + view.scrollLeft,
          startY: event.pageY - viewBounds.y + view.scrollTop,
          valid: false
        };
        if (view.resolveResourceRecord) {
          me.creationData.sourceResource = view.resolveResourceRecord(element);
        }

        me.mouseDetacher = EventHelper.on({
          mouseup: {
            element: document.body,
            handler: 'onMouseUp'
          },
          mousemove: {
            element: timeAxisSubGridElement,
            handler: 'onMouseMove'
          },
          thisObj: me
        });
      }
    }

    /**
     * Update connector line showing dependency between source and target when mouse moves. Also check if mouse is over a valid
     * target terminal
     * @private
     */
    onMouseMove(event) {
      const me = this,
        view = me.view,
        data = me.creationData,
        viewBounds = Rectangle.from(view.element, document.body),
        deltaX = event.pageX - viewBounds.x + view.scrollLeft - data.startX,
        deltaY = event.pageY - viewBounds.y + view.scrollTop - data.startY,
        length = Math.round(Math.sqrt(deltaX * deltaX + deltaY * deltaY)) - 3,
        angle = Math.atan2(deltaY, deltaX);

      if (!me.connector) {
        /**
         * Fired on the owning Scheduler/Gantt before a dependency creation drag operation starts. Return false to prevent it
         * @event beforeDependencyCreateDrag
         * @param {object} data
         */
        if (view.trigger('beforeDependencyCreateDrag', { data: me.creationData }) === false) {
          me.abort();
          return;
        }
        me.createConnector(data.startPoint.x, data.startPoint.y);
        /**
         * Fired on the owning Scheduler/Gantt when a dependency creation drag operation starts
         * @event dependencyCreateDragStart
         * @param {object} data
         */
        view.trigger('dependencyCreateDragStart', { data: me.creationData });
      }

      me.connector.style.width = `${length}px`;
      me.connector.style.transform = `rotate(${angle}rad)`;

      if (event.target.matches(`.${me.terminalCls}`) && event.target !== data.sourceTerminal) {
        data.targetTerminal = event.target;
        data.target = view.resolveTimeSpanRecord(event.target);
        if (view.resolveResourceRecord) {
          data.targetResource = view.resolveResourceRecord(event.target);
        }

        const fromSide = data.sourceTerminal.dataset.side,
          toSide = data.targetTerminal.dataset.side,
          updateValidity = (valid) => {
            data.valid = valid;
            event.target.classList.add(valid ? 'b-valid' : 'b-invalid');
            me.connector.classList.add(valid ? 'b-valid' : 'b-invalid');
          };

        let type;

        // NOTE: Top/Bottom sides are not taken into account due to
        //       scheduler doesn't check for type value anyway, whereas
        //       gantt will reject any other dependency types undefined in
        //       DependencyBaseModel.Type enumeration.
        switch (true) {
          case fromSide === 'left' && toSide === 'left':
            type = DependencyBaseModel.Type.StartToStart;
            break;
          case fromSide === 'left' && toSide === 'right':
            type = DependencyBaseModel.Type.StartToEnd;
            break;
          case fromSide === 'right' && toSide === 'left':
            type = DependencyBaseModel.Type.EndToStart;
            break;
          case fromSide === 'right' && toSide === 'right':
            type = DependencyBaseModel.Type.EndToEnd;
            break;
        }

        data.valid = view.dependencyStore.isValidDependency(data.source.id, data.target.id, type);

        // Promise is returned when using the engine
        if (data.valid instanceof Promise) {
          data.valid.then(updateValidity);
        } else {
          updateValidity(data.valid);
        }
      } else {
        data.target = data.targetTerminal = null;
        data.valid = false;
        me.connector.classList.remove('b-valid');
        me.connector.classList.remove('b-invalid');
      }

      me.lastMouseMoveEvent = event;
    }

    /**
     * Create a new dependency if mouse release over valid terminal. Hides connector
     * @private
     */
    onMouseUp(event) {
      const me = this,
        data = me.creationData,
        target = event.target;

      // TODO: should call finalize and allow user to hook it (as in EventDrag, EventResize)

      if (data.valid && target.matches(`.${me.terminalCls}`)) {
        data.targetTerminal = target;
        me.createDependency();
        data.valid = true;
        /**
         * Fired on the owning Scheduler/Gantt when a dependency drag creation operation succeeds
         * @event dependencyCreateDrop
         * @param {object} data
         */
        me.view.trigger('dependencyCreateDrop', { data });
      } else {
        data.valid = false;
      }

      /**
       * Fired on the owning Scheduler/Gantt after a dependency drag creation operation finished, no matter to outcome
       * @event afterDependencyCreateDrop
       * @param {object} data
       */
      me.view.trigger('afterDependencyCreateDrop', { data });

      me.abort();
    }

    /**
     * Aborts dependency creation, removes proxy and cleans up listeners
     */
    abort() {
      const me = this,
        { view, creationData } = me;

      // Remove terminals from source and target events.
      if (creationData) {
        const { source, sourceResource, target, targetResource } = creationData;

        if (source) {
          const el = view.getElementFromEventRecord(source, sourceResource);
          if (el) {
            me.hideTerminals(el);
          }
        }
        if (target) {
          const el = view.getElementFromEventRecord(target, targetResource);
          if (el) {
            me.hideTerminals(el);
          }
        }
      }

      me.creationData = null;

      me.mouseDetacher && me.mouseDetacher();

      me.removeConnector();
    }

    //endregion

    //region Connector

    /**
     * Creates a connector line that visualizes dependency source & target
     * @private
     */
    createConnector(x, y) {
      const me = this,
        view = me.view;

      me.connector = DomHelper.createElement({
        parent: view.timeAxisSubGridElement,
        className: `${me.baseCls}-connector`,
        style: `left:${x}px;top:${y}px`
      });

      view.element.classList.add('b-creating-dependency');

      if (me.showCreationTooltip) {
        if (me.creationTooltip) {
          me.creationTooltip.show();
        } else {
          me.creationTooltip = new Tooltip(
            Object.assign(
              {
                id: `${view.id}-dependency-drag-tip`,
                cls: 'b-sch-dependency-creation-tooltip',
                autoShow: true,
                anchorToTarget: false,
                trackMouse: true,
                // Do not constrain at all, want it to be able to go outside of the viewport to not get in the way
                constrainTo: null,
                onBeforeAlign: (e) => me.updateTipContent(e.source, me.creationData),
                header: {
                  dock: 'right'
                }
              },
              me.creationTooltip || {}
            )
          );
        }
      }
      view.scrollManager.startMonitoring({
        element: view.timeAxisSubGridElement,
        callback: () => me.creationData && me.lastMouseMoveEvent && me.onMouseMove(me.lastMouseMoveEvent),
        thisObj: me
      });
    }

    /**
     * Remove connector
     * @private
     */
    removeConnector(callback) {
      const me = this,
        { connector, view } = me;

      if (connector) {
        connector.classList.add('b-removing');
        connector.style.width = '0';
        me.setTimeout(() => {
          connector.remove();
          me.connector = null;
          if (callback) {
            callback.call(me);
          }
        }, 200);
      }

      view.element.classList.remove('b-creating-dependency');
      me.creationTooltip && me.creationTooltip.hide();

      view.scrollManager.stopMonitoring(view.timeAxisSubGridElement);
    }

    //endregion

    //region Terminals

    /**
     * Show terminals for specified event at sides defined in #terminalSides.
     * @param {Scheduler.model.TimeSpan} timeSpanRecord Event/task to show terminals for
     * @param {HTMLElement} element Event/task element
     */
    showTerminals(timeSpanRecord, element) {
      const me = this;

      if (!me.isCreateAllowed) {
        return;
      }

      const cls = me.terminalCls,
        terminalsVisibleCls = `${cls}s-visible`;

      // We operate on the event bar, not the wrap
      element = DomHelper.down(element, me.view.eventInnerSelector);

      // bail out if terminals already shown or if view is readonly
      // do not draw new terminals if we are resizing event
      if (
        element.classList.contains(terminalsVisibleCls) ||
        this.view.element.classList.contains('b-resizing-event') ||
        me.view.readOnly
      )
        return;

      // create terminals for desired sides
      me.terminalSides.forEach((side) => {
        const terminal = DomHelper.createElement({
          parent: element,
          className: `${cls} ${cls}-${side}`,
          dataset: {
            side,
            feature: true
          }
        });

        terminal.detacher = EventHelper.on({
          element: terminal,
          mouseout: 'onTerminalMouseOut',
          mousedown: {
            handler: 'onTerminalMouseDown',
            capture: true
          },
          thisObj: me
        });
      });

      element.classList.add(terminalsVisibleCls);
      timeSpanRecord.cls.add(terminalsVisibleCls);

      me.showingTerminalsFor = element;
    }

    /**
     * Hide terminals for specified event
     * @param {HTMLElement} eventElement Event element
     */
    hideTerminals(eventElement) {
      // remove all terminals
      const me = this,
        eventParams = me.client.getTimeSpanMouseEventParams(eventElement),
        timeSpanRecord = eventParams[`${this.eventName}Record`],
        terminalsVisibleCls = `${me.terminalCls}s-visible`;

      DomHelper.forEachSelector(eventElement, `.${me.terminalCls}`, (terminal) => {
        terminal.detacher && terminal.detacher();
        terminal.remove();
      });

      DomHelper.down(eventElement, me.view.eventInnerSelector).classList.remove(terminalsVisibleCls);
      timeSpanRecord.cls.remove(terminalsVisibleCls);

      me.showingTerminalsFor = null;
    }

    //endregion

    //region Dependency creation

    /**
     * Create a new dependency from source terminal to target terminal
     * @internal
     */
    createDependency() {
      const me = this,
        data = me.creationData,
        source = data.source,
        target = data.target,
        fromSide = data.sourceTerminal.dataset.side,
        toSide = data.targetTerminal.dataset.side,
        type = (fromSide === 'left' ? 0 : 2) + (toSide === 'right' ? 1 : 0);

      me.store.add({
        from: source.id,
        to: target.id,
        type,
        fromSide,
        toSide
      });
    }

    //endregion

    //region Tooltip

    /**
     * Update dependency creation tooltip
     * @private
     */
    updateTipContent(tip, data) {
      const me = this;
      let { valid } = data;

      Object.assign(data, {
        fromText: data.source.name,
        toText: data.target ? data.target.name : '',
        fromSide: data.sourceTerminal.dataset.side,
        toSide: data.targetTerminal ? data.targetTerminal.dataset.side : ''
      });

      let tipTitleIconClsSuffix, tipTitleText;

      // Promise, when using engine
      if (valid instanceof Promise) {
        tip.element.classList.remove('b-invalid');
        tip.element.classList.add('b-checking');
        tipTitleIconClsSuffix = 'checking';
        tipTitleText = me.L('Checking');

        valid.then((valid) => {
          data.valid = valid;
          if (!tip.isDestroyed) {
            me.updateTipContent(tip, data);
          }
        });
      }
      // Valid
      else if (valid === true) {
        tip.element.classList.remove('b-invalid');
        tip.element.classList.remove('b-checking');
        tipTitleIconClsSuffix = 'valid';
        tipTitleText = me.L('valid');
      }
      // Invalid
      else {
        tip.element.classList.remove('b-checking');
        tip.element.classList.add('b-invalid');
        tipTitleIconClsSuffix = 'invalid';
        tipTitleText = me.L('invalid');
      }

      tip.titleElement.innerHTML = `<i class="b-icon b-icon-${tipTitleIconClsSuffix}"></i>${tipTitleText}`;
      tip.html = `<table class="b-sch-dependency-creation-tooltip">
                        <tr><td>${me.L('from')}: </td><td>${data.fromText}</td><td><div class="b-sch-box b-${
        data.fromSide
      }"></div></td></tr>
                        <tr><td>${me.L('to')}: </td><td>${data.toText}</td><td><div class="b-sch-box b-${
        data.toSide
      }"></div></td></tr>
                    </table>`;
    }

    //endregion
  };

/**
 * @module Common/helper/WalkHelper
 */

/**
 * Tree walking helper
 * @internal
 */
class WalkHelper {
  /**
   * Pre-walks any hierarchical data structure
   *
   * @param data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static preWalk(data, childrenFn, fn) {
    let walkStack = [data],
      node,
      children;

    while (walkStack.length) {
      node = walkStack.pop();

      fn(node);

      children = childrenFn(node);

      if (children) {
        walkStack = walkStack.concat(children.slice().reverse());
      }
    }
  }

  /**
   * Pre-walk unordered.
   *
   * Like {@link #function-preWalk-static preWalk} but doesn't reverses children before walk,
   * thus children will be walked last child first - first child last
   *
   * @param data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static preWalkUnordered(data, childrenFn, fn) {
    let walkStack = [data],
      node,
      children;

    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];

      fn(node);

      children = childrenFn(node);

      if (children) {
        walkStack.splice(walkStack.length - 1, 1, ...children);
      } else {
        walkStack.length = walkStack.length - 1;
      }
    }
  }

  /**
   * Post-walks any hierarchical data structure
   *
   * @param data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static postWalk(data, childrenFn, fn) {
    let visited = new Map(),
      walkStack = [data],
      node,
      children;

    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];

      if (visited.has(node)) {
        fn(node);
        walkStack.pop();
      } else {
        children = childrenFn(node);

        if (children) {
          walkStack = walkStack.concat(children.slice().reverse());
        }

        visited.set(node, node);
      }
    }
  }

  /**
   * Pre/Post-walks any hierarchical data structure calling inFn each node when it walks in,
   * and outFn when it walks out.
   *
   * @param data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} inFn  Function to call on each entry upon enter
   * @param {Function} outFn Function to call on each entry upon exit
   */
  static prePostWalk(data, childrenFn, inFn, outFn) {
    let visited = new Map(),
      walkStack = [data],
      node,
      children;

    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];

      if (visited.has(node)) {
        outFn(node);
        walkStack.pop();
      } else {
        inFn(node);

        children = childrenFn(node);

        if (children) {
          walkStack = walkStack.concat(children.slice().reverse());
        }

        visited.set(node, node);
      }
    }
  }
}
WalkHelper._$name = 'WalkHelper';

/**
 * @module Scheduler/util/RectangularPathFinder
 */

/**
 * Class which finds rectangular path, i.e. path with 90 degrees turns, between two boxes.
 * @private
 */
class RectangularPathFinder extends Base {
  static get defaultConfig() {
    return {
      /**
       * Default start connection side: 'left', 'right', 'top', 'bottom'
       * @config {String|Boolean}
       * @default
       */
      startSide: 'right',

      /**
       * Default start arrow size in pixels
       * @config {Number}
       * @default
       */
      startArrowSize: 0,

      /**
       * Default start arrow staff size in pixels
       * @config {Number}
       * @default
       */
      startArrowMargin: 12,

      /**
       * Default starting connection point shift from box's arrow pointing side middle point
       * @config {Number}
       * @default
       */
      startShift: 0,

      /**
       * Default end arrow pointing direction, possible values are: 'left', 'right', 'top', 'bottom'
       * @config {String|Boolean}
       * @default
       */
      endSide: 'left',

      /**
       * Default end arrow size in pixels
       * @config {Number}
       * @default
       */
      endArrowSize: 0,

      /**
       * Default end arrow staff size in pixels
       * @config {Number}
       * @default
       */
      endArrowMargin: 12,

      /**
       * Default ending connection point shift from box's arrow pointing side middle point
       * @config {Number}
       * @default
       */
      endShift: 0,

      /**
       * Start / End box vertical margin, the amount of pixels from top and bottom line of a box where drawing
       * is prohibited
       * @config {Number}
       * @default
       */
      verticalMargin: 2,

      /**
       * Start / End box horizontal margin, the amount of pixels from left and right line of a box where drawing
       * @config {Number}
       * @default
       */
      horizontalMargin: 5,

      /**
       * Other rectangular areas (obstacles) to search path through
       * @config {Object[]}
       * @default
       */
      otherBoxes: null
    };
  }

  /**
   * Returns list of horizontal and vertical segments connecting two boxes
   * <pre>
   *    |    | |  |    |       |
   *  --+----+----+----*-------*---
   *  --+=>Start  +----*-------*--
   *  --+----+----+----*-------*--
   *    |    | |  |    |       |
   *    |    | |  |    |       |
   *  --*----*-+-------+-------+--
   *  --*----*-+         End <=+--
   *  --*----*-+-------+-------+--
   *    |    | |  |    |       |
   * </pre>
   * Path goes by lines (-=) and turns at intersections (+), boxes depicted are adjusted by horizontal/vertical
   * margin and arrow margin, original boxes are smaller (path can't go at original box borders). Algorithm finds
   * the shortest path with minimum amount of turns. In short it's mix of "Lee" and "Dijkstra pathfinding"
   * with turns amount taken into account for distance calculation.
   *
   * The algorithm is not very performant though, it's O(N^2), where N is amount of
   * points in the grid, but since the maximum amount of points in the grid might be up to 34 (not 36 since
   * two box middle points are not permitted) that might be ok for now.
   *
   * @param {Object} lineDef An object containing any of the class configuration option overrides as well
   *                         as `startBox`, `endBox`, `startHorizontalMargin`, `startVerticalMargin`,
   *                         `endHorizontalMargin`, `endVerticalMargin` properties
   * @param {Object} lineDef.startBox An object containing `start`, `end`, `top`, `bottom` properties
   * @param {Object} lineDef.endBox   An object containing `start`, `end`, `top`, `bottom` properties
   * @param {Number} lineDef.startHorizontalMargin Horizontal margin override for start box
   * @param {Number} lineDef.startVerticalMargin   Vertical margin override for start box
   * @param {Number} lineDef.endHorizontalMargin   Horizontal margin override for end box
   * @param {Number} lineDef.endVerticalMargin     Vertical margin override for end box
   *
   *
   * @return {Object[]|Boolean} Array of line segments or false if path cannot be found
   * @return {Number} return.x1
   * @return {Number} return.y1
   * @return {Number} return.x2
   * @return {Number} return.y2
   */
  //
  //@ignore
  //@privateparam {Function[]|Function} noPathFallbackFn
  //     A function or array of functions which will be tried in case a path can't be found
  //     Each function will be given a line definition it might try to adjust somehow and return.
  //     The new line definition returned will be tried to find a path.
  //     If a function returns false, then next function will be called if any.
  //
  findPath(lineDef, noPathFallbackFn) {
    let me = this,
      lineDefFull,
      startBox,
      endBox,
      startShift,
      endShift,
      startSide,
      endSide,
      startArrowSize,
      endArrowSize,
      startArrowMargin,
      endArrowMargin,
      horizontalMargin,
      verticalMargin,
      startHorizontalMargin,
      startVerticalMargin,
      endHorizontalMargin,
      endVerticalMargin,
      otherHorizontalMargin,
      otherVerticalMargin,
      otherBoxes,
      connStartPoint,
      connEndPoint,
      pathStartPoint,
      pathEndPoint,
      gridStartPoint,
      gridEndPoint,
      startGridBox,
      endGridBox,
      grid,
      path,
      tryNum;

    if (noPathFallbackFn && !Array.isArray(noPathFallbackFn)) {
      noPathFallbackFn = [noPathFallbackFn];
    }

    for (tryNum = 0; lineDef && !path; ) {
      lineDefFull = Object.assign(me.config, lineDef);

      startBox = lineDefFull.startBox;
      endBox = lineDefFull.endBox;
      startShift = lineDefFull.startShift;
      endShift = lineDefFull.endShift;
      startSide = lineDefFull.startSide;
      endSide = lineDefFull.endSide;
      startArrowSize = lineDefFull.startArrowSize;
      endArrowSize = lineDefFull.endArrowSize;
      startArrowMargin = lineDefFull.startArrowMargin;
      endArrowMargin = lineDefFull.endArrowMargin;
      horizontalMargin = lineDefFull.horizontalMargin;
      verticalMargin = lineDefFull.verticalMargin;
      startHorizontalMargin = lineDefFull.hasOwnProperty('startHorizontalMargin')
        ? lineDefFull.startHorizontalMargin
        : horizontalMargin;
      startVerticalMargin = lineDefFull.hasOwnProperty('startVerticalMargin')
        ? lineDefFull.startVerticalMargin
        : verticalMargin;
      endHorizontalMargin = lineDefFull.hasOwnProperty('endHorizontalMargin')
        ? lineDefFull.endHorizontalMargin
        : horizontalMargin;
      endVerticalMargin = lineDefFull.hasOwnProperty('endVerticalMargin')
        ? lineDefFull.endVerticalMargin
        : verticalMargin;
      otherHorizontalMargin = lineDefFull.hasOwnProperty('otherHorizontalMargin')
        ? lineDefFull.otherHorizontalMargin
        : horizontalMargin;
      otherVerticalMargin = lineDefFull.hasOwnProperty('otherVerticalMargin')
        ? lineDefFull.otherVerticalMargin
        : verticalMargin;
      otherBoxes = lineDefFull.otherBoxes;

      startSide = me.normalizeSide(startSide);
      endSide = me.normalizeSide(endSide);

      connStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startBox, startSide, startShift);
      connEndPoint = me.getConnectionCoordinatesFromBoxSideShift(endBox, endSide, endShift);

      startGridBox = me.calcGridBaseBoxFromBoxAndDrawParams(
        startBox,
        startSide,
        startArrowSize,
        startArrowMargin,
        startHorizontalMargin,
        startVerticalMargin
      );
      endGridBox = me.calcGridBaseBoxFromBoxAndDrawParams(
        endBox,
        endSide,
        endArrowSize,
        endArrowMargin,
        endHorizontalMargin,
        endVerticalMargin
      );
      otherBoxes =
        otherBoxes &&
        otherBoxes.map((box) =>
          me.calcGridBaseBoxFromBoxAndDrawParams(box, false, 0, 0, otherHorizontalMargin, otherVerticalMargin)
        );
      pathStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startGridBox, startSide, startShift);
      pathEndPoint = me.getConnectionCoordinatesFromBoxSideShift(endGridBox, endSide, endShift);
      grid = me.buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherBoxes);
      gridStartPoint = me.convertDecartPointToGridPoint(grid, pathStartPoint);
      gridEndPoint = me.convertDecartPointToGridPoint(grid, pathEndPoint);
      path = me.findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide);

      // Loop if
      // - path is still not found
      // - have no next line definition (which should be obtained from call to one of the functions from noPathFallbackFn array
      // - have noPathFallBackFn array
      // - current try number is less then noPathFallBackFn array length
      for (lineDef = false; !path && !lineDef && noPathFallbackFn && tryNum < noPathFallbackFn.length; tryNum++) {
        lineDef = noPathFallbackFn[tryNum](lineDefFull);
      }
    }

    if (path) {
      path = me.prependPathWithArrowStaffSegment(path, connStartPoint, startArrowSize, startSide);
      path = me.appendPathWithArrowStaffSegment(path, connEndPoint, endArrowSize, endSide);
      path = me.optimizePath(path);
    }

    return path;
  }

  getConnectionCoordinatesFromBoxSideShift(box, side, shift) {
    let coords;

    switch (side) {
      case 'left':
        coords = {
          x: box.start,
          y: (box.top + box.bottom) / 2 + shift
        };
        break;
      case 'right':
        coords = {
          x: box.end,
          y: (box.top + box.bottom) / 2 + shift
        };
        break;
      case 'top':
        coords = {
          x: (box.start + box.end) / 2 + shift,
          y: box.top
        };
        break;
      case 'bottom':
        coords = {
          x: (box.start + box.end) / 2 + shift,
          y: box.bottom
        };
        break;
    }

    return coords;
  }

  calcGridBaseBoxFromBoxAndDrawParams(box, side, arrowSize, arrowMargin, horizontalMargin, verticalMargin) {
    let gridBox;

    switch (side) {
      case 'left':
        gridBox = {
          start: box.start - Math.max(arrowSize + arrowMargin, horizontalMargin),
          end: box.end + horizontalMargin,
          top: box.top - verticalMargin,
          bottom: box.bottom + verticalMargin
        };
        break;
      case 'right':
        gridBox = {
          start: box.start - horizontalMargin,
          end: box.end + Math.max(arrowSize + arrowMargin, horizontalMargin),
          top: box.top - verticalMargin,
          bottom: box.bottom + verticalMargin
        };
        break;
      case 'top':
        gridBox = {
          start: box.start - horizontalMargin,
          end: box.end + horizontalMargin,
          top: box.top - Math.max(arrowSize + arrowMargin, verticalMargin),
          bottom: box.bottom + verticalMargin
        };
        break;
      case 'bottom':
        gridBox = {
          start: box.start - horizontalMargin,
          end: box.end + horizontalMargin,
          top: box.top - verticalMargin,
          bottom: box.bottom + Math.max(arrowSize + arrowMargin, verticalMargin)
        };
        break;
      default:
        gridBox = {
          start: box.start - horizontalMargin,
          end: box.end + horizontalMargin,
          top: box.top - verticalMargin,
          bottom: box.bottom + verticalMargin
        };
    }

    return gridBox;
  }

  buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherGridBoxes) {
    let xs,
      ys,
      y,
      x,
      ix,
      iy,
      xslen,
      yslen,
      ib,
      blen,
      box,
      permitted,
      point,
      points = {},
      linearPoints = [];

    xs = [
      startGridBox.start,
      startSide === 'left' || startSide === 'right' ? (startGridBox.start + startGridBox.end) / 2 : pathStartPoint.x,
      startGridBox.end,
      endGridBox.start,
      endSide === 'left' || endSide === 'right' ? (endGridBox.start + endGridBox.end) / 2 : pathEndPoint.x,
      endGridBox.end
    ];
    ys = [
      startGridBox.top,
      startSide === 'top' || startSide === 'bottom' ? (startGridBox.top + startGridBox.bottom) / 2 : pathStartPoint.y,
      startGridBox.bottom,
      endGridBox.top,
      endSide === 'top' || endSide === 'bottom' ? (endGridBox.top + endGridBox.bottom) / 2 : pathEndPoint.y,
      endGridBox.bottom
    ];

    if (otherGridBoxes) {
      otherGridBoxes.forEach((box) => {
        xs.push(box.start, (box.start + box.end) / 2, box.end);
        ys.push(box.top, (box.top + box.bottom) / 2, box.bottom);
      });
    }

    xs = [...new Set(xs.sort((a, b) => a - b))];
    ys = [...new Set(ys.sort((a, b) => a - b))];

    // TODO: fastest way to make unique, Set is slower
    // for ( let i = 0, I = array.length; i < I; i++ ) {
    //     if ( ~array.indexOf( array[ i ], i + 1 ) ) {
    //         array.splice( i, 1 );
    //         i--;
    //         I--;
    //     }
    // }

    for (iy = 0, yslen = ys.length; iy < yslen; ++iy) {
      points[iy] = points[iy] || {};
      y = ys[iy];
      for (ix = 0, xslen = xs.length; ix < xslen; ++ix) {
        x = xs[ix];

        permitted =
          (x <= startGridBox.start || x >= startGridBox.end || y <= startGridBox.top || y >= startGridBox.bottom) &&
          (x <= endGridBox.start || x >= endGridBox.end || y <= endGridBox.top || y >= endGridBox.bottom);

        if (otherGridBoxes) {
          for (ib = 0, blen = otherGridBoxes.length; permitted && ib < blen; ++ib) {
            box = otherGridBoxes[ib];
            permitted =
              x <= box.start ||
              x >= box.end ||
              y <= box.top ||
              y >= box.bottom ||
              // Allow point if it is a path start/end even if point is inside any box
              (x === pathStartPoint.x && y === pathStartPoint.y) ||
              (x === pathEndPoint.x && y === pathEndPoint.y);
          }
        }

        point = {
          distance: Math.pow(2, 53) - 1, // Number.MAX_SAFE_INTEGER (not supported in Opera/IE)
          permitted: permitted,
          x: x,
          y: y,
          ix: ix,
          iy: iy
        };

        points[iy][ix] = point;
        linearPoints.push(point);
      }
    }

    return {
      width: xs.length,
      height: ys.length,
      xs: xs,
      ys: ys,
      points: points,
      linearPoints: linearPoints
    };
  }

  convertDecartPointToGridPoint(grid, point) {
    let x = grid.xs.indexOf(point.x),
      y = grid.ys.indexOf(point.y);

    return grid.points[y][x];
  }

  findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide) {
    let me = this,
      path = false;

    if (gridStartPoint.permitted && gridEndPoint.permitted) {
      grid = me.waveForward(grid, gridStartPoint, 0);
      path = me.collectPath(grid, gridEndPoint, endSide);
    }

    return path;
  }

  // Returns neighbors from Von Neiman ambit (see Lee pathfinding algorithm description)
  getGridPointNeighbors(grid, gridPoint, predicateFn) {
    let ix = gridPoint.ix,
      iy = gridPoint.iy,
      result = [],
      neighbor;

    // NOTE:
    // It's important to push bottom neighbors first since this method is used
    // in collectPath(), which reversively collects path from end to start node
    // and if bottom neighbors are pushed first in result array then collectPath()
    // will produce a line which is more suitable (pleasant looking) for our purposes.
    if (iy < grid.height - 1) {
      neighbor = grid.points[iy + 1][ix];
      (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
    }
    if (iy > 0) {
      neighbor = grid.points[iy - 1][ix];
      (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
    }
    if (ix < grid.width - 1) {
      neighbor = grid.points[iy][ix + 1];
      (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
    }
    if (ix > 0) {
      neighbor = grid.points[iy][ix - 1];
      (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
    }

    return result;
  }

  waveForward(grid, gridStartPoint, distance) {
    const me = this;

    // I use the WalkHelper here because a point on a grid and it's neighbors might be considered as a hierarchy.
    // The point is the parent node, and it's neighbors are the children nodes. Thus the grid here is hierarchical
    // data structure which can be walked. WalkHelper walks non-recursivelly which is exactly what I need as well.
    WalkHelper.preWalkUnordered(
      // Walk starting point - a node is a grid point and it's distance from the starting point
      [gridStartPoint, distance],
      // Children query function
      // NOTE: It's important to fix neighbor distance first, before waving to a neighbor, otherwise waving might
      //       get through a neighbor point setting it's distance to a value more then (distance + 1) whereas we,
      //       at the children quering moment in time, already know that the possibly optimal distance is (distance + 1)
      ([point, distance]) =>
        me
          .getGridPointNeighbors(
            grid,
            point,
            (neighborPoint) => neighborPoint.permitted && neighborPoint.distance > distance + 1
          )
          .map(
            (neighborPoint) => [neighborPoint, distance + 1] // Neighbor distance fixation
          ),
      // Walk step iterator function
      ([point, distance]) => (point.distance = distance) // Neighbor distance applying
    );

    return grid;
  }

  collectPath(grid, gridEndPoint, endSide) {
    let me = this,
      pathFound = true,
      neighbors,
      lowestDistanceNeighbor,
      xDiff,
      yDiff,
      path = [];

    while (pathFound && gridEndPoint.distance) {
      neighbors = me.getGridPointNeighbors(
        grid,
        gridEndPoint,
        (point) => point.permitted && point.distance == gridEndPoint.distance - 1
      );

      pathFound = neighbors.length > 0;

      if (pathFound) {
        // Prefer turnless neighbors first
        neighbors = neighbors.sort((a, b) => {
          let xDiff, yDiff;

          xDiff = a.ix - gridEndPoint.ix;
          yDiff = a.iy - gridEndPoint.iy;

          let resultA =
            ((endSide === 'left' || endSide === 'right') && yDiff === 0) ||
            ((endSide === 'top' || endSide === 'bottom') && xDiff === 0)
              ? -1
              : 1;

          xDiff = b.ix - gridEndPoint.ix;
          yDiff = b.iy - gridEndPoint.iy;

          let resultB =
            ((endSide === 'left' || endSide === 'right') && yDiff === 0) ||
            ((endSide === 'top' || endSide === 'bottom') && xDiff === 0)
              ? -1
              : 1;

          if (resultA > resultB) return 1;
          if (resultA < resultB) return -1;
          // apply additional sorting to be sure to pick bottom path in IE
          if (resultA === resultB) return a.y > b.y ? -1 : 1;
        });

        lowestDistanceNeighbor = neighbors[0];

        path.push({
          x1: lowestDistanceNeighbor.x,
          y1: lowestDistanceNeighbor.y,
          x2: gridEndPoint.x,
          y2: gridEndPoint.y
        });

        // Detecting new side, either xDiff or yDiff must be 0 (but not both)
        xDiff = lowestDistanceNeighbor.ix - gridEndPoint.ix;
        yDiff = lowestDistanceNeighbor.iy - gridEndPoint.iy;

        switch (true) {
          case !yDiff && xDiff > 0:
            endSide = 'left';
            break;
          case !yDiff && xDiff < 0:
            endSide = 'right';
            break;
          case !xDiff && yDiff > 0:
            endSide = 'top';
            break;
          case !xDiff && yDiff < 0:
            endSide = 'bottom';
            break;
        }

        gridEndPoint = lowestDistanceNeighbor;
      }
    }

    return (pathFound && path.reverse()) || false;
  }

  prependPathWithArrowStaffSegment(path, connStartPoint, startArrowSize, startSide) {
    let prependSegment, firstSegment;

    if (path.length > 0) {
      firstSegment = path[0];
      prependSegment = {
        x2: firstSegment.x1,
        y2: firstSegment.y1
      };

      switch (startSide) {
        case 'left':
          prependSegment.x1 = connStartPoint.x - startArrowSize;
          prependSegment.y1 = firstSegment.y1;
          break;
        case 'right':
          prependSegment.x1 = connStartPoint.x + startArrowSize;
          prependSegment.y1 = firstSegment.y1;
          break;
        case 'top':
          prependSegment.x1 = firstSegment.x1;
          prependSegment.y1 = connStartPoint.y - startArrowSize;
          break;
        case 'bottom':
          prependSegment.x1 = firstSegment.x1;
          prependSegment.y1 = connStartPoint.y + startArrowSize;
          break;
      }

      path.unshift(prependSegment);
    }

    return path;
  }

  appendPathWithArrowStaffSegment(path, connEndPoint, endArrowSize, endSide) {
    let appendSegment, lastSegment;

    if (path.length > 0) {
      lastSegment = path[path.length - 1];
      appendSegment = {
        x1: lastSegment.x2,
        y1: lastSegment.y2
      };

      switch (endSide) {
        case 'left':
          appendSegment.x2 = connEndPoint.x - endArrowSize;
          appendSegment.y2 = lastSegment.y2;
          break;
        case 'right':
          appendSegment.x2 = connEndPoint.x + endArrowSize;
          appendSegment.y2 = lastSegment.y2;
          break;
        case 'top':
          appendSegment.x2 = lastSegment.x2;
          appendSegment.y2 = connEndPoint.y - endArrowSize;
          break;
        case 'bottom':
          appendSegment.x2 = lastSegment.x2;
          appendSegment.y2 = connEndPoint.y + endArrowSize;
          break;
      }

      path.push(appendSegment);
    }

    return path;
  }

  optimizePath(path) {
    let optPath = [],
      prevSegment,
      curSegment;

    if (path.length > 0) {
      prevSegment = path.shift();
      optPath.push(prevSegment);

      while (path.length > 0) {
        curSegment = path.shift();

        // both segments are equal
        if (
          prevSegment.x1 == curSegment.x1 &&
          prevSegment.y1 == curSegment.y1 &&
          prevSegment.x2 == curSegment.x2 &&
          prevSegment.y2 == curSegment.y2
        ) {
          prevSegment = curSegment;
        }
        // both segments are horizontal
        else if (prevSegment.y1 - prevSegment.y2 === 0 && curSegment.y1 - curSegment.y2 === 0) {
          prevSegment.x2 = curSegment.x2;
        }
        // both segments are vertical
        else if (prevSegment.x1 - prevSegment.x2 === 0 && curSegment.x1 - curSegment.x2 === 0) {
          prevSegment.y2 = curSegment.y2;
        }
        // segments has different orientation (path turn)
        else {
          optPath.push(curSegment);
          prevSegment = curSegment;
        }
      }
    }

    return optPath;
  }

  normalizeSide(side) {
    return RectangularPathFinder.sideToSide[side] || side;
  }

  static get sideToSide() {
    return {
      l: 'left',
      r: 'right',
      t: 'top',
      b: 'bottom'
    };
  }
}

RectangularPathFinder._$name = 'RectangularPathFinder';

/**
 * @module Scheduler/feature/Dependencies
 */

const fromBoxSide = ['left', 'left', 'right', 'right'],
  toBoxSide = ['left', 'right', 'left', 'right'];

/**
 * Feature that draws dependencies between events Uses a {@link Scheduler.data.DependencyStore DependencyStore} to determine which dependencies to draw, if
 * none is defined one will be created automatically. Dependencies can also be specified as Scheduler#dependencies, see
 * example below.
 *
 * This feature is **disabled** by default. It is **not** supported in vertical mode.
 *
 * @mixes Scheduler/feature/mixin/DependencyCreation
 *
 * @extends Common/mixin/InstancePlugin
 * @demo dependencies
 * @externalexample scheduler/Dependencies.js
 */
class Dependencies extends DependencyCreation(Delayable(InstancePlugin)) {
  /**
   * Fired when dependencies are rendered
   * @event dependenciesDrawn
   * @param {Boolean} [partial] Optional event parameter. `true` when subset of dependencies is repainted, omitted
   * when all lines were repainted.
   */

  //region Config

  static get defaultConfig() {
    return {
      /**
       * Path finder instance configuration
       * @config {Object}
       */
      pathFinderConfig: null,

      /**
       * The CSS class to add to a dependency line when hovering over it
       * @config {String}
       * @default
       * @private
       */
      overCls: 'b-sch-dependency-over',

      /**
       * The CSS class applied to dependency lines
       * @config {String}
       * @default
       * @private
       */
      baseCls: 'b-sch-dependency',

      /**
       * Store that holds dependencies (using DependencyModel or subclass thereof). A store will be automatically
       * created if none is specified
       * @config {Scheduler.data.DependencyStore}
       */
      store: false, // Force invocation of setter, null bypasses the setter

      /**
       * Dependency definitions (data to DependencyModels). Will be added to store. Can also be specified on
       * Scheduler for convenience
       * @config {DependencyModel[]|Object[]}
       */
      dependencies: null,

      highlightDependenciesOnEventHover: false,

      /**
       * Set to true to show a tooltip when hovering a dependency line
       * @config {Boolean}
       */
      showTooltip: true,

      /**
       * A tooltip config object that will be applied to the dependency hover tooltip. Can be used to for example
       * customize delay
       * @config {Object}
       */
      tooltip: null,

      bufferSize: 50,

      cacheGridSize: {
        x: 500,
        index: 25
      },

      drawnDependencies: [],
      drawnLines: [],
      dependenciesToRefresh: new Map(),

      storeClass: DependencyStore
    };
  }

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: [
        'render',
        'renderContents',
        'onElementClick',
        'onElementDblClick',
        'onElementMouseOver',
        'onElementMouseOut'
      ],
      assign: ['getElementForDependency', 'getDependencyForElement']
    };
  }

  //endregion

  //region Init & destroy

  construct(client, config = {}) {
    const me = this;

    me.scheduler = client;

    if (client.isVertical) {
      throw new Error('Dependencies feature is not supported in vertical mode');
    }

    // Many things may schedule a draw. Ensure it only happens once, on the next frame.
    // And Ensure it really is on the *next* frame after invocation by passing
    // the cancelOutstanding flag.
    me.doScheduleDraw = me.createOnFrame('draw', [], me, true);

    // use scheduler's/gantt's DependencyStore if available
    if (client.dependencyStore) {
      config.store = client.dependencyStore;
    }

    super.construct(client, config);

    client.store.on({
      refresh: me.onRowStoreRefresh,
      thisObj: me
    });

    client.rowManager.on({
      // TODO: check if these are needed, might be enough with chained renderContents
      translaterow: me.onTranslateRow,
      refresh: me.onRowsRefresh,
      rerender: me.onRowsRerender,
      changetotalheight: me.onChangeTotalHeight,
      thisObj: me
    });

    // dependencies are drawn on scroll, both horizontal and vertical
    client.on({
      horizontalscroll: me.onHorizontalScroll,
      svgcanvascreated: me.createMarkers,
      togglenode: me.onToggleNode,
      scroll: me.onVerticalScroll,
      //            eventlayout      : me.onEventLayout,
      timelineviewportresize: me.onViewportResize,
      thisObj: me
    });

    me.bindEventStoreListeners();

    me.pathFinder = new RectangularPathFinder(me.pathFinderConfig);
    delete me.pathFinderConfig;

    me.lineDefAdjusters = me.createLineDefAdjusters();

    // expose getter/setter for dependencies on scheduler
    Object.defineProperty(client, 'dependencies', {
      configurable: true,
      get: () => me.store.records,
      set: (dependencies) => (me.store.data = dependencies)
    });
  }

  set store(store) {
    const me = this,
      { client } = me;

    if (store !== me._store) {
      // Create new store if none assigned through config
      me._store = store || (store = new this.storeClass());

      me._detachStoreEvents && me._detachStoreEvents();

      if (!client.dependencyStore) {
        client._dependencyStore = store;
      }

      if (store) {
        // dependencies can be set on scheduler or feature, for convenience
        if (client.dependencies) {
          store.add(client.dependencies);
          delete client.dependencies;
        }

        if (me.dependencies) {
          store.add(me.dependencies);
          delete me.dependencies;
        }

        // used to store meta per scheduler on models, in case they are used in multiple schedulers
        store.metaMapId = client.id;

        // Ask the client for its eventStore after we set our store.
        // Its eventStore getter attempts to read our store.
        store.eventStore = client.eventStore;

        me._detachStoreEvents = store.on({
          change: me.onDependencyChange,
          eventstorechange: me.bindEventStoreListeners,
          detachable: true,
          thisObj: me
        });
      }
    }
  }

  get store() {
    return this._store;
  }

  doDestroy() {
    this.tooltip && this.tooltip.destroy();

    super.doDestroy();
  }

  createMarkers() {
    const me = this,
      svg = me.client.svgCanvas,
      endMarker = (me.endMarker = me.initMarkerElement('arrowEnd', '8', 'M0,0 L0,6 L9,3 z'));

    // Edge and IE11 do not support required svg 2.0 orient value
    if (BrowserHelper.isEdge || BrowserHelper.isIE11) {
      const startMarker = (me.startMarker = me.initMarkerElement('arrowStart', '1', 'M0,3 L9,6 L9,0 z'));

      svg.appendChild(startMarker);
    } else {
      endMarker.setAttribute('orient', 'auto-start-reverse');
    }

    svg.appendChild(endMarker);
  }

  /**
   * Creates SVG marker element (arrow) which is used for all dependency lines
   * @private
   * @param {String} id Id of the marker element
   * @param {String} refX
   * @param {String} arrowPath Path defining arrow
   */
  initMarkerElement(id, refX, arrowPath) {
    return DomHelper.createElement({
      id,
      tag: 'marker',
      ns: 'http://www.w3.org/2000/svg',
      markerHeight: 9,
      markerWidth: 9,
      refX,
      refY: 3,
      viewBox: '0 0 9 6',
      orient: 'auto',
      markerUnits: 'userSpaceOnUse',
      children: [
        {
          tag: 'path',
          ns: 'http://www.w3.org/2000/svg',
          d: arrowPath
        }
      ]
    });
  }

  /**
   * Returns an array of functions used to alter path config when no path found.
   * It first tries to shrink arrow margins and secondly hides arrows entirely
   * @private
   * @returns {Function[]}
   */
  createLineDefAdjusters() {
    const client = this.client;

    function shrinkArrowMargins(lineDef) {
      let adjusted = false;

      if (lineDef.startArrowMargin > client.barMargin || lineDef.endArrowMargin > client.barMargin) {
        lineDef.startArrowMargin = lineDef.endArrowMargin = client.barMargin;
        adjusted = true;
      }

      return adjusted ? lineDef : adjusted;
    }

    function resetArrowMargins(lineDef) {
      let adjusted = false;

      if (lineDef.startArrowMargin > 0 || lineDef.endArrowMargin > 0) {
        lineDef.startArrowMargin = lineDef.endArrowMargin = 0;
        adjusted = true;
      }

      return adjusted ? lineDef : adjusted;
    }

    // function shrinkStartEndMarginsBy2(lineDef) {
    //     let adjusted = false;
    //
    //     if (lineDef.hasOwnProperty('startHorizontalMargin') && lineDef.startHorizontalMargin > 2) {
    //         lineDef.startHorizontalMargin = Math.round(lineDef.startHorizontalMargin / 2);
    //         adjusted = true;
    //     }
    //     if (lineDef.hasOwnProperty('startVerticalMargin') && lineDef.startVerticalMargin > 2) {
    //         lineDef.startVerticalMargin = Math.round(lineDef.startVerticalMargin / 2);
    //         adjusted = true;
    //     }
    //     if (lineDef.hasOwnProperty('endHorizontalMargin') && lineDef.endHorizontalMargin > 2) {
    //         lineDef.endHorizontalMargin = Math.round(lineDef.endHorizontalMargin / 2);
    //         adjusted = true;
    //     }
    //     if (lineDef.hasOwnProperty('endVerticalMargin') && lineDef.endVerticalMargin > 2) {
    //         lineDef.endVerticalMargin = Math.round(lineDef.endVerticalMargin / 2);
    //         adjusted = true;
    //     }
    //
    //     return adjusted ? lineDef : adjusted;
    // }
    //
    // function resetArrowSizes(lineDef) {
    //     let adjusted = false;
    //
    //     if (lineDef.startArrowSize > 0 || lineDef.endArrowSize > 0) {
    //         lineDef.startArrowSize = lineDef.endArrowSize = 0;
    //         adjusted = true;
    //     }
    //
    //     return adjusted ? lineDef : adjusted;
    // }

    return [
      shrinkArrowMargins,
      resetArrowMargins //,
      // shrinkStartEndMarginsBy2,
      // shrinkStartEndMarginsBy2,
      // shrinkStartEndMarginsBy2,
      // resetArrowSizes
    ];
  }

  //endregion

  //region Elements

  getElementForDependency(dependency, assignmentData = null) {
    let selector = `[depId="${dependency.id}"]`;

    if (assignmentData) {
      selector += `[fromId="${assignmentData.from.id}"][toId="${assignmentData.to.id}"]`;
    }

    return this.client.svgCanvas.querySelector(selector);
  }

  getDependencyForElement(element) {
    const id = typeof element === 'string' ? element : element.getAttribute('depId');

    return this.store.getById(id);
  }

  //endregion

  //region Events

  //region Events that triggers redraw

  onToggleNode() {
    // Need to repopulate grid cache
    this.dependencyGridCache = null;
    // node toggled in tree, can affect resources both above and below, need to redraw all.
    this.scheduleDraw(true);
  }

  // onEventLayout() {
  //     this.scheduleDraw(true);
  // }

  onViewportResize() {
    this.scheduleDraw(true);
  }

  /**
   * Flags for redrawing if a rows height has changed
   * @private
   */
  onTranslateRow({ row }) {
    // a changetotalheight event is fired after translations, if a rowHeight change is detected here it will redraw
    // all dependencies
    if (row.lastTop >= 0 && row.top !== row.lastTop) {
      this.scheduleDraw(true);
    }
  }

  /**
   * Redraws all dependencies if a rows height changed, as detected in onTranslateRow
   * @private
   */
  onChangeTotalHeight() {
    // redraw all dependencies if the height changes. Could be caused by resource add/remove.
    // in reality not all deps needs to be redrawn, those fully above the row which changed height could be left
    // as is, but determining that would likely require more processing than redrawing
    this.scheduleDraw(true);
  }

  /**
   * Draws dependencies on horizontal scroll
   * @private
   */
  onHorizontalScroll() {
    // ResizeMonitor triggers scroll during render, make sure we have been drawn some other way before redrawing
    if (this.isDrawn) {
      this.scheduleDraw(false);
    }
  }

  /**
   * Draws dependencies on vertical scroll
   * @private
   */
  onVerticalScroll() {
    // ResizeMonitor triggers scroll during render, make sure render is done
    if (this.isDrawn) {
      // Do not invalidate on scroll, if height changes it will be invalidated anyway
      this.scheduleDraw(false);
    }
  }

  onRowsRefresh() {
    this.scheduleDraw(true);
  }

  /**
   * When rows are rerendered, better redraw dependencies (might have been collapsed etc).
   * @private
   */
  onRowsRerender() {
    this.scheduleDraw(true);
  }

  /**
   * Redraws dependencies when a row has changed
   * @private
   */
  onRowStoreRefresh({ action }) {
    switch (action) {
      case 'sort':
      case 'filter':
      case 'batch':
        // Will need to recreate grid cache after sort, filter, and any unspecified
        // set of operations encapsulated by a batch, and redraw everything
        this.dependencyGridCache = null;
        return this.scheduleDraw(true);
    }
  }

  /**
   * Redraws dependencies when a dependency has changed
   * @private
   */
  onDependencyChange({ action, record, records }) {
    const me = this;

    if (!me.scheduler.rendered || me.disabled) {
      return;
    }

    switch (action) {
      case 'dataset':
        me.dependencyGridCache = {};
      // dataset should fall through to add after clearing the cache
      // eslint disable no-fallthrough
      case 'add':
        // dependency added, draw it

        // Check if there is a cache exists. If it does - use it,
        // if not - create one after all records are drawn, this will cache all existing records
        const cache = me._dependencyGridCache;

        records.forEach((dependency) => {
          // Previously this code would draw added dependencies here, no matter if in view or not. To not have
          // to have the logic for determining whats in view or not here also, simply do a full draw below.
          // Old approach was especially costly when using CrudManager, which adds on load

          cache && me.addToGridCache(dependency);
        });

        if (!cache) {
          me._thisIsAUsedExpression(me.dependencyGridCache);
        }

        me.scheduleDraw();

        return;
      case 'update':
        // Dependency updated. Might have changed source or target, redraw it completely
        return me.scheduleRefreshDependency(record);
      case 'remove':
        // dependencies removed, release elements and remove from cache
        records.forEach((dependency) => {
          me.releaseDependency(dependency, true);
          me.removeFromCache(dependency);
        });
        me.client.trigger('dependenciesDrawn');
        return;
      // Removing all or filtering -> full redraw
      case 'removeall':
      case 'filter':
        me.dependencyGridCache = null;
        // continue to schedule draw
        break;
    }

    // other changes (removeall, dataset, filter) trigger full redraw
    me.scheduleDraw(true);
  }

  /**
   * Attaches listeners to related event store, clears old listener if one exists
   * @private
   */
  bindEventStoreListeners() {
    const me = this;

    me._eventStoreListenersDetacher && me._eventStoreListenersDetacher();

    // Maps to taskStore for Gantt
    me._eventStoreListenersDetacher = me.store.eventStore.on({
      change: me.onEventChange,
      thisObj: me
    });
  }

  /**
   * Redraws dependencies when an event has changed
   * @private
   */
  onEventChange({ action, record }) {
    switch (action) {
      case 'filter':
        // filtering events, need to redraw all dependencies
        return this.scheduleDraw(true);
      case 'update':
        // event updated, redraw its dependencies
        return this.drawForTimeSpan(record, true);
      case 'removeall':
        this.resetGridCache();
        return this.scheduleDraw(true);
    }

    // adding event has no effect on dependencies, unless it changes row height. in which case it will be handled
    // by onTranslateRow().
    // updating an event might also change row height, handled the same way.
    // removing events will also remove dependencies, thus handled in onDependencyChange
  }

  onAssignmentRefresh({ action }) {
    if (action === 'dataset') {
      // Assigning using EventEdit replaces all assignments. Taking the easy way out, throwing cache away
      this.resetGridCache();
      this.scheduleDraw(true);
    }
  }

  onAssignmentChange({ action, record, records }) {
    const me = this;

    if (record) {
      records = [record];
    }

    if (action === 'add' || action === 'remove' || action === 'update') {
      records.forEach((assignment) => {
        const dependencies = assignment.event ? me.store.getEventDependencies(assignment.event) : [];
        dependencies.forEach((dependency) => {
          // New assignment added by other means than EventEdit
          if (action === 'add') {
            me.scheduleRefreshDependency(dependency);
          }

          // Event unassigned, remove dep line
          else if (action === 'remove') {
            let assignments;

            // Removed source?
            if (dependency.from === assignment.eventId) {
              // Might point to a multi assigned event, need to remove all lines
              assignments = dependency.targetEvent.assignments.map((to) => ({ from: assignment, to }));
            }
            // Nope, target
            else {
              // Might point to a multi assigned event, need to remove all lines
              assignments = dependency.sourceEvent.assignments.map((from) => ({ from, to: assignment }));
            }

            assignments.forEach((assignmentData) => {
              me.releaseDependency(dependency, assignmentData);
              me.removeFromCache(dependency, assignmentData);
            });
          }

          // Single assignment updated, redraw lines for it
          else if (action === 'update') {
            const assignments = me
              .getDependencyAssignments(dependency)
              .filter((a) => a && (a.from === record || a.to === record));
            assignments.forEach((assignmentData) => {
              me.scheduleRefreshDependency(dependency, assignmentData);
            });
          }
        });
      });
    }
  }

  //endregion

  onElementClick(event) {
    const me = this;

    if (event.target.matches('.' + me.baseCls)) {
      const dependency = DomDataStore.get(event.target).dependency,
        eventName = event.type === 'click' ? 'Click' : 'DblClick';

      /**
       * Fires on the owning Scheduler/Gantt when a click is registered on a dependency line.
       * @event dependencyClick
       * @param {Scheduler.view.Scheduler} source The scheduler
       * @param {Scheduler.model.DependencyModel} dependency
       * @param {MouseEvent} event
       */
      /**
       * Fires on the owning Scheduler/Gantt when a click is registered on a dependency line.
       * @event dependencyDblClick
       * @param {Scheduler.view.Scheduler} source The scheduler
       * @param {Scheduler.model.DependencyModel} dependency
       * @param {MouseEvent} event
       */
      me.client.trigger(`dependency${eventName}`, {
        dependency,
        event
      });
    }
  }

  onElementDblClick(event) {
    return this.onElementClick(event);
  }

  onElementMouseOver(event) {
    const me = this;

    if (event.target.matches('.' + me.baseCls)) {
      const dependency = DomDataStore.get(event.target).dependency;

      /**
       * Fires on the owning Scheduler/Gantt when the mouse moves over a dependency line.
       * @event dependencyMouseOver
       * @param {Scheduler.view.Scheduler} source The scheduler
       * @param {Scheduler.model.DependencyModel} dependency
       * @param {MouseEvent} event
       */
      me.client.trigger('dependencyMouseOver', {
        dependency,
        event
      });

      if (me.overCls) me.highlight(dependency, me.overCls);
    }
  }

  onElementMouseOut(event) {
    const me = this;

    if (event.target.matches('.' + me.baseCls)) {
      const dependency = DomDataStore.get(event.target).dependency;

      /**
       * Fires on the owning Scheduler/Gantt when the mouse moves out of a dependency line.
       * @event dependencyMouseOut
       * @param {Scheduler.view.Scheduler} source The scheduler
       * @param {Scheduler.model.DependencyModel} dependency
       * @param {MouseEvent} event
       */
      me.client.trigger('dependencyMouseOut', {
        dependency,
        event
      });

      if (me.overCls && !dependency.meta.removed) me.unhighlight(dependency);
    }
  }

  //endregion

  //region Highlight

  highlight(dependency, cls = this.overCls) {
    const element = this.getElementForDependency(dependency);
    element && element.classList.add(cls);

    dependency.highlight(cls);
  }

  unhighlight(dependency, cls = this.overCls) {
    const element = this.getElementForDependency(dependency);
    element && element.classList.remove(cls);

    dependency.unhighlight(cls);
  }

  highlightEventDependencies(timespan) {
    timespan.allDependencies.forEach((dep) => this.highlight(dep));
  }

  unhighlightEventDependencies(timespan) {
    timespan.allDependencies.forEach((dep) => this.unhighlight(dep));
  }

  //endregion

  //region Determining dependencies to draw

  // Neither resource can be hidden for a dependency to be considered visible
  isDependencyVisible(dependency, assignmentData = null) {
    const from = dependency.sourceEvent,
      to = dependency.targetEvent;

    // Bail out early in case source or target doesn't exist
    if (!(from && to)) {
      return false;
    }

    let fromResource, toResource;

    // Using multi-assignment, resource obtained from assignment
    if (assignmentData) {
      fromResource = assignmentData.from.resource;
      toResource = assignmentData.to.resource;

      const { eventStore } = this.client;
      // Filtering EventStore does not filter AssignmentStore, determine if Event is available in this case
      if (eventStore.isFiltered && (eventStore.indexOf(from) === -1 || eventStore.indexOf(to) === -1)) {
        return false;
      }
    }
    // Not using assignments, resource obtained from event
    else {
      fromResource = from.resource;
      toResource = to.resource;
    }

    return (
      from instanceof Model &&
      // Verify these are real existing Resources and not placeholders (resource not existing in resource store)
      fromResource instanceof ResourceModel &&
      toResource instanceof ResourceModel &&
      !fromResource.instanceMeta(this.scheduler.store).hidden &&
      !toResource.instanceMeta(this.scheduler.store).hidden
    );
  }

  // Get the bounding box for either the source or the target event
  getBox(dependency, source, assignmentData = null) {
    const eventRecord = this.getTimeSpanRecordFromDependency(dependency, source);

    let resource;

    // Multi-assignment, get resource from assignment
    if (assignmentData) {
      resource = assignmentData[source ? 'from' : 'to'].resource;
    }
    // Single, get resource from event
    else {
      resource = eventRecord.resource;
    }

    // TODO: change getResourceEventBox to use Rectangle
    return this.scheduler.getResourceEventBox(eventRecord, resource, true);
  }

  // Get source or target events resource
  getRowRecordFromDependency(dependency, source, assignmentData) {
    // Multi-assigned, use assignments resource
    if (assignmentData) {
      return assignmentData[source ? 'from' : 'to'].resource;
    }

    // Not multi-assigned, get events resource
    return this.getTimeSpanRecordFromDependency(dependency, source).resource;
  }

  // Get source or target event
  getTimeSpanRecordFromDependency(dependency, source = true) {
    return dependency[`${source ? 'source' : 'target'}Event`];
  }

  getMetaId(assignmentData = null) {
    return assignmentData
      ? `${this.client.id}-ass${assignmentData.from.id}-ass${assignmentData.to.id}`
      : this.client.id;
  }

  // Gets the source and target events bounds and unions them to determine the dependency bounds
  getDependencyBounds(dependency, assignmentData = null) {
    const me = this,
      client = me.client,
      ddr = dependency.getDateRange();

    // quick bailout for hidden rows
    if (!client.rowManager.rowCount || !me.isDependencyVisible(dependency, assignmentData)) {
      return null;
    }
    // quick bailout in case dependency dates and view dates do not intersect
    if (!(ddr && DateHelper.intersectSpans(ddr.start, ddr.end, client.startDate, client.endDate))) {
      return null;
    }

    const metaId = me.getMetaId(assignmentData),
      instanceMeta = dependency.instanceMeta(metaId);

    // If we are forcing recalculation of dep bounds, or there are no calculated bounds for this dependency
    // or the calculated bounds were based on a "best guess", then recalculate the bounds.
    if (me._resetBoundsCache || !instanceMeta.bounds || !instanceMeta.bounds.layout) {
      const startBox = me.getBox(dependency, true, assignmentData),
        endBox = me.getBox(dependency, false, assignmentData);

      // cant draw dependency if either start or end is in collapsed row
      if (!startBox || !endBox) {
        return null;
      }

      const from = me.getTimeSpanRecordFromDependency(dependency, true),
        to = me.getTimeSpanRecordFromDependency(dependency, false),
        startRectangle = new Rectangle(
          startBox.start,
          startBox.top,
          startBox.end - startBox.start,
          startBox.bottom - startBox.top
        ),
        endRectangle = new Rectangle(endBox.start, endBox.top, endBox.end - endBox.start, endBox.bottom - endBox.top),
        bounds = Rectangle.union(startRectangle, endRectangle);

      [
        [from, startRectangle, startBox],
        [to, endRectangle, endBox]
      ].map(([record, rectangle, eventBox]) => {
        // When using other milestoneLayoutMode than default milestones should be treated as normal events.
        // Milestones are zero width by default, so we must measure the milestone el's height
        // (or icon el width) and use that as the width. We cannot use the event's calculated height because
        // if there are labels, the milestone diamond will be smaller.
        // If the event doesn't have an element, then it's outside of the rendered block and the exact
        // width doesn't matter.
        if (client.milestoneLayoutMode === 'default' && record.isMilestone) {
          if (!client.milestoneWidth && eventBox.eventEl) {
            client.milestoneWidth = record.iconCls
              ? eventBox.eventEl.firstElementChild.offsetWidth
              : parseInt(window.getComputedStyle(eventBox.eventEl, ':before').fontSize);
          }

          // If it could not be measured due to the event being outside of the rendered block
          // we have to use the calculated height.
          const milestoneWidth = client.milestoneWidth || rectangle.height;
          rectangle.left -= milestoneWidth / 2;
          rectangle.right += milestoneWidth / 2;
        }
      });

      instanceMeta.bounds = {
        bounds,
        startRectangle,
        endRectangle,

        // Cache whether both rectangles are based on the true layout
        // or a best guess approximation to be recalculated
        // next time through.
        layout: startBox.layout && endBox.layout
      };
    }

    return dependency.instanceMeta(metaId).bounds;
  }

  // Grid cache is a virtual grid holding info on which dependencies intersects its virtual cells.
  // Used to determine which dependencies should be considered for drawing, iterating over all dependencies each update
  // gets too costly when count increases (>10000).
  //
  // Illustration shows entire schedule area, dddd is a dependency line, vvv is viewport, xxx virtual cell border:
  //
  // ----------------------------------
  // |     vvvvvxvvvvv                |
  // |     v    x    v                |
  // |     v d  x    v                |
  // |     v d  x    v                |
  // |xxxxxvxdxxx    v                |
  // |     vvdvvxvvvvv                |
  // |       d  x                     |
  // |       d  x                     |
  // |       d  x                     |
  // |xxxxxxxdxxxxxxx                 |
  // |       d  x                     |
  // |       d  x                     |
  // |          x                     |
  // |          x                     |
  // |xxxxxxxxxxxxxxx                 |
  // ----------------------------------
  //
  // The dependency crosses three virtual grid cells [0,0], [0,1] and [0,2]. Stored in a map in cache:
  // {
  //    0 : {
  //      0 : [ d, ... ],
  //      1 : [ d, ... ],
  //      2 : [ d, ... ]
  //    }
  // }
  //
  // Viewport crosses four virtual grid cells [0,0], [1,0], [0,1], [1,1]. Those cells are checked in the cached map to
  // find out which rows should be considered for drawing.
  //
  // This approach minimizes the amount of iteration needed
  get dependencyGridCache() {
    const me = this;

    if (!me._dependencyGridCache) {
      me._dependencyGridCache = {};
      me.store.forEach((dependency) => me.addToGridCache(dependency));
    }

    return me._dependencyGridCache;
  }

  // With multi-assign each dependency might be drawn several times
  getDependencyAssignments(dependency) {
    if (!this.client.assignmentStore) {
      return [null]; // On purpose, to be iterable
    }

    const fromAssignments = dependency.sourceEvent && dependency.sourceEvent.assignments,
      toAssignments = dependency.targetEvent && dependency.targetEvent.assignments,
      assignments = [];

    // flatMap could be used, but not in Edge yet

    fromAssignments &&
      fromAssignments.forEach(
        (from) =>
          toAssignments &&
          toAssignments.forEach((to) => {
            assignments.push({ from, to });
          })
      );

    return assignments;
  }

  addToGridCache(dependency) {
    const me = this,
      { dependencyGridCache, cacheGridSize } = me,
      rowStore = me.client.store,
      assignments = me.getDependencyAssignments(dependency);

    assignments.forEach((assignmentData) => {
      const dependencyBounds = me.getDependencyBounds(dependency, assignmentData);

      if (dependencyBounds) {
        const metaId = me.getMetaId(assignmentData),
          meta = dependency.instanceMeta(metaId),
          metaGridCache = (meta.gridCache = []),
          // Using index vertically rather than y for reliability with variable row height
          fromIndex = rowStore.indexOf(me.getRowRecordFromDependency(dependency, true, assignmentData)),
          toIndex = rowStore.indexOf(me.getRowRecordFromDependency(dependency, false, assignmentData)),
          topIndex = Math.min(fromIndex, toIndex),
          bottomIndex = Math.max(fromIndex, toIndex),
          // Convert dependency bounds/index into virtual grid cells
          box = dependencyBounds.bounds,
          boxLeft = Math.floor(Math.max(box.x, 0) / cacheGridSize.x),
          boxRight = Math.floor(box.right / cacheGridSize.x),
          boxTop = Math.floor(topIndex / cacheGridSize.index),
          boxBottom = Math.floor(bottomIndex / cacheGridSize.index);

        let cacheX, cacheY, x, y;

        // Store the dependency in the virtual cells which it intersects
        for (x = boxLeft; x <= boxRight; x++) {
          cacheX = dependencyGridCache[x] || (dependencyGridCache[x] = {});

          for (y = boxTop; y <= boxBottom; y++) {
            cacheY = cacheX[y] || (cacheX[y] = []);

            cacheY.push({ dependency, assignmentData, metaId });
            metaGridCache.push([x, y]);
          }
        }
      }
    });
  }

  removeFromCache(dependency, assignmentData = null) {
    const me = this,
      assignments = assignmentData ? [assignmentData] : me.getDependencyAssignments(dependency);

    assignments.forEach((assignmentData) => {
      const metaId = me.getMetaId(assignmentData),
        meta = dependency.instanceMeta(metaId);

      meta.gridCache &&
        me._dependencyGridCache &&
        meta.gridCache.forEach(([x, y]) => {
          if (me._dependencyGridCache.hasOwnProperty(x) && me._dependencyGridCache[x].hasOwnProperty(y)) {
            const entries = me._dependencyGridCache[x][y],
              index = entries.findIndex(
                (d) =>
                  d.dependency === dependency &&
                  (d.assignmentData === assignmentData ||
                    (d.assignmentData.from === assignmentData.from && d.assignmentData.to === assignmentData.to))
              );

            // Cannot use ArrayHelper#remove since it cannot compare deeply
            if (index > -1) {
              entries.splice(index, 1);
            }
          }
        });

      meta.bounds = null;
      meta.gridCache = null;
    });
  }

  set dependencyGridCache(cache) {
    this._dependencyGridCache = cache;
  }

  // Reset cached bounds, not grid cache since it is expensive to create. It is so coarse anyway so should be fine
  // with most changes, except for sorting and similar. Reset on demand instead
  resetBoundsCache() {
    // Not actually resetting here, would just be costly to iterate and reset per dependency, instead flagging to
    // force cached value to be updated
    this._resetBoundsCache = true;
  }

  // In some cases we do need to reset cache, like when time axis is reconfigured
  resetGridCache() {
    this.dependencyGridCache = null;
  }

  //endregion

  //region Draw & render

  //region Lines

  prepareLineDef(dependency, dependencyDrawData, assignmentData = null) {
    const me = this,
      source = me.getTimeSpanRecordFromDependency(dependency, true),
      target = me.getTimeSpanRecordFromDependency(dependency, false),
      type = dependency.type;

    let startSide = dependency.fromSide,
      endSide = dependency.toSide;

    // Fallback to view trait if dependency start side is not given
    if (!startSide) {
      switch (true) {
        case type === DependencyModel.Type.StartToEnd:
          startSide = me.getConnectorStartSide(source);
          break;

        case type === DependencyModel.Type.StartToStart:
          startSide = me.getConnectorStartSide(source);
          break;

        case type === DependencyModel.Type.EndToStart:
          startSide = me.getConnectorEndSide(source);
          break;

        case type === DependencyModel.Type.EndToEnd:
          startSide = me.getConnectorEndSide(source);
          break;

        default:
          throw new Error('Invalid dependency type: ' + type);
      }
    }

    // Fallback to view trait if dependency end side is not given /*or can be obtained from type*/
    if (!endSide) {
      switch (true) {
        case type === DependencyModel.Type.StartToEnd:
          endSide = me.getConnectorEndSide(target);
          break;

        case type === DependencyModel.Type.StartToStart:
          endSide = me.getConnectorStartSide(target);
          break;

        case type === DependencyModel.Type.EndToStart:
          endSide = me.getConnectorStartSide(target);
          break;

        case type === DependencyModel.Type.EndToEnd:
          endSide = me.getConnectorEndSide(target);
          break;

        default:
          throw new Error('Invalid dependency type: ' + type);
      }
    }

    const { startRectangle, endRectangle } = dependencyDrawData;

    return {
      startBox: {
        start: startRectangle.x,
        end: startRectangle.right,
        top: startRectangle.y,
        bottom: startRectangle.bottom
      },

      endBox: {
        start: endRectangle.x,
        end: endRectangle.right,
        top: endRectangle.y,
        bottom: endRectangle.bottom
      },
      startSide: startSide,
      endSide: endSide
    };
  }

  // Draws a single SVG line that represents the dependency
  drawLine(canvas, dependency, points, assignmentData = null) {
    const { client } = this,
      metaId = this.getMetaId(assignmentData);

    // Reuse existing element if possible
    let line = dependency.instanceMeta(metaId).lineElement;

    if (!line) {
      line = dependency.instanceMeta(metaId).lineElement = document.createElementNS(
        'http://www.w3.org/2000/svg',
        'polyline'
      );
      line.setAttribute('depId', dependency.id);
      if (assignmentData) {
        line.setAttribute('fromId', assignmentData.from.id);
        line.setAttribute('toId', assignmentData.to.id);
      }
      canvas.appendChild(line);
    }

    // TODO: Use DomHelper.syncClassList

    // className is SVGAnimatedString for svg elements, reading attribute instead
    line.classList.length && line.classList.remove.apply(line.classList, line.getAttribute('class').split(' '));

    line.classList.add(this.baseCls);

    if (dependency.cls) {
      line.classList.add(dependency.cls);
    }
    if (dependency.bidirectional) {
      line.classList.add('b-sch-bidirectional-line');
    }
    if (dependency.highlighted) {
      line.classList.add(...dependency.highlighted.split(' '));
    }
    if (BrowserHelper.isIE11) {
      const ddr = dependency.getDateRange(true),
        viewStart = client.startDate;

      if (ddr.start < viewStart) {
        line.classList.add('b-no-start-marker');
      }
      if (ddr.end < viewStart) {
        line.classList.add('b-no-end-marker');
      }
    }

    line.setAttribute(
      'points',
      !points
        ? ''
        : points
            .map((p, i) => (i !== points.length - 1 ? `${p.x1},${p.y1}` : `${p.x1},${p.y1} ${p.x2},${p.y2}`))
            .join(' ')
    );

    DomDataStore.set(line, {
      dependency
    });
  }

  //endregion

  /**
   * Re-caches and redraws a dependency, for all assignments.
   * @param {Scheduler.model.DependencyModel} dependency Dependency to refresh
   */
  refreshDependency(dependency) {
    const me = this,
      assignments = me.getDependencyAssignments(dependency);

    // Release dependency element, for all assignments if using AssignmentStore
    me.releaseDependency(dependency, assignments[0] !== null);
    // Remove it from grid & bounds cache
    me.removeFromCache(dependency);
    // Re-add it to grid cache
    me.addToGridCache(dependency);
    // Draw all assignments
    assignments.forEach((assignmentData) => me.drawDependency(dependency, null, assignmentData));
  }

  /**
   * Re-caches and redraws a dependency for given assignment.
   * @param {Scheduler.model.DependencyModel} dependency Dependency to refresh
   * @param {Object} assignmentData
   * @param {Scheduler.model.AssignmentModel} assignmentData.from Source assignment
   * @param {Scheduler.model.AssignmentModel} assignmentData.to Target assignment
   * @private
   */
  refreshDependencyAssignment(dependency, assignmentData) {
    const me = this;

    // In case it was assigned to something not in view/timeline, release the line
    me.releaseDependency(dependency, assignmentData);
    // Update cache to only contain whats left of it
    me.removeFromCache(dependency, assignmentData);
    me.addToGridCache(dependency);
    // Draw lines
    me.drawDependency(dependency, null, assignmentData);
  }

  /**
   * Stores all dependencies/assignments that were requested to refresh and schedules repaint on next animation frame
   * @param {Scheduler.model.DependencyModel} dependency Dependency model to refresh
   * @param {Object} [assignmentData] Assignment data
   * @param {Scheduler.model.AssignmentModel} [assignmentData.from] Source assignment
   * @param {Scheduler.model.AssignmentModel} [assignmentData.to] Target assignment
   * @private
   */
  scheduleRefreshDependency(dependency, assignmentData = null) {
    const map = this.dependenciesToRefresh;

    // If this method was called once without assignment data - all lines releated should be repainted
    if (!assignmentData) {
      map.set(dependency, true);
    } else if (map.has(dependency)) {
      if (map.get(dependency) !== true) {
        map.get(dependency).add(assignmentData);
      }
    } else {
      map.set(dependency, new Set([assignmentData]));
    }

    if (map.size === 1) {
      this.requestAnimationFrame(() => {
        this.refreshDependencyOnFrame();
      });
    }
  }

  /**
   * Repaints scheduled dependencies/assignments
   * @private
   */
  refreshDependencyOnFrame() {
    const me = this,
      map = me.dependenciesToRefresh;

    // First clear cache and release dependencies. This will modify DOM
    map.forEach((assignments, dependency) => {
      if (assignments === true) {
        const assignments = me.getDependencyAssignments(dependency);
        // Release dependency element, for all assignments if using AssignmentStore
        me.releaseDependency(dependency, assignments[0] !== null);
        // Remove it from grid & bounds cache
        me.removeFromCache(dependency);
      } else {
        assignments.forEach((assignment) => {
          // In case it was assigned to something not in view/timeline, release the line
          me.releaseDependency(dependency, assignment);
          // Update cache to only contain whats left of it
          me.removeFromCache(dependency, assignment);
        });
      }
    });

    // Then fill cache before drawing dependencies. This will read the DOM forcing reflow
    map.forEach((assignments, dependency) => {
      // Re-add it to grid cache
      me.addToGridCache(dependency);
    });

    // Finally append elements to the DOM
    map.forEach((assignments, dependency) => {
      if (assignments === true) {
        assignments = me.getDependencyAssignments(dependency);
      }

      assignments.forEach((assignmentData) => {
        me.drawDependency(dependency, null, assignmentData);
      });
    });

    map.clear();

    me.client.trigger('dependenciesDrawn', { partial: true });
  }

  /**
   * Draws a single dependency (for a single assignment if using multiple), if in view.
   * @param {Scheduler.model.DependencyModel} dependency Dependency to draw
   */
  drawDependency(dependency, drawData = null, assignmentData = null) {
    const me = this,
      canvas = me.client.svgCanvas,
      { drawnDependencies, oldDrawnDependencies } = me,
      // Determines if a dependency should be draw, and if so returns the coordinates of its events
      dependencyDrawData = drawData || me.getDependencyBounds(dependency, assignmentData),
      lookup = (d) =>
        d.dependency === dependency &&
        (d.assignmentData === assignmentData ||
          (d.assignmentData.from === assignmentData.from && d.assignmentData.to === assignmentData.to));

    if (!me.disabled && dependencyDrawData) {
      // Build line defs
      const lineDef = me.prepareLineDef(dependency, dependencyDrawData),
        lines = me.pathFinder.findPath(lineDef, me.lineDefAdjusters);

      me.drawLine(canvas, dependency, lines, assignmentData);

      // Cannot use ArrayHelper#include since object wont be the same, only its contents
      if (!drawnDependencies.some(lookup)) {
        drawnDependencies.push({ dependency, assignmentData });
      }
    }

    // Remove from oldDrawnDeps, to not have element removed. Cannot use ArrayHelper#remove as stated above
    const oldIndex = oldDrawnDependencies && oldDrawnDependencies.findIndex(lookup);
    if (oldIndex >= 0) {
      oldDrawnDependencies.splice(oldIndex, 1);
    }
  }

  /**
   * Draws multiple dependencies, called from drawForEvent() or drawFromTask().
   * @private
   */
  drawForTimeSpan(timeSpanRecord, async = false) {
    const me = this;

    // If the client is doing an animated update, we must update at end.
    // That will be asynchronous relative to now, so do not pass on the async flag.
    if (me.client.isAnimating) {
      me.client.on({
        transitionend() {
          me.drawForTimeSpan(timeSpanRecord, true);
        },
        once: true
      });
    }
    // Otherwise, schedule the draw for the next frame.
    else {
      me.store.getTimeSpanDependencies(timeSpanRecord).forEach((dependency) => {
        if (async) {
          me.scheduleRefreshDependency(dependency);
        } else {
          me.refreshDependency(dependency);
        }
      });
    }
  }

  /**
   * Draws all dependencies for the specified event.
   */
  drawForEvent(eventRecord) {
    this.drawForTimeSpan(eventRecord);
  }

  // Redraw all dependencies for a particular eventRecord, using its current element instead of calculating a box
  // Used to do live redraw while resizing or dragging events
  updateDependenciesForTimeSpan(timeSpanRecord, element) {
    const me = this,
      eventRecord = timeSpanRecord.isAssignment ? timeSpanRecord.event : timeSpanRecord,
      deps = me.store.getTimeSpanDependencies(eventRecord),
      metaId = me.getMetaId(),
      { client } = me,
      originalTaskRect = Rectangle.from(element, client.timeAxisSubGridElement);

    let bounds;

    deps.forEach((dep) => {
      const assignments = me.getDependencyAssignments(dep);
      assignments.forEach((assignmentData) => {
        const taskRect = originalTaskRect.clone();
        let startRectangle, endRectangle, box;

        // If dragging one multi assigned event the others wont move until it is dropped. Prevent their dep
        // lines from updating by bailing out
        if (assignmentData && assignmentData.from !== timeSpanRecord && assignmentData.to !== timeSpanRecord) {
          return;
        }

        // Bail out if dependency is not visible (other end might be collapsed)
        if (!me.isDependencyVisible(dep, assignmentData)) {
          return;
        }

        if (me.getTimeSpanRecordFromDependency(dep, true) === eventRecord) {
          startRectangle = taskRect;

          // try to look into dependency cache first
          if ((bounds = dep.instanceMeta(metaId).bounds)) {
            endRectangle = bounds.endRectangle;
          } else {
            box = me.getBox(dep, false, assignmentData);

            // Row might be in collapsed node, in which case we get no box
            if (box) {
              endRectangle = new Rectangle(box.start, box.top, box.end - box.start, box.bottom - box.top);
            }
          }
        } else {
          // try to look into dependency cache first
          if ((bounds = dep.instanceMeta(metaId).bounds)) {
            startRectangle = bounds.startRectangle;
          } else {
            box = me.getBox(dep, true, assignmentData);

            // Row might be in collapsed node, in which case we get no box
            if (box) {
              startRectangle = new Rectangle(box.start, box.top, box.end - box.start, box.bottom - box.top);
            }
          }

          endRectangle = taskRect;
        }

        if (startRectangle && endRectangle) {
          me.drawDependency(dep, { startRectangle, endRectangle }, assignmentData);
        }
      });
    });
  }

  scheduleDraw(relayout = false) {
    const me = this;

    // There way be number of concurrent calls to this method, we need to reset cache if at least
    // once it was called with relayout = true
    if (relayout) {
      me.resetBoundsCache();
    }

    // If the scheduler/gantt is doing an animated update, schedule the draw
    // for when that's done so that we get correct element boxes.
    if (me.client.isAnimating) {
      if (!me.clientTransitionRemover) {
        me.clientTransitionRemover = me.client.on({
          transitionend() {
            me.clientTransitionRemover();
            me.clientTransitionRemover = null;
            me.draw();
          },
          once: true
        });
      }
    }
    // Otherwise, schedule the draw for the next frame.
    else {
      me.doScheduleDraw();
    }
  }

  /**
   * Draws all dependencies that overlap the current viewport
   */
  draw(reLayout = false) {
    const me = this,
      { client } = me;

    // Early bailout if we get here before we have any deps
    if (!me.oldDrawnDependencies && !me.store.count) {
      return;
    }

    // if animation is in progress, schedule drawing and skip current one
    if (client.isAnimating) {
      client.on({
        transitionend() {
          me.scheduleDraw(true);
        },
        once: true
      });

      return;
    }

    // viewBox is the bounds of the current viewport, used to determine which dependencies to draw
    const viewBox = me.client.timeAxisSubGrid.viewRectangle;

    if (reLayout) {
      me.resetBoundsCache();
    }

    me.oldDrawnDependencies = me.drawnDependencies;
    me.drawnDependencies = [];

    // too early
    if (!viewBox.width || !viewBox.height) return [];

    // expand viewBox with buffer size
    viewBox.inflate(me.bufferSize);

    // Do not draw if no rows
    if (!me.disabled && client.store.count && client.rowManager.rowCount) {
      const consideredDependencies = {},
        { dependencyGridCache, cacheGridSize } = me,
        viewLeft = Math.floor(Math.max(viewBox.left, 0) / cacheGridSize.x),
        viewRight = Math.floor(viewBox.right / cacheGridSize.x),
        topIndex = Math.floor(client.rowManager.topRow.dataIndex / cacheGridSize.index),
        bottomIndex = Math.floor(client.rowManager.bottomRow.dataIndex / cacheGridSize.index),
        dependenciesToDraw = [];

      let x, rowIndex, i;

      // Iterate over virtual dependency grid cells, pushing each dependency that intersects that cell
      for (x = viewLeft; x <= viewRight; x++) {
        for (rowIndex = topIndex; rowIndex <= bottomIndex; rowIndex++) {
          const cacheX = dependencyGridCache[x],
            deps = cacheX && cacheX[rowIndex];

          for (i = 0; deps && i < deps.length; i++) {
            const { dependency, assignmentData, metaId } = deps[i],
              // Unique id for dependency combined with assignment
              flagId = dependency.id + '-' + metaId;

            if (!consideredDependencies[flagId]) {
              // Only draw those actually in view
              const bounds = me.getDependencyBounds(dependency, assignmentData);
              if (bounds && bounds.bounds.intersect(viewBox, true)) {
                dependenciesToDraw.push([dependency, bounds, assignmentData]);
              }

              consideredDependencies[flagId] = true;
            }
          }
        }
      }

      // Append dependencies to the DOM only after all have been calculated
      dependenciesToDraw.forEach(([dependency, bounds, assignmentData]) => {
        me.drawDependency(dependency, bounds, assignmentData);
      });
    }

    // Stop forcing recalculation of bounds
    me._resetBoundsCache = false;

    // Release elements for any dependencies that wasn't drawn
    me.oldDrawnDependencies.forEach((data) => me.releaseDependency(data.dependency, data.assignmentData));

    client.trigger('dependenciesDrawn');

    this.isDrawn = true;
  }

  /**
   * Release a dependency that is determined to be no longer visible
   * @param {Scheduler.model.DependencyModel} dependency
   */
  releaseDependency(dependency, assignmentData = null) {
    // Remove for all assignments (related to this client, store might be shared)
    if (assignmentData === true) {
      Object.keys(dependency.meta.map || {})
        .filter((key) => key.startsWith(this.client.id))
        .forEach((key) => {
          const data = dependency.meta.map[key];
          if (data.lineElement) {
            data.lineElement.remove();
            data.lineElement = null;
          }
        });
    }
    // Remove specific
    else {
      const metaId = this.getMetaId(assignmentData),
        lineElement = dependency.instanceMeta(metaId).lineElement;

      if (lineElement) {
        dependency.instanceMeta(metaId).lineElement = null;
        // Not reusing elements for other lines currently
        lineElement.remove();
      }
    }
  }

  render() {
    const me = this,
      client = me.scheduler;

    me.draw();

    if (me.showTooltip) {
      me.tooltip = me.createTooltip();
    }

    client.timeAxis.on({
      endreconfigure: me.resetGridCache,
      thisObj: me
    });

    client.assignmentStore &&
      client.assignmentStore.on({
        change: me.onAssignmentChange,
        refresh: me.onAssignmentRefresh,
        thisObj: me
      });

    if (me.highlightDependenciesOnEventHover) {
      client.on(client.scheduledEventName + 'MouseEnter', (params) =>
        me.highlightEventDependencies(params.eventRecord || params.taskRecord)
      );
      client.on(client.scheduledEventName + 'MouseLeave', (params) =>
        me.unhighlightEventDependencies(params.eventRecord || params.taskRecord)
      );
    }
  }

  renderContents() {
    this.draw();
  }

  //endregion

  //region Connector sides

  /**
   * Gets displaying item start side
   *
   * @param {Scheduler.model.TimeSpan} timeSpanRecord
   * @return {String} 'left' / 'right' / 'top' / 'bottom'
   */
  getConnectorStartSide(timeSpanRecord) {
    return this.client.currentOrientation.getConnectorStartSide(timeSpanRecord);
  }

  /**
   * Gets displaying item end side
   *getRowRecordFromDependency
   * @param {Scheduler.model.TimeSpan} timeSpanRecord
   * @return {String} 'left' / 'right' / 'top' / 'bottom'
   */
  getConnectorEndSide(timeSpanRecord) {
    return this.client.currentOrientation.getConnectorEndSide(timeSpanRecord);
  }

  //endregion

  //region Tooltip

  createTooltip() {
    const me = this;

    return new Tooltip(
      Object.assign(
        {
          align: 'b-t',
          id: `${me.client.id}-dependency-tip`,
          //TODO: need some way better to specify this. maybe each feature should be queried?
          forSelector: `.b-timelinebase:not(.b-eventeditor-editing):not(.b-resizing-event):not(.b-dragcreating):not(.b-dragging-event):not(.b-creating-dependency) .${me.baseCls}`,
          clippedBy: [me.client.timeAxisSubGridElement, me.client.bodyContainer],
          forElement: me.client.timeAxisSubGridElement,
          showOnHover: true,
          hoverDelay: 0,
          hideDelay: 0,
          anchorToTarget: false,
          trackMouse: false,
          getHtml: me.getHoverTipHtml.bind(me)
        },
        me.tooltip || {}
      )
    );
  }

  /**
   * Generates html for the tooltip shown when hovering a dependency
   * @param {Object} tooltipConfig
   * @returns {string} Html to display in the tooltip
   * @private
   */
  getHoverTipHtml({ tip, forElement }) {
    const me = this,
      dependencyModel = me.getDependencyForElement(forElement),
      fromEvent = dependencyModel.sourceEvent,
      toEvent = dependencyModel.targetEvent;

    return TemplateHelper.tpl`
             <table class="b-sch-dependency-tooltip">
                <tr>
                    <td>${me.L('from')}: </td>
                    <td>${fromEvent.name}</td>
                    <td>
                        <div class="b-sch-box b-${fromBoxSide[dependencyModel.type]}"></div>
                    </td>
                </tr>
                <tr>
                    <td>${me.L('to')}: </td>
                    <td>${toEvent.name}</td>
                    <td><div class="b-sch-box b-${toBoxSide[dependencyModel.type]}"></div></td>
                </tr>
            </table>
        `;
  }

  //endregion

  /**
   * Disable this feature
   * @property {Boolean}
   */
  get disabled() {
    return this._disabled;
  }

  set disabled(disabled) {
    this._disabled = disabled;

    this.updateCreateListeners();

    if (this.client.rendered) {
      this.draw();
    }
  }
}

Dependencies._$name = 'Dependencies';
GridFeatureManager.registerFeature(Dependencies, false, 'Scheduler');

// region polyfills
// from https://github.com/eligrey/classList.js
if (document.createElementNS && !('classList' in document.createElementNS('http://www.w3.org/2000/svg', 'g'))) {
  (function(view) {
    if (!('Element' in view)) return;

    var classListProp = 'classList',
      protoProp = 'prototype',
      elemCtrProto = view.Element[protoProp],
      objCtr = Object,
      strTrim =
        String[protoProp].trim ||
        function() {
          return this.replace(/^\s+|\s+$/g, '');
        },
      arrIndexOf =
        Array[protoProp].indexOf ||
        function(item) {
          for (var i = 0, len = this.length; i < len; i++) {
            if (i in this && this[i] === item) {
              return i;
            }
          }
          return -1;
        },
      // Vendors: please allow content code to instantiate DOMExceptions
      DOMEx = function(type, message) {
        this.name = type;
        this.code = DOMException[type]; // eslint-disable-line no-undef
        this.message = message;
      },
      checkTokenAndGetIndex = function(classList, token) {
        if (token === '') {
          throw new DOMEx('SYNTAX_ERR', 'The token must not be empty.');
        }
        if (/\s/.test(token)) {
          throw new DOMEx('INVALID_CHARACTER_ERR', 'The token must not contain space characters.');
        }
        return arrIndexOf.call(classList, token);
      },
      ClassList = function(elem) {
        var trimmedClasses = strTrim.call(elem.getAttribute('class') || ''),
          classes = trimmedClasses ? trimmedClasses.split(/\s+/) : [];

        for (var i = 0, len = classes.length; i < len; i++) {
          this.push(classes[i]);
        }
        this._updateClassName = function() {
          elem.setAttribute('class', this.toString());
        };
      },
      classListProto = (ClassList[protoProp] = []),
      classListGetter = function() {
        return new ClassList(this);
      };

    // Most DOMException implementations don't allow calling DOMException's toString()
    // on non-DOMExceptions. Error's toString() is sufficient here.
    DOMEx[protoProp] = Error[protoProp];
    classListProto.item = function(i) {
      return this[i] || null;
    };
    classListProto.contains = function(token) {
      return ~checkTokenAndGetIndex(this, token + '');
    };
    classListProto.add = function() {
      var tokens = arguments,
        i = 0,
        l = tokens.length,
        token,
        updated = false;

      do {
        token = tokens[i] + '';
        if (!~checkTokenAndGetIndex(this, token)) {
          this.push(token);
          updated = true;
        }
      } while (++i < l);

      if (updated) {
        this._updateClassName();
      }
    };
    classListProto.remove = function() {
      var tokens = arguments,
        i = 0,
        l = tokens.length,
        token,
        updated = false,
        index;

      do {
        token = tokens[i] + '';
        index = checkTokenAndGetIndex(this, token);
        while (~index) {
          this.splice(index, 1);
          updated = true;
          index = checkTokenAndGetIndex(this, token);
        }
      } while (++i < l);

      if (updated) {
        this._updateClassName();
      }
    };
    classListProto.toggle = function(token, force) {
      var result = this.contains(token),
        method = result ? force !== true && 'remove' : force !== false && 'add';

      if (method) {
        this[method](token);
      }

      if (force === true || force === false) {
        return force;
      } else {
        return !result;
      }
    };
    classListProto.replace = function(token, replacementToken) {
      var index = checkTokenAndGetIndex(token + '');
      if (~index) {
        this.splice(index, 1, replacementToken);
        this._updateClassName();
      }
    };
    classListProto.toString = function() {
      return this.join(' ');
    };

    if (objCtr.defineProperty) {
      var classListPropDesc = {
        get: classListGetter,
        enumerable: true,
        configurable: true
      };
      try {
        objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
      } catch (ex) {
        // IE 8 doesn't support enumerable:true
        // adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36
        // modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected
        if (ex.number === undefined || ex.number === -0x7ff5ec54) {
          classListPropDesc.enumerable = false;
          objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
        }
      }
    } else if (objCtr[protoProp].__defineGetter__) {
      elemCtrProto.__defineGetter__(classListProp, classListGetter);
    }
  })(window);
}

// There is full or partial native classList support, so just check if we need
// to normalize the add/remove and toggle APIs.

(function() {
  var testElement = document.createElement('_');

  testElement.classList.add('c1', 'c2');

  // Polyfill for IE 10/11 and Firefox <26, where classList.add and
  // classList.remove exist but support only one argument at a time.
  if (!testElement.classList.contains('c2')) {
    var createMethod = function(method) {
      var original = DOMTokenList.prototype[method]; // eslint-disable-line no-undef

      DOMTokenList.prototype[method] = function(token) {
        // eslint-disable-line no-undef
        for (var i = 0, len = arguments.length; i < len; i++) {
          token = arguments[i];
          original.call(this, token);
        }
      };
    };
    createMethod('add');
    createMethod('remove');
  }

  testElement.classList.toggle('c3', false);

  // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
  // support the second argument.
  if (testElement.classList.contains('c3')) {
    var _toggle = DOMTokenList.prototype.toggle; // eslint-disable-line no-undef

    DOMTokenList.prototype.toggle = function(token, force) {
      // eslint-disable-line no-undef
      if (1 in arguments && !this.contains(token) === !force) {
        return force;
      } else {
        return _toggle.call(this, token);
      }
    };
  }

  // replace() polyfill
  if (!('replace' in document.createElement('_').classList)) {
    DOMTokenList.prototype.replace = function(token, replacementToken) {
      // eslint-disable-line no-undef
      var tokens = this.toString().split(' '),
        index = tokens.indexOf(token + '');

      if (~index) {
        tokens = tokens.slice(index);
        this.remove.apply(this, tokens);
        this.add(replacementToken);
        this.add.apply(this, tokens.slice(1));
      }
    };
  }

  testElement = null;
})();
// endregion

/**
 * @module Scheduler/view/DependencyEditor
 */

/**
 * A dependency editor popup.
 *
 * @extends Common/widget/Popup
 * @private
 */
class DependencyEditor extends Popup {
  static get defaultConfig() {
    return {
      items: [],
      draggable: {
        handleSelector: ':not(button,.b-field-inner)' // blacklist buttons and field inners
      },
      axisLock: 'flexible'
    };
  }

  processWidgetConfig(widget) {
    const dependencyEditFeature = this.dependencyEditFeature;

    let fieldConfig = {};

    if (widget.ref === 'lagField' && !dependencyEditFeature.showLagField) {
      return false;
    }
    if (widget.ref === 'deleteButton' && !dependencyEditFeature.showDeleteButton) {
      return false;
    }

    Object.assign(widget, fieldConfig);

    return super.processWidgetConfig(widget);
  }

  afterShow(...args) {
    const deleteButton = this.widgetMap.deleteButton;

    // Only show delete button if the dependency record belongs to a store
    if (deleteButton) {
      deleteButton.hidden = !this.record.isPartOfStore();
    }
    super.afterShow(...args);
  }

  onInternalKeyDown(event) {
    this.trigger('keyDown', { event });
    super.onInternalKeyDown(event);
  }
}
DependencyEditor._$name = 'DependencyEditor';

/**
 * @module Scheduler/feature/DependencyEdit
 */

/**
 * Feature that displays a popup containing fields for editing a dependency. Requires the {@link Scheduler.feature.Dependencies Dependencies} feature to be enabled.
 *
 * This feature is **disabled** by default. It does **not** support vertical mode.
 *
 * @extends Common/mixin/InstancePlugin
 * @externalexample scheduler/Dependencies.js
 */

class DependencyEdit extends InstancePlugin {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * True to hide this editor if a click is detected outside it (defaults to true)
       * @config {Boolean}
       * @default
       * @category Editor
       */
      autoClose: true,

      /**
       * True to save and close this panel if ENTER is pressed in one of the input fields inside the panel.
       * @config {Boolean}
       * @default
       * @category Editor
       */
      saveAndCloseOnEnter: true,

      /**
       * True to show a delete button in the form.
       * @config {Boolean}
       * @default
       * @category Editor widgets
       */
      showDeleteButton: true,

      /**
       * The event that shall trigger showing the editor. Defaults to `dependencydblclick`, set to empty string or `null` to disable editing of dependencies.
       * @config {String}
       * @default
       * @category Editor
       */
      triggerEvent: 'dependencydblclick',

      /**
       * True to show the lag field for the dependency
       * @config {Boolean}
       * @default
       * @category Editor widgets
       */
      showLagField: false,

      dependencyRecord: null,

      /**
       * Default editor configuration, which widgets it shows etc.
       * @config {Object}
       * @category Editor
       */
      editorConfig: {
        title: 'L{Edit dependency}',
        localeClass: this,
        closable: true,

        items: [
          /**
           * Reference to the from name
           * @member {Common.widget.DisplayField} fromNameField
           * @readonly
           */
          {
            type: 'display',
            localeClass: this,
            label: 'L{From}',
            editable: false,
            ref: 'fromNameField'
          },
          /**
           * Reference to the to name field
           * @member {Common.widget.DisplayField} toNameField
           * @readonly
           */
          {
            type: 'display',
            localeClass: this,
            label: 'L{To}',
            ref: 'toNameField'
          },
          /**
           * Reference to the type field
           * @member {Common.widget.Combo} typeField
           * @readonly
           */
          {
            type: 'combo',
            localeClass: this,
            label: 'L{Type}',
            name: 'type',
            ref: 'typeField',
            editable: false,
            valueField: 'id',
            displayField: 'name',
            items: Object.keys(DependencyModel.Type).map((type) => {
              return {
                id: DependencyModel.Type[type],
                name: this.L(type)
              };
            })
          },

          /**
           * Reference to the lag field
           * @member {Common.widget.DurationField} lagField
           * @readonly
           */
          {
            type: 'duration',
            localeClass: this,
            label: 'L{Lag}',
            name: 'lag',
            ref: 'lagField'
          }
        ],

        bbar: [
          {
            type: 'widget',
            cls: 'b-label-filler'
          },
          /**
           * Reference to the save button, if used
           * @member {Common.widget.Button} saveButton
           * @readonly
           */
          {
            color: 'b-green',
            localeClass: this,
            text: 'L{Save}',
            ref: 'saveButton'
          },
          /**
           * Reference to the delete button, if used
           * @member {Common.widget.Button} deleteButton
           * @readonly
           */
          {
            color: 'b-gray',
            localeClass: this,
            text: 'L{Delete}',
            ref: 'deleteButton'
          },
          /**
           * Reference to the cancel button, if used
           * @member {Common.widget.Button} cancelButton
           * @readonly
           */
          {
            color: 'b-gray',
            localeClass: this,
            text: 'L{Cancel}',
            ref: 'cancelButton'
          }
        ]
      }
    };
  }

  //endregion

  //region Init & destroy

  construct(client, config) {
    const me = this;

    client.dependencyEdit = me;

    me.dependencyStore = client.dependencyStore;

    super.construct(client, config);

    if (!client.features.dependencies) {
      throw new Error('Dependencies feature required when using DependencyEdit');
    }

    me.clientListenersDetacher = client.on({
      [me.triggerEvent]: me.onActivateEditor,
      thisObj: me
    });
  }

  doDestroy() {
    this.clientListenersDetacher();

    this.editor && this.editor.destroy();

    super.doDestroy();
  }

  //endregion

  //region Editing

  get editorConfig() {
    return this._editorConfig;
  }

  set editorConfig(editorConfig) {
    const me = this,
      defaultEditorConfig = me.getDefaultConfiguration().editorConfig;

    // Apply editorConfig to the default editorConfig, allowing users to manipulate for example only bbar
    editorConfig = ObjectHelper.assign({}, defaultEditorConfig, editorConfig);

    editorConfig.items = editorConfig.items || [];

    me._editorConfig = editorConfig;
  }

  //endregion

  //region Save

  get isValid() {
    return Object.values(this.editor.widgetMap).every((field) => {
      if (!field.name || field.hidden) {
        return true;
      }

      return field.isValid !== false;
    });
  }

  get values() {
    const values = {};

    this.editor.eachWidget((widget) => {
      if (!widget.name || widget.hidden) return;

      values[widget.name] = widget.value;
    }, true);

    return values;
  }

  /**
   * Template method, intended to be overridden. Called before the dependency record has been updated.
   * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record
   *
   **/
  onBeforeSave(dependencyRecord) {}

  /**
   * Template method, intended to be overridden. Called after the dependency record has been updated.
   * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record
   *
   **/
  onAfterSave(dependencyRecord) {}

  /**
   * Updates record being edited with values from the editor
   * @private
   */
  updateRecord(dependency) {
    const values = this.values;

    dependency.beginBatch();

    dependency.set(values);

    if (this.lagField) {
      const lag = this.lagField.value;

      dependency.setLag(lag.magnitude, lag.unit);
    }

    if (this.typeField && 'type' in values) {
      dependency.set({ fromSide: null, toSide: null });
    }

    dependency.endBatch();
  }
  //endregion

  //region Events

  onPopupKeyDown({ event }) {
    if (event.key === 'Enter' && this.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === 'input') {
      // Need to prevent this key events from being fired on whatever receives focus after the editor is hidden
      event.preventDefault();

      this.onSaveClick();
    }
  }

  onSaveClick() {
    if (this.save()) {
      this.editor.hide();
    }
  }

  onDeleteClick() {
    this.deleteDependency();
    this.editor.hide();
  }

  onCancelClick() {
    this.editor.hide();
  }

  //region Editing

  // Called from editDependency() to actually show the editor
  internalShowEditor(dependencyRecord) {
    const me = this,
      scheduler = me.client;

    let showPoint = me.lastPointerDownCoordinate;

    /**
     * Fires on the owning Scheduler before an dependency is displayed in the editor.
     * This may be listened for to allow an application to take over dependency editing duties. Returning `false`
     * stops the default editing UI from being shown.
     * @event beforeDependencyEdit
     * @param {Scheduler.view.Scheduler} source The scheduler
     * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependencyEdit feature
     * @param {Scheduler.model.DependencyModel} dependencyRecord The record about to be shown in the editor.
     * @preventable
     */
    if (
      scheduler.trigger('beforeDependencyEdit', {
        dependencyEdit: me,
        dependencyRecord
      }) === false
    ) {
      return;
    }

    const editor = me.getEditor(dependencyRecord);

    me.loadRecord(dependencyRecord);

    /**
     * Fires on the owning Scheduler when the editor for a dependency is available but before it is shown. Allows
     * manipulating fields etc.
     * @event beforeDependencyEditShow
     * @param {Scheduler.view.Scheduler} source The scheduler
     * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependencyEdit feature
     * @param {Scheduler.model.DependencyModel} dependencyRecord The record about to be shown in the editor.
     * @param {Scheduler.view.DependencyEditor} editor The editor
     */
    scheduler.trigger('beforeDependencyEditShow', {
      dependencyEdit: me,
      dependencyRecord,
      editor
    });

    if (!showPoint) {
      const center = Rectangle.from(me.client.element).center;

      showPoint = [center.x - editor.width / 2, center.y - editor.height / 2];
    }

    editor.showByPoint(showPoint);
  }

  /**
   * Opens an {@link Scheduler.view.DependencyEditor DependencyEditor} to edit the passed dependency.
   * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency to edit
   */
  editDependency(dependencyRecord) {
    if (this.client.readOnly) return;

    this.internalShowEditor(dependencyRecord);
  }

  //endregion

  //region Save

  /**
   * Gets an editor instance. Creates on first call, reuses on consecutive
   * @internal
   * @returns {Scheduler.view.DependencyEditor} Editor popup
   */
  getEditor() {
    const me = this;

    let { editor } = me;

    if (editor) {
      return editor;
    }

    editor = me.editor = new DependencyEditor(
      ObjectHelper.assign(
        {
          dependencyEditFeature: me,
          autoShow: false,
          anchor: true,
          scrollAction: 'realign',
          clippedBy: [me.client.timeAxisSubGridElement, me.client.bodyContainer],
          constrainTo: window,
          autoClose: me.autoClose,
          cls: me.cls,
          listeners: {
            keydown: me.onPopupKeyDown,
            thisObj: me
          }
        },
        me.editorConfig
      )
    );

    if (editor.items.length === 0) {
      console.warn('Editor configured without any `items`');
    }

    // assign widget refs
    editor.eachWidget((widget) => {
      const ref = widget.ref || widget.id;
      // don't overwrite if already defined
      if (ref && !me[ref]) {
        me[ref] = widget;
      }
    });

    me.saveButton && me.saveButton.on('click', me.onSaveClick, me);
    me.deleteButton && me.deleteButton.on('click', me.onDeleteClick, me);
    me.cancelButton && me.cancelButton.on('click', me.onCancelClick, me);

    return me.editor;
  }

  //endregion

  //region Delete

  /**
   * Sets fields values from record being edited
   * @private
   */
  loadRecord(dependency) {
    const me = this;

    me.fromNameField.value = dependency.sourceEvent.name;
    me.toNameField.value = dependency.targetEvent.name;

    if (me.lagField) {
      me.lagField.unit = dependency.lagUnit;
    }

    me.editor.record = me.dependencyRecord = dependency;
  }

  //endregion

  //region Stores

  /**
   * Saves the changes (applies them to record if valid, if invalid editor stays open)
   * @private
   * @fires beforeDependencySave
   * @fires beforeDependencyAdd
   * @fires afterDependencySave
   * @returns {*}
   */
  save() {
    const me = this,
      { client, dependencyRecord } = me;

    if (!dependencyRecord || !me.isValid) return;

    const dependencyStore = me.dependencyStore,
      values = me.values;

    /**
     * Fires on the owning Scheduler before a dependency is saved
     * @event beforeDependencySave
     * @param {Scheduler.view.Scheduler} source The scheduler instance
     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be saved
     * @param {Object} values The new values
     * @preventable
     */
    if (
      client.trigger('beforeDependencySave', {
        dependencyRecord,
        values
      }) !== false
    ) {
      me.onBeforeSave(dependencyRecord);

      me.updateRecord(dependencyRecord);

      // Check if this is a new record
      if (dependencyStore && !dependencyRecord.stores.length) {
        /**
         * Fires on the owning Scheduler before a dependency is added
         * @event beforeDependencyAdd
         * @param {Scheduler.view.Scheduler} source The scheduler
         * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependency edit feature
         * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be added
         * @preventable
         */
        if (client.trigger('beforeDependencyAdd', { dependencyRecord, dependencyEdit: me }) !== false) {
          dependencyStore.add(dependencyRecord);
        } else {
          return;
        }
      }

      client.project && client.project.propagate();

      /**
       * Fires on the owning Scheduler after a dependency is successfully saved
       * @event afterDependencySave
       * @param {Scheduler.view.Scheduler} source The scheduler instance
       * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be saved
       */
      client.trigger('afterDependencySave', { dependencyRecord });
      me.onAfterSave(dependencyRecord);
    }

    return dependencyRecord;
  }

  /**
   * Delete dependency being edited
   * @private
   * @fires beforeDependencyDelete
   */
  deleteDependency() {
    const me = this;

    /**
     * Fires on the owning Scheduler before a dependency is deleted
     * @event beforeDependencyDelete
     * @param {Scheduler.view.Scheduler} source The scheduler instance
     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record about to be deleted
     * @preventable
     */
    if (me.client.trigger('beforeDependencyDelete', { dependencyRecord: me.dependencyRecord }) !== false) {
      if (me.editor.containsFocus) {
        me.editor.revertFocus();
      }

      me.client.dependencyStore.remove(me.dependencyRecord);
      me.client.project && me.client.project.propagate();

      return true;
    }

    return false;
  }

  //endregion

  //region Events

  onActivateEditor({ dependency, event }) {
    if (!this.disabled) {
      this.lastPointerDownCoordinate = [event.clientX, event.clientY];
      this.editDependency(dependency);
    }
  }

  //endregion

  /**
   * Disable this feature
   * @property {Boolean}
   */
  get disabled() {
    return this._disabled;
  }

  set disabled(disabled) {
    this._disabled = disabled;
  }
}

DependencyEdit._$name = 'DependencyEdit';
GridFeatureManager.registerFeature(DependencyEdit, false);

/**
 * @module Scheduler/feature/base/TimeSpanRecordContextMenuBase
 */

// This is a version of what Containers do, except that we have to apply our namedItems
// all the way down any configured menu hierarchy, and the resulting structure must
// be available *before* menu instantiation for the processItems method to interrogate.
const applyNamedItems = function(items, namedItems) {
  for (const ref in items) {
    let item = items[ref];
    if (item) {
      if (ref in namedItems) {
        item = items[ref] =
          typeof item === 'object' ? ObjectHelper.merge(ObjectHelper.clone(namedItems[ref]), item) : namedItems[ref];
      }

      // Our namedItems must apply all the way down any descendant menus.
      // Extract menu here because it may have been applied by a namedItem.
      const menu = item.menu;
      if (menu) {
        applyNamedItems('items' in menu ? menu.items : menu, namedItems);
      }
    }
  }
};

/**
 * Abstract base class used by other context menu features such as {@link Scheduler/feature/EventContextMenu EventContextMenu} and
 * {@link Scheduler/feature/ScheduleContextMenu ScheduleContextMenu}.
 * @extends Common/mixin/InstancePlugin
 * @abstract
 */
class TimeSpanRecordContextMenuBase extends InstancePlugin {
  //region Config
  static get defaultConfig() {
    return {
      /**
       * This is a preconfigured set of {@link Common.widget.Container#config-namedItems} used to create the default
       * context menu.
       * @config {Object}
       */
      defaultItems: null,

      /**
       * An {@link Common.widget.Menu Menu} items object containing named child menu items
       * to apply to the feature's provided context menu, see {@link #config-defaultItems}.
       *
       * This may add extra items as below, but may also remove any of the {@link #config-defaultItems}
       * by configuring the name of the item as `false`
       *
       * ```javascript
       * features : {
       *     taskContextMenu : { // use eventContextMenu in the Scheduler product
       *         // This object is applied to the Feature's predefined defaultItems object
       *         items : {
       *             switchToDog : {
       *                 text : 'Dog',
       *                 icon : 'b-fa b-fa-fw b-fa-dog',
       *                 onItem({contextRecord}) {
       *                     contextRecord.dog = true;
       *                     contextRecord.cat = false;
       *                 },
       *                 weight : 500     // Make this second from end
       *             },
       *             switchToCat : {
       *                 text : 'Cat',
       *                 icon : 'b-fa b-fa-fw b-fa-cat',
       *                 onItem({contextRecord}) {
       *                     contextRecord.dog = false;
       *                     contextRecord.cat = true;
       *                 },
       *                 weight : 510     // Make this sink to end
       *             },
       *             add : false // We do not want the "Add" submenu to be available
       *         }
       *     }
       * }
       * ```
       *
       * @config {Object|Object[]}
       */
      items: null,

      /**
       * A function called before displaying the menu that allows manipulations of its items. Called with a
       * single parameter with format { contextRecord, eventElement, items }. Returning `false`
       * from this function prevents the menu from being shown.
       *
       * ```javascript
       * features : {
       *     taskContextMenu : {
       *         processItems({contextRecord, items}) {
       *             // Add or remove items here as needed
       *             if (contextRecord.type === 'Meeting') {
       *                 items.cancel = {
       *                     text   : 'Cancel',
       *                     icon   : 'b-fa b-fa-fw b-fa-ban',
       *                     weight : 200 // Move to end
       *                 };
       *             }
       *
       *             // Hide delete for parents
       *             items.deleteTask.hidden = contextRecord.isParent;
       *         }
       *     }
       * }
       * ```
       *
       * @config {Function}
       */
      processItems: null
    };
  }

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['onElementContextMenu']
    };
  }

  //endregion

  //region Init

  doDestroy() {
    if (this.menu) {
      this.menu.destroy();
    }
  }

  //endregion

  //region Events

  /**
   * Called when user right clicks.
   * @param event
   * @fires eventContextMenuItem
   * @internal
   */
  onElementContextMenu(event) {
    const me = this,
      client = me.client,
      target = event.target,
      eventElement = DomHelper.up(target, client.eventSelector) || target;

    if (eventElement) {
      event.preventDefault();

      const record = me.resolveRecord(eventElement);

      if (record) {
        me.showContextMenuFor(record, { targetElement: eventElement, event });
      }
    }
  }

  //endregion

  /**
   * Shows context menu for the provided record. If record is not rendered (outside of time span, or collapsed)
   * menu won't appear.
   * @param {Scheduler.model.TimeSpan} record
   * @param {Object} [options]
   * @param {HTMLElement} options.targetElement Element to align context menu to
   * @param {Event} options.event Browser event. If provided menu will be aligned according to clientX/clientY coordinates.
   * If omitted, context menu will be centered to targetElement
   */
  showContextMenuFor(record, options) {}

  /**
   * @param {Object} eventParams
   * @param {Object[]} items
   * @protected
   * @internal
   */
  showContextMenu(eventParams) {
    const me = this,
      event = eventParams.event,
      menuType = eventParams.menuType.toLowerCase(),
      eventType = StringHelper.lowercaseFirstLetter(menuType),
      clientGetItemsMethod = `get${StringHelper.capitalizeFirstLetter(menuType)}MenuItems`,
      { client, processItems, defaultItems, namedItems } = me,
      point = event ? [event.clientX + 1, event.clientY + 1] : Rectangle.from(eventParams.targetElement).center,
      items = (eventParams.items = ObjectHelper.isEmpty(me.items)
        ? ObjectHelper.clone(defaultItems)
        : ObjectHelper.merge(ObjectHelper.clone(defaultItems), me.items));

    eventParams.namedItems = namedItems;
    eventParams.selection = client.selectedRecords;

    // Apply the named items prior to Container's item processing.
    // Our namedItems must cascade to all descendant Menu levels.
    // And they MUST have all been converted prior to the processItems call.
    applyNamedItems(items, namedItems);

    // Call the chainable method which other features use to add their own menu items.
    // For example getEventMenuItems
    if (client[clientGetItemsMethod]) {
      client[clientGetItemsMethod](eventParams, items);
    }

    // Allow user a chance at processing the items and preventing the menu from showing
    if ((!processItems || processItems(eventParams) !== false) && !ObjectHelper.isEmpty(eventParams.items)) {
      // beforeContextMenuShow is a lifecycle method which may be implemented in subclasses to
      // preprocess the event.
      if (me.beforeContextMenuShow(eventParams) !== false) {
        // Trigger event that allows preventing menu or manipulating its items
        if (client.trigger(`${eventType}ContextMenuBeforeShow`, eventParams) !== false) {
          me.menu = WidgetHelper.showContextMenu(point, {
            owner: client,
            scrollAction: 'hide',
            clippedBy: [client.timeAxisSubGridElement, client.bodyContainer],
            constrainTo: window,
            items,
            onDestroy() {
              me.menu = null;
            },
            // Load up the item event with the contextual info
            onBeforeItem: (itemEvent) => {
              Object.assign(itemEvent, eventParams);
            },

            onItem: (itemEvent) => client.trigger(`${eventType}ContextMenuItem`, itemEvent),

            listeners: {
              show({ source: menu }) {
                eventParams.menu = menu;
                client.trigger(`${eventType}ContextMenuShow`, eventParams);
              }
            }
          });
        }
      }
    }
  }

  // Implement in subclasses to massage options or veto show.
  beforeContextMenuShow() {}

  /**
   * Hides the context menu
   * @protected
   * @internal
   */
  hideContextMenu(animate) {
    this.menu && this.menu.hide(animate);
  }

  /**
   * Provides the default configuration of the context menu.
   *
   * Concrete classes must all provide their own defaultItems value in their defaultConfig blocks
   * @private
   */
  set defaultItems(defaultItems) {
    this._defaultItems = defaultItems;
  }

  get defaultItems() {
    const result = ObjectHelper.clone(this._defaultItems);

    // Read-only client should have no default items enabled
    if (this.client.readOnly) {
      for (let item in result) {
        result[item] = false;
      }
    }

    return result;
  }
}
TimeSpanRecordContextMenuBase._$name = 'TimeSpanRecordContextMenuBase';

/**
 * @module Scheduler/feature/EventContextMenu
 */

/**
 * Displays a context menu for events. Items are populated by other features and/or application code.
 *
 * To add extra items for all events (Array notation):
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         eventContextMenu : {
 *             // Extra items for all events
 *             items : [
 *                 {
 *                     text : 'Extra',
 *                     icon : 'b-fa b-fa-fw b-fa-flag',
 *                     onItem({eventRecord}) {
 *                         eventRecord.flagged = true;
 *                     }
 *                 }
 *             ]
 *         }
 *     }
 * });
 * ```
 *
 * To add extra items for all events (Object notation):
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         eventContextMenu : {
 *             // Extra items for all events
 *             items : {
 *                 extraItems : {
 *                     text : 'Extra',
 *                     icon : 'b-fa b-fa-fw b-fa-flag',
 *                     onItem({eventRecord}) {
 *                         eventRecord.flagged = true;
 *                     }
 *                 }
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * To remove existing items:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         eventContextMenu : {
 *             items : {
 *                 deleteEvent   : false,
 *                 unassignEvent : false
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * Manipulate existing items for all events or specific events:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         eventContextMenu : {
 *             // Process items before menu is shown
 *             processItems({eventRecord, items}) {
 *                  // Push an extra item for conferences
 *                  if (eventRecord.type === 'conference') {
 *                      items.showSessionItem = {
 *                          text : 'Show sessions',
 *                          onItem({eventRecord}) {
 *                              // ...
 *                          }
 *                      };
 *                  }
 *
 *                  // Do not show menu for secret events
 *                  if (eventRecord.type === 'secret') {
 *                      return false;
 *                  }
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * This feature is **enabled** by default
 *
 * @extends Scheduler/feature/base/TimeSpanRecordContextMenuBase
 * @demo eventcontextmenu
 */
class EventContextMenu extends TimeSpanRecordContextMenuBase {
  //region Config
  static get defaultConfig() {
    return {
      /**
       * An array of extra menu items to add to the context menu
       *
       * ```javascript
       * const scheduler = new Scheduler({
       *     features : {
       *         eventContextMenu : {
       *             // Extra items for all events
       *             items : [
       *                 {
       *                     text : 'Extra',
       *                     icon : 'b-fa b-fa-fw b-fa-flag',
       *                     onItem({eventRecord}) {
       *                         eventRecord.flagged = true;
       *                     }
       *                 }
       *             ]
       *         }
       *     }
       * });
       * ```
       *
       * or items config to add extra items to the context menu or hide default items
       *
       * ```javascript
       * const scheduler = new Scheduler({
       *     features : {
       *         eventContextMenu : {
       *             items : {
       *                 // Add custom 'Extra' item
       *                 extra : {
       *                     text : 'Extra',
       *                     icon : 'b-fa b-fa-fw b-fa-flag',
       *                     onItem({eventRecord}) {
       *                         eventRecord.flagged = true;
       *                     }
       *                 },
       *                 // Hide default 'Delete event' and 'Unassign event' items
       *                 deleteEvent   : false,
       *                 unassignEvent : false
       *             }
       *         }
       *     }
       * });
       * ```
       *
       * @config {Object|Object[]}
       */
      items: null,

      /**
       * A function called before displaying the menu that allows manipulations of its items.
       * Called with a single parameter with format { date, resourceRecord, items }.
       * Returning `false` from this function prevents the menu from being shown.
       *
       * ```javascript
       * features : {
       *     eventContextMenu : {
       *         // Process items before menu is shown
       *         processItems({eventRecord, items}) {
       *              // Push an extra item for conferences
       *              if (eventRecord.type === 'conference') {
       *                  items.showSessionItem = {
       *                      text : 'Show sessions',
       *                      onItem({eventRecord}) {
       *                          // ...
       *                      }
       *                  };
       *              }
       *
       *              // Do not show menu for secret events
       *              if (eventRecord.type === 'secret') {
       *                  return false;
       *              }
       *         }
       *     }
       * }
       * ```
       *
       * @config {Function}
       */
      processItems: null,

      /**
       * This is a preconfigured set of {@link Common.widget.Container#config-namedItems} used to create the default context menu.
       *
       * The provided defaultItems setting is
       *
       *```javascript
       *    {
       *        deleteEvent   : true,
       *        unassignEvent : true
       *    }
       *```
       *
       * The `namedItems` provided by this feature are listed below. These are the property
       * names which you may configure in the feature's {@link #config-items} config:
       *
       * - `deleteEvent` Deletes the context event.
       * - `unassignEvent` Unassigns the context event from the context resource.
       *
       * To remove existing items, set corresponding keys to `false`
       *
       * ```javascript
       * const scheduler = new Scheduler({
       *     features : {
       *         eventContextMenu : {
       *             items : {
       *                 deleteEvent   : false,
       *                 unassignEvent : false
       *             }
       *         }
       *     }
       * });
       * ```
       *
       * See the feature config in the above example for details.
       * @config {Object}
       */
      defaultItems: {
        deleteEvent: true,
        unassignEvent: true
      }
    };
  }
  //endregion

  //region Events

  /**
   * Fired from scheduler before the context menu is shown for an event. Allows manipulation of the items
   * to show in the same way as in `processItems`. Returning false from a listener prevents the menu from
   * being shown.
   * @event eventContextMenuBeforeShow
   * @preventable
   * @param {Scheduler.view.Scheduler} source
   * @param {Object} items Menu item configs
   * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered
   * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
   * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used
   * @param {HTMLElement} eventElement
   */

  /**
   * Fired from scheduler when an item is selected in the context menu.
   * @event eventContextMenuItem
   * @param {Scheduler.view.Scheduler} source
   * @param {Common.widget.MenuItem} item
   * @param {Scheduler.model.EventModel} eventRecord
   * @param {Scheduler.model.ResourceModel} resourceRecord
   * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used
   * @param {HTMLElement} eventElement
   */

  /**
   * Fired from scheduler after showing the context menu for an event
   * @event eventContextMenuShow
   * @preventable
   * @param {Scheduler.view.Scheduler} source
   * @param {Common.widget.Menu} menu The menu
   * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered
   * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
   * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used
   * @param {HTMLElement} eventElement
   */

  //endregion

  //region Events

  resolveRecord(element) {
    return this.client.resolveEventRecord(element);
  }

  //endregion

  /**
   * Shows context menu for the provided event. If record is not rendered (outside of time span/filtered)
   * menu won't appear.
   * @param {Scheduler.model.EventModel} eventRecord
   * @param {Object} [options]
   * @param {HTMLElement} options.targetElement Element to align context menu to
   * @param {Event} options.event Browser event. If provided menu will be aligned according to clientX/clientY coordinates.
   * If omitted, context menu will be centered to taskElement
   */
  showContextMenuFor(eventRecord, { targetElement, event } = {}) {
    const me = this,
      { client } = me;

    if (!targetElement) {
      targetElement = client.getElementsFromEventRecord(eventRecord)[0];

      // If record is not rendered, do nothing
      if (!targetElement) {
        return;
      }
    }

    me.showContextMenu({
      menuType: 'event',
      eventElement: targetElement,
      targetElement,
      eventRecord,
      resourceRecord: client.resolveResourceRecord(targetElement),
      assignmentRecord: client.resolveAssignmentRecord(targetElement),
      event
    });
  }

  set defaultItems(defaultItems) {
    this._defaultItems = defaultItems;
  }

  get defaultItems() {
    const result = super.defaultItems;

    if (!this.client.assignmentStore) {
      result.unassignEvent = false;
    }

    return result;
  }

  get namedItems() {
    const me = this,
      { client } = me;

    if (!me._namedItems) {
      me._namedItems = {
        deleteEvent: {
          text: client.L('Delete event'),
          icon: 'b-icon b-icon-trash',
          weight: -160,
          onItem: ({ menu, eventRecord }) => {
            // We must synchronously push focus back into the menu's triggering
            // event so that the our beforeRemove handlers can move focus onwards
            // to the closest remaining event.
            // Otherwise, the menu's default hide processing on hide will attempt
            // to move focus back to the menu's triggering event which will
            // by then have been deleted.
            const revertTarget = menu.focusInEvent && menu.focusInEvent.relatedTarget;
            if (revertTarget) {
              revertTarget.focus();
              client.navigator.activeItem = revertTarget;
            }
            client.removeRecords([eventRecord]);
          }
        },
        unassignEvent: {
          text: client.L('Unassign event'),
          icon: 'b-icon b-icon-unassign',
          weight: -150,
          name: 'unassignEvent',
          onItem: ({ menu, eventRecord, resourceRecord }) => {
            // We must synchronously push focus back into the menu's triggering
            // event so that the our beforeRemove handlers can move focus onwards
            // to the closest remaining event.
            // Otherwise, the menu's default hide processing on hide will attempt
            // to move focus back to the menu's triggering event which will
            // by then have been deleted.
            const revertTarget = menu.focusInEvent && menu.focusInEvent.relatedTarget;
            if (revertTarget) {
              revertTarget.focus();
              client.navigator.activeItem = revertTarget;
            }
            eventRecord.unassign(resourceRecord);
          }
        }
      };
    }

    return me._namedItems;
  }
}

EventContextMenu.featureClass = '';

EventContextMenu._$name = 'EventContextMenu';
GridFeatureManager.registerFeature(EventContextMenu, true, 'Scheduler');

//import styles from '../../../resources/sass/tooltip/clocktemplate.scss';

/**
 * @module Scheduler/tooltip/ClockTemplate
 */

/**
 * A template showing a clock, it consumes an object containing a date and a text
 * @private
 */
class ClockTemplate extends Base {
  static get defaultConfig() {
    return {
      minuteHeight: 8,
      minuteTop: 2,
      hourHeight: 8,
      hourTop: 2,
      handLeft: 10,
      timeAxisViewModel: null,
      template: function(data) {
        return `<div class="b-sch-clockwrap b-sch-clock-${this.mode} ${data.cls || ''}">
                    <div class="b-sch-clock">
                        <div class="b-sch-hour-indicator">${DateHelper.format(data.date, 'MMM')}</div>
                        <div class="b-sch-minute-indicator">${DateHelper.format(data.date, 'D')}</div>
                        <div class="b-sch-clock-dot"></div>
                    </div>
                    <span class="b-sch-clock-text">${data.text}</span>
                </div>`;
      }
    };
  }

  construct(config) {
    super.construct(config);

    this.timeAxisViewModelDetacher = this.timeAxisViewModel.on({
      update: this.onTimeAxisViewModelUpdate,
      thisObj: this
    });
  }

  doDestroy() {
    this.timeAxisViewModelDetacher && this.timeAxisViewModelDetacher();
  }

  onTimeAxisViewModelUpdate() {
    delete this._mode;
  }

  updateDateIndicator(tipEl, date) {
    const me = this,
      hourIndicatorEl = tipEl.querySelector('.b-sch-hour-indicator'),
      minuteIndicatorEl = tipEl.querySelector('.b-sch-minute-indicator');

    if (date && hourIndicatorEl && minuteIndicatorEl) {
      if (me.mode === 'hour') {
        hourIndicatorEl.style.transform = `rotate(${(date.getHours() % 12) * 30}deg)`;
        minuteIndicatorEl.style.transform = `rotate(${date.getMinutes() * 6}deg)`;
      } else {
        hourIndicatorEl.style.transform = 'none';
        minuteIndicatorEl.style.transform = 'none';
      }
    }
  }

  get mode() {
    // 'hour' for a clock view or 'day' for a calendar view
    return (
      this._mode ||
      (this._mode = DateHelper.compareUnits(this.timeAxisViewModel.timeResolution.unit, 'day') >= 0 ? 'day' : 'hour')
    );
  }

  set template(template) {
    this._template = template;
  }

  /**
   * Get the clock template, which accepts an object of format { date, text }
   * @returns {function(*): string}
   */
  get template() {
    return this._template;
  }
}
ClockTemplate._$name = 'ClockTemplate';

/**
 * @module Scheduler/feature/base/DragBase
 */

//TODO: shift to copy
//TODO: dragging of event that starts & ends outside of view

/**
 * Base class for EventDrag (Scheduler) and TaskDrag (Gantt) features. Contains shared code. Not to be used directly.
 *
 * @extends Common/mixin/InstancePlugin
 * @abstract
 */
class DragBase extends InstancePlugin {
  //region Config

  static get defaultConfig() {
    return {
      // documented on Schedulers EventDrag feature and Gantts TaskDrag
      dragTipTemplate: (data) => `
                <div class="b-sch-tip-${data.valid ? 'valid' : 'invalid'}">
                    ${data.startClockHtml}
                    ${data.endClockHtml}
                    <div class="b-sch-tip-message">${data.message}</div>
                </div>
            `,

      // documented on Schedulers EventDrag feature, not used for Gantt
      constrainDragToResource: true,

      /**
       * Specifies whether or not to show tooltip while dragging event
       * @config {Boolean}
       * @default
       */
      showTooltip: true,

      /**
       * When enabled, the event being dragged always "snaps" to the exact start date that it will have after drop.
       * @config {Boolean}
       * @default
       */
      showExactDropPosition: false,

      /**
       * Set to false to allow dragging tasks freely on the page, useful when you want to drag tasks between multiple Scheduler instances
       * @config {Boolean}
       * @default
       */
      constrainDragToTimeline: true,

      /*
       * The store from which the dragged items are mapped to the UI.
       * In Scheduler's implementation of this base class, this will be
       * an EventStore, in Gantt's implementations, this will be a TaskStore.
       * Because both derive from this base, we must refer to it as this.store.
       * @private
       */
      store: null,

      tooltipCls: null
    };
  }

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['render']
    };
  }

  //endregion

  //region Init

  /**
   * Called when scheduler is rendered. Sets up drag and drop and hover tooltip.
   * @private
   */
  render() {
    const me = this,
      view = me.client;

    if (me.drag) {
      me.drag.destroy();
    }

    me.drag = new DragHelper({
      name: me.constructor.name, // usefull when debugging with multiple draggers
      mode: 'translateXY',
      lockY: me.constrainDragToResource,
      minX: true, // Allows dropping before time axis
      constrain: false,
      cloneTarget: !me.constrainDragToTimeline,
      dragWithin: me.constrainDragToTimeline ? null : document.body,
      hideOriginalElement: true,
      outerElement: view.timeAxisSubGridElement,
      targetSelector: view.eventSelector,
      isElementDraggable: (el, event) => !view.readOnly && me.isElementDraggable(el, event),
      scrollManager: me.constrainDragToTimeline ? view.scrollManager : null,
      listeners: {
        beforedragstart: 'onBeforeDragStart',
        dragstart: 'onDragStart',
        drag: 'onDrag',
        drop: 'onDrop',
        abort: 'onDragAbort',
        reset: 'onDragReset',
        thisObj: me
      }
    });

    if (!me.constrainDragToResource) {
      view.rowManager.on({
        changeTotalHeight: 'updateYConstraint',
        thisObj: me
      });
    }

    if (me.showTooltip) {
      me.clockTemplate = new ClockTemplate({
        timeAxisViewModel: view.timeAxisViewModel
      });
    }
  }

  doDestroy() {
    const me = this;
    me.drag && me.drag.destroy();
    me.clockTemplate && me.clockTemplate.destroy();
    me.tip && me.tip.destroy();
    super.doDestroy();
  }

  //endregion

  //region Drag events

  onBeforeDragStart({ context, event }) {
    const me = this,
      client = me.client,
      name = client.scheduledEventName,
      eventRecord = client.resolveEventRecord(context.element);

    if (me.disabled || !eventRecord || !eventRecord.isDraggable) {
      return false;
    }

    return (
      client.trigger(`before${name}Drag`, {
        eventRecord,
        context: me.dragData
      }) !== false
    );
  }

  /**
   * Triggered when dragging of an event starts. Initializes drag data associated with the event being dragged.
   * @private
   */
  onDragStart({ context, event }) {
    const me = this,
      client = me.client,
      name = client.scheduledEventName;

    me.currentOverClient = client;
    me.scrollClients = {};

    me.onMouseOverNewTimeline(client);

    const dragData = (me.dragData = me.getDragData(context, event));

    if (me.showTooltip) {
      const tipTarget = dragData.context.dragProxy ? dragData.context.dragProxy.firstChild : context.element;

      if (!me.tip) {
        me.tip = new Tooltip({
          id: `${client.id}-event-drag-tip`,
          align: 'b-t',
          autoShow: true,
          clippedBy: me.constrainDragToTimeline ? [client.timeAxisSubGridElement, client.bodyContainer] : null,
          forElement: tipTarget,
          getHtml: me.getTipHtml.bind(me),
          // During drag, it must be impossible for the mouse to be over the tip.
          style: 'pointer-events:none',
          cls: me.tooltipCls
        });

        me.tip.on('innerhtmlupdate', me.updateDateIndicator, me);
      } else {
        me.tip.showBy(tipTarget);
      }
    }

    // me.copyKeyPressed = me.isCopyKeyPressed();
    //
    // if (me.copyKeyPressed) {
    //     dragData.refElements.addCls('sch-event-copy');
    //     dragData.originalHidden = true;
    // }

    // Trigger eventDragStart or taskDragStart depending on product
    client.trigger(`${name}DragStart`, {
      [`${name}Records`]: dragData.draggedRecords,
      context: dragData
    });
  }

  updateDateIndicator() {
    const { startDate, endDate } = this.dragData,
      tip = this.tip,
      endDateElement = tip.element.querySelector('.b-sch-tooltip-enddate');

    this.clockTemplate.updateDateIndicator(tip.element, startDate);

    endDateElement && this.clockTemplate.updateDateIndicator(endDateElement, endDate);
  }

  /**
   * Triggered while dragging an event. Updates drag data, validation etc.
   * @private
   */
  onDrag({ context, event }) {
    const me = this,
      dd = me.dragData,
      start = dd.startDate;

    let client;

    if (me.constrainToTimeline) {
      client = me.client;
    } else {
      let target = event.target;

      // Can't detect target under a touch event
      if (/^touch/.test(event.type)) {
        const center = Rectangle.from(dd.context.element, null, true).center;

        target = DomHelper.elementFromPoint(center.x, center.y);
      }

      client = IdHelper.fromElement(target, 'timelinebase');
    }

    const depFeature = me.client.features.dependencies,
      x = context.newX,
      y = context.newY;

    if (!client) {
      if (depFeature) {
        depFeature.updateDependenciesForTimeSpan(dd.draggedRecords[0], dd.context.element);
      }
      return;
    }

    if (client !== me.currentOverClient) {
      me.onMouseOverNewTimeline(client);
    }

    //this.checkShiftChange();

    me.updateDragContext(context, event);

    // Snapping not supported when dragging outside a scheduler
    if (me.constrainDragToTimeline && (me.showExactDropPosition || me.client.timeAxisViewModel.snap)) {
      const newDate = client.getDateFromCoordinate(me.getCoordinate(dd.draggedRecords[0], context.element, [x, y])),
        timeDiff = newDate - dd.sourceDate,
        realStart = new Date(dd.origStart - 0 + timeDiff),
        offset = client.timeAxisViewModel.getDistanceBetweenDates(realStart, dd.startDate);

      if (dd.startDate >= client.timeAxis.startDate && offset != null) {
        DomHelper.addTranslateX(context.element, offset);
      }
    }

    // Let product specific implementations trigger drag event (eventDrag, taskDrag)
    me.triggerEventDrag(dd, start);

    let valid = me.checkDragValidity(dd, event);

    if (valid && typeof valid !== 'boolean') {
      context.message = valid.message || '';
      valid = valid.valid;
    }

    context.valid = valid !== false;

    if (me.showTooltip) {
      me.tip.realign();
    }

    if (depFeature) {
      depFeature.updateDependenciesForTimeSpan(
        dd.draggedRecords[0],
        dd.context.element.querySelector(client.eventInnerSelector)
      );
    }
  }

  onMouseOverNewTimeline(newTimeline) {
    const me = this,
      scrollClients = me.scrollClients;

    me.currentOverClient.element.classList.remove('b-dragging-' + me.currentOverClient.scheduledEventName);

    newTimeline.element.classList.add('b-dragging-' + newTimeline.scheduledEventName);

    if (!(newTimeline.id in scrollClients)) {
      const scrollManager = newTimeline.scrollManager;

      scrollManager.startMonitoring({
        element: newTimeline.timeAxisSubGridElement
      });
      scrollClients[newTimeline.id] = newTimeline;
    }

    me.currentOverClient = newTimeline;
  }

  /**
   * Triggered when dropping an event. Finalizes the operation.
   * @private
   */
  onDrop({ context, event }) {
    const me = this,
      { currentOverClient, dragData } = me;

    if (!context.valid) {
      return me.onInvalidDrop({ context, event });
    }

    let modified = false;

    me.updateDragContext(context, event);

    if (me.tip) {
      me.tip.hide();
    }

    if (context.valid && dragData.startDate && dragData.endDate) {
      dragData.finalize = (...params) => {
        me.finalize(...params);
        context.finalize(...params);
      };

      // Allow implementer to take control of the flow, by returning false from this listener,
      // to show a confirmation popup etc. This event is documented in EventDrag and TaskDrag
      currentOverClient.trigger(`before${currentOverClient.capitalizedEventName}DropFinalize`, {
        context: dragData,
        event
      });

      context.async = dragData.async;

      // Internal validation, making sure all dragged records fit inside the view
      if (!context.async && me.isValidDrop(dragData)) {
        modified = dragData.startDate - dragData.origStart !== 0 || dragData.newResource !== dragData.resourceRecord;
      }
    }

    if (!context.async) {
      me.finalize(dragData.valid && context.valid && modified);
    }
  }

  onDragAbort({ context }) {
    this.client.currentOrientation.onDragAbort(context);

    if (this.tip) {
      this.tip.hide();
    }
  }

  /**
   * Triggered by drag handler on invalid drop, cleans up.
   * @private
   */
  onInvalidDrop() {
    const me = this;

    me.dragData.draggedRecords.forEach((record) => (record.instanceMeta(me.currentOverClient).retainElement = false));

    if (me.tip) {
      me.tip.hide();
    }
  }

  // For the drag across multiple schedulers, tell all involved scroll managers to stop monitoring
  onDragReset({ source: dragHelper }) {
    const me = this;

    for (const managerId in me.scrollClients || {}) {
      me.scrollClients[managerId].scrollManager.stopMonitoring(me.scrollClients[managerId].timeAxisSubGridElement);
    }

    if (dragHelper.context && dragHelper.context.started) {
      const { eventBarEls } = me.dragData;

      eventBarEls[0].classList.remove('b-drag-main');
    }

    me.scrollClients = null;

    if (me.currentOverClient) {
      me.currentOverClient.element.classList.remove('b-dragging-' + me.currentOverClient.scheduledEventName);
    }

    // Dependencies are updated dynamically during drag, so ensure they are redrawn
    // if the event snaps back with no change after abort or an invalid drop.
    if (me.dragData && !me.dragData.context.valid) {
      const dependencies = me.currentOverClient.features.dependencies;

      if (dependencies) {
        dependencies.scheduleDraw(true);
      }
    }

    // TODO we should clean this up, requires review of the flow first
    // me.dragData = null;
  }

  /**
   * Triggered internally on invalid drop.
   * @private
   */
  onInternalInvalidDrop() {
    const me = this,
      { currentOverClient } = me;

    if (me.tip) {
      me.tip.hide();
    }

    me.drag.abort();

    // Documented on EventDrag & TaskDrag features
    currentOverClient.trigger(`after${currentOverClient.capitalizedEventName}Drop`, {
      [currentOverClient.scheduledEventName + 'Records']: me.dragData.draggedRecords,
      valid: false,
      context: me.dragData
    });
  }

  //endregion

  //region Finalization & validation

  /**
   * Called on drop to update the record of the event being dropped.
   * @private
   * @param {Boolean} updateRecords Specify true to update the record, false to treat as invalid
   */
  async finalize(updateRecords) {
    const me = this,
      { currentOverClient: client, dragData } = me,
      { context, draggedRecords } = dragData;

    let result;

    draggedRecords.forEach((record, i) => {
      // Clear flag which makes the event not rerender
      record.instanceMeta(client).retainElement = false;

      // Ensure the dragged elements are available from the EventMapper's cache
      // It won't return an event that is in use by dragging.
      dragData.eventBarEls[i].classList.remove(me.drag.draggingCls);
    });

    if (updateRecords) {
      // updateRecords may or may not be async.
      // We see if it returns a Promise.
      result = me.updateRecords(dragData);

      // If updateRecords is async, the calling DragHelper must know this and
      // go into a awaitingFinalization state.
      if (result instanceof Promise) {
        context.async = true;
        await result;
      }

      // If the finalize handler decided to change the dragData's validity...
      if (!dragData.valid) {
        me.onInternalInvalidDrop();
      } else {
        me.drag.reset();

        // Trigger afterEventDrop or afterTaskDrop depending on product
        client.trigger(`after${client.capitalizedEventName}Drop`, {
          [`${client.scheduledEventName}Records`]: draggedRecords,
          valid: true,
          context: dragData
        });
      }
    } else {
      me.onInternalInvalidDrop();
    }

    return result;
  }

  //endregion

  //region Drag data

  /**
   * Updates drag datas dates and validity (calls #validatorFn if specified)
   * @private
   */
  updateDragContext(info, event) {
    const me = this,
      dd = me.dragData,
      client = me.currentOverClient,
      x = info.newX,
      y = info.newY,
      cx = info.clientX,
      cy = info.clientY,
      element = info.element,
      proxyRegion = Rectangle.from(element, client.timeAxisSubGridElement),
      record = dd.draggedRecords[0],
      eventRecord = record.isAssignment ? record.event : record;

    dd.browserEvent = event;

    if (client.timeAxis.isContinuous) {
      let newDate = client.getDateFromCoordinate(me.getCoordinate(eventRecord, element, [cx, cy]), null, false);

      // Date not found if mouse outside of schedule
      if (!newDate) {
        // Date at right edge (endDate), using local coords
        newDate = client.getDateFromCoordinate(me.getCoordinate(eventRecord, element, [x + element.offsetWidth, y]));

        // Also out of time axis? Flag as invalid
        if (!newDate) {
          dd.context.valid = false;
          return;
        }

        // Subtract duration to get startDate
        newDate = DateHelper.add(newDate, -eventRecord.duration, eventRecord.durationUnit);
        dd.timeDiff = newDate - dd.sourceDate;
      } else {
        dd.timeDiff = newDate - dd.screenSourceDate;
      }

      // calculate and round new startDate based on actual dd.timeDiff
      dd.startDate = me.adjustStartDate(dd.origStart, dd.timeDiff);
      dd.endDate = new Date(dd.startDate - 0 + dd.duration);
    } else {
      const range = me.resolveStartEndDates(proxyRegion);

      dd.startDate = range.startDate;
      dd.endDate = range.endDate;

      dd.timeDiff = dd.startDate - dd.origStart;
    }

    Object.assign(dd, me.getProductDragContext(dd));

    if (dd.valid && dd.endDate > client.timeAxis.startDate && dd.startDate < client.timeAxis.endDate) {
      const result = !event || me.checkDragValidity(dd, event);

      if (!result || typeof result === 'boolean') {
        dd.context.valid = result !== false;
        dd.context.message = '';
      } else {
        dd.context.valid = result.valid !== false;
        dd.context.message = result.message;
      }
    } else {
      dd.context.valid = false;
    }
  }

  /**
   * Initializes drag data (dates, constraints, dragged events etc). Called when drag starts.
   * @private
   * @param info
   * @param event
   * @returns {*}
   */
  getDragData(info, event) {
    const me = this,
      client = me.client,
      { record, dateConstraints, eventBarEls, draggedRecords } = me.setupProductDragData(info);

    let origStart = record.startDate,
      origEnd = record.endDate,
      timeAxis = client.timeAxis,
      startsOutsideView = origStart < timeAxis.startDate,
      endsOutsideView = origEnd > timeAxis.endDate;

    const coordinate = me.getCoordinate(record, info.element, [info.elementStartX, info.elementStartY]),
      clientCoordinate = me.getCoordinate(record, info.element, [info.startClientX, info.startClientY]);

    // prevent elements from being released when out of view
    draggedRecords.forEach((record) => (record.instanceMeta(client).retainElement = true));

    // Select current without deselecting other events if Ctrl key is pressed
    if (me.drag.startEvent.ctrlKey) {
      me.client.selectEvent(draggedRecords[0], true);
    }

    const dragData = {
      context: info,

      dateConstraints,

      eventBarEls,

      record,
      draggedRecords,

      sourceDate: startsOutsideView ? origStart : client.getDateFromCoordinate(coordinate),
      screenSourceDate: client.getDateFromCoordinate(clientCoordinate, null, false),
      origStart: origStart,
      origEnd: origEnd,
      startDate: origStart,
      endDate: origEnd,
      timeDiff: 0,

      startsOutsideView,
      endsOutsideView,

      duration: origEnd - origStart,
      browserEvent: event // So we can know if SHIFT/CTRL was pressed
    };

    eventBarEls.forEach((el, i) => {
      el.classList.add(me.drag.draggingCls);
      el.classList.remove('b-sch-event-hover');
      el.classList.remove('b-active');
      el.classList.remove('b-first-render');
    });

    if (eventBarEls.length > 1) {
      // RelatedElements are secondary elements moved by the same delta as the grabbed element
      info.relatedElements = eventBarEls.slice(1);
      info.relatedElStartPos = [];
      info.relatedElDragFromPos = [];

      // Move the selected events into a unified cascade.
      if (me.unifiedDrag) {
        // EventBarEls should animate into the cascade
        me.client.isAnimating = true;

        EventHelper.on({
          element: eventBarEls[1],
          transitionend: (e) => {
            me.client.isAnimating = false;
          },
          once: true
        });

        // Main dragged element should not look different. The relatedElements do.
        eventBarEls[0].classList.add('b-drag-main');

        let [x, y] = DomHelper.getTranslateXY(info.element);

        info.relatedElements.forEach((el, i) => {
          // Cache the start pos for reversion in case of invalid drag
          info.relatedElStartPos[i] = DomHelper.getTranslateXY(el);

          // Move into cascade and cache the dragFrom pos
          x += 10;
          y += 10;
          DomHelper.setTranslateXY(el, x, y);
          info.relatedElDragFromPos[i] = [x, y];
        });
      } else {
        // Start pos and dragFrom pos are the same for non-unified
        info.relatedElements.forEach((el, i) => {
          info.relatedElStartPos[i] = info.relatedElDragFromPos[i] = DomHelper.getTranslateXY(el);
        });
      }
    }

    return dragData;
  }

  // Provide your custom implementation of this to allow additional selected records to be dragged together with the original one.
  getRelatedRecords(record) {
    return [];
  }

  //endregion

  //region Constraints

  // private
  setupConstraints(constrainRegion, elRegion, tickSize, constrained) {
    const me = this,
      xTickSize = !me.showExactDropPosition && tickSize > 1 ? tickSize : 0,
      yTickSize = 0;

    // if `constrained` is false then we haven't specified getDateConstraint method and should constrain mouse position to scheduling area
    // else we have specified date constraints and so we should limit mouse position to smaller region inside of constrained region using offsets and width.
    if (constrained) {
      me.setXConstraint(constrainRegion.left, constrainRegion.right - elRegion.width, xTickSize);
    }
    me.setYConstraint(constrainRegion.top, constrainRegion.bottom - elRegion.height, yTickSize);
  }

  updateYConstraint() {
    const me = this,
      { dragData } = me,
      { context } = me.drag;

    // If we're dragging when the vertical size is recalculated by the host grid,
    // we must update our Y constraint
    if (context) {
      const constrainRegion = me.scheduler.getScheduleRegion(null, dragData.record);

      me.setYConstraint(constrainRegion.top, constrainRegion.bottom - context.grabbed.offsetHeight, 0);
    }
  }

  setXConstraint(iLeft, iRight, iTickSize) {
    const me = this,
      drag = me.drag;

    drag.leftConstraint = iLeft;
    drag.rightConstraint = iRight;

    drag.minX = iLeft;
    drag.maxX = iRight;
  }

  setYConstraint(iUp, iDown, iTickSize) {
    const me = this,
      drag = me.drag;

    drag.topConstraint = iUp;
    drag.bottomConstraint = iDown;

    drag.minY = iUp;
    drag.maxY = iDown;
  }

  //endregion

  //region Other stuff

  adjustStartDate(startDate, timeDiff) {
    return this.client.timeAxis.roundDate(
      new Date(startDate - 0 + timeDiff),
      this.client.snapRelativeToEventStartDate ? startDate : false
    );
  }

  resolveStartEndDates(proxyRect) {
    let dd = this.dragData,
      startEnd,
      start = dd.origStart,
      end = dd.origEnd;

    if (!dd.startsOutsideView) {
      startEnd = this.client.getStartEndDatesFromRectangle(proxyRect, 'round');
      if (startEnd) {
        start = startEnd.start || dd.startDate;
        end = DateHelper.add(start, dd.duration, 'ms');
      }
    } else if (!dd.endsOutsideView) {
      startEnd = this.client.getStartEndDatesFromRectangle(proxyRect, 'round');
      if (startEnd) {
        end = startEnd.end || dd.endDate;
        start = DateHelper.add(end, -dd.duration, 'ms');
      }
    }

    return {
      startDate: start,
      endDate: end
    };
  }

  //endregion

  //region Dragtip

  /**
   * Gets html to display in tooltip while dragging event. Uses clockTemplate to display start & end dates.
   */
  getTipHtml() {
    const me = this,
      { startDate, endDate, draggedRecords } = me.dragData,
      startText = me.client.getFormattedDate(startDate),
      endText = me.client.getFormattedEndDate(endDate, startDate),
      { valid, message } = me.dragData.context;

    return me.dragTipTemplate({
      valid,
      startDate,
      endDate,
      startText,
      endText,
      message: message || '',
      [me.client.scheduledEventName + 'Record']: draggedRecords[0],
      dragData: me.dragData,
      startClockHtml: me.clockTemplate.template({
        date: startDate,
        text: startText,
        cls: 'b-sch-tooltip-startdate'
      }),
      endClockHtml: draggedRecords[0].isMilestone
        ? ''
        : me.clockTemplate.template({
            date: endDate,
            text: endText,
            cls: 'b-sch-tooltip-enddate'
          })
    });
  }

  //endregion

  /**
   * Disable this feature
   * @property {Boolean}
   */
  get disabled() {
    return this._disabled;
  }

  set disabled(disabled) {
    this._disabled = disabled;
  }

  //region Product specific, implemented in subclasses

  // Check if element can be dropped at desired location
  isValidDrop(dragData) {
    throw new Error('Implement in subclass');
  }

  // Similar to the fn above but also calls validatorFn
  checkDragValidity(dragData) {
    throw new Error('Implement in subclass');
  }

  // Update records being dragged
  updateRecords(context) {
    throw new Error('Implement in subclass');
  }

  // Determine if an element can be dragged
  isElementDraggable(el, event) {
    throw new Error('Implement in subclass');
  }

  // Get coordinate for correct axis
  getCoordinate(record, element, coord) {
    throw new Error('Implement in subclass');
  }

  // Product specific drag data
  setupProductDragData(info) {
    throw new Error('Implement in subclass');
  }

  // Product specific data in drag context
  getProductDragContext(dd) {
    throw new Error('Implement in subclass');
  }

  //endregion
}
DragBase._$name = 'DragBase';

/**
 * @module Scheduler/feature/EventDrag
 */

const nullResourceArray = [null];

//TODO: relay events as in Dependencies. (drag -> eventdrag etc)
//TODO: shift to copy
//TODO: dragging of event that starts & ends outside of view

/**
 * Allows user to drag and drop events within the scheduler, to change startDate or resource assignment.
 *
 * This feature is **enabled** by default
 *
 * @example
 * // constrain drag to current resource
 * let scheduler = new Scheduler({
 *   features: {
 *     eventDrag: {
 *       constrainDragToResource: true
 *     }
 *   }
 * });
 *
 * @extends Scheduler/feature/base/DragBase
 * @demo basic
 * @externalexample scheduler/EventDrag.js
 */
class EventDrag extends DragBase {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Template used to generate drag tooltip contents.
       * ```
       * const scheduler = new Scheduler({
       *   features : {
       *     eventDrag : {
       *       dragTipTemplate({eventRecord, startText}) {
       *         return `${eventRecord.name}: ${startText}`
       *       }
       *     }
       *   }
       * });
       * ```
       * @config {Function} dragTipTemplate
       * @param {Object} data Tooltip data
       * @param {Scheduler.model.EventModel} data.eventRecord
       * @param {Boolean} data.valid Currently over a valid drop target or not
       * @param {Date} data.startDate New start date
       * @param {Date} data.endDate New end date
       * @param {String} data.startText Formatted new start date
       * @param {String} data.endText Formatted new end date
       * @param {String} data.startClockHtml Pre-generated HTML to display startDate as clock/calendar
       * @param {String} data.endClockHtml Pre-generated HTML to display endDate as clock/calendar
       * @param {Object} data.dragData Detailed drag context
       * @returns {String}
       */

      /**
       * Set to true to only allow dragging events within the same resource.
       * @config {Boolean}
       * @default
       */
      constrainDragToResource: false,

      /**
       * An empty function by default, but provided so that you can perform custom validation on
       * the item being dragged. This function is called during the drag and drop process and also after the drop is made.
       * Return true if the new position is valid, false to prevent the drag.
       * @param {Object} context A drag drop context object containing { draggedRecords, startDate, endDate, newResource }
       * @param {Event} e The event object
       * @return {Boolean}
       * @config {Function}
       */
      validatorFn: () => {},

      /**
       * The `this` reference for the validatorFn
       * @config {Object}
       */
      validatorFnThisObj: null,

      /**
       * When the host Scheduler is `{@link Scheduler.view.mixin.EventSelection#config-multiEventSelect multiEventSelect}: true`
       * then, there are two modes of dragging *within the same Scheduler*.
       *
       * Non unified means that all selected events are dragged by the same number of resource rows.
       *
       * Unified means that all selected events are collected together and dragged as one, and are all dropped
       * on the same targeted resource row at the same targeted time.
       * @config {Boolean}
       * @default false
       */
      unifiedDrag: null
    };
  }

  //endregion

  //region Events

  /**
   * Fired on the owning Scheduler to allow implementer to prevent immediate finalization by setting `data.context.async = true`
   * in the listener, to show a confirmation popup etc
   * ```
   *  scheduler.on('beforeeventdropfinalize', ({context}) => {
   *      context.async = true;
   *      setTimeout(() => {
   *          // async code don't forget to call finalize
   *          context.finalize();
   *      }, 1000);
   *  })
   * ```
   * @event beforeEventDropFinalize
   * @param {Scheduler.view.Scheduler} source Scheduler instance
   * @param {Object} context
   * @param {Boolean} context.async Set true to handle dragdrop asynchronously (e.g. to wait for user
   * @param {Scheduler.model.EventModel} context.targetEventRecord Event record for drop target
   * @param {Scheduler.model.ResourceModel} context.newResource Resource record for drop target
   * confirmation)
   * @param {Function} context.finalize Call this method to finalize dragdrop. This method accepts one
   * argument: pass true to update records, or false, to ignore changes
   */

  /**
   * Fired on the owning Scheduler after event drop
   * @event afterEventDrop
   * @param {Scheduler.view.Scheduler} source
   * @param {Scheduler.model.EventModel[]} eventRecords
   * @param {Boolean} valid
   * @param {Object} context
   */

  /**
   * Fired on the owning Scheduler when an event is dropped
   * @event eventDrop
   * @param {Scheduler.view.Scheduler} source
   * @param {Scheduler.model.EventModel[]} eventRecords
   * @param {Boolean} isCopy
   * @param {Object} context
   * @param {Scheduler.model.EventModel} context.targetEventRecord Event record for drop target
   * @param {Scheduler.model.ResourceModel} context.newResource Resource record for drop target
   */

  /**
   * Fired on the owning Scheduler before event dragging starts. Return false to prevent the action
   * @event beforeEventDrag
   * @param {Scheduler.view.Scheduler} source
   * @param {Scheduler.model.EventModel} eventRecord
   * @param {Object} context
   */

  /**
   * Fired on the owning Scheduler when event dragging starts
   * @event eventDragStart
   * @param {Scheduler.view.Scheduler} source
   * @param {Scheduler.model.EventModel[]} eventRecords
   * @param {Object} context
   */

  /**
   * Fired on the owning Scheduler when event is dragged
   * @event eventDrag
   * @param {Scheduler.view.Scheduler} source
   * @param {Scheduler.model.EventModel[]} eventRecords
   * @param {Date} startDate
   * @param {Date} endDate
   * @param {Scheduler.model.ResourceModel} newResource
   * @param {Object} context
   */

  //endregion

  //region Init

  construct(scheduler, config) {
    this.scheduler = scheduler;
    this.store = scheduler.eventStore;

    super.construct(scheduler, config);
  }

  //endregion

  //region Drag events

  isElementDraggable(el, event) {
    const { scheduler } = this,
      eventElement = DomHelper.up(el, scheduler.eventSelector),
      { eventResize } = scheduler.features;

    if (!eventElement) {
      return false;
    }

    // displaying something resizable within the event?
    if (el.matches('[class$="-handle"]')) {
      return false;
    }

    const eventRecord = scheduler.resolveEventRecord(eventElement);

    // using EventResize and over a virtual handle?
    // Milestones cannot be resized
    if (eventResize && !eventRecord.isMilestone && eventResize.resize.overAnyHandle(event, eventElement)) {
      return false;
    }

    return true;
  }

  triggerEventDrag(dd, start) {
    // If there has been a change...
    if (dd.startDate - start !== 0 || dd.newResource !== dd.resourceRecord) {
      this.scheduler.trigger('eventDrag', {
        eventRecords: dd.draggedRecords,
        startDate: dd.startDate,
        endDate: dd.endDate,
        newResource: dd.newResource,
        context: dd
      });
    }
  }

  onDragStart({ context, event }) {
    const eventContextMenuFeature = this.client.features.eventContextMenu;

    super.onDragStart({ context, event });

    // If this is a touch action, hide the context menu which may have shown
    if (eventContextMenuFeature) {
      eventContextMenuFeature.hideContextMenu(false);
    }
  }

  //endregion

  //region Finalization & validation

  /**
   * Checks if an event can be dropped on the specified resource.
   * @private
   * @returns {Boolean} Valid (true) or invalid (false)
   */
  isValidDrop(dragData) {
    const { newResource, resourceRecord } = dragData;
    let sourceRecord = dragData.draggedRecords[0];

    // Not allowed to drop an event to group header
    if (newResource.meta.specialRow) {
      return false;
    }

    // Not allowed to assign an event twice to the same resource -
    // which might happen when we deal with an assignment store
    if (resourceRecord !== newResource) {
      // if we operate assignments
      if (sourceRecord instanceof AssignmentModel) {
        sourceRecord = sourceRecord.event;
      }

      return !sourceRecord.isAssignedTo(newResource);
    }

    return true;
  }

  checkDragValidity(dragData, event) {
    const me = this,
      scheduler = this.currentOverClient;

    // First make sure DragHelper thinks it's a valid drag, then scheduler domain checks
    return (
      me.dragData.context.valid &&
      (scheduler.allowOverlap ||
        scheduler.isDateRangeAvailable(
          dragData.startDate,
          dragData.endDate,
          dragData.draggedRecords[0],
          dragData.newResource
        )) &&
      me.validatorFn.call(me.validatorFnThisObj || me, dragData, event)
    );
  }

  //endregion

  //region Update records

  /**
   * Update events being dragged.
   * @private
   * @param context Drag data.
   */
  updateRecords(context) {
    const me = this,
      fromScheduler = me.scheduler,
      toScheduler = me.currentOverClient,
      copyKeyPressed = false, //me.isCopyKeyPressed(),
      { assignmentStore } = fromScheduler,
      { draggedRecords } = context;

    // Multiple assignment mode
    if (assignmentStore) {
      if (toScheduler !== fromScheduler) {
        throw new Error('Assignments cannot be dragged cross-scheduler');
      }
      me.updateRecordsMultipleAssignmentMode(fromScheduler, toScheduler, context, copyKeyPressed);
    }
    // Single assignment mode
    else {
      me.updateRecordsSingleAssignmentMode(fromScheduler, toScheduler, context, copyKeyPressed);
    }

    // Tell the world there was a successful drop
    toScheduler.trigger('eventDrop', {
      eventRecords: draggedRecords,
      isCopy: copyKeyPressed,
      event: context.browserEvent,
      targetEventRecord: context.targetEventRecord,
      targetResourceRecord: context.newResource,
      context
    });
  }

  /**
   * Update records being dragged, gantt mode. Sets resource and start date.
   * @private
   */
  updateRecordsSingleAssignmentMode(fromScheduler, toScheduler, context, copy) {
    // The code is written to emit as few store events as possible
    const me = this,
      isCrossScheduler = fromScheduler !== toScheduler,
      { eventStore: fromEventStore, resourceStore } = fromScheduler,
      { draggedRecords, timeDiff, resourceRecord: fromResource, newResource: toResource } = context,
      unifiedDrag = me.unifiedDrag || (isCrossScheduler && draggedRecords.length > 1),
      toAdd = [],
      // By how many resource rows has the drag moved.
      indexDiff = me.constrainDragToResource
        ? 0
        : resourceStore.indexOf(fromResource) - resourceStore.indexOf(toResource),
      event1Date = me.adjustStartDate(draggedRecords[0].startDate, timeDiff);

    let updated;

    draggedRecords.forEach((draggedEvent, i) => {
      const eventBar = context.eventBarEls[i],
        oldGeneration = draggedEvent.generation,
        // grabbing resources early, since after ".copy()" the record won't belong to any store
        // and ".getResources()" won't work. If it's a move to another scheduler, ensure the
        // array still has a length. The process function will do an assign as opposed
        // to a reassign
        relatedResources = isCrossScheduler ? nullResourceArray : draggedEvent.resources;

      // If changing resource, the element wont be found in SchedulerStores#onEventBeforeCommit and thus the
      // committing cls wont be applied. Apply it here, in case we are using a backend. If we are not, it will be
      // replaced anyway on the immediate redraw
      eventBar.querySelector(fromScheduler.eventInnerSelector).classList.add(fromScheduler.committingCls);

      if (copy) {
        draggedEvent = draggedEvent.fullCopy(null);
        toAdd.push(draggedEvent);
      } else if (fromEventStore !== toScheduler.eventStore) {
        // Removing deassigns events from their resources
        fromEventStore.remove(draggedRecords);

        // This will not affect the UI because the events are not assigned to any resource
        toScheduler.eventStore.add(draggedRecords);

        // Make the event mapper reuse this element
        draggedEvent.instanceMeta(toScheduler).fromDragProxy = true;
      }

      // Process original dragged record
      draggedEvent.beginBatch();

      // calculate new startDate (and round it) based on timeDiff
      let newStartDate = unifiedDrag ? event1Date : me.adjustStartDate(draggedEvent.startDate, timeDiff);

      (indexDiff !== 0 || unifiedDrag || isCrossScheduler) &&
        relatedResources.length &&
        relatedResources.forEach((r) => {
          let newResource = toResource;

          // If not dragging events as a unified block, distribute each to a new resource
          // using the same offset as the dragged event.
          if (!unifiedDrag && !isCrossScheduler) {
            let newIndex = resourceStore.indexOf(r) - indexDiff;

            if (newIndex < 0) {
              newIndex = 0;
            } else if (newIndex >= resourceStore.getCount()) {
              newIndex = resourceStore.getCount() - 1;
            }

            newResource = resourceStore.getAt(newIndex);
          }

          if (r) {
            draggedEvent.reassign(r, newResource);
          } else {
            draggedEvent.assign(newResource);
          }

          const newId = toScheduler.getEventRenderId(draggedEvent, newResource);

          // Ensure the element gets preferentially reused for its own new render
          // when batching of its changes is ended and it fires events through its eventStore
          if (newId) {
            // If it's cross-scheduler, the element has to be moved into the element
            // recycling cache of the toScheduler, and positioned in its foregroundCanvas
            if (isCrossScheduler) {
              const elRect = Rectangle.from(context.context.element, toScheduler.foregroundCanvas, true),
                clone = context.context.element.cloneNode(true);

              // Ensure that after inserting the dragged element clone into the toScheduler's foregoundCanvas
              // it's at the same visual position that it was dragged to.
              DomHelper.setTranslateXY(clone, elRect.x, elRect.y);
              clone.classList.remove('b-first-render');
              clone.classList.remove('b-active');
              clone.classList.remove('b-drag-proxy');
              clone.classList.remove('b-dragging');

              // This puts a clone of the dragged element into the toScheduler's recycling cache
              // *AND* inserts it into the toScheduler's foregroundCanvas.
              toScheduler.currentOrientation.cacheTimeSpanElement(draggedEvent, newResource, clone);
            } else {
              toScheduler.currentOrientation.releaseTimeSpanDiv(eventBar, true);
              toScheduler.currentOrientation.updateElementId(eventBar, newId);
            }
          }
        });

      draggedEvent.setStartDate(newStartDate, true, fromEventStore.skipWeekendsDuringDragDrop);

      draggedEvent.endBatch();

      // We need to know whether we have successfully made an update in order to
      // sync the dragContext's valid flag.
      if (draggedEvent.generation !== oldGeneration) {
        updated = true;
      }
    });

    if (toAdd.length) {
      const count = fromEventStore.count;
      fromEventStore.add(toAdd);
      if (fromEventStore.count !== count) {
        updated = true;
      }
    }

    if (!updated) {
      context.valid = false;
    }
  }

  /**
   * Update records being dragged, scheduler mode. Sets resource and start date.
   * @private
   */
  updateRecordsMultipleAssignmentMode(fromScheduler, toScheduler, context, copy) {
    const me = this,
      isCrosScheduler = fromScheduler !== toScheduler,
      { eventStore } = fromScheduler,
      { draggedRecords, timeDiff, resourceRecord: fromResource, newResource: toResource } = context,
      // In case multiSelect is true, several assignments to one event may be processed here. We will store
      // ids of processed events here to avoid setting incorrect start date
      handledEventsMap = {};

    let updated;

    draggedRecords.forEach((assignment, i) => {
      const event = assignment.event,
        eventBar = context.eventBarEls[i],
        oldGeneration = event.generation,
        newId = fromScheduler.getEventRenderId(assignment.event, toResource);

      if (handledEventsMap[event.id]) {
        return;
      }

      handledEventsMap[event.id] = true;

      // Ensure the element gets preferentially reused for its own new render
      if (newId) {
        // If it's cross-scheduler, the element has to be moved into the element
        // recycling cache of the toScheduler, and positioned in its foregroundCanvas
        if (isCrosScheduler) {
          toScheduler.currentOrientation.cacheTimeSpanElement(event, eventBar);
        } else {
          toScheduler.currentOrientation.updateElementId(eventBar, newId);
        }
      }

      event.setStartDate(me.adjustStartDate(event.startDate, timeDiff), true, eventStore.skipWeekendsDuringDragDrop);

      // if we dragged the event to a different resource
      if (fromResource !== toResource) {
        if (copy) {
          event.assign(toResource);
        } else if (!event.isAssignedTo(toResource)) {
          event.reassign(assignment.resource, toResource);
        } else {
          event.unassign(assignment.resource);
        }
      }

      // We need to know whether we have successfully made an update in order to
      // sync the dragContext's valid flag.
      updated = updated || assignment.resource !== fromResource || event.generation !== oldGeneration;
    });

    if (!updated) {
      context.valid = false;
    }
  }

  //endregion

  //region Drag data

  getProductDragContext(dd) {
    const targetEventRecord = this.scheduler.resolveEventRecord(dd.browserEvent.target);

    let newResource;

    if (this.constrainDragToResource) {
      newResource = dd.resourceRecord;
    } else if (!this.constrainDragToTimeline) {
      // If we're dragging freely on the page, require to drag onto a resource row always
      newResource = this.resolveResource();
    } else {
      newResource = this.resolveResource() || dd.newResource || dd.resourceRecord;
    }

    return {
      valid: Boolean(newResource),
      newResource,
      targetEventRecord
    };
  }

  setupProductDragData(info) {
    const me = this,
      scheduler = me.scheduler,
      element = info.grabbed,
      eventRecord = scheduler.resolveEventRecord(element),
      resourceRecord = scheduler.resolveResourceRecord(element),
      assignmentRecord = scheduler.resolveAssignmentRecord(element),
      eventRegion = Rectangle.from(element),
      draggedRecords = [assignmentRecord || eventRecord],
      eventBarEls = [];

    if (me.constrainDragToResource && !resourceRecord) {
      throw new Error('Resource could not be resolved for event: ' + eventRecord.id);
    }

    const dateConstraints = scheduler.getDateConstraints(
      me.constrainDragToResource ? resourceRecord : null,
      eventRecord
    );

    if (me.constrainDragToTimeline) {
      me.setupConstraints(
        scheduler.getScheduleRegion(me.constrainDragToResource ? resourceRecord : null, eventRecord),
        eventRegion,
        scheduler.timeAxisViewModel.snapPixelAmount,
        Boolean(dateConstraints)
      );
    }

    // We multi drag other selected events if multiEventSelect is set and
    // (the dragged event is already selected, or the ctrl key is pressed)
    if (scheduler.multiEventSelect && (scheduler.isEventSelected(draggedRecords[0]) || me.drag.startEvent.ctrlKey)) {
      draggedRecords.push.apply(draggedRecords, me.getRelatedRecords(assignmentRecord || eventRecord));
    }

    // Collecting all elements to drag
    draggedRecords.forEach((r) => {
      if (r instanceof AssignmentModel) {
        eventBarEls.push.apply(eventBarEls, scheduler.getElementsFromEventRecord(r.event, r.resource, null, true));
      } else {
        eventBarEls.push.apply(eventBarEls, scheduler.getElementsFromEventRecord(r, null, null, true));
      }
    });

    // What is dragged is the wrapper.
    eventBarEls.forEach((el, i) => (eventBarEls[i] = el.parentNode));

    return { record: eventRecord, dateConstraints, eventBarEls, draggedRecords };
  }

  /**
   * Initializes drag data (dates, constraints, dragged events etc). Called when drag starts.
   * @private
   * @param info
   * @param event
   * @returns {*}
   */
  getDragData(info, event) {
    return Object.assign(super.getDragData(info, event), {
      resourceRecord: this.scheduler.resolveResourceRecord(info.grabbed)
    });
  }

  /**
   * Provide your custom implementation of this to allow additional selected records to be dragged together with the original one.
   * @param {Scheduler.model.EventModel} eventRecord The eventRecord about to be dragged
   * @return {Scheduler.model.EventModel[]} An array of event records to drag together with the original event
   */
  getRelatedRecords(eventRecord) {
    return this.scheduler.selectedEvents.filter((selectedRecord) => selectedRecord !== eventRecord);
  }

  /**
   * Get correct axis coordinate depending on schedulers mode (horizontal -> x, vertical -> y). Also takes milestone
   * layout into account.
   * @private
   * @param {Scheduler.model.EventModel} eventRecord Record being dragged
   * @param {HTMLElement} element Element being dragged
   * @param {Number[]} coord XY coordinates
   * @returns {Number|Number[]} X,Y or XY
   */
  getCoordinate(eventRecord, element, coord) {
    const scheduler = this.currentOverClient;

    if (scheduler.isHorizontal) {
      let x = coord[0];

      // Adjust coordinate for milestones if using a layout mode, since they are aligned differently than events
      if (scheduler.milestoneLayoutMode !== 'default' && eventRecord.isMilestone) {
        switch (scheduler.milestoneAlign) {
          case 'center':
            x += element.offsetWidth / 2;
            break;
          case 'end':
            x += element.offsetWidth;
            break;
        }
      }

      return x;
    } else {
      let y = coord[1];
      // Adjust coordinate for milestones if using a layout mode, since they are aligned differently than events
      if (scheduler.milestoneLayoutMode !== 'default' && eventRecord.isMilestone) {
        switch (scheduler.milestoneAlign) {
          case 'center':
            y += element.offsetHeight / 2;
            break;
          case 'end':
            y += element.offsetHeight;
            break;
        }
      }

      return y;
    }
  }

  /**
   * Get resource record occluded by the drag proxy.
   * @private
   * @returns {Scheduler.model.ResourceModel}
   */
  resolveResource() {
    const me = this,
      client = me.currentOverClient,
      { isHorizontal } = client,
      { context } = me.dragData,
      element = context.dragProxy || context.element,
      scrollerElement = client.timeAxisSubGrid.virtualScrollerElement,
      // Page coords for elementFromPoint
      pageRect = Rectangle.from(element, null, true),
      x = isHorizontal ? context.clientX : pageRect.center.x,
      y = client.isVertical || me.unifiedDrag ? context.clientY : pageRect.center.y,
      // Local coords to resolve resource in vertical
      localRect = Rectangle.from(element, me.currentOverClient.timeAxisSubGridElement, true),
      { x: lx, y: ly } = localRect.center;

    // This is benchmarked as the fastest way to find a Grid Row from a viewport Y coordinate
    // so use it in preference to elementFromPoint (which causes a forced synchonous layout) in horiontal mode.
    if (isHorizontal) {
      const row = client.rowManager.getRowAt(y);
      if (row) {
        return client.resourceStore.getAt(row.dataIndex);
      }
    }

    // Do not find the drag element at the x, y position.
    element.style.pointerEvents = 'none';

    // Do not find the horizontal scrollbar either
    if (scrollerElement) {
      scrollerElement.style.display = 'none';
    }
    const node = DomHelper.elementFromPoint(x, y);
    element.style.pointerEvents = '';
    if (scrollerElement) {
      scrollerElement.style.display = '';
    }

    // If we found an element there, and it can be used to resolve a resourceRecord, use that
    return node && client.resolveResourceRecord(node, [lx, ly]);
  }

  //endregion

  //region Other stuff

  adjustStartDate(startDate, timeDiff) {
    const scheduler = this.currentOverClient;

    return scheduler.timeAxis.roundDate(
      new Date(startDate - 0 + timeDiff),
      scheduler.snapRelativeToEventStartDate ? startDate : false
    );
  }

  resolveStartEndDates(proxyRect) {
    const scheduler = this.currentOverClient,
      dd = this.dragData;

    let startEnd,
      start = dd.origStart,
      end = dd.origEnd;

    if (!dd.startsOutsideView) {
      startEnd = scheduler.getStartEndDatesFromRectangle(proxyRect, 'round');
      if (startEnd) {
        // Make sure we didn't target a start date that is filtered out, if we target last hour cell (e.g. 21:00) of
        // the time axis, and the next tick is 08:00 following day. Trying to drop at end of 21:00 cell should target start of next cell
        if (startEnd.start && !scheduler.timeAxis.dateInAxis(startEnd.start, false)) {
          const tick = scheduler.timeAxis.getTickFromDate(startEnd.start);

          if (tick) {
            startEnd.start = scheduler.timeAxis.getDateFromTick(tick);
          }
        }

        start = startEnd.start || dd.startDate;
        end = DateHelper.add(start, dd.duration, 'ms');
      }
    } else if (!dd.endsOutsideView) {
      startEnd = scheduler.getStartEndDatesFromRectangle(proxyRect, 'round');
      if (startEnd) {
        end = startEnd.end || dd.endDate;
        start = DateHelper.add(end, -dd.duration, 'ms');
      }
    }

    return {
      startDate: start,
      endDate: end
    };
  }

  //endregion
}

EventDrag._$name = 'EventDrag';
GridFeatureManager.registerFeature(EventDrag, true, 'Scheduler');

/**
 * @module Scheduler/feature/base/DragCreateBase
 */

// TODO: add hovertip if EvenDrag feature not used
// TODO: some of the code here could be shared with EventResize. make common base class?
// TODO: touch support
// TODO: mouse up outside not working as it should

/**
 * Base class for EventDragCreate (Scheduler) and TaskDragCreate (Gantt) features. Contains shared code. Not to be used directly.
 *
 * @extends Common/mixin/InstancePlugin
 */
class DragCreateBase extends InstancePlugin {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * true to start disabled
       * @config {Boolean}
       * @default
       */
      disabled: false,

      /**
       * true to show a time tooltip when dragging to create a new event
       * @config {Boolean}
       * @default
       */
      showTooltip: true,

      /**
       * Number of pixels the drag target must be moved before dragging is considered to have started. Defaults to 2.
       * @config {Number}
       * @default
       */
      dragTolerance: 2,

      // used by gantt to only allow one task per row
      preventMultiple: false,

      validatorFn: () => {},

      /**
       * `this` reference for the validatorFn
       * @config {Object}
       */
      validatorFnThisObj: null,

      /**
       * CSS class to add to proxy used when creating a new event
       * @config {String}
       * @default
       * @private
       */
      proxyCls: 'b-sch-dragcreator-proxy',

      tipTemplate: (data) => `
                <div class="b-sch-tip-${data.valid ? 'valid' : 'invalid'}">
                    ${data.startClockHtml}
                    ${data.endClockHtml}
                    <div class="b-sch-tip-message">${data.message}</div>
                </div>
            `
    };
  }

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['onElementMouseDown', 'onElementMouseMove'],
      before: ['onElementContextMenu']
    };
  }

  doDestroy() {
    this.tip && this.tip.destroy();
    this.resize && this.resize.destroy();
    super.doDestroy();
  }

  //endregion

  //region Proxy element & resizing

  /**
   * Adds a proxy element to illustrate the timespan that might be created
   * @param config
   * @param {Common.data.Model} config.rowRecord  The row for which an event proxy element is being created.
   * @param {Number} config.startX the position along the time axis at which to display the proxy element.
   * @param {Number} [config.width] the width of the proxy element.
   */
  addProxy(config) {
    const me = this,
      { client } = me,
      { barMargin } = client,
      region = client.currentOrientation.getRowRegion(config.rowRecord);

    let width, height, proxyX, proxyY;

    if (client.isHorizontal) {
      proxyX = 'currentX' in config ? Math.min(config.startX, config.currentX + 1) : config.startX;
      proxyY = region.y + barMargin;
      width = config.width || me.dragTolerance;
      height = region.height - barMargin * 2;
    } else {
      proxyX = region.x + barMargin;
      proxyY = 'currentY' in config ? Math.min(config.startY, config.currentY + 1) : config.startY;
      width = region.width - barMargin * 2;
      height = config.height || me.dragTolerance;
    }

    // This CSS class is to block further drag creates when one is in progress (like awaiting async finalization)
    client.element.classList.add('b-dragcreating');
    // This CSS class is to block hover for other events during actually dragging the proxy
    client.element.classList.add('b-dragcreating-proxy-sizing');

    // We are dragging to size element from nothing. Its size on drag is calculated by its *initial size*, plus the
    // mouse movement delta, so it MUST start at zero for that to yield the correct result.
    return (me.proxy = DomHelper.createElement({
      parent: client.foregroundCanvas,
      className: me.proxyCls,
      style: `transform:translate(${proxyX}px, ${proxyY}px);width:${width}px;height:${height}px`,
      // Prevent element from being recycled by DomHelper.sync()
      retainElement: true
    }));
  }

  /**
   * Remove proxy element and clean up related stuff
   * @private
   */
  removeProxy() {
    const me = this;
    if (me.proxy) {
      me.proxy.remove();
      me.resize.destroy();
      me.proxy = me.resize = null;

      // This CSS class is to block further drag creates when one is in progress (like awaiting async finalization)
      me.client.element.classList.remove('b-dragcreating');
      // This CSS class is to block hover for other events during actually dragging the proxy
      me.client.element.classList.remove('b-dragcreating-proxy-sizing');
      me.tip && me.tip.hide();
    }
  }

  /**
   * Creates an instance of ResizeHelper used to resize the proxy element
   * @param event
   * @param data
   */
  initResizer(event, data) {
    const me = this;

    let edge;

    if (me.client.isHorizontal) {
      edge = data.currentX > data.startX ? 'right' : 'left';
    } else {
      edge = data.currentY > data.startY ? 'bottom' : 'top';
    }

    me.resize && me.resize.destroy();

    me.resize = new ResizeHelper({
      name: me.constructor.name, // For debugging
      direction: me.client.isVertical ? 'vertical' : 'horizontal',
      isTouch: event.type.startsWith('touch'),
      grab: {
        element: me.proxy,
        edge,
        event: data.startEvent
      },
      allowEdgeSwitch: true, // Means that they can switch edges; the mouse can cross the zero point and drag the other way
      outerElement: me.client.timeAxisSubGridElement, // Constrain resize to view
      scrollManager: me.client.scrollManager,
      scroller: me.client.timeAxisSubGrid.scrollable, // Scroll in both directions
      listeners: {
        resizing: me.onResizing,
        resize: me.onResize,
        cancel: me.onCancel,
        thisObj: me
      }
    });

    me.resize.context.resource = data.resource;
  }

  //endregion

  //region Tooltip

  /**
   * Creates a tooltip that displays start & end dates. Anchored to the proxy element
   */
  initTooltip() {
    const me = this,
      client = me.client;

    if (me.showTooltip) {
      if (me.tip) {
        me.tip.showBy(me.getTooltipTarget());
      } else {
        me.clockTemplate = new ClockTemplate({
          timeAxisViewModel: client.timeAxisViewModel
        });

        me.tip = new Tooltip({
          id: `${client.id}-drag-create-tip`,
          autoShow: true,
          trackMouse: false,
          getHtml: me.getTipHtml.bind(me),
          align: client.isVertical ? 't-b' : 'b100-t100',
          hideDelay: 0,
          axisLock: true // Don't want it flipping to the side where we are dragging
        });

        me.tip.on('innerhtmlupdate', me.updateDateIndicator, me);
      }
    }
  }

  updateDateIndicator() {
    const me = this,
      { startDate, endDate } = me.createContext,
      tip = me.tip,
      endDateElement = tip.element.querySelector('.b-sch-tooltip-enddate');

    if (startDate && endDate) {
      me.clockTemplate.updateDateIndicator(tip.element, startDate);

      endDateElement && me.clockTemplate.updateDateIndicator(endDateElement, endDate);
    }
  }

  /**
   * Updates tooltips contents
   * @returns {*}
   */
  getTipHtml() {
    if (!this.resize.context) return;

    // keeping this on separate row to not mess up look of other declarations
    const me = this,
      client = me.client,
      {
        edge,
        newX,
        newY,
        elementStartX,
        elementStartY,
        elementWidth,
        elementHeight,
        newWidth,
        newHeight,
        valid,
        message
      } = me.resize.context;

    let start, end;

    if (client.isHorizontal) {
      const x = edge === 'left' ? newX : elementStartX,
        // Coordinates are 0 based, widths are not so subtracting 1 from the widths
        endX = Math.min(Math.max(x + (newWidth || elementWidth) - 1, 0), client.timeAxisViewModel.totalSize - 1);
      start = client.getDateFromCoordinate(x, 'round', true);
      end = client.getDateFromCoordinate(endX, 'round', true);
    } else {
      const y = edge === 'top' ? newY : elementStartY,
        // Coordinates are 0 based, widths are not so subtracting 1 from the widths
        endY = Math.min(Math.max(y + (newHeight || elementHeight) - 1, 0), client.timeAxisViewModel.totalSize - 1);
      start = client.getDateFromCoordinate(y, 'round', true);
      end = client.getDateFromCoordinate(endY, 'round', true);
    }

    const first = DateHelper.min(start, end),
      last = DateHelper.max(start, end),
      startText = first && client.getFormattedDate(first),
      endText = last && end && client.getFormattedEndDate(last, first);

    return me.tipTemplate({
      valid: valid,
      startDate: first,
      endDate: last,
      startText: startText,
      endText: endText,
      message: message,
      startClockHtml: me.clockTemplate.template({
        date: first,
        text: startText,
        cls: 'b-sch-tooltip-startdate'
      }),
      endClockHtml: me.clockTemplate.template({
        // actual end date and display date may differ
        date: client.getDisplayEndDate(last, first),
        text: endText,
        cls: 'b-sch-tooltip-enddate'
      })
    });
  }

  //endregion

  //region Finalize (create EventModel)

  finalize(doCreate) {
    const me = this;

    if (doCreate) {
      // Call product specific implementation
      me.finalizeDragCreate(me.createContext);
    }

    me.proxy.retainElement = false;

    me.client.trigger('afterDragCreate', {
      proxyElement: me.proxy
    });

    me.reset();
  }

  //endregion

  //region Events

  onElementMouseDown(event) {
    const me = this,
      { client } = me;

    // detect mouse down directly in scheduler cell
    if (event.button === 0 && event.target.matches('.b-sch-timeaxis-cell') && !me.disabled && !client.readOnly) {
      const rowRecord = client.isVertical
        ? client.resolveResourceRecord(event)
        : client.getRecordFromElement(event.target);

      // no drag creation in group headers etc.
      if (rowRecord.meta.specialRow) {
        return;
      }

      if (me.preventMultiple && !me.isRowEmpty(rowRecord)) {
        return;
      }

      me.monitorMove = true;
      me.createContext = {
        startEvent: event,
        startScreenX: event.screenX,
        startScreenY: event.screenY,
        startX: event.offsetX,
        startY: event.offsetY,
        cellElement: event.target,
        rowRecord
      };

      me.mouseUpDetacher = EventHelper.on({
        element: document.body,
        mouseup: 'onMouseUp',
        once: true,
        thisObj: this
      });
    }
  }

  onElementMouseMove(event) {
    const me = this;

    if (me.monitorMove) {
      const { createContext, client } = me,
        delta = me.client.isVertical
          ? createContext.startScreenY - event.screenY
          : createContext.startScreenX - event.screenX;

      if (Math.abs(delta) > me.dragTolerance) {
        const dateTime = client.getDateFromDomEvent(event),
          region = Rectangle.from(client.timeAxisSubGridElement, null, true);

        if (me.handleBeforeDragCreate(dateTime, event) === false) {
          me.monitorMove = false;
          return;
        }

        // Math.max with 0 because if the mousedown is within dragTolerance of
        // the left edge and then drag goes left, dragging can begin with
        // the X in negative territory.
        createContext.currentX = Math.max(event.clientX - region.x + client.timeAxisSubGrid.scrollable.x, 0);
        createContext.currentY = Math.max(event.clientY - region.y + client.timeAxisSubGrid.scrollable.y, 0);
        me.addProxy(me.createContext);
        me.initResizer(event, me.createContext);
        me.initTooltip();

        me.monitorMove = false;

        client.trigger('dragCreateStart', {
          proxyElement: me.proxy
        });
      }
    }

    // If dragcreate is async, resizer was already reset and we should not
    // align tooltip anymore
    if (me.proxy && me.showTooltip && me.resize.context) {
      me.tip.alignTo(me.getTooltipTarget());
    }
  }

  getTooltipTarget() {
    const me = this,
      target = Rectangle.from(me.proxy, null, true);

    if (me.client.isVertical) {
      // Align to the dragged edge of the proxy, and then bump bottom so that the anchor aligns perfectly.
      if (me.resize.context.edge === 'bottom') {
        target.y = target.bottom - 1;
      }
      target.height = me.tip.anchorSize[1] / 2;
    } else {
      // Align to the dragged edge of the proxy, and then bump right so that the anchor aligns perfectly.
      if (me.resize.context.edge === 'right') {
        target.x = target.right - 1;
      }
      target.width = me.tip.anchorSize[0] / 2;
    }

    return { target };
  }

  onMouseUp() {
    const me = this;

    me.client.element.classList.remove('b-dragcreating-proxy-sizing');

    me.monitorMove = false;
  }

  /**
   * Prevent right click when drag creating
   * @returns {Boolean}
   * @internal
   */
  onElementContextMenu() {
    if (this.proxy) return false;
  }

  onResizing({ context, event }) {
    const me = this,
      client = me.client,
      x = context.edge === 'left' ? context.newX : context.elementStartX,
      y = context.edge === 'top' ? context.newY : context.elementStartY,
      // Coordinates are 0 based, widths are not so subtracting 1 from the widths
      endX = Math.min(
        x + Math.max((context.newWidth || context.elementWidth) - 1, 0),
        client.timeAxisViewModel.totalSize - 1
      ),
      endY = Math.min(
        y + Math.max((context.newHeight || context.elementHeight) - 1, 0),
        client.timeAxisViewModel.totalSize - 1
      ),
      startCoord = client.isVertical ? y : x,
      endCoord = client.isVertical ? endY : endX,
      first = client.getDateFromCoordinate(startCoord, 'round', true),
      last = client.getDateFromCoordinate(endCoord, 'round', true),
      dc = me.dateConstraints;

    let start = DateHelper.min(first, last),
      end = DateHelper.max(first, last);

    if (dc) {
      end = DateHelper.constrain(end, dc.start, dc.end);
      start = DateHelper.constrain(start, dc.start, dc.end);
    }

    Object.assign(me.createContext, {
      startDate: start,
      endDate: end
    });

    context.valid = me.checkValidity(me.createContext, event);
    context.message = '';

    if (context.valid && typeof context.valid !== 'boolean') {
      context.message = context.valid.message;
      context.valid = context.valid.valid;
    }

    // If users returns nothing, that's interpreted as valid
    context.valid = context.valid !== false;
  }

  onResize({ context: { valid }, event }) {
    const me = this,
      { startDate, endDate } = me.createContext;

    if (!startDate || !endDate || endDate - startDate <= 0) valid = false;

    Object.assign(me.createContext, {
      event: event,
      async: false,
      finalize: (doCreate) => me.finalize(doCreate)
    });

    if (valid) {
      me.client.trigger('beforeDragCreateFinalize', {
        context: me.createContext,
        event,
        proxyElement: me.proxy
      });
    }

    // Drag create could be finalized immediately
    if (me.createContext) {
      // OMG, how not to confuse those contexts?
      me.resize.context.async = me.createContext.async;

      if (!me.createContext.async) {
        me.finalize(valid);
      } else {
        // We do not want to remove resizer yet, because it will also remove context and proxy element (or resize to 0 width)
        // Instead we blindfold resize helper to prevent event resize from starting parallel drag create
        me.resize.removeListeners();
      }
    }
  }

  get dragging() {
    return this.resize;
  }

  onCancel() {
    this.cancel();
  }

  cancel() {
    this.reset();
    this.mouseUpDetacher && this.mouseUpDetacher();
  }

  reset() {
    const me = this;

    me.removeProxy();
    me.createContext = null;
    me.monitorMove = false;
  }

  //endregion

  //region Product specific, implemented in subclasses

  checkValidity(context, event) {
    throw new Error('Implement in subclass');
  }

  triggerDragCreateEnd(newRecord, context) {
    throw new Error('Implement in subclass');
  }

  handleBeforeDragCreate(dateTime, event) {
    throw new Error('Implement in subclass');
  }

  isRowEmpty(rowRecord) {
    throw new Error('Implement in subclass');
  }

  //endregion
}
DragCreateBase._$name = 'DragCreateBase';

/**
 * @module Scheduler/feature/EventDragCreate
 */

// TODO: add hovertip if EventDrag feature not used
// TODO: some of the code here could be shared with EventResize. make common base class?
// TODO: touch support
// TODO: mouse up outside not working as it should

/**
 * Feature that allows the user to create new events by dragging in empty parts of the scheduler rows.
 *
 * This feature is **enabled** by default
 *
 * **NOTE:** Incompatible with {@link Scheduler.feature.Pan Pan} feature.
 *
 * @extends Scheduler/feature/base/DragCreateBase
 * @demo basic
 * @externalexample scheduler/EventDragCreate.js
 */
class EventDragCreate extends DragCreateBase {
  //region Config

  static get defaultConfig() {
    return {
      // used by gantt to only allow one task per row
      preventMultiple: false,

      /**
       * An empty function by default, but provided so that you can perform custom validation on the event being created.
       * Return true if the new event is valid, false to prevent an event being created.
       * @param {Object} context A drag create context, containing at least { startDate, endDate, resourceRecord }
       * @param {Event} event The event object
       * @return {Boolean} isValid
       * @config {function}
       */
      validatorFn: () => {}
    };
  }

  //endregion

  //region Events

  /**
   * Fires on the owning Scheduler after the new event has been created.
   * @event dragCreateEnd
   * @param {Scheduler.view.Scheduler} source
   * @param {Scheduler.model.EventModel} newEventRecord
   * @param {Scheduler.model.ResourceModel} resourceRecord
   * @param {MouseEvent} event The ending mouseup event.
   * @param {HTMLElement} proxyElement The proxy element showing the drag creation zone.
   */

  /**
   * Fires on the owning Scheduler at the beginning of the drag gesture
   * @event beforeDragCreate
   * @param {Scheduler.view.Scheduler} source
   * @param {Scheduler.model.ResourceModel} resourceRecord
   * @param {Date} date The datetime associated with the drag start point.
   */

  /**
   * Fires on the owning Scheduler after the drag start has created a proxy element.
   * @event dragCreateStart
   * @param {Scheduler.view.Scheduler} source
   * @param {HTMLElement} proxyElement The proxy representing the new event.
   */

  /**
   * Fired on the owning Scheduler to allow implementer to prevent immediate finalization by setting `data.context.async = true`
   * in the listener, to show a confirmation popup etc
   * ```
   *  scheduler.on('beforedragcreatefinalize', ({context}) => {
   *      context.async = true;
   *      setTimeout(() => {
   *          // async code don't forget to call finalize
   *          context.finalize();
   *      }, 1000);
   *  })
   * ```
   * @event beforeDragCreateFinalize
   * @param {Scheduler.view.Scheduler} source Scheduler instance
   * @param {HTMLElement} proxyElement Proxy element, representing future event
   * @param {Object} context
   * @param {Boolean} context.async Set true to handle drag create asynchronously (e.g. to wait for user
   * confirmation)
   * @param {Function} context.finalize Call this method to finalize drag create. This method accepts one
   * argument: pass true to update records, or false, to ignore changes
   */

  /**
   * Fires on the owning Scheduler at the end of the drag create gesture whether or not
   * a new event was created by the gesture.
   * @event afterDragCreate
   * @param {Scheduler.view.Scheduler} source
   * @param {HTMLElement} proxyElement The proxy element showing the drag creation zone.
   */

  //endregion

  //region Init

  construct(scheduler, config) {
    const me = this;

    me.scheduler = scheduler;

    // Assign eventStore as store, it is used when drag creating by shared code
    me.store = scheduler.eventStore;

    super.construct(scheduler, config);
  }

  //endregion

  //region Scheduler specific implementation

  finalizeDragCreate(context) {
    const newEventRecord = new this.store.modelClass({
      startDate: context.startDate,
      endDate: context.endDate
    });

    this.proxy.dataset.eventId = newEventRecord.id;
    this.scheduler.trigger('dragCreateEnd', {
      newEventRecord,
      resourceRecord: context.rowRecord,
      event: context.event,
      proxyElement: this.proxy
    });
  }

  handleBeforeDragCreate(dateTime, event) {
    const me = this,
      result = me.scheduler.trigger('beforeDragCreate', {
        resourceRecord: me.createContext.rowRecord,
        date: dateTime,
        event
      });

    if (result) {
      // Tooltip will not be activated while drag is in progress,
      // but we need to hide it deliberately on drag start
      const tipFeature = me.scheduler.features.scheduleTooltip;
      if (tipFeature) {
        tipFeature.hoverTip && tipFeature.hoverTip.hide();
      }
    }

    // Save date constraints
    me.dateConstraints = me.scheduler.getDateConstraints(me.createContext.rowRecord, dateTime);

    return result;
  }

  checkValidity(context, event) {
    const me = this,
      client = me.client;

    // Nicer for users of validatorFn
    context.resourceRecord = context.rowRecord;

    return (
      (client.allowOverlap ||
        client.isDateRangeAvailable(context.startDate, context.endDate, null, context.resourceRecord)) &&
      me.validatorFn.call(me.validatorFnThisObj || me, context, event)
    );
  }

  // Determine if resource already has events or not
  isRowEmpty(resourceRecord) {
    const events = this.store.getEventsForResource(resourceRecord);
    return !events || !events.length;
  }

  //endregion
}

EventDragCreate._$name = 'EventDragCreate';
GridFeatureManager.registerFeature(EventDragCreate, true, 'Scheduler');

/**
 * @module Scheduler/feature/EventDragSelect
 */

/**
 * Enables users to click and drag to select events inside the Scheduler's timeline.
 *
 * This feature is **disabled** by default.
 *
 * **NOTE:** Incompatible with {@link Scheduler.feature.EventDragCreate EventDragCreate} and the {@link Scheduler.feature.Pan Pan} features.
 *
 * @extends Common/mixin/InstancePlugin
 * @mixes Common/mixin/Delayable
 *
 * @example
 * let scheduler = new Scheduler({
 *   features : {
 *     eventDragSelect      : true,
 *     eventDragCreate      : false
 *   }
 * });
 *
 * @classtype eventDragSelect
 */
class EventDragSelect extends Delayable(InstancePlugin) {
  // region Init

  construct(timeline, config) {
    this.timeline = timeline;

    timeline.multiEventSelect = true;

    if (timeline.features.eventDragCreate || timeline.features.pan) {
      throw new Error('Cannot combine this feature with Pan or EventDragCreate features');
    }

    const targetSelectors = ['.b-grid-cell', '.b-timeline-subgrid'];

    this.targetSelector = targetSelectors.join(',');

    super.construct(timeline, config);
  }

  //endregion

  //region Plugin config

  // Plugin configuration. This plugin chains some of the functions in Scheduler.
  static get pluginConfig() {
    return {
      chain: ['onElementMouseDown', 'onElementMouseMove', 'onElementMouseUp']
    };
  }

  //endregion

  onElementMouseDown(event) {
    const me = this,
      scheduler = me.client;

    // only react to mouse input, and left button
    if (event.touches || event.button !== 0) {
      return;
    }

    // only react to mousedown directly on grid cell or subgrid element
    if (event.target.matches(me.targetSelector)) {
      me.startX = event.clientX;
      me.startY = event.clientY;

      me.element = DomHelper.createElement(
        {
          tag: 'div',
          className: 'b-dragselect-rect'
        },
        true
      )[0];

      Widget.floatRoot.appendChild(me.element);
      scheduler.element.classList.add('b-dragselecting');

      me.eventRectangles = Array.from(scheduler.element.querySelectorAll(scheduler.eventSelector)).map((el) => ({
        rectangle: Rectangle.from(el),
        record: scheduler.resolveEventRecord(el)
      }));

      scheduler.clearEventSelection();
      me.subGridElementRect = Rectangle.from(scheduler.timeAxisSubGrid.element);

      // No key processing during drag selection
      scheduler.navigator.disabled = true;
    }
  }

  onElementMouseMove(event) {
    const me = this;

    // Synthetic mousemove event has no button for IE11
    // Detect if a mouseup happened outside our element (or browser window for that matter). Note 'buttons' is not supported by Safari
    if (event.buttons === 0 && !BrowserHelper.isSafari && (!BrowserHelper.isIE11 || event.isTrusted)) {
      me.onElementMouseUp(event);
      return;
    }

    if (typeof me.startX === 'number') {
      const x = Math.max(event.clientX, me.subGridElementRect.left),
        y = Math.max(event.clientY, me.subGridElementRect.top),
        left = Math.min(me.startX, x),
        top = Math.min(me.startY, y),
        width = Math.abs(me.startX - x),
        height = Math.abs(me.startY - y),
        rect = new Rectangle(left, top, width, height).constrainTo(me.subGridElementRect);

      DomHelper.setTranslateXY(me.element, rect.left, rect.top);
      me.element.style.width = rect.width + 'px';
      me.element.style.height = rect.height + 'px';

      me.rectangle = rect;

      me.updateSelection();
    }
  }

  onElementMouseUp(event) {
    const me = this;

    if (typeof me.startX === 'number') {
      me.element && me.element.remove();
      me.client.element.classList.remove('b-dragselecting');
      me.startX = me.startY = null;

      // Navigator will react to the 'click' event which clears selection, bypass this with a short timeout
      me.setTimeout(() => (me.client.navigator.disabled = false), 100);
    }
  }

  updateSelection() {
    const me = this,
      renderedEventRects = me.eventRectangles,
      rectangle = me.rectangle;

    for (let i = 0, len = renderedEventRects.length; i < len; i++) {
      const eventData = renderedEventRects[i],
        shouldSelect = rectangle.intersect(eventData.rectangle, true);

      if (shouldSelect && !eventData.selected) {
        eventData.selected = true;

        me.client.selectEvent(eventData.record, true);
      } else if (!shouldSelect && eventData.selected) {
        eventData.selected = false;

        me.client.deselectEvent(eventData.record);
      }
    }
  }
}

EventDragSelect._$name = 'EventDragSelect';
GridFeatureManager.registerFeature(EventDragSelect, false, 'Scheduler');

/**
 * @module Scheduler/feature/base/EditBase
 */

const DH = DateHelper,
  makeDate = (fields) => {
    // single field, update record directly
    if (fields.length === 1) return fields[0].value;
    // two fields, date + time
    else if (fields.length === 2) {
      const [date, time] = fields[0] instanceof DateField ? fields : fields.reverse(),
        dateValue = DH.parse(date.value);

      dateValue.setHours(
        time.value.getHours(),
        time.value.getMinutes(),
        time.value.getSeconds(),
        time.value.getMilliseconds()
      );

      return dateValue;
    }
    // shouldn't happen...
    return null;
  },
  copyTime = (dateTo, dateFrom) => {
    let d = new Date(dateTo.getTime());
    d.setHours(dateFrom.getHours(), dateFrom.getMinutes());
    return d;
  },
  adjustEndDate = (startDate, startTime, me) => {
    // The end datetime just moves in response to the changed start datetime, keeping the same duration.
    if (startDate && startTime) {
      const newEndDate = DH.add(
        copyTime(me.startDateField.value, me.startTimeField.value),
        me.eventRecord.durationMS,
        'milliseconds'
      );
      me.endDateField.value = newEndDate;
      me.endTimeField.value = DH.clone(newEndDate);
    }
  };

/**
 * Base class for EventEdit (Scheduler) and TaskEdit (Gantt) features. Contains shared code. Not to be used directly.
 *
 * @extends Common/mixin/InstancePlugin
 */
class EditBase extends InstancePlugin {
  //region Config

  // TODO: check which configs are actually used

  static get defaultConfig() {
    return {
      /**
       * True to hide this editor if a click is detected outside it (defaults to true)
       * @config {Boolean}
       * @default
       * @category Editor
       */
      autoClose: true,

      /**
       * True to save and close this panel if ENTER is pressed in one of the input fields inside the panel.
       * @config {Boolean}
       * @default
       * @category Editor
       */
      saveAndCloseOnEnter: true,

      triggerEvent: null,

      /**
       * True to show a delete button in the form.
       * @config {Boolean}
       * @default
       * @category Editor widgets
       */
      showDeleteButton: true,

      /**
       * True to show a text field for entering event name
       * @config {Boolean}
       * @default
       * @category Editor widgets
       */
      showNameField: true,

      /**
       * Config for the `startTimeField` constructor.
       * @config {Object}
       * @category Editor widgets
       */
      startTimeConfig: null,

      /**
       * Config for the `startDateField` constructor.
       * @config {Object}
       * @category Editor widgets
       */
      startDateConfig: null,

      /**
       * Config for the `endTimeField` constructor.
       * @config {Object}
       * @category Editor widgets
       */
      endTimeConfig: null,

      /**
       * Config for the `endDateField` constructor.
       * @config {Object}
       * @category Editor widgets
       */
      endDateConfig: null,

      /**
       * This config parameter is passed to the `startDateField` and `endDateField` constructor.
       * @config {String}
       * @default
       * @category Editor widgets
       */
      dateFormat: 'L', // date format that uses browser locale

      /**
       * This config parameter is passed to the `startTimeField` and `endTimeField` constructor.
       * @config {String}
       * @default
       * @category Editor widgets
       */
      timeFormat: 'LT', // date format that uses browser locale

      /**
       * Default editor configuration, which widgets it shows etc.
       * @config {Object}
       * @category Editor
       */
      editorConfig: null,

      /**
       * Array of widgets. Will be inserted above buttons unless an index is
       * specified for the widget:
       * ```
       * new Grid({
       *   features : {
       *     eventEdit : {
       *       extraItems : [
       *         { type : 'text', index : 1 },
       *         ...
       *       ]
       *     }
       *   }
       * });
       * ```
       * @config {String|Object[]}
       * @category Editor widgets
       */
      extraItems: null,

      /**
       * This config has been deprecated in favour of {@link #config-extraItems}.
       * @deprecated 2.1
       * @config {String|Object[]}
       * @category Editor widgets
       */
      extraWidgets: null
    };
  }

  //endregion

  //region Init & destroy

  construct(client, config) {
    const me = this;

    client.eventEdit = me;

    super.construct(client, config);

    me.clientListenersDetacher = client.on({
      [me.triggerEvent]: me.onActivateEditor,
      dragcreateend: me.onDragCreateEnd,
      thisObj: me
    });
  }

  doDestroy() {
    this.clientListenersDetacher();

    this.editor && this.editor.destroy();

    super.doDestroy();
  }

  //endregion

  //region Editing

  get editorConfig() {
    return this._editorConfig;
  }

  set editorConfig(editorConfig) {
    const me = this,
      defaultEditorConfig = me.getDefaultConfiguration().editorConfig;

    // Apply editorConfig to the default editorConfig, allowing users to manipulate for example only bbar
    editorConfig = ObjectHelper.assign({}, defaultEditorConfig, editorConfig);

    editorConfig.items = editorConfig.items || [];

    // Massage the incoming widgets according to our needs before caching the configuration for use in getEditor.
    me.insertExtraWidgetsIntoDefaultWidgets(editorConfig);

    me._editorConfig = editorConfig;
  }

  get extraWidgets() {
    if (!this._skipWarn) {
      console.warn('`extraWidgets` was deprecated in 2.1, please change your code to use `extraItems`');
    }
    return this._extraItems;
  }

  set extraWidgets(widgets) {
    console.warn('`extraWidgets` was deprecated in 2.1, please change your code to use `extraItems`');
    this._extraItems = widgets;
  }

  // TODO: When removing extraWidgets above, these can also be removed
  get extraItems() {
    const me = this;

    // Pull in extraWidgets, for compatibility
    me._skipWarn = true;
    me._thisIsAUsedExpression(me.extraWidgets);
    me._skipWarn = false;

    return me._extraItems;
  }

  set extraItems(items) {
    this._extraItems = items;
  }

  /**
   * Insert extra fields into default Editor fields according to specific rules:
   * - If no index provided insert them into `extraItems` placeholder (or at the end if not);
   * - If index provided sort ASC and insert one by one, but only after no-index fields are inserted;
   * - If `extraItems` placeholder exists, don't take widgets that go after it into account;
   * @private
   */
  insertExtraWidgetsIntoDefaultWidgets(editorConfig) {
    const me = this;

    if (!me.extraItems || !me.extraItems.length) {
      return;
    }

    // Find default extra widgets position
    let index = editorConfig.items.findIndex((widget) => widget.type === 'extraItems'),
      tail;

    // If extra widgets placeholder exists
    if (index > -1) {
      // Remove extra widgets placeholder from its position
      editorConfig.items.splice(index, 1);

      // Backup everything that goes after extra widgets placeholder, like Save/Delete/Cancel buttons
      tail = editorConfig.items.splice(index);
    }

    // Split extra widgets on 2 parts: those which have index and those which haven't
    let withIndex = me.extraItems.filter((widget) => widget.index >= 0),
      withoutIndex = me.extraItems.filter((widget) => !(widget.index >= 0));

    // Add those without index to the end of the default widgets
    editorConfig.items = editorConfig.items.concat(withoutIndex);

    // Sort those which have index in ASC order, so we insert fields in series
    withIndex.sort((widgetA, widgetB) => widgetA.index - widgetB.index);

    // And now insert extra widgets at their individually specified index
    withIndex.forEach((widget) => editorConfig.items.splice(widget.index, 0, widget));

    if (tail && tail.length) {
      // Return backuped fields to the end of the widgets
      editorConfig.items = editorConfig.items.concat(tail);
    }
  }

  onDatesChange(params) {
    const me = this,
      field = params.source,
      value = params.value;

    switch (field.ref) {
      case 'startDateField':
        me.startTimeField && adjustEndDate(value, me.startTimeField.value, me);
        break;

      case 'startTimeField':
        me.startDateField && adjustEndDate(me.startDateField.value, value, me);
        break;
    }

    if (me.endTimeField) {
      // If the event starts and ends on the same day, the time fields need
      // to have their min and max set against each other.
      if (DH.isEqual(DH.clearTime(me.startDateField.value), DH.clearTime(me.endDateField.value))) {
        me.endTimeField.min = me.startTimeField.value;
      } else {
        me.endTimeField.min = null;
      }
    }
  }

  //endregion

  //region Save

  save() {
    throw new Error('Implement in subclass');
  }

  get isValid() {
    const me = this;
    return Object.values(me.editor.widgetMap).every((field) => {
      if (!field.name || field.hidden) {
        return true;
      }

      return field.isValid !== false;
    });
  }

  get values() {
    const me = this,
      startFields = [],
      endFields = [],
      values = {};

    me.editor.eachWidget((widget) => {
      const name = widget.name;
      if (!name || widget.hidden) return;

      if (name === 'startDate') {
        startFields.push(widget);
      } else if (name === 'endDate') {
        endFields.push(widget);
      } else {
        values[name] = widget.value;
      }
    }, true);

    values.startDate = makeDate(startFields);
    values.endDate = makeDate(endFields);

    // Since there is no duration field in the editor,
    // we don't need to recalc duration value on each date change.
    // It's enough to return correct duration value in `values`,
    // so the record will get updated with the correct data.
    values.duration = DH.diff(values.startDate, values.endDate, me.editor.record.durationUnit, true);

    return values;
  }

  /**
   * Template method, intended to be overridden. Called before the event record has been updated.
   * @param {Scheduler.model.EventModel} eventRecord The event record
   *
   **/
  onBeforeSave(eventRecord) {}

  /**
   * Template method, intended to be overridden. Called after the event record has been updated.
   * @param {Scheduler.model.EventModel} eventRecord The event record
   *
   **/
  onAfterSave(eventRecord) {}

  /**
   * Updates record being edited with values from the editor
   * @private
   */
  updateRecord(record) {
    const { values } = this;

    // Clean resourceId / resources out of values when using assignment store, it will handle the assignment
    if (this.scheduler.assignmentStore) {
      delete values.resource;
    }

    record.set(values);
  }

  //endregion

  //region Events

  onPopupBeforeHide() {
    const me = this;
    me.client.element.classList.remove('b-eventeditor-editing');
    me.dragProxyElement && me.dragProxyElement.remove();
    me.dragProxyElement = null;
  }

  onPopupKeyDown({ event }) {
    if (event.key === 'Enter' && this.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === 'input') {
      // Need to prevent this key events from being fired on whatever receives focus after the editor is hidden
      event.preventDefault();

      // If enter key was hit in an input element of a start field, need to adjust end date fields (the same way as if #onDatesChange handler was called)
      if (event.target.name === 'startDate') {
        adjustEndDate(this.startDateField.value, this.startTimeField.value, this);
      }

      this.onSaveClick();
    }
  }

  onSaveClick() {
    if (this.save()) {
      this.editor.close();
    }
  }

  onDeleteClick() {
    if (this.deleteEvent()) {
      // We expect deleteEvent will trigger close if autoClose is true and focus has moved out,
      // otherwise need to call it manually
      if (!this.editor.autoClose || this.editor.containsFocus) {
        this.editor.close();
      }
    }
  }

  onCancelClick() {
    this.editor.close();
  }

  //endregion
}
EditBase._$name = 'EditBase';

/**
 * @module Scheduler/view/EventEditor
 */

/**
 * Provided event editor dialog.
 *
 * @extends Common/widget/Popup
 * @private
 */
class EventEditor extends Popup {
  static get defaultConfig() {
    return {
      items: [],
      draggable: {
        handleSelector: ':not(button,.b-field-inner)' // blacklist buttons and field inners
      },
      axisLock: 'flexible'
    };
  }

  processWidgetConfig(widget) {
    const me = this,
      eventEditFeature = me.eventEditFeature;

    if (widget.type === 'extraItems') {
      return false;
    }

    let fieldConfig = {};

    if (widget.ref === 'resourceField') {
      if (!eventEditFeature.showResourceField) return false;

      // Can't use store directly since it may be grouped and then contains irrelevant group records
      me.resourceStore = widget.store = new eventEditFeature.resourceStore.constructor({
        chained: true,
        chainAllRecords: true, // By default it chains processedRecords, leading to only "expanded" resources showing up in editor
        masterStore: eventEditFeature.resourceStore,
        chainedFilterFn: (record) => !record.meta.specialRow
      });

      widget.multiSelect = Boolean(eventEditFeature.scheduler.assignmentStore);

      if (eventEditFeature.resourceFieldConfig) fieldConfig = eventEditFeature.resourceFieldConfig;
    }

    if (widget.ref === 'nameField' && !eventEditFeature.showNameField) return false;

    if (widget.ref === 'deleteButton' && !eventEditFeature.showDeleteButton) return false;

    if ((widget.name === 'startDate' || widget.name === 'endDate') && widget.type === 'date') {
      fieldConfig.format = eventEditFeature.dateFormat;
    }

    if ((widget.name === 'startDate' || widget.name === 'endDate') && widget.type === 'time') {
      fieldConfig.format = eventEditFeature.timeFormat;
    }

    if (eventEditFeature.startDateConfig && widget.name === 'startDate' && widget.type === 'date') {
      fieldConfig = eventEditFeature.startDateConfig;
    }

    if (eventEditFeature.startTimeConfig && widget.name === 'startDate' && widget.type === 'time') {
      fieldConfig = eventEditFeature.startTimeConfig;
    }

    if (eventEditFeature.endDateConfig && widget.name === 'endDate' && widget.type === 'date') {
      fieldConfig = eventEditFeature.endDateConfig;
    }

    if (eventEditFeature.endTimeConfig && widget.name === 'endDate' && widget.type === 'time') {
      fieldConfig = eventEditFeature.endTimeConfig;
    }

    Object.assign(widget, fieldConfig);

    return super.processWidgetConfig(widget);
  }

  show(...args) {
    // Updated chained store. It is not done automatically for grouping/trees.
    if (this.resourceStore) {
      this.resourceStore.fillFromMaster();
    }

    super.show(...args);
  }

  afterShow(...args) {
    const deleteButton = this.widgetMap.deleteButton;

    // Only show delete button if the event belongs to a store
    if (deleteButton) {
      deleteButton.hidden = this.readOnly || !this.record.stores.length;
    }
    super.afterShow(...args);
  }

  onInternalKeyDown(event) {
    this.trigger('keyDown', { event });
    super.onInternalKeyDown(event);
  }

  set readOnly(readOnly) {
    const { deleteButton, saveButton, cancelButton } = this.widgetMap;

    this._readOnly = readOnly;

    this.element.classList[readOnly ? 'add' : 'remove']('b-readonly');

    this.eachWidget((widget) => {
      widget.readOnly = readOnly;
    });

    if (deleteButton) {
      deleteButton.hidden = readOnly;
    }

    if (saveButton) {
      saveButton.hidden = readOnly;
    }

    if (cancelButton) {
      cancelButton.hidden = readOnly;
    }
  }

  get readOnly() {
    return this._readOnly;
  }
}
EventEditor._$name = 'EventEditor';

/**
 * @module Scheduler/feature/EventEdit
 */

/**
 * Feature that displays a popup containing fields for editing event data.
 *
 * To customize its contents you can:
 *
 * * Toggle visibility of some built in widgets: `showResourceField`, `showNameField` and `showDeleteButton`
 * * Change the date format of the date & time fields: `dateFormat` and `timeFormat`
 * * Configure date & time fields: `startDateConfig`, `startTimeConfig`, `endDateConfig` and `endTimeConfig`
 * * Configure the resource field: `resourceFieldConfig`
 * * Append additional fields: `extraItems`
 * * Advanced: Replace entire contents using `editorConfig`
 *
 * This feature is **enabled** by default
 *
 * @extends Scheduler/feature/base/EditBase
 * @demo eventeditor
 * @externalexample scheduler/EventEdit.js
 */
class EventEdit extends EditBase {
  //region Config

  // TODO: check which configs are actually used

  static get defaultConfig() {
    return {
      /**
       * The event that shall trigger showing the editor. Defaults to `eventdblclick`, set to `` or null to disable editing of existing events.
       * @config {String}
       * @default
       * @category Editor
       */
      triggerEvent: 'eventdblclick',

      /**
       * True to show a combo for picking resource
       * @config {Boolean}
       * @default
       * @category Editor widgets
       */
      showResourceField: true,

      // TODO remove this config?
      /**
       * Config for the resourceField constructor.
       * @config {Object}
       * @category Editor widgets
       */
      resourceFieldConfig: null,

      /**
       * The field in the model that defines the eventType.
       * Applied as class (b-eventtype-xx) to editor element, to allow showing/hiding fields depending on eventType.
       * @config {String}
       * @default
       * @category Editor
       */
      typeField: 'eventType',

      /**
       * The current {@link Scheduler.model.EventModel} record, which is being edited by the event editor.
       * @property {Scheduler.model.EventModel}
       * @readonly
       */
      eventRecord: null,

      /**
       * Specify `true` to put the editor in read only mode.
       * @config {Boolean}
       * @default false
       */
      readOnly: null,

      /**
       * Default editor configuration, which widgets it shows etc.
       * @config {Object}
       * @category Editor
       */
      editorConfig: {
        title: 'L{Edit Event}',
        localeClass: this,
        closable: true,

        items: [
          /**
           * Reference to the name field, if used
           * @member {Common.widget.TextField} nameField
           * @readonly
           */
          {
            type: 'text',
            localeClass: this,
            label: 'L{Name}',
            clearable: true,
            name: 'name',
            ref: 'nameField'
          },
          /**
           * Reference to the resource field, if used
           * @member {Common.widget.Combo} resourceField
           * @readonly
           */
          {
            type: 'combo',
            localeClass: this,
            label: 'L{Resource}',
            name: 'resource',
            ref: 'resourceField',
            editable: false,
            valueField: 'id',
            displayField: 'name'
          },
          /**
           * Reference to the start date field, if used
           * @member {Common.widget.DateField} startDateField
           * @readonly
           */
          {
            type: 'date',
            cls: 'b-inline',
            clearable: false,
            required: true,
            localeClass: this,
            label: 'L{Start}',
            name: 'startDate',
            ref: 'startDateField',
            flex: '1 0 60%'
          },
          /**
           * Reference to the start time field, if used
           * @member {Common.widget.TimeField} startTimeField
           * @readonly
           */
          {
            type: 'time',
            clearable: false,
            required: true,
            name: 'startDate',
            ref: 'startTimeField',
            cls: 'b-match-label',
            flex: '1 0 40%'
          },
          /**
           * Reference to the end date field, if used
           * @member {Common.widget.DateField} endDateField
           * @readonly
           */
          {
            type: 'date',
            cls: 'b-inline',
            clearable: false,
            required: true,
            localeClass: this,
            label: 'L{End}',
            name: 'endDate',
            ref: 'endDateField',
            flex: '1 0 60%'
          },
          /**
           * Reference to the end time field, if used
           * @member {Common.widget.TimeField} endTimeField
           * @readonly
           */
          {
            type: 'time',
            clearable: false,
            required: true,
            name: 'endDate',
            ref: 'endTimeField',
            cls: 'b-match-label',
            flex: '1 0 40%'
          },
          {
            // widgets specified in extraItems will be inserted here
            type: 'extraItems'
          }
        ],

        bbar: [
          {
            type: 'widget',
            cls: 'b-label-filler'
          },
          /**
           * Reference to the save button, if used
           * @member {Common.widget.Button} saveButton
           * @readonly
           */
          {
            color: 'b-green',
            localeClass: this,
            text: 'L{Save}',
            ref: 'saveButton'
          },
          /**
           * Reference to the delete button, if used
           * @member {Common.widget.Button} deleteButton
           * @readonly
           */
          {
            color: 'b-gray',
            localeClass: this,
            text: 'L{Delete}',
            ref: 'deleteButton'
          },
          /**
           * Reference to the cancel button, if used
           * @member {Common.widget.Button} cancelButton
           * @readonly
           */
          {
            color: 'b-gray',
            localeClass: this,
            text: 'L{Cancel}',
            ref: 'cancelButton'
          }
        ]
      }
    };
  }

  static get pluginConfig() {
    return {
      chain: ['getEventMenuItems', 'onEnterKey'],
      assign: ['editEvent']
    };
  }

  //endregion

  //region Init & destroy

  construct(scheduler, config) {
    const me = this;

    me.scheduler = scheduler;
    me.eventStore = scheduler.eventStore;
    me.resourceStore = scheduler.resourceStore;

    super.construct(scheduler, config);
  }

  //endregion

  //region Editing

  /**
   * Get/set readonly state
   * @property {Boolean}
   */
  get readOnly() {
    return this.editor ? this.editor.readOnly : this._readOnly;
  }

  set readOnly(readOnly) {
    this._readOnly = readOnly;

    if (this.editor) {
      this.editor.readOnly = readOnly;
    }
  }

  /**
   * Gets an editor instance. Creates on first call, reuses on consecutive
   * @internal
   * @returns {Common.widget.Popup} Editor popup
   */
  getEditor() {
    const me = this;

    let { editor } = me;

    if (editor) {
      return editor;
    }

    editor = me.editor = new EventEditor(
      ObjectHelper.assign(
        {
          eventEditFeature: me,
          align: 'b-t',
          id: `${me.scheduler.id}-event-editor`,
          autoShow: false,
          anchor: true,
          scrollAction: 'realign',
          clippedBy: [me.scheduler.timeAxisSubGridElement, me.scheduler.bodyContainer],
          constrainTo: window,
          autoClose: me.autoClose,
          cls: me.cls,
          readOnly: me.readOnly
        },
        me.editorConfig
      )
    );

    if (editor.items.length === 0) {
      console.warn('Event Editor configured without any `items`');
    }

    // add listeners programmatically so users cannot override them accidentally
    editor.on({
      beforehide: me.onPopupBeforeHide,
      keydown: me.onPopupKeyDown,
      thisObj: me
    });

    // assign widget variables, using widget name: startDate -> me.startDateField
    // widgets with id set use that instead, id -> me.idField
    Object.values(editor.widgetMap).forEach((widget) => {
      const ref = widget.ref || widget.id;
      // don't overwrite if already defined
      if (ref && !me[ref]) {
        me[ref] = widget;

        switch (widget.name) {
          case 'startDate':
          case 'endDate':
            widget.on('change', me.onDatesChange, me);
            break;
        }
      }
    });

    me.saveButton && me.saveButton.on('click', me.onSaveClick, me);
    me.deleteButton && me.deleteButton.on('click', me.onDeleteClick, me);
    me.cancelButton && me.cancelButton.on('click', me.onCancelClick, me);

    return me.editor;
  }

  // Called from editEvent() to actually show the editor
  internalShowEditor(eventRecord, resourceRecord, element = null) {
    const me = this,
      scheduler = me.scheduler;

    // Align to the element (b-sch-event) and not the wrapper
    const eventElement =
        element ||
        DomHelper.down(scheduler.getElementFromEventRecord(eventRecord, resourceRecord), scheduler.eventInnerSelector),
      eventType = eventRecord.get(me.typeField);

    // Event not in current TimeAxis - cannot be edited without extending the TimeAxis.
    // If there's no event element and the eventRecord is not in the store, we still
    // edit centered on the Scheduler - we're adding a new event
    if (eventElement || !eventRecord.isPartOfStore(scheduler.eventStore)) {
      /**
       * Fires on the owning Scheduler before an event is displayed in an editor.
       * This may be listened for to allow an application to take over event editing duties. Returning `false`
       * stops the default editing UI from being shown.
       * @event beforeEventEdit
       * @param {Scheduler.view.Scheduler} source The scheduler
       * @param {Scheduler.feature.EventEdit} eventEdit The eventEdit feature
       * @param {Scheduler.model.EventModel} eventRecord The record about to be shown in the event editor.
       * @param {Scheduler.model.ResourceModel} resourceRecord The Resource record for the event. If the event
       * is being created, it will not contain a resource, so this parameter specifies the resource the
       * event is being created for.
       * @param {HTMLElement} eventElement The element which represents the event in the scheduler display.
       * @preventable
       */
      if (
        scheduler.trigger('beforeEventEdit', {
          eventEdit: me,
          eventRecord,
          resourceRecord,
          eventElement
        }) === false
      ) {
        scheduler.element.classList.remove('b-eventeditor-editing');
        me.dragProxyElement && me.dragProxyElement.remove();
        me.dragProxyElement = null;
        return;
      }

      me.resourceRecord = resourceRecord;

      const editor = me.getEditor(eventRecord);

      // expose eventType in dataset, for querying and styling
      editor.element.dataset.eventType = eventType || '';

      // toggle visibility of widgets belonging to eventTypes
      editor.eachWidget(
        (widget) =>
          widget.dataset && widget.dataset.eventType && (widget.hidden = widget.dataset.eventType !== eventType)
      );

      /**
       * Fires on the owning Scheduler when the editor for an event is available but before it is populated with
       * data and shown. Allows manipulating fields etc.
       * @event beforeEventEditShow
       * @param {Scheduler.view.Scheduler} source The scheduler
       * @param {Scheduler.feature.EventEdit} eventEdit The eventEdit feature
       * @param {Scheduler.model.EventModel} eventRecord The record about to be shown in the event editor.
       * @param {Scheduler.model.ResourceModel} resourceRecord The Resource record for the event. If the event
       * is being created, it will not contain a resource, so this parameter specifies the resource the
       * event is being created for.
       * @param {HTMLElement} eventElement The element which represents the event in the scheduler display.
       * @param {Common.widget.Popup} editor The editor
       */
      scheduler.trigger('beforeEventEditShow', {
        eventEdit: me,
        eventRecord,
        resourceRecord,
        eventElement,
        editor
      });

      me.loadRecord(eventRecord, resourceRecord);

      if (eventElement) {
        eventElement.classList.add('b-editing');
        editor.anchor = true;
        editor.showBy(eventElement);
      }
      // We are adding a new event. Display the editor centered in the Scheduler
      else {
        editor.anchor = false;
        editor.showBy({
          target: scheduler.element,
          align: 'c-c'
        });
      }

      // Adjust time field step increment based on timeAxis resolution
      const timeResolution = scheduler.timeAxisViewModel.timeResolution;

      if (timeResolution.unit === 'hour' || timeResolution.unit === 'minute') {
        me.startTimeField.step = me.endTimeField.step = `${timeResolution.increment}${timeResolution.unit}`;
      }
    }
  }

  /**
   * Opens an editor for the passed event. This function is exposed on Scheduler and can be called as
   * `scheduler.editEvent()`.
   * @param {Scheduler.model.EventModel} eventRecord Event to edit
   * @param {Scheduler.model.ResourceModel} [resourceRecord] The Resource record for the event.
   * This parameter is needed if the event is newly created for a resource and has not been assigned, or when using
   * multi assignment.
   * @param {HTMLElement} [element] Element to anchor editor to (defaults to events element)
   */
  editEvent(eventRecord, resourceRecord, element = null) {
    const me = this,
      scheduler = me.scheduler;

    if (scheduler.readOnly) return;

    // The Promise being async allows a mouseover to trigger the event tip
    // unless we add the editing class immediately.
    scheduler.element.classList.add('b-eventeditor-editing');

    if (!resourceRecord) {
      if (eventRecord.resource) {
        resourceRecord = eventRecord.resource;
      }
      // New event not yet in store has not got the relation set up, use id if available
      else if (eventRecord.resourceId) {
        resourceRecord = scheduler.resourceStore.getById(eventRecord.resourceId);
      }
    }

    // If element is specified (call triggered by EventDragCreate)
    // Then we can align to that, and no scrolling is necessary.
    // If we are simply being asked to edit a new event which is not
    // yet added, the editor is centered, and no scroll is necessary
    if (element || scheduler.eventStore.indexOf(eventRecord) < 0) {
      me.internalShowEditor(eventRecord, resourceRecord, element);
    } else {
      // Ensure event is in view before showing the editor.
      // Note that we first need to extend the time axis to include
      // currently out of range events.
      scheduler
        .scrollResourceEventIntoView(resourceRecord, eventRecord, null, {
          animate: true,
          edgeOffset: 0,
          extendTimeAxis: false
        })
        .then(
          () => me.internalShowEditor(eventRecord, resourceRecord),
          () => scheduler.element.classList.remove('b-eventeditor-editing')
        );
    }
  }

  /**
   * Sets fields values from record being edited
   * @private
   */
  loadRecord(eventRecord, resourceRecord, readOnly = false) {
    const me = this,
      { eventStore } = me.client;
    //        this.setReadOnly(readOnly);

    me.eventRecord = eventRecord;
    me.resourceRecord = resourceRecord;

    me.editor.record = eventRecord;

    if (me.resourceField) {
      const resources = eventStore.getResourcesForEvent(eventRecord);

      // If this is an unassigned event, select the resource we've been provided
      if (!eventStore.storage.includes(eventRecord, true) && me.resourceRecord) {
        me.resourceField.value = me.resourceRecord[me.resourceField.valueField];
      } else if (me.scheduler.assignmentStore) {
        me.resourceField.value = resources.map((resource) => resource[me.resourceField.valueField]);
      }
    }
  }

  //endregion

  //region Save

  // Override of EditBase get values, to exclude resourceId when using an AssignmentStore. Without this
  // event.resourceId would end up as [r1, r2] etc. Which in turn breaks the event -> resource relation
  get values() {
    const values = super.values;

    if (this.scheduler.assignmentStore) {
      // Not used with AssignmentStore
      delete values.resourceId;
    }

    return values;
  }

  /**
   * Saves the changes (applies them to record if valid, if invalid editor stays open)
   * @private
   * @fires beforeeventsave
   * @fires beforeeventadd
   * @fires aftereventsave
   * @returns {*}
   */
  save() {
    const me = this,
      { scheduler, eventRecord } = me;

    if (!eventRecord || !me.isValid) {
      return;
    }

    const eventStore = me.eventStore,
      values = me.values,
      resourceRecords = (me.resourceField && me.resourceField.records) || [me.resourceRecord];

    // Check for potential overlap scenarios before saving. TODO needs to be indicated in the UI
    if (!me.scheduler.allowOverlap && eventStore) {
      const abort = resourceRecords.some((resource) => {
        return !eventStore.isDateRangeAvailable(values.startDate, values.endDate, eventRecord, resource);
      });

      if (abort) {
        return;
      }
    }

    /**
     * Fires on the owning Scheduler before an event is saved
     * @event beforeeventsave
     * @param {Scheduler.view.Scheduler} source The scheduler instance
     * @param {Scheduler.model.EventModel} eventRecord The record about to be saved
     * @param {Scheduler.model.ResourceModel} resourceRecord [DEPRECATED IN FAVOR OF `resourceRecords`] The resource to which the event is assigned
     * @param {Scheduler.model.ResourceModel[]} resourceRecords The resources to which the event is assigned
     * @param {Object} values The new values
     * @preventable
     */
    if (
      scheduler.trigger('beforeEventSave', {
        eventRecord,
        resourceRecords,
        resourceRecord: resourceRecords[0],
        values
      }) !== false
    ) {
      me.onBeforeSave(eventRecord);

      eventRecord.beginBatch();
      me.updateRecord(eventRecord);
      eventRecord.endBatch();

      // Check if this is a new record
      if (eventStore && !eventRecord.stores.length) {
        /**
         * Fires on the owning Scheduler before an event is added
         * @event beforeEventAdd
         * @param {Scheduler.view.Scheduler} source The Scheduler instance.
         * @param {Scheduler.model.EventModel} eventRecord The record about to be added
         * @param {Scheduler.model.ResourceModel[]} resources **Deprecated** Use `resourceRecords` instead
         * @param {Scheduler.model.ResourceModel[]} resourceRecords Resources that the record is assigned to
         * @preventable
         */
        if (
          scheduler.trigger('beforeEventAdd', { eventRecord, resourceRecords, resources: resourceRecords }) !== false
        ) {
          // Hand over the proxy element to be used by the new event
          if (me.dragProxyElement) {
            const eventTpl = scheduler.generateTplData(eventRecord, resourceRecords[0]);

            // Adopt the proxy as an event element.
            if (eventTpl) {
              DomHelper.syncClassList(me.dragProxyElement, eventTpl.wrapperCls);
              DomHelper.createElement({
                tag: 'div',
                parent: me.dragProxyElement,
                className: eventTpl.cls.toString()
              });

              // This is a signal that it's from a drag-create, so needs to stay
              me.dragProxyElement.classList.add('b-sch-dragcreator-proxy');
              me.dragProxyElement.id = eventTpl.id;
              scheduler.isHorizontal && scheduler.currentOrientation.releaseTimeSpanDiv(me.dragProxyElement, true);
              me.dragProxyElement = null;

              // Flag to let HorizontalEventMapper know that it should reuse the element even though the
              // event is new
              eventRecord.instanceMeta(scheduler).fromDragProxy = true;
            }
          }

          // Add to eventStore first, then assign the resource. Order is necessary since assigning might
          // involve an AssignmentStore
          me.eventStore.add(eventRecord);
          me.eventStore.assignEventToResource(eventRecord, resourceRecords);

          // If a filter was reapplied and filtered out the newly added event we need to clean up the drag proxy...
          if (!me.eventStore.includes(eventRecord)) {
            // Feels a bit strange having that responsibility here, but since it is already handled
            const proxyElement = scheduler.element.querySelector('.b-sch-dragcreator-proxy');

            if (proxyElement) {
              scheduler.currentOrientation.availableDivs.remove(proxyElement);
              proxyElement.remove();
            }
          }
        } else {
          return;
        }
      } else if (scheduler.assignmentStore) {
        me.eventStore.assignEventToResource(eventRecord, resourceRecords, true);
      }

      /**
       * Fires on the owning Scheduler after an event is successfully saved
       * @event afterEventSave
       * @param {Scheduler.view.Scheduler} source The scheduler instance
       * @param {Scheduler.model.EventModel} eventRecord The record about to be saved
       */
      scheduler.trigger('afterEventSave', { eventRecord });
      me.onAfterSave(eventRecord);
    }

    return eventRecord;
  }

  //endregion

  //region Delete

  /**
   * Delete event being edited
   * @private
   * @fires beforeeventdelete
   */
  deleteEvent() {
    const me = this,
      eventRecord = me.eventRecord;

    /**
     * Fires on the owning Scheduler before an event is deleted
     * @event beforeeventdelete
     * @param {Scheduler.view.Scheduler} source The Scheduler instance.
     * @param {Scheduler.model.EventModel} eventRecord The record about to be deleted
     * @preventable
     */
    if (me.scheduler.trigger('beforeEventDelete', { eventRecord }) !== false) {
      // The reason it does it here is to move focus *before* it gets deleted,
      // and then there's code in the delete to see that it's deleting the focused one,
      // and jump forwards or backwards to move to the next or previous event
      // See 'Should allow key activation' test in tests/view/mixins/EventNavigation.t.js
      if (me.editor.containsFocus) {
        me.editor.revertFocus();
      }
      me.scheduler.removeRecords([eventRecord]);
      return true;
    }

    return false;
  }

  //endregion

  //region Stores

  get resourceStore() {
    return this._resourceStore;
  }

  set resourceStore(store) {
    this._resourceStore = store;
    if (this.resourceField) {
      this.resourceField.store = store;
    }
  }

  //endregion

  //region Events

  onActivateEditor({ eventRecord, resourceRecord }) {
    this.editEvent(eventRecord, resourceRecord);
  }

  onDragCreateEnd({ newEventRecord, resourceRecord, proxyElement }) {
    const me = this;

    // Call scheduler template method
    me.scheduler.onEventCreated(newEventRecord);

    // Clone proxy after showing editor so it's not deleted
    const dragProxyElement = proxyElement.cloneNode(true);
    dragProxyElement.removeAttribute('id');
    proxyElement.parentElement.appendChild(dragProxyElement);

    me.dragProxyElement = dragProxyElement;

    me.editEvent(newEventRecord, resourceRecord, dragProxyElement);
  }

  // chained from EventNavigation
  onEnterKey({ assignmentRecord, eventRecord }) {
    if (assignmentRecord) {
      this.editEvent(eventRecord, assignmentRecord.resource);
    } else if (eventRecord) {
      this.editEvent(eventRecord, eventRecord.resource);
    }
  }

  //endregion

  //region Context menu

  getEventMenuItems({ eventRecord, resourceRecord, items }) {
    if (!this.scheduler.readOnly) {
      items.editEvent = {
        text: this.L('Edit Event'),
        icon: 'b-icon b-icon-edit',
        weight: -200,
        onItem: () => {
          this.editEvent(eventRecord, resourceRecord);
        }
      };
    }
  }

  //endregion
}

EventEdit._$name = 'EventEdit';
GridFeatureManager.registerFeature(EventEdit, true, 'Scheduler');

/**
 * @module Scheduler/feature/EventFilter
 */

/**
 * Adds event filter menu items to the timeline header context menu.
 *
 * This feature is **enabled** by default
 *
 * @extends Common/mixin/InstancePlugin
 */
class EventFilter extends InstancePlugin {
  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['getHeaderMenuItems']
    };
  }

  construct(scheduler, config) {
    super.construct(scheduler, config);

    this.scheduler = scheduler;
  }

  /**
   * Populates the header context menu items.
   * @param {Grid.column.Column} column Column for which the menu will be shown
   * @param {Object[]} items Array of menu items
   * @internal
   */
  getHeaderMenuItems(column, items) {
    const me = this;

    if (column.type !== 'timeAxis') return;

    items.push({
      text: me.L('filterEvents'),
      icon: 'b-fw-icon b-icon-filter',
      menu: {
        type: 'popup',
        items: [
          {
            type: 'textfield',
            cls: 'b-eventfilter b-last-row',
            clearable: true,
            keyStrokeChangeDelay: 300,
            label: me.L('byName'),
            width: 200,
            listeners: {
              change: me.onEventFilterChange,
              thisObj: me
            }
          }
        ],
        onBeforeShow({ source: menu }) {
          const [filterByName] = menu.items,
            filter = me.scheduler.eventStore.filters.getBy('property', 'name');

          filterByName.value = filter && filter.value;
        }
      }
    });
  }

  onEventFilterChange({ value }) {
    const me = this;

    if (value !== '') {
      me.scheduler.eventStore.filter('name', value);
    } else {
      me.scheduler.eventStore.removeFieldFilter('name');
    }
  }
}

EventFilter.featureClass = 'b-event-filter';

EventFilter._$name = 'EventFilter';
GridFeatureManager.registerFeature(EventFilter, true, ['Scheduler', 'Gantt']);

//TODO: Prevent right click while resizing (do it in ResizeHelper?)

/**
 * @module Scheduler/feature/base/ResizeBase
 */

const tipAlign = {
  top: 'b-t',
  right: 'b100-t100',
  bottom: 't-b',
  left: 'b0-t0'
};

/**
 * Base class for EventResize (Scheduler) and TaskResize (Gantt) features. Contains shared code. Not to be used directly.
 *
 * @extends Common/mixin/InstancePlugin
 * @abstract
 */
class ResizeBase extends InstancePlugin {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * `false` to not show a tooltip while resizing
       * @config {Boolean}
       * @default
       */
      showTooltip: true,

      /**
       * true to see exact event length during resizing
       * @config {Boolean}
       * @default
       */
      showExactResizePosition: false,

      /**
       * An empty function by default, but provided so that you can perform custom validation on
       * the item being resized. Return true if the new duration is valid, false to signal that it is not.
       * @param {Object} context The resize context, contains the record & dates.
       * @param {Event} e The browser Event object
       * @return {Boolean}
       * @config {Function}
       */
      validatorFn: () => {},

      /**
       * `this` reference for the validatorFn
       * @config {Object}
       */
      validatorFnThisObj: null,

      /**
       * The tooltip instance to show while resizing an event or a configuration object for the {@link Common.widget.Tooltip}.
       * @config {Common.widget.Tooltip}
       */
      tip: null,

      tipTemplate: (data) => `
                <div class="b-sch-tip-${data.valid ? 'valid' : 'invalid'}">
                    ${data.startClockHtml}
                    ${data.endClockHtml}
                    <div class="b-sch-tip-message">${data.message}</div>
                </div>
            `
    };
  }

  static get pluginConfig() {
    return {
      chain: ['render']
    };
  }

  //endregion

  //region Init & destroy

  render() {
    const me = this,
      client = me.client;

    me.resize && me.resize.destroy();

    me.resize = me.createResizeHelper();

    if (me.showTooltip) {
      me.clockTemplate = new ClockTemplate({
        timeAxisViewModel: client.timeAxisViewModel
      });
    }
  }

  doDestroy() {
    const me = this;

    me.tip && me.tip.destroy();
    me.clockTemplate && me.clockTemplate.destroy();
    me.resize && me.resize.destroy();

    super.doDestroy();
  }

  //endregion

  //region Events

  isElementResizable(element, event) {
    const { client, resize } = this,
      timespanRecord = client.resolveTimeSpanRecord(element);

    if (client.readOnly) {
      return false;
    }

    let resizable = timespanRecord && timespanRecord.isResizable;

    // go up from "handle" to resizable element
    element = DomHelper.up(event.target, client.eventSelector);

    // Not resizable if the mousedown is on a resizing handle of
    // a percent bar.
    const handleHoldingElement = element ? element.firstElementChild : element,
      handleEl = event.target.closest('[class$="-handle"]');
    if (!resizable || (handleEl && handleEl !== handleHoldingElement)) {
      return false;
    }

    let startsOutside = element.classList.contains('b-sch-event-startsoutside'),
      endsOutside = element.classList.contains('b-sch-event-endsoutside');

    if (resizable === true) {
      if (startsOutside && endsOutside) {
        return false;
      } else if (startsOutside) {
        resizable = 'end';
      } else if (endsOutside) {
        resizable = 'start';
      } else {
        return resize.overStartHandle(event, element) || resize.overEndHandle(event, element);
      }
    }

    if ((startsOutside && resizable === 'start') || (endsOutside && resizable === 'end')) {
      return false;
    }

    if (
      (resize.overStartHandle(event, element) && resizable === 'start') ||
      (resize.overEndHandle(event, element) && resizable === 'end')
    ) {
      return true;
    }

    return false;
  }

  onBeforeResizeStart({ element, event }) {
    const { client } = this,
      name = client.scheduledEventName,
      timespanRecord = client.resolveTimeSpanRecord(element);

    // trigger beforeEventResize or beforeTaskResize depending on product
    return (
      client.trigger(`before${client.capitalizedEventName}Resize`, { [name + 'Record']: timespanRecord, event }) !==
      false
    );
  }

  onResizeStart({ context, event }) {
    const me = this,
      client = me.client,
      timespanRecord = client.resolveTimeSpanRecord(context.element),
      name = client.scheduledEventName;

    client.element.classList.add('b-resizing-event');

    // Let products to their specific stuff
    me.setupProductResizeContext(context, event);

    if (me.showTooltip) {
      if (me.tip) {
        me.tip.align = tipAlign[context.edge];
        me.tip.showBy(me.getTooltipTarget());
      } else {
        me.tip = new Tooltip({
          id: `${client.id}-event-resize-tip`,
          autoShow: true,
          axisLock: true,
          trackMouse: false,
          getHtml: me.getTipHtml.bind(me),
          align: tipAlign[context.edge],
          hideDelay: 0
        });

        me.tip.on('innerhtmlupdate', me.updateDateIndicator, me);
      }
    }

    // flag to not allow release of element when scrolling
    timespanRecord.instanceMeta(client).retainElement = true;

    // Trigger eventResizeStart or taskResizeStart depending on product
    client.trigger(`${name}ResizeStart`, { [`${name}Record`]: timespanRecord, event });
  }

  updateDateIndicator() {
    const { edge, startDate, endDate } = this.resize.context,
      { element } = this.tip;

    if (startDate || endDate) {
      if (edge === 'right' || edge === 'bottom') {
        this.clockTemplate.updateDateIndicator(element.querySelector('.b-sch-tooltip-enddate'), endDate);
      } else {
        this.clockTemplate.updateDateIndicator(element, startDate);
      }
    }
  }

  getTooltipTarget() {
    const me = this,
      target = Rectangle.from(me.resize.context.element, null, true);

    if (me.resize.direction === 'horizontal') {
      // Align to the dragged edge of the proxy, and then bump right so that the anchor aligns perfectly.
      if (me.resize.context.edge === 'right') {
        target.x = target.right - 1;
      }
      target.width = me.tip.anchorSize[0] / 2;
    } else {
      // Align to the dragged edge of the proxy, and then bump bottom so that the anchor aligns perfectly.
      if (me.resize.context.edge === 'bottom') {
        target.y = target.bottom - 1;
      }
      target.height = me.tip.anchorSize[1] / 2;
    }

    return { target };
  }

  onResizing({ context, event }) {
    const me = this,
      { client } = me,
      depFeature = client.features.dependencies,
      timespanRecord = me.getTimespanRecord(context),
      name = client.scheduledEventName,
      { element, edge } = context,
      xy = DomHelper.getTranslateXY(element);

    let start, end;

    if (edge === 'top' || edge === 'left') {
      end = timespanRecord.endDate;

      if (client.snapRelativeToEventStartDate) {
        start = client.getDateFromXY(xy, null, true);
        start = client.timeAxis.roundDate(start, timespanRecord.startDate);
      } else {
        start = client.getDateFromXY(xy, 'round', true);
      }
    }
    // bottom || right
    else {
      xy[0] += element.offsetWidth;
      xy[1] += element.offsetHeight;

      start = timespanRecord && timespanRecord.startDate;

      if (client.snapRelativeToEventStartDate) {
        end = client.getDateFromXY(xy, null, true);
        end = client.timeAxis.roundDate(end, timespanRecord.endDate);
      } else {
        end = client.getDateFromXY(xy, 'round', true);
      }
    }

    start = start || context.startDate;
    end = end || context.endDate;

    if (context.dateConstraints) {
      start = DateHelper.constrain(start, context.dateConstraints.start, context.dateConstraints.end);
      end = DateHelper.constrain(end, context.dateConstraints.start, context.dateConstraints.end);
    }

    if (me.showExactResizePosition || client.timeAxisViewModel.snap) {
      const exactSize =
        edge === 'top' || edge === 'left'
          ? client.timeAxisViewModel.getDistanceBetweenDates(start, timespanRecord.endDate)
          : client.timeAxisViewModel.getDistanceBetweenDates(timespanRecord.startDate, end);

      switch (edge) {
        case 'top':
          DomHelper.setTranslateY(element, context.elementStartY + context.elementWidth - exactSize);
          element.style.height = exactSize + 'px';
          break;
        case 'right':
          element.style.width = exactSize + 'px';
          break;
        case 'bottom':
          element.style.height = exactSize + 'px';
          break;
        case 'left':
          DomHelper.setTranslateX(element, context.elementStartX + context.elementWidth - exactSize);
          element.style.width = exactSize + 'px';
          break;
      }
    }

    const dateChanged = context.endDate - end !== 0 || context.startDate - start !== 0;

    context.endDate = end;
    context.startDate = start;

    // No need to query on every pixel of mouse move
    if (dateChanged) {
      context.valid = me.checkValidity(context, event);
    }

    // Trigger eventPartialResize or taskPartialResize depending on product
    client.trigger(`${name}PartialResize`, {
      [`${name}Record`]: timespanRecord,
      startDate: start,
      endDate: end,

      element,
      context
    });

    if (depFeature) {
      depFeature.updateDependenciesForTimeSpan(timespanRecord, element);
    }

    if (me.showTooltip) {
      me.tip.alignTo(me.getTooltipTarget());
    }
  }

  checkValidity(context, event) {
    let valid =
      context.startDate &&
      context.endDate > context.startDate &&
      this.validatorFn.call(this.validatorFnThisObj || this, context, event);

    if (valid && typeof valid !== 'boolean') {
      context.message = valid.message || '';

      valid = valid.valid;
    }

    return valid !== false;
  }

  onFinishResize({ source: drag, context, event }) {
    const me = this,
      timespanRecord = me.getTimespanRecord(context),
      oldStart = timespanRecord.startDate,
      oldEnd = timespanRecord.endDate,
      start = context.startDate || oldStart,
      end = context.endDate || oldEnd,
      client = me.client;

    let modified = false;

    // allow release of element again
    timespanRecord.instanceMeta(client).retainElement = false;

    const old = context.finalize;
    context.finalize = (...params) => {
      // We are overriding context of the resize helper. It is finalized automatically on sync resize. Which means,
      // we should only call finalize if context is async.
      context.async && me.finalize(...params);
      old.call(context, params);
    };

    context.valid =
      start &&
      end &&
      end - start > 0 && // Input sanity check
      (start - oldStart !== 0 || end - oldEnd !== 0) && // Make sure start OR end changed
      context.valid !== false;

    if (context.valid) {
      // Seems to be a valid resize operation, ask outside world if anyone wants to take control over the finalizing,
      // to show a confirm dialog prior to applying the new values. Triggers beforeEventResizeFinalize or
      // beforeTaskResizeFinalize depending on product
      client.trigger(`before${client.scheduledEventName}ResizeFinalize`, { context: context, event });
      modified = true;
    }

    if (!context.async) {
      me.finalize(modified);
    }
  }

  onCancelResize({ context }) {
    const timespanRecord = this.getTimespanRecord(context);

    // resizing may not have started at all (just clicking a resize handle)
    if (timespanRecord) {
      timespanRecord.instanceMeta(this.client).retainElement = false;
    }

    this.finalize(false);
  }

  finalize(updateRecord) {
    const me = this,
      { client } = me,
      context = me.resize.context,
      timespanRecord = me.getTimespanRecord(context),
      name = client.scheduledEventName;

    let wasChanged = false;

    if (me.tip) {
      me.tip.hide();
    }

    if (context.started) {
      if (updateRecord) {
        // Scheduler and gantt updates the record differently
        wasChanged = me.internalUpdateRecord(context, timespanRecord);
      }

      if (!updateRecord || !wasChanged) {
        const dependencies = client.features.dependencies;

        // Dependencies are updated dynamically during resize, so ensure they are redrawn
        // if the event snaps back with no change.
        if (dependencies) {
          dependencies.scheduleDraw(true);
        }

        client.repaintEventsForResource(me.getRowRecord(context));
      }
    }

    client.element.classList.remove('b-resizing-event');

    // Triggers eventResizeEnd or taskResizeEnd depending on product
    client.trigger(`${name}ResizeEnd`, {
      changed: wasChanged,
      [`${name}Record`]: timespanRecord || client.resolveEventRecord(context.element)
    });
  }

  //endregion

  //region Tooltip

  getTipHtml({ tip }) {
    const me = this;
    let { startDate, endDate, valid, message } = me.resize.context;

    // Empty string hides the tip - we get called before the Resizer, so first call will be empty
    if (!startDate || !endDate) {
      return tip.html;
    }

    if (message === undefined) message = '';

    endDate = me.client.getDisplayEndDate(endDate, startDate);

    let startText = me.client.getFormattedDate(startDate),
      endText = me.client.getFormattedDate(endDate);

    return me.tipTemplate({
      valid,
      startDate,
      endDate,
      startText,
      endText,
      message,
      startClockHtml: me.clockTemplate.template({
        date: startDate,
        text: startText,
        cls: 'b-sch-tooltip-startdate'
      }),
      endClockHtml: me.clockTemplate.template({
        date: endDate,
        text: endText,
        cls: 'b-sch-tooltip-enddate'
      })
    });
  }

  //endregion

  //region Product specific, implemented in subclasses

  getRowRecord(context) {
    throw new Error('Implement in subclass');
  }

  getTimespanRecord(context) {
    throw new Error('Implement in subclass');
  }

  setupProductResizeContext(context, event) {
    throw new Error('Implement in subclass');
  }

  // Store containing the timespan record being resized
  get store() {
    throw new Error('Implement in subclass');
  }

  //endregion
}
ResizeBase._$name = 'ResizeBase';

//TODO: Prevent right click while resizing (do it in ResizeHelper?)

/**
 * @module Scheduler/feature/EventResize
 */

/**
 * Feature that allows resizing an event by dragging its end.
 *
 * By default it displays a tooltip with the new start and end dates, formatted using
 * {@link Scheduler/view/mixin/TimelineViewPresets#config-displayDateFormat}.
 *
 * This feature is **enabled** by default
 *
 * @extends Scheduler/feature/base/ResizeBase
 * @demo basic
 * @externalexample scheduler/EventResize.js
 */
class EventResize extends ResizeBase {
  //region Events

  /**
   * Fired on the owning Scheduler before resizing starts. Return false to prevent operation
   * @event beforeEventResize
   * @param {Scheduler.model.EventModel} eventRecord
   * @param {Event} event
   */

  /**
   * Fires on the owning Scheduler when event resizing starts
   * @event eventResizeStart
   * @param {Scheduler.model.EventModel} eventRecord
   * @param {Event} event
   */

  /**
   * Fires on the owning Scheduler on each resize move event
   * @event eventPartialResize
   * @param {Scheduler.model.EventModel} eventRecord
   * @param {Date} startDate
   * @param {Date} endDate
   * @param {HTMLElement} element
   */

  /**
   * Fired on the owning Scheduler to allow implementer to prevent immediate finalization by setting `data.context.async = true`
   * in the listener, to show a confirmation popup etc
   * ```
   *  scheduler.on('beforeeventresizefinalize', ({context}) => {
   *      context.async = true;
   *      setTimeout(() => {
   *          // async code don't forget to call finalize
   *          context.finalize();
   *      }, 1000);
   *  })
   * ```
   * @event beforeEventResizeFinalize
   * @param {Object} data
   * @param {Scheduler.view.Scheduler} data.source Scheduler instance
   * @param {Object} data.context
   * @param {Boolean} data.context.async Set true to handle resize asynchronously (e.g. to wait for user
   * confirmation)
   * @param {Function} data.context.finalize Call this method to finalize resize. This method accepts one
   * argument: pass true to update records, or false, to ignore changes
   */

  /**
   * Fires on the owning Scheduler after the resizing gesture has finished.
   * @event eventResizeEnd
   * @param {Boolean} wasChanged
   * @param {Scheduler.model.EventModel} eventRecord
   */

  //endregion

  //region Scheduler specifics

  createResizeHelper() {
    const me = this,
      client = me.client;

    return new ResizeHelper({
      direction: client.isVertical ? 'vertical' : 'horizontal',
      name: me.constructor.$name, // for debugging
      isElementResizable: (el, event) => me.isElementResizable(el, event),
      targetSelector: client.eventSelector,
      handleContainerSelector: client.eventInnerSelector,
      resizingCls: 'b-sch-event-wrap-resizing',
      allowResize: me.isElementResizable.bind(me),
      outerElement: client.timeAxisSubGridElement, // constrain resize to view
      scrollManager: client.scrollManager,
      dragThreshold: 0,
      scroller: client.timeAxisSubGrid.scrollable, // allow reading correct x & y scroll
      listeners: {
        beforeresizestart: me.onBeforeResizeStart,
        resizestart: me.onResizeStart,
        resizing: me.onResizing,
        resize: me.onFinishResize,
        cancel: me.onCancelResize,
        thisObj: me
      }
    });
  }

  // Store used by ResizeBase to detect updates on dropped record
  get store() {
    return this.client.eventStore;
  }

  // Used by ResizeBase to get an eventRecord from the drag context
  getTimespanRecord(context) {
    return context.eventRecord;
  }

  getRowRecord(context) {
    return context.resourceRecord;
  }

  // Injects Scheduler specific data into the drag context
  setupProductResizeContext(context, event) {
    const scheduler = this.client,
      eventRecord = scheduler.resolveEventRecord(context.element),
      resourceRecord = scheduler.resolveResourceRecord(context.element);

    Object.assign(context, {
      eventRecord,
      resourceRecord,
      dateConstraints: scheduler.getDateConstraints(resourceRecord, eventRecord)
    });
  }

  onResizeStart({ context, event }) {
    super.onResizeStart({ context, event });

    // Hide terminals when resizing starts
    if (this.client.features.dependencies) {
      this.client.features.dependencies.hideTerminals(context.element);
    }

    // Add resizing cls to inner element, as expected by styling
    context.element.querySelector('.b-sch-event').classList.add('b-sch-event-resizing');
  }

  checkValidity(context, event) {
    return (
      (this.client.allowOverlap ||
        this.client.isDateRangeAvailable(
          context.startDate,
          context.endDate,
          context.eventRecord,
          context.resourceRecord
        )) &&
      super.checkValidity(context, event)
    );
  }

  onFinishResize({ source, context, event }) {
    super.onFinishResize({ source, context, event });

    // When resizing is done successfully, mouse should be over element, so we show terminals
    if (this.client.features.dependencies) {
      this.client.features.dependencies.showTerminals(context.eventRecord, context.element);
    }
  }

  internalUpdateRecord(context, timespanRecord) {
    const { store } = this,
      { generation } = timespanRecord;

    if (context.edge === 'left' || context.edge === 'top') {
      timespanRecord.setStartDate(context.startDate, false, store.skipWeekendsDuringDragDrop);
    } else {
      timespanRecord.setEndDate(context.endDate, false, store.skipWeekendsDuringDragDrop);
    }

    // The record has been changed
    if (timespanRecord.generation !== generation) {
      return true;
    }

    // The record has not been changed
    this.client.repaintEventsForResource(context.resourceRecord);
    return false;
  }

  finalize(updateRecord) {
    this.resize.context.element.querySelector('.b-sch-event').classList.remove('b-sch-event-resizing');
    super.finalize(updateRecord);
  }

  //endregion
}

EventResize._$name = 'EventResize';
GridFeatureManager.registerFeature(EventResize, true, 'Scheduler');

/**
 * @module Scheduler/feature/base/TooltipBase
 */

/**
 * Base class for EventTooltip (Scheduler) and TaskTooltip (Gantt) features. Contains shared code. Not to be used directly.
 *
 * @extends Common/mixin/InstancePlugin
 */
class TooltipBase extends InstancePlugin {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Specify true to have tooltip updated when mouse moves, if you for example want to display date at mouse
       * position.
       * @config {Boolean}
       * @default
       */
      autoUpdate: false,

      template: null,

      cls: null,

      align: 'b-t',

      clockTemplate: null
    };
  }

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['render']
    };
  }

  //endregion

  //region Init

  construct(client, config) {
    const me = this;

    // process initial config into an actual config object
    config = me.processConfig(config);

    super.construct(client, config);

    // Default triggering selector is the client's inner element selector
    if (!me.forSelector) {
      me.forSelector = `${client.eventInnerSelector}:not(.b-dragproxy)`;
    }

    me.clockTemplate = new ClockTemplate({
      timeAxisViewModel: client.timeAxisViewModel
    });

    client.on({
      [`before${client.scheduledEventName}drag`]: () => {
        me.tooltip && me.tooltip.hide();
      }
    });
  }

  // TooltipBase feature handles special config cases, where user can supply a function to use as template
  // instead of a normal config object
  processConfig(config) {
    if (typeof config === 'function') {
      return {
        template: config
      };
    }

    return config;
  }

  // override setConfig to process config before applying it (used mainly from ReactScheduler)
  setConfig(config) {
    super.setConfig(this.processConfig(config));
  }

  doDestroy() {
    this.clockTemplate && this.clockTemplate.destroy();
    this.tooltip && this.tooltip.destroy();

    super.doDestroy();
  }

  //endregion

  render() {
    const me = this,
      client = me.client,
      ignoreSelector = [
        '.b-dragselecting',
        '.b-eventeditor-editing',
        '.b-resizing-event',
        '.b-dragcreating',
        `.b-dragging-${client.scheduledEventName}`,
        '.b-creating-dependency',
        '.b-dragproxy'
      ]
        .map((cls) => `:not(${cls})`)
        .join('');

    if (me.tooltip) me.tooltip.destroy();

    /**
     * A reference to the tooltip instance, which will have a special `eventRecord` property that
     * you can use to get data from the contextual event record to which this tooltip is related.
     * @member {Common.widget.Tooltip} tooltip
     * @readonly
     */
    me.tooltip = new Tooltip(
      Object.assign(
        {
          axisLock: 'flexible',
          id: me.tipId || `${me.client.id}-event-tip`,
          cls: me.tipCls,
          forSelector: `.b-timelinebase${ignoreSelector} ${me.forSelector}`,
          scrollAction: 'realign',
          clippedBy: [client.timeAxisSubGridElement, client.bodyContainer],
          forElement: client.timeAxisSubGridElement,
          showOnHover: true,
          hoverDelay: 0,
          hideDelay: 100,
          anchorToTarget: true,
          allowOver: true,
          getHtml: me.getTipHtml.bind(me)
        },
        me.config
      )
    );

    me.tooltip.on('innerhtmlupdate', me.updateDateIndicator, me);
  }

  updateDateIndicator() {
    const me = this,
      client = me.client,
      tip = me.tooltip,
      timeSpanRecord = tip.activeTarget && client.resolveTimeSpanRecord(tip.activeTarget),
      endDateElement = tip.element.querySelector('.b-sch-tooltip-enddate');

    if (!timeSpanRecord) return;

    me.clockTemplate.updateDateIndicator(tip.element, timeSpanRecord.startDate);

    endDateElement && me.clockTemplate.updateDateIndicator(endDateElement, timeSpanRecord.endDate);
  }

  resolveTimeSpanRecord(forElement) {
    return this.client.resolveTimeSpanRecord(forElement);
  }

  getTipHtml({ tip, forElement }) {
    const me = this,
      client = me.client,
      recordProp = me.recordType || `${client.scheduledEventName}Record`,
      timeSpanRecord = me.resolveTimeSpanRecord(forElement);

    // If user has mouseovered a fading away element of a deleted event,
    // an event record will not be found. In this case the tip must hide.
    if (timeSpanRecord) {
      const { startDate, endDate } = timeSpanRecord,
        startText = client.getFormattedDate(startDate),
        endDateValue = client.getDisplayEndDate(endDate, startDate),
        endText = client.getFormattedDate(endDateValue);

      tip.eventRecord = timeSpanRecord;
      tip.title = timeSpanRecord.name;

      return me.template({
        tip,
        // eventRecord for Scheduler, taskRecord for Gantt
        [`${recordProp}`]: timeSpanRecord,
        startDate,
        endDate,
        startText,
        endText,
        startClockHtml: me.clockTemplate.template({
          date: startDate,
          text: startText,
          cls: 'b-sch-tooltip-startdate'
        }),
        endClockHtml: timeSpanRecord.isMilestone
          ? ''
          : me.clockTemplate.template({
              date: endDateValue,
              text: endText,
              cls: 'b-sch-tooltip-enddate'
            })
      });
    } else {
      tip.hide();
      return '';
    }
  }
}
TooltipBase._$name = 'TooltipBase';

/**
 * @module Scheduler/feature/EventTooltip
 */

/**
 * Displays a tooltip when hovering events. The template used to render the tooltip can be customized, see {@link #config-template}.
 * Config options are also applied to the tooltip shown, see {@link Common.widget.Tooltip} for available options.
 *
 * ```javascript
 * new Scheduler({
 *   features : {
 *     eventTooltip : {
 *         // Tooltip configs can be used here
 *         align : 'l-r' // Align left to right
 *     }
 *   }
 * });
 * ```
 *
 * This feature is **enabled** by default
 *
 * @extends Scheduler/feature/base/TooltipBase
 * @demo basic
 * @externalexample scheduler/EventTooltip.js
 */
class EventTooltip extends TooltipBase {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Template (a function accepting event data and returning a string) used to display info in the tooltip.
       * The template will be called with an object containing the fields below
       * @param {Object} data
       * @param {Scheduler.model.EventModel} data.eventRecord
       * @param {Date} data.startDate
       * @param {Date} data.endDate
       * @param {String} data.startText
       * @param {String} data.endText
       * @config {Function} template
       */
      template: (data) => `
                ${data.eventRecord.name ? `<div class="b-sch-event-title">${data.eventRecord.name}</div>` : ''}
                ${data.startClockHtml}
                ${data.endClockHtml}`,

      cls: 'b-sch-event-tooltip'
    };
  }

  //endregion
}

EventTooltip._$name = 'EventTooltip';
GridFeatureManager.registerFeature(EventTooltip, true, 'Scheduler');

/**
 * @module Grid/feature/mixin/SummaryFormatter
 */

/**
 * Mixin for Summary and GroupSummary that handles formatting sums.
 * @mixin
 * @private
 */
var SummaryFormatter = (Target) =>
  class SummaryFormatter extends (Target || Base) {
    /**
     * Calculates sums and returns as a html table
     * @param {Grid.column.Column} column Column to calculate sum for
     * @param {Common.data.Model[]} records Records to include in calculation
     * @param {String} cls CSS class to apply to summary table
     * @returns {string}
     */
    generateHtml(column, records, cls) {
      const store = this.store,
        summaries = column.summaries || (column.sum ? [{ sum: column.sum, renderer: column.summaryRenderer }] : []);

      let html = `<table class="${cls}">`;

      summaries.forEach((config) => {
        let type = config.sum,
          sum = null;

        if (type === true) type = 'sum';

        switch (type) {
          case 'sum':
          case 'add':
            sum = store.sum(column.field, records);
            break;
          case 'max':
            sum = store.max(column.field, records);
            break;
          case 'min':
            sum = store.min(column.field, records);
            break;
          case 'average':
          case 'avg':
            sum = store.average(column.field, records);
            break;
          case 'count':
            sum = records.length;
            break;
          case 'countNotEmpty':
            sum = records.reduce((sum, record) => {
              const value = record[column.field];
              return sum + (value !== null && value !== undefined ? 1 : 0);
            }, 0);
            break;
        }

        if (typeof type === 'function') {
          sum = records.reduce(type, 'seed' in config ? config.seed : 0);
        }

        if (sum !== null) {
          const valueCls = 'b-grid-summary-value',
            // value to display, either using renderer or as is
            valueHtml = config.renderer ? config.renderer({ config, sum }) : sum,
            // optional label
            labelHtml = config.label ? `<td class="b-grid-summary-label">${config.label}</td>` : '';

          let summaryHtml;

          // no <td>s in html, wrap it (always the case when not using renderer)
          if (!String(valueHtml).includes('<td>')) {
            summaryHtml = labelHtml
              ? // has label, use returned html as value cell
                `${labelHtml}<td class="${valueCls}">${valueHtml}</td>`
              : // no label, span entire table
                `<td colspan="2" class="${valueCls}">${valueHtml}</td>`;
          }
          // user is in charge of giving correct formatting
          else {
            summaryHtml = valueHtml;
          }

          html += `<tr>${summaryHtml}</tr>`;
        }
      });

      return html + '</table>';
    }
  };

/**
 * @module Grid/feature/GroupSummary
 */

/**
 * Displays a summary row as a group footer in a grouped grid. Uses same configuration options on columns as
 * {@link Grid.feature.Summary}.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * ```
 * features : {
 *     group        : 'city',
 *     groupSummary : true
 * }
 * ```
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @demo groupsummary
 * @classtype groupsummary
 * @externalexample feature/GroupSummary.js
 */
class GroupSummary extends SummaryFormatter(InstancePlugin) {
  //region Init

  construct(grid, config) {
    const me = this;

    Object.assign(me, {
      grid: grid,
      store: grid.store
    });

    // flag that will make the Store insert rows for group footers
    me.store.useGroupFooters = true;

    super.construct(grid, config);

    if (!grid.features.group) {
      throw new Error('Requires Group feature to work, please enable');
    }

    me.store.on({
      update: me.onStoreUpdate,
      // need to run before grids listener, to flag for full refresh
      prio: 1,
      thisObj: me
    });

    me.grid.rowManager.on({
      beforerenderrow: me.onBeforeRenderRow,
      rendercell: me.renderCell,
      thisObj: me
    });
  }

  //endregion

  //region Plugin config

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {};
  }

  //endregion

  //region Render

  /**
   * Called before rendering row contents, used to reset rows no longer used as group summary rows
   * @private
   */
  onBeforeRenderRow({ row, record }) {
    if (row.isGroupFooter && !record.meta.hasOwnProperty('groupFooterFor')) {
      // not a group row, remove css
      row.isGroupFooter = false;
      row.removeCls('b-group-footer');
      // force full "redraw" when rendering cells
      row.forceInnerHTML = true;
    }
  }

  /**
   * Called when a cell is rendered, styles the group rows first cell.
   * @private
   */
  renderCell({ column, cellElement, rowElement, row, record, size }) {
    const me = this;

    // no need to do the code below if not grouping
    if (!me.store.isGrouped) return;

    if (record.meta.hasOwnProperty('groupFooterFor')) {
      // this is a group row, add css
      rowElement.classList.add('b-group-footer');
      row.isGroupFooter = true;

      // returns height config or count. config format is { height, count }. where `height is in px and should be
      // added to value calculated from `count
      const heightSetting = me.updateSummaryHtml(cellElement, column, record.meta.groupRecord.groupChildren);

      const count = typeof heightSetting === 'number' ? heightSetting : heightSetting.count;

      // number of summaries returned, use to calculate cell height
      if (count > 1) {
        size.height = me.grid.rowHeight + count * me.grid.rowHeight * 0.1;
      }

      // height config with height specified, added to cell height
      if (heightSetting.height) {
        size.height += heightSetting.height;
      }
    }
  }

  updateSummaryHtml(cellElement, column, records) {
    records = records.slice();
    records.pop(); // last record is group footer, remove

    const html = this.generateHtml(column, records, 'b-grid-group-summary');

    // First time, set table
    if (!cellElement.children.length) {
      cellElement.innerHTML = html;
    }
    // Following times, sync changes
    else {
      DomHelper.sync(html, cellElement.firstElementChild);
    }

    // return summary "count", used to set row height
    return column.summaries ? column.summaries.length : column.sum ? 1 : 0;
  }

  //endregion

  //region Events

  /**
   * Updates summaries on store changes (except record update, handled below)
   * @private
   */
  onStoreUpdate({ source: store, changes }) {
    // If a grouping field is among the changes, StoreGroup#onDataChanged will
    // take care of the update by re-sorting.
    if (changes && store.groupers.find((grouper) => grouper.field in changes)) {
      return;
    }
    // only update summary when a field that affects summary is changed
    // TODO: this should maybe be removed, another column might depend on the value for its summary?
    let shouldUpdate = Object.keys(changes).some((field) => {
      const colField = this.grid.columns.get(field);
      // check existence, since a field not used in a column might have changed
      return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));
    });

    if (shouldUpdate) {
      this.grid.forceFullRefresh = true;
    }
  }

  //endregion
}

GroupSummary.featureClass = 'b-group-summary';

GroupSummary._$name = 'GroupSummary';
GridFeatureManager.registerFeature(GroupSummary);

/**
 * @module Scheduler/view/Header
 */

/**
 * Custom header subclass which handles the existence of the special TimeAxisColumn
 *
 * @extends Grid/view/Header
 * @private
 */
class Header$1 extends Header {
  refreshContent() {
    // Only render contents into the header once as it contains the special rendering of the TimeAxisColumn
    if (this.headersElement && this.headersElement.childNodes.length === 0) {
      super.refreshContent();
    }
  }
}
Header$1._$name = 'Header';

/**
 * @module Scheduler/view/model/TimeAxisViewModel
 */

/**
 * This class is an internal view model class, describing the visual representation of a {@link Scheduler.data.TimeAxis}.
 * The config for the header rows is described in the {@link Scheduler.preset.ViewPreset#config-headerConfig headerConfig}.
 * To calculate the size of each cell in the time axis, this class requires:
 *
 * - availableSpace  - The total width or height available for the rendering
 * - tickSize       - The fixed width or height of each cell in the lowest header row. This value is normally read from the
 * {@link Scheduler.preset.ViewPreset viewPreset} but this can also be updated programmatically using the {@link #property-tickSize} setter
 *
 * Normally you should not interact with this class directly.
 *
 * @extends Common/mixin/Events
 */
class TimeAxisViewModel extends Events() {
  //region Default config

  // TODO: replace _availableSpace etc with availableSpace in config and make setters work during config phase

  static get defaultConfig() {
    return {
      /**
       * The time axis providing the underlying data to be visualized
       * @config {Scheduler.data.TimeAxis}
       * @internal
       */
      timeAxis: null,

      /**
       * The available width/height, this is normally not known by the consuming UI component using this model
       * class until it has been fully rendered. The consumer of this model should set
       * {@link #property-availableSpace} when its width has changed.
       * @config {Number}
       * @internal
       */
      availableSpace: null,

      /**
       * The "tick width" for horizontal mode or "tick height" for vertical mode, to use for the cells in the
       * bottom most header row.
       * This value is normally read from the {@link Scheduler.preset.ViewPreset viewPreset}
       * @config {Number}
       * @default
       * @internal
       */
      tickSize: 100,

      /**
       * true if there is a requirement to be able to snap events to a certain view resolution.
       * This has implications of the {@link #config-tickSize} that can be used, since all widths must be in even pixels.
       * @config {Boolean}
       * @default
       * @internal
       */
      snap: false,

      /**
       * true if cells in the bottom-most row should be fitted to the {@link #property-availableSpace available space}.
       * @config {Boolean}
       * @default
       * @internal
       */
      forceFit: false,

      headerConfig: null,

      calendar: null,

      mode: 'horizontal', // or 'vertical'

      //used for Exporting. Make sure the tick columns are not recalculated when resizing.
      suppressFit: false,

      // cache of the config currently used.
      columnConfig: {},

      // the view preset name to apply initially
      viewPreset: null,

      // The default header level to draw column lines for
      columnLinesFor: 'middle',

      // To give a link to the eventStore inside the header renderer if provided
      eventStore: null,

      originalTickSize: null,

      headersDatesCache: {}
    };
  }

  //endregion

  //region Init & destroy

  construct(config) {
    const me = this;

    // getSingleUnitInPixels results are memoized because of frequent calls during rendering.
    me.unitToPixelsCache = {};

    super.construct(config);

    let viewPreset = me.timeAxis.viewPreset || me.viewPreset;

    if (viewPreset) {
      if (viewPreset instanceof ViewPreset) {
        me.consumeViewPreset(viewPreset);
      } else {
        let preset = PresetManager.getPreset(viewPreset);
        preset && me.consumeViewPreset(preset);
      }
    }

    // When time axis is changed, reconfigure the model
    me.timeAxis.on('reconfigure', me.onTimeAxisReconfigure, me);

    me.configured = true;
  }

  doDestroy() {
    this.timeAxis.un('reconfigure', this.onTimeAxisReconfigure, this);
  }

  /**
   * Returns a model object of the current timeAxis, containing an array representing the cells for each level in the header.
   * This object will always contain a 'middle' array, and depending on the {@link Scheduler.preset.ViewPreset#config-headerConfig} it can also contain a 'top' and 'bottom' property.
   * @return {Object} The model representing each cell (with start date and end date) in the timeline representation.
   * @internal
   */
  get columnConfig() {
    return this._columnConfig;
  }

  set columnConfig(config) {
    this._columnConfig = config;
  }

  //endregion

  //region Events

  /**
   * Fires after the model has been updated.
   * @event update
   * @param {Scheduler.view.model.TimeAxisViewModel} source The model instance
   */

  /**
   * Fires after the model has been reconfigured.
   * @event reconfigure
   * @param {Scheduler.view.model.TimeAxisViewModel} source The model instance
   */

  //endregion

  //region Mode

  /**
   * Using horizontal mode?
   * @returns {Boolean}
   * @readonly
   * @internal
   */
  get isHorizontal() {
    return this.mode !== 'vertical';
  }

  /**
   * Using vertical mode?
   * @returns {Boolean}
   * @readonly
   * @internal
   */
  get isVertical() {
    return this.mode === 'vertical';
  }

  /**
   * Gets/sets the forceFit value for the model. Setting it will cause it to update its contents and fire the
   * {@link #event-update} event.
   * @property {Boolean}
   * @internal
   */
  set forceFit(value) {
    if (value !== this._forceFit) {
      this._forceFit = value;
      this.update();
    }
  }

  //endregion

  //region Reconfigure & update

  reconfigure(config) {
    // clear the cached headers
    const me = this;

    me._headers = null;

    Object.assign(me, config);

    me.trigger('reconfigure');
  }

  onTimeAxisReconfigure({ source: timeAxis, suppressRefresh }) {
    if (this.viewPreset !== timeAxis.viewPreset) {
      this.consumeViewPreset(timeAxis.viewPreset);
    }
    if (!suppressRefresh) {
      this.update();
    }
  }

  /**
   * Updates the view model current timeAxis configuration and available space.
   * @param {Number} [availableSpace] The available space for the rendering of the axis (used in forceFit mode)
   * @param {Boolean} [silent] Pass `true` to suppress the firing of the `update` event.
   * @param {Boolean} [forceUpdate] Pass `true` to fire the `update` event even if the size has not changed.
   * @internal
   */
  update(availableSpace, silent = false, forceUpdate = false) {
    const me = this,
      { timeAxis, headerConfig } = me;

    // We're in configuration, or no change, quit
    if (me.isConfiguring || me._availableSpace === availableSpace) {
      if (forceUpdate) {
        me.trigger('update');
      }
      return;
    }

    me._availableSpace = Math.max(availableSpace || me.availableSpace || 0, 0);

    if (typeof me.availableSpace !== 'number') {
      throw new Error('Invalid available space provided to TimeAxisModel');
    }

    // Despite available space is 0, we still should generate column config in order for scheduler to render
    if (me.availableSpace <= 0) {
      console.warn(
        'No available space provided for time axis. Make sure you have set width for horizontal mode and height for vertical'
      );
    }

    me.columnConfig = {};

    // The "column width" is considered to be the width of each tick in the lowest header row and this width
    // has to be same for all cells in the lowest row.
    const tickSize = (me._tickSize = me.calculateTickSize(me.originalTickSize));

    if (typeof tickSize !== 'number' || tickSize <= 0) {
      throw new Error('Invalid timeAxis tick size');
    }

    // getSingleUnitInPixels results are memoized because of frequent calls during rendering.
    me.unitToPixelsCache = {};

    // totalSize is cached because of frequent calls which calculate it.
    me._totalSize = null;

    // Generate the underlying date ranges for each header row, which will provide input to the cell rendering
    for (const pos in headerConfig) {
      if (headerConfig[pos].cellGenerator) {
        me.columnConfig[pos] = headerConfig[pos].cellGenerator.call(me, timeAxis.startDate, timeAxis.endDate);
      } else {
        me.columnConfig[pos] = me.createHeaderRow(pos, headerConfig[pos]);
      }
    }

    if (!silent) {
      me.trigger('update');
    }
  }

  //endregion

  //region CalendarColumn

  // /**
  //  * Will update columns start/end dates to perform date/coordinate lookups
  //  * @param {Object[]} columns Array of column configs including start/end dates
  //  * @private
  //  */
  // updateCalendarColumnDates(columns) {
  //     this.calendarColumnDates = [];
  //
  //     for (let i = 0; i < columns.length; i++) {
  //         let obj = columns[i];
  //         this.calendarColumnDates.push([obj.start, obj.end]);
  //     }
  // }

  // // TODO: make getter
  // /**
  //  * Returns current column start/end dates array
  //  * @returns {Date[]}
  //  * @private
  //  */
  // getCalendarColumnDates() {
  //     return this.calendarColumnDates;
  // }

  //endregion

  //region Date / position mapping

  /**
   * Returns the distance in pixels for a timespan with the given start and end date.
   * @param {Date} start start date
   * @param {Date} end end date
   * @return {Number} The length of the time span
   * @category Date mapping
   */
  getDistanceBetweenDates(start, end) {
    return Math.round(this.getPositionFromDate(end) - this.getPositionFromDate(start));
  }

  /**
   * Returns the distance in pixels for a time span
   * @param {Number} durationMS Time span duration in ms
   * @return {Number} The length of the time span
   * @category Date mapping
   */
  getDistanceForDuration(durationMs) {
    let me = this,
      tick = this.timeAxis.getAt(0),
      pxPerMs = me.tickSize / (tick.endDate - tick.startDate);

    return pxPerMs * durationMs;
  }

  /**
   * Gets the position of a date on the projected time axis or -1 if the date is not in the timeAxis.
   * @param {Date} date the date to query for.
   * @returns {Number} the coordinate representing the date
   * @category Date mapping
   */
  getPositionFromDate(date, options = {}) {
    const me = this,
      tick = me.getScaledTick(date, options);

    if (tick === -1) {
      return -1;
    }

    return Math.round(me.tickSize * (tick - me.timeAxis.visibleTickStart));
  }

  // Translates a tick along the time axis to facilitate scaling events when excluding certain days or hours
  getScaledTick(date, { respectExclusion, snapToNextIncluded, isEnd, min, max }) {
    const { timeAxis } = this,
      { include, unit, weekStartDay } = timeAxis;

    let tick = timeAxis.getTickFromDate(date);

    if (tick !== -1 && respectExclusion && include) {
      let tickChanged = false;

      // Stretch if we are using a larger unit than 'hour', except if it is 'day'. If so, it is already handled
      // by a cheaper reconfiguration of the ticks in `generateTicks`
      if (include.hour && DateHelper.compareUnits(unit, 'hour') > 0 && unit !== 'day') {
        const { from, to, lengthFactor, center } = include.hour,
          // Original hours
          originalHours = date.getHours(),
          // Crop to included hours
          croppedHours = Math.min(Math.max(originalHours, from), to);

        // If we are not asked to snap (when other part of span is not included) any cropped away hour
        // should be considered excluded
        if (!snapToNextIncluded && croppedHours !== originalHours) {
          return -1;
        }

        const // Should scale hour and smaller units (seconds will hardly affect visible result...)
          fractionalHours = croppedHours + date.getMinutes() / 60,
          // Number of hours from the center    |xxxx|123c----|xxx|
          hoursFromCenter = center - fractionalHours,
          // Step from center to stretch event  |x|112233c----|xxx|
          newHours = center - hoursFromCenter * lengthFactor;

        // Adding instead of setting to get a clone of the date, to not affect the original
        date = DateHelper.add(date, newHours - originalHours, 'h');

        tickChanged = true;
      }

      if (include.day && DateHelper.compareUnits(unit, 'day') > 0) {
        const { from, to, lengthFactor, center } = include.day;

        //region Crop
        let checkDay = date.getDay();

        // End date is exclusive, check the day before if at 00:00
        if (
          isEnd &&
          date.getHours() === 0 &&
          date.getMinutes() === 0 &&
          date.getSeconds() === 0 &&
          date.getMilliseconds() === 0
        ) {
          if (--checkDay < 0) {
            checkDay = 6;
          }
        }
        let addDays = 0;

        if (checkDay < from || checkDay >= to) {
          // If end date is in view but start date is excluded, snap to next included day
          if (snapToNextIncluded) {
            // Step back to "to-1" (not inclusive) for end date
            if (isEnd) {
              addDays = (to - checkDay - 8) % 7;
            }
            // Step forward to "from" for start date
            else {
              addDays = (from - checkDay + 7) % 7;
            }

            date = DateHelper.add(date, addDays, 'd');
            date = DateHelper.startOf(date, 'd', false);

            // Keep end after start and vice versa
            if ((max && date.getTime() >= max) || (min && date.getTime() <= min)) {
              return -1;
            }
          } else {
            // day excluded at not snapping to next
            return -1;
          }
        }
        //endregion

        const // Center to stretch around, for some reason pre-calculated cannot be used for sundays :)
          fixedCenter = date.getDay() === 0 ? 0 : center,
          // Should scale day and smaller units (minutes will hardly affect visible result...)
          fractionalDay = date.getDay() + date.getHours() / 24, //+ dateClone.getMinutes() / (24 * 1440),
          // Number of days from the calculated center
          daysFromCenter = fixedCenter - fractionalDay,
          // Step from center to stretch event
          newDay = fixedCenter - daysFromCenter * lengthFactor;

        // Adding instead of setting to get a clone of the date, to not affect the original
        date = DateHelper.add(date, newDay - fractionalDay + weekStartDay, 'd');

        tickChanged = true;
      }

      // Now the date might start somewhere else (fraction of ticks)
      if (tickChanged) {
        // When stretching date might end up outside of time axis, making it invalid to use. Clip it to time axis
        // to circumvent this
        date = DateHelper.constrain(date, timeAxis.startDate, timeAxis.endDate);

        // Get a new tick based on the "scaled" date
        tick = timeAxis.getTickFromDate(date);
      }
    }

    return tick;
  }

  /**
   * Gets the date for a position on the time axis
   * @param {Number} position The page X or Y coordinate
   * @param {String} [roundingMethod] The rounding method to use
   * @returns {Date} the Date corresponding to the xy coordinate
   * @category Date mapping
   */
  getDateFromPosition(position, roundingMethod) {
    const me = this,
      timeAxis = me.timeAxis,
      tick = me.getScaledPosition(position) / me.tickSize + timeAxis.visibleTickStart;

    if (tick < 0 || tick > timeAxis.count) {
      return null;
    }

    return timeAxis.getDateFromTick(tick, roundingMethod);
  }

  // Translates a position along the time axis to facilitate scaling events when excluding certain days or hours
  getScaledPosition(position) {
    const { include, unit, weekStartDay } = this.timeAxis;

    // Calculations are

    if (include) {
      const dayWidth = this.getSingleUnitInPixels('day');

      // Have to calculate day before hour to get end result correct
      if (include.day && DateHelper.compareUnits(unit, 'day') > 0) {
        const { from, lengthFactor } = include.day,
          // Scaling happens within a week, determine position within it
          positionInWeek = position % (dayWidth * 7),
          // Store were the week starts to be able to re-add it after scale
          weekStartPosition = position - positionInWeek;
        // Scale position using calculated length per day factor, adding the width of excluded days
        position = positionInWeek / lengthFactor + (from - weekStartDay) * dayWidth + weekStartPosition;
      }

      // Hours are not taken into account when viewing days, since the day ticks are reconfigured in
      // `generateTicks` instead
      if (include.hour && DateHelper.compareUnits(unit, 'hour') > 0 && unit !== 'day') {
        const { from, lengthFactorExcl } = include.hour,
          hourWidth = this.getSingleUnitInPixels('hour'),
          // Scaling happens within a day, determine position within it
          positionInDay = position % dayWidth,
          // Store were the day starts to be able to re-add it after scale
          dayStartPosition = position - positionInDay;
        // Scale position using calculated length per day factor, adding the width of excluded hours
        position = positionInDay / lengthFactorExcl + from * hourWidth + dayStartPosition;
      }
    }

    return position;
  }

  /**
   * Returns the amount of pixels for a single unit
   * @internal
   * @return {Number} The unit in pixel
   */
  getSingleUnitInPixels(unit) {
    const me = this;

    return (
      me.unitToPixelsCache[unit] ||
      (me.unitToPixelsCache[unit] =
        (DateHelper.getUnitToBaseUnitRatio(me.timeAxis.unit, unit, true) * me.tickSize) / me.timeAxis.increment)
    );
  }

  /**
   * [Experimental] Returns the pixel increment for the current view resolution.
   * @internal
   * @return {Number} The increment
   */
  get snapPixelAmount() {
    if (this.snap) {
      const { resolution } = this.timeAxis;
      return (resolution.increment || 1) * this.getSingleUnitInPixels(resolution.unit);
    } else {
      return 1;
    }
  }

  //endregion

  //region Sizes

  /**
   * Get/set the current time column size (the width or height of a cell in the bottom-most time axis header row,
   * depending on mode)
   * @internal
   * @property {Number}
   */
  get tickSize() {
    return this._tickSize;
  }

  set tickSize(size) {
    this.setTickSize(size, false);
  }

  setTickSize(size, suppressEvent) {
    this._tickSize = this.originalTickSize = size;

    this.update(undefined, suppressEvent);
  }

  get timeResolution() {
    return this.timeAxis.resolution;
  }

  // Calculates the time column width/height based on the value defined viewPreset "tickWidth/tickHeight". It also
  // checks for the forceFit view option and the snap, both of which impose constraints on the time column width
  // configuration.
  calculateTickSize(proposedSize) {
    const me = this,
      { forceFit, timeAxis } = me,
      timelineUnit = timeAxis.unit;

    let size = 0,
      ratio = 1; //Number.MAX_VALUE;

    if (me.snap) {
      const resolution = timeAxis.resolution;
      ratio = DateHelper.getUnitToBaseUnitRatio(timelineUnit, resolution.unit) * resolution.increment;
    }
    // else {
    //     const measuringUnit = DH.getMeasuringUnit(timelineUnit);
    //     Math.min(ratio, DH.getUnitToBaseUnitRatio(timelineUnit, measuringUnit));
    // }

    if (!me.suppressFit) {
      const ticks = timeAxis.visibleTickTimeSpan,
        // TODO: change this to always floor if we want to prevent scheduler scroll when not really needed
        fittingSize = Math[forceFit ? 'floor' : 'round'](me.availableSpace / ticks);

      size = forceFit || proposedSize < fittingSize ? fittingSize : proposedSize;

      if (ratio > 0 && (!forceFit || ratio < 1)) {
        // For touch, make sure we always fill the available space with forceFit (to not show edges of side-time-pickers)
        const method = forceFit ? 'floor' : 'round';
        size = Math.round(Math.max(1, Math[method](ratio * size)) / ratio);
      }
    } else {
      size = proposedSize;
    }

    return size;
  }

  /**
   * Returns the total width/height of the time axis representation, depending on mode.
   * @return {Number} The width or height
   * @internal
   * @readonly
   */
  get totalSize() {
    return this._totalSize || (this._totalSize = Math.round(this.tickSize * this.timeAxis.visibleTickTimeSpan));
  }

  /**
   * Get/set the available space for the time axis representation. If size changes it will cause it to update its
   * contents and fire the {@link #event-update} event.
   * @internal
   * @property {Number}
   */
  get availableSpace() {
    return this._availableSpace;
  }

  set availableSpace(space) {
    const me = this;
    // We should only need to repaint fully if the tick width has changed (which will happen if forceFit is set, or if the full size of the time axis doesn't
    // occupy the available space - and gets stretched
    me._availableSpace = Math.max(0, space);

    if (me._availableSpace > 0) {
      const newTickSize = me.calculateTickSize(me.originalTickSize);

      if (newTickSize > 0 && newTickSize !== me.tickSize) {
        me.update();
      }
    }
  }

  //endregion

  //region Fitting & snapping

  /**
   * Returns start dates for ticks at the specified level in format { date, isMajor }.
   * @param {String} level Level in headerConfig (top, bottom, middle)
   * @param {Boolean} useLowestHeader Use lowest level
   * @param getEnd
   * @returns {Array}
   * @internal
   */
  getDates(level = this.columnLinesFor, useLowestHeader = false, getEnd = false) {
    const me = this,
      ticks = [],
      linesForLevel = useLowestHeader ? me.lowestHeader : level,
      majorLevel = me.majorHeaderName,
      levelUnit = me.headerConfig && me.headerConfig[level].unit,
      majorUnit = majorLevel && me.headerConfig && me.headerConfig[majorLevel].unit,
      validMajor = majorLevel && DateHelper.doesUnitsAlign(majorUnit, levelUnit),
      hasGenerator = !!(me.headerConfig && me.headerConfig[linesForLevel].cellGenerator);

    if (hasGenerator) {
      const cells = me.columnConfig[linesForLevel];

      for (let i = 1, l = cells.length; i < l; i++) {
        ticks.push({ date: cells[i].startDate });
      }
    } else {
      me.forEachInterval(linesForLevel, (start, end) => {
        ticks.push({
          date: getEnd ? end : start,
          // do not want to consider tick to be major tick, hence the check for majorHeaderName
          isMajor: majorLevel !== level && validMajor && me.isMajorTick(getEnd ? end : start)
        });
      });
    }

    return ticks;
  }

  get forceFit() {
    return this._forceFit;
  }

  /**
   * This function fits the time columns into the available space in the time axis column.
   * @param {Boolean} suppressEvent `true` to skip firing the 'update' event.
   * @internal
   */
  fitToAvailableSpace(suppressEvent) {
    const proposedSize = Math.floor(this.availableSpace / this.timeAxis.visibleTickTimeSpan);
    this.setTickSize(proposedSize, suppressEvent);
  }

  get snap() {
    return this._snap;
  }

  /**
   * Gets/sets the snap value for the model. Setting it will cause it to update its contents and fire the
   * {@link #event-update} event.
   * @property {Boolean}
   * @internal
   */
  set snap(value) {
    if (value !== this._snap) {
      this._snap = value;
      if (this.configured) this.update();
    }
  }

  //endregion

  //region Headers

  // private
  createHeaderRow(position, headerRowConfig) {
    const me = this,
      cells = [],
      align = headerRowConfig.align,
      today = DateHelper.clearTime(new Date()),
      headerCellCls = headerRowConfig.headerCellCls || '';

    let size = 0;

    me.headersDatesCache[position] = {};

    me.forEachInterval(position, (start, end, i) => {
      let value = DateHelper.format(start, headerRowConfig.dateFormat),
        cellData = {
          align,
          start,
          end,
          value,
          headerCellCls,
          width: this.getDistanceBetweenDates(start, end),
          index: i
        };

      if (cellData.width === 0) {
        return;
      }

      // Vertical mode uses absolute positioning for header cells
      cellData.coord = size;
      size += cellData.width;

      me.headersDatesCache[position][start.getTime()] = 1;

      if (headerRowConfig.renderer) {
        value = headerRowConfig.renderer.call(headerRowConfig.thisObj || me, start, end, cellData, i, me.eventStore);

        cellData.value = value == null ? '' : value;
      }

      // To be able to style individual day cells, weekends or other important days
      if (headerRowConfig.unit === 'day' && (!headerRowConfig.increment || headerRowConfig.increment === 1)) {
        cellData.headerCellCls += ' b-sch-dayheadercell-' + start.getDay();

        if (me.calendar && me.calendar.isWeekend(start)) {
          cellData.headerCellCls += ' b-sch-dayheadercell-nonworking';
        }

        if (DateHelper.clearTime(start, true) - today === 0) {
          cellData.headerCellCls += ' b-sch-dayheadercell-today';
        }
      }

      cells.push(cellData);
    });

    return cells;
  }

  get headers() {
    const me = this;

    if (!me._headers) {
      const headers = (me._headers = []),
        { top, middle, bottom } = me.headerConfig;

      top && headers.push(top);
      middle && headers.push(middle);
      bottom && headers.push(bottom);
    }

    return me._headers;
  }

  get mainHeader() {
    // main header is always `middle` (which is always requires to present in `headerConfig`)
    return this.headerConfig.middle;
  }

  get bottomHeader() {
    return this.headers[this.headers.length - 1];
  }

  get lowestHeader() {
    return 'bottom' in this.headerConfig ? 'bottom' : 'middle';
  }

  /**
   * This method is meant to return name of the header which 2nd lowest. It is used for {@link #function-isMajorTick} method
   * @return {String}
   * @private
   */
  get majorHeaderName() {
    const headerConfig = this.headerConfig;

    // If there's a bottom header - return middle one as it's required
    if (headerConfig.bottom) {
      return 'middle';
    }

    // if there is a top header - return that, because middle is required and we do not have bottom for sure
    if (headerConfig.top) {
      return 'top';
    }

    return null;
  }

  //endregion

  //region Ticks

  /**
   * For vertical view (and column lines plugin) we sometimes want to know if current tick starts along with the
   * upper header level.
   * @param {Date} date
   * @return {Boolean}
   * @private
   */
  isMajorTick(date) {
    const nextLevel = this.majorHeaderName;
    // if forceFit is used headersDatesCache won´t have been generated yet on the first call here,
    // since no size is set yet
    return (
      (nextLevel && this.headersDatesCache[nextLevel] && this.headersDatesCache[nextLevel][date.getTime()]) || false
    );
  }

  /**
   * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
   * Return false to break the iteration.
   * @param {String} position 'main' (middle), 'top' or 'bottom'
   * @param {Function} iteratorFn The function to call, will be called with start date, end date and "tick index"
   * @param {Object} [thisObj] `this` reference for the function
   * @internal
   */
  forEachInterval(position, iteratorFn, thisObj = this) {
    const { headerConfig } = this;

    if (!headerConfig) return; // Not initialized

    if (position === 'top' || (position === 'middle' && headerConfig.bottom)) {
      const header = headerConfig[position];

      this.timeAxis.forEachAuxInterval(header.unit, header.increment, iteratorFn, thisObj);
    } else {
      // This is the lowest header row, which should be fed the data in the tickStore (or a row above using same unit)
      this.timeAxis.forEach((r, index) => iteratorFn.call(thisObj, r.startDate, r.endDate, index));
    }
  }

  /**
   * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
   * Return false to break the iteration.
   * @internal
   * @param {Function} iteratorFn The function to call
   * @param {Object} [thisObj] `this` reference for the function
   */
  forEachMainInterval(iteratorFn, thisObj) {
    this.forEachInterval('middle', iteratorFn, thisObj);
  }

  //endregion

  //region ViewPreset

  consumeViewPreset(preset) {
    const me = this;

    // clear the cached headers
    me._headers = null;

    me._thisIsAUsedExpression(me.tickSize);

    // Since we are bypassing the tickSize setter below, ensure that
    // the config initial setter has been removed by referencing the property.
    // We only do this to avoid multiple updates from this. TODO: Fix this issue,
    // and do not bypass setters.
    me._viewPreset = preset;

    Object.assign(me, {
      headerConfig: preset.headerConfig,
      columnLinesFor: preset.columnLinesFor || 'middle',
      _tickSize: me.isHorizontal ? preset.tickWidth : preset.tickHeight
    });

    me.originalTickSize = me.tickSize;
  }

  //endregion

  // //region Calendar
  //
  // setCalendar(cal) {
  //     if (cal !== this.calendar) {
  //         this.calendar = cal;
  //
  //         if (cal) {
  //             this.update();
  //         }
  //     }
  // }
  //
  // //endregion
}
TimeAxisViewModel._$name = 'TimeAxisViewModel';

// Used to avoid having to create huge amounts of Date objects
const tempDate = new Date();

/**
 * @module Scheduler/view/mixin/TimelineDateMapper
 */

/**
 * Mixin that contains functionality to convert between coordinates and dates etc.
 *
 * @mixin
 */
var TimelineDateMapper = (Target) =>
  class TimelineDateMapper extends (Target || Base) {
    //region Coordinate <-> Date

    /**
     * Gets the date for an X or Y coordinate, either local to the view element or the page based on the 3rd argument.
     * @param {Number} coordinate The X or Y coordinate
     * @param {String} [roundingMethod] The rounding method to use
     * @param {Boolean} [local], true if the coordinate is local to the scheduler view element
     * @returns {Date} the Date corresponding to the xy coordinate
     * @category Dates
     */
    getDateFromCoordinate(coordinate, roundingMethod, local = true) {
      if (!local) {
        coordinate = this.currentOrientation.translateToScheduleCoordinate(coordinate);
      }

      return this.timeAxisViewModel.getDateFromPosition(coordinate, roundingMethod);
    }

    /**
     * Gets the date for the passed X coordinate.
     * If the coordinate is not in the currently rendered view, -1 will be returned.
     * @param {Number} x The X coordinate
     * @param {String} roundingMethod The rounding method to use
     * @returns {Date} the Date corresponding to the x coordinate
     * @param {Boolean} [local] true if the coordinate is local to the scheduler element
     * @category Dates
     */
    getDateFromX(x, roundingMethod, local = true) {
      return this.getDateFromCoordinate(x, roundingMethod, local);
    }

    /**
     * Gets the date for an XY coordinate
     * @param {Array} xy The page X and Y coordinates
     * @param {String} [roundingMethod] Optional, 'floor' to floor the value or 'round' to round the value to nearest increment
     * @param {Boolean} [local] true if the coordinate is local to the scheduler element
     * @returns {Date} the Date corresponding to the xy coordinate
     * @category Dates
     */
    getDateFromXY(xy, roundingMethod, local = true) {
      return this.currentOrientation.getDateFromXY(xy, roundingMethod, local);
    }

    //endregion

    //region Date display

    /**
     * Get/set format to use when displaying dates. Usually set by specifying a view preset
     * @property {String}
     * @category Dates
     */
    get displayDateFormat() {
      return this._displayDateFormat;
    }

    set displayDateFormat(format) {
      this._displayDateFormat = format;

      // Start/EndDateColumn listens for this to change their format to match
      this.trigger('displayDateFormatChange', { format });
    }

    /**
     * Method to get a formatted display date
     * @private
     * @param {Date} date The date
     * @return {String} The formatted date
     */
    getFormattedDate(date) {
      return DateHelper.format(date, this.displayDateFormat);
    }

    /**
     * Method to get a displayed end date value, see {@link #function-getFormattedEndDate} for more info.
     * @private
     * @param {Date} endDate The date to format
     * @param {Date} startDate The start date
     * @return {Date} The date value to display
     */
    getDisplayEndDate(endDate, startDate) {
      const format = this.displayDateFormat,
        stripEscapeRe = /(\\.)/g,
        hourInfoRe = /([gGhHisucUOPZ]|MS)/; // TODO: PORT!

      if (
        // If time is midnight,
        endDate.getHours() === 0 &&
        endDate.getMinutes() === 0 &&
        // and end date is greater then start date
        (!startDate ||
          !(
            endDate.getYear() === startDate.getYear() &&
            endDate.getMonth() === startDate.getMonth() &&
            endDate.getDate() === startDate.getDate()
          )) &&
        // and UI display format doesn't contain hour info (in this case we'll just display the exact date)
        !hourInfoRe.test(format.replace(stripEscapeRe, ''))
      ) {
        // format the date inclusively as 'the whole previous day'.
        endDate = DateHelper.add(endDate, -1, 'day');
      }

      return endDate;
    }

    /**
     * Method to get a formatted end date for a scheduled event, the grid uses the "displayDateFormat" property defined in the current view preset.
     * End dates are formatted as 'inclusive', meaning when an end date falls on midnight and the date format doesn't involve any hour/minute information,
     * 1ms will be subtracted (e.g. 2010-01-08T00:00:00 will first be modified to 2010-01-07 before being formatted).
     * @private
     * @param {Date} endDate The date to format
     * @param {Date} startDate The start date
     * @return {String} The formatted date
     */
    getFormattedEndDate(endDate, startDate) {
      return this.getFormattedDate(this.getDisplayEndDate(endDate, startDate));
    }

    //endregion

    //region Other date functions

    /**
     * Gets the x or y coordinate relative to the scheduler element, or page coordinate (based on the 'local' flag)
     * If the coordinate is not in the currently rendered view, -1 will be returned.
     * @param {Date|Number} date the date to query for (or a date as ms)
     * @param {Boolean|Object} options true to return a coordinate local to the scheduler view element (defaults to true),
     * also accepts a config object like { local : true }.
     * @returns {Number} the x or y position representing the date on the time axis
     * @category Dates
     */
    getCoordinateFromDate(date, options = true) {
      const me = this,
        { timeAxisViewModel } = me,
        { isContinuous, startMS, endMS, startDate, unit } = me.timeAxis,
        dateMS = date.valueOf();

      // Avoiding to break the API while allowing passing options through to getPositionFromDate()
      if (options === true) {
        options = {
          local: true
        };
      } else if (!options) {
        options = {
          local: false
        };
      } else if (!('local' in options)) {
        options.local = true;
      }

      let pos;

      // TODO for 2.0 try to normalize and just use dates as input for this method,
      // then this if-statement would not be needed
      if (!(date instanceof Date)) {
        tempDate.setTime(date);
        date = tempDate;
      }

      // Shortcut for continuous time axis that is using a unit that can be reliably translated to days (or smaller)
      if (
        isContinuous &&
        date.getTimezoneOffset() === startDate.getTimezoneOffset() &&
        DateHelper.getUnitToBaseUnitRatio(unit, 'day') !== -1
      ) {
        if (dateMS < startMS || dateMS > endMS) {
          return -1;
        }
        pos = Math.round(((dateMS - startMS) / (endMS - startMS)) * timeAxisViewModel.totalSize);
      }
      // Non-continuous or using for example months (vary in length)
      else {
        pos = timeAxisViewModel.getPositionFromDate(date, options);
      }

      if (!options.local) {
        pos = me.currentOrientation.translateToPageCoordinate(pos);
      }

      return pos;
    }

    /**
     * Gets the time for a DOM event such as 'mousemove' or 'click'
     * @param {Event} e the Event instance
     * @param {String} [roundingMethod] Optional, 'floor' to floor the value or 'round' to round the value to nearest increment
     * @param {Boolean} [local], true if the event is local to the scheduler element
     * @returns {Date} The date corresponding to the EventObject x coordinate
     * @category Dates
     */
    getDateFromDomEvent(e, roundingMethod, local = true) {
      const x = local ? e.offsetX : e.x,
        y = local ? e.offsetY : e.y;

      return this.getDateFromXY([x, y], roundingMethod, local);
    }

    /**
     * Returns the distance in pixels for the time span in the view.
     * @param {Date} startDate The start date of the span
     * @param {Date} endDate The end date of the span
     * @return {Number} The distance in pixels
     * @category Dates
     */
    getTimeSpanDistance(startDate, endDate) {
      return this.timeAxisViewModel.getDistanceBetweenDates(startDate, endDate);
    }

    /**
     * Returns the center date of the currently visible timespan of scheduler.
     *
     * @return {Date} date Center date for the viewport.
     * @readonly
     * @category Dates
     */
    get viewportCenterDate() {
      const me = this,
        timeAxis = me.timeAxis,
        subGrid = me.timeAxisSubGrid,
        scroller = subGrid.scrollable,
        centerX = scroller.x + subGrid.width / 2,
        centerY = scroller.y + subGrid.height / 2;

      if (timeAxis.isContinuous) {
        // Calculate center pixel in the viewport.
        // Then Calculate how far through the axis range that is.
        const scrollCenter = me.isHorizontal ? centerX / scroller.scrollWidth : centerY / scroller.scrollHeight,
          centerMilli = timeAxis.startMS + (timeAxis.endMS - timeAxis.startMS) * scrollCenter;

        return new Date(centerMilli);
      } else {
        const xy = me.isHorizontal ? [centerX, 0] : [0, centerY];

        return me.getDateFromXY(xy, null, true);
      }
    }

    get viewportCenterDateCached() {
      return this.cachedCenterDate || (this.cachedCenterDate = this.viewportCenterDate);
    }

    //endregion

    //region TimeAxis getters/setters

    /**
     * Gets/sets the current time resolution object, which contains a unit identifier and an increment count { unit, increment}
     * @property {Object}
     * @category Dates
     */
    get timeResolution() {
      return this.timeAxis.resolution;
    }

    set timeResolution(increment) {
      this.timeAxis.resolution = {
        increment,
        unit: this.timeAxis.resolution.unit
      };
    }

    //endregion

    //region Snap

    /**
     * Controls whether the scheduler should snap to the resolution when interacting with it
     * @property {Boolean}
     * @category Dates
     */
    set snap(enabled) {
      // timeAxisViewModel is not created yet during configuration
      if (!this.isConfiguring) {
        this.timeAxisViewModel.snap = enabled;
      } else {
        this._snap = enabled;
      }
    }

    get snap() {
      // timeAxisViewModel is not created yet during configuration
      if (this.isConfiguring) {
        return this._snap;
      }
      return this.timeAxisViewModel.snap;
    }

    //endregion

    onSchedulerHorizontalScroll({ subGrid, scrollLeft }) {
      // Invalidate cached center date unless we are scrolling to center on it.
      if (!this.scrollingToCenter) {
        this.cachedCenterDate = null;
      }
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Scheduler/view/mixin/TimelineDomEvents
 */

const eventNameMap = {
  mousedown: 'MouseDown',
  mouseup: 'MouseUp',
  click: 'Click',
  dblclick: 'DblClick',
  contextmenu: 'ContextMenu',
  mouseover: 'MouseOver',
  mouseout: 'MouseOut'
};

/**
 * Mixin that handles dom events (click etc) for scheduler and rendered events.
 *
 * @mixin
 */
var TimelineDomEvents = (Target) =>
  class TimelineDomEvents extends (Target || Base) {
    //region Default config

    static get defaultConfig() {
      return {
        // TODO: PORT longpress missing
        scheduledBarEvents: {
          mousedown: 'handleScheduledBarEvent',
          mouseup: 'handleScheduledBarEvent',
          click: 'handleScheduledBarEvent',
          dblclick: 'handleScheduledBarEvent',
          contextmenu: 'handleScheduledBarEvent',
          mouseover: 'handleScheduledBarEvent',
          mouseout: 'handleScheduledBarEvent'
        },

        // TODO: PORT pinch, pinchstart, pinchend missing
        schedulerEvents: {
          click: 'handleScheduleEvent',
          dblclick: 'handleScheduleEvent',
          contextmenu: 'handleScheduleEvent'
        }
      };
    }

    //endregion

    //region Init

    /**
     * Adds listeners for DOM events for the scheduler and its events.
     * Which events is specified in Scheduler#scheduledBarEvents and Scheduler#schedulerEvents.
     * @private
     */
    initDomEvents() {
      const me = this;

      // Set thisObj and element of the configured listener specs.
      me.scheduledBarEvents.element = me.schedulerEvents.element = me.timeAxisSubGridElement;
      me.scheduledBarEvents.thisObj = me.schedulerEvents.thisObj = me;

      // same listener used for different events
      EventHelper.on(me.scheduledBarEvents);
      EventHelper.on(me.schedulerEvents);
    }

    //endregion

    //region Event handling

    getTimeSpanMouseEventParams(eventElement, event) {
      throw new Error('Implement in subclass');
    }

    getScheduleMouseEventParams(cellData, event) {
      throw new Error('Implement in subclass');
    }

    /**
     * Wraps dom Events for rendered scheduler EventModels and fires prefixed as our events.
     * For example click -> eventclick
     * @private
     * @param event
     */
    handleScheduledBarEvent(event) {
      const me = this,
        eventElement = DomHelper.up(event.target, me.eventSelector),
        eventName = eventNameMap[event.type] || StringHelper.capitalizeFirstLetter(event.type);

      if (eventElement) {
        me.trigger(me.scheduledEventName + eventName, me.getTimeSpanMouseEventParams(eventElement, event));
      }
    }

    /**
     * Wraps dom Events for the scheduler and fires as our events.
     * For example click -> scheduleClick
     * @private
     * @param event
     */
    handleScheduleEvent(event) {
      const me = this,
        eventElement = DomHelper.up(event.target, me.eventSelector),
        cellElement = !eventElement && DomHelper.up(event.target, '.' + me.timeCellCls),
        eventName = eventNameMap[event.type] || StringHelper.capitalizeFirstLetter(event.type);

      if (cellElement) {
        const clickedDate = me.getDateFromDomEvent(event, 'floor'),
          cellData = DomDataStore.get(cellElement),
          index = cellData.row.dataIndex;

        // TODO: PORT vertical later
        // } else {
        //     const cellNode = event.getTarget(me.timeCellSelector, 5);
        //
        //     if (cellNode) {
        //         const cellIndex = typeof cellNode.cellIndex == 'number' ? cellNode.cellIndex : cellNode.getAttribute('data-cellIndex'),
        //               header    = me.headerCt.getGridColumns()[cellIndex];
        //
        //         resource = header && header.model;
        //     }
        // }

        // TODO: PORT pinch event
        //if (event.type.indexOf('pinch') >= 0) {
        //    me.fireEvent('schedule' + event.type, me, event);
        //} else {

        me.trigger(
          'schedule' + eventName,
          Object.assign(
            {
              date: clickedDate,
              row: cellData.row,
              index,
              event
            },
            me.getScheduleMouseEventParams(cellData, event)
          )
        );
        //}
      }
    }

    /**
     * Relays mouseover events as eventmouseenter if over rendered event.
     * Also adds Scheduler#overScheduledEventClass to the hovered element.
     * @private
     */
    onElementMouseOver(event) {
      super.onElementMouseOver(event);

      const me = this,
        target = event.target;

      // We must be over the event bar
      if (target.closest(me.eventInnerSelector)) {
        const eventElement = target.closest(me.eventSelector);

        eventElement.classList.add(me.overScheduledEventClass);

        if (eventElement !== me.hoveredEventNode && !me.preventOverCls) {
          me.hoveredEventNode = eventElement;

          const params = me.getTimeSpanMouseEventParams(eventElement, event);
          if (params) {
            // do not fire this event if model cannot be found
            // this can be the case for "b-sch-dragcreator-proxy" elements for example
            me.trigger(me.scheduledEventName + 'MouseEnter', params);
          }
        }
      } else {
        me.hoveredEventNode = null;
      }
    }

    /**
     * Relays mouseout events as eventmouseleave if out from rendered event.
     * Also removes Scheduler#overScheduledEventClass from the hovered element.
     * @private
     */
    onElementMouseOut(event) {
      super.onElementMouseOut(event);

      const me = this;

      // We must be over the event bar
      if (
        event.target.closest(me.eventInnerSelector) &&
        me.resolveTimeSpanRecord(event.target) &&
        me.hoveredEventNode
      ) {
        // out to child shouldn't count...
        if (
          event.relatedTarget &&
          DomHelper.isDescendant(event.target.closest(me.eventInnerSelector), event.relatedTarget)
        )
          return;

        me.unhover(event);
      }
    }

    unhover(event) {
      const me = this,
        eventElement = me.hoveredEventNode;
      if (eventElement) {
        eventElement.classList.remove(me.overScheduledEventClass);
        me.trigger(me.scheduledEventName + 'MouseLeave', me.getTimeSpanMouseEventParams(eventElement, event));
        me.hoveredEventNode = null;
      }
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Scheduler/view/mixin/TimelineViewPresets
 */

/**
 * View preset handling
 *
 * @mixin
 */
var TimelineViewPresets = (Target) =>
  class TimelineViewPresets extends (Target || Base) {
    //region Default config

    static get defaultConfig() {
      //if (!PresetManager.presets) PresetManager.registerDefaults();

      return {
        /**
         * A string key used to lookup a predefined {@link Scheduler.preset.ViewPreset} (e.g. 'weekAndDay', 'hourAndDay'),
         * managed by {@link Scheduler.preset.PresetManager}. See {@link Scheduler.preset.PresetManager} for more information.
         * Or a config object for a viewPreset.
         *
         * Options:
         * - 'secondAndMinute'
         * - 'minuteAndHour'
         * - 'hourAndDay'
         * - 'dayAndWeek'
         * - 'weekAndDay'
         * - 'weekAndMonth',
         * - 'monthAndYear'
         * - 'year'
         * - 'manyYears'
         * - 'weekAndDayLetter'
         * - 'weekDateAndMonth'
         * - 'day'
         * - 'week'
         *
         * If passed as a config object, the settings from the viewPreset with the provided 'name' property will be used along
         * with any overridden values in your object.
         *
         * To override:
         * ```javascript
         * viewPreset       : {
         *   name                : 'hourAndDay',
         *   headerConfig        : {
         *       middle          : {
         *           unit       : "hour",
         *           increment  : 12,
         *           renderer   : (startDate, endDate, headerConfig, cellIdx) => {
         *               return "";
         *           }
         *       }
         *   }
         * }
         * ```
         * or set a new valid preset config if the preset is not registered in the {@link Scheduler.preset.PresetManager}.
         *
         * When you use scheduler in weekview mode, this config is used to pick view preset. If passed view preset is not
         * supported by weekview (only 2 supported by default - 'day' and 'week') default preset will be used - 'week'.
         * @config {String|Object}
         * @default
         * @category Common
         */
        viewPreset: 'weekAndDayLetter',

        /**
         * Defines how dates will be formatted in tooltips etc. This config has priority over similar config on the
         * view preset. For allowed values see {@link Common.helper.DateHelper##function-format-static}.
         * @config {String}
         * @category Scheduled events
         */
        displayDateFormat: null
      };
    }

    //endregion

    //region Get/set

    /**
     * Get/set the current view preset
     * @property {Scheduler.preset.ViewPreset|String}
     * @category Common
     */
    get viewPreset() {
      return this._viewPreset;
    }

    set viewPreset(preset) {
      if (this._viewPreset !== preset) {
        this.setViewPreset(preset);
      }
    }

    /**
     * Sets the current view preset. See the {@link Scheduler.preset.PresetManager} class for details.
     *
     * @param {String|Object|Scheduler.preset.ViewPreset} preset The id of the new preset (see {@link Scheduler.preset.PresetManager} for details)
     * @param {Date} [startDate] A new start date for the time axis
     * @param {Date} [endDate] A new end date for the time axis
     * @private
     */
    setViewPreset(preset, startDate, endDate, initial, options = {}) {
      const me = this;

      // This is set if the object is inside the Base constructor's configure method.
      initial = initial || me.isConfiguring;

      let centerDate = options.centerDate,
        timeAxis = me._timeAxis; // Do not tickle the getter, we are just peeking to see if it's there yet.

      // normalize preset (applies preset customizations or gets a predefined preset)
      preset = PresetManager.normalizePreset(preset);

      if (initial || me.trigger('beforePresetChange', { preset, startDate, endDate }) !== false) {
        me._viewPreset = preset;

        // prefer to use displayDateFormat configured on the panel
        me.displayDateFormat = me.config.displayDateFormat || preset.displayDateFormat;

        const isHorizontal = me.isHorizontal;

        if (timeAxis) {
          // None of this reconfiguring should cause a refresh
          me.suspendRefresh();

          // Timeaxis may already be configured (in case of sharing with the timeline partner), no need to reconfigure it
          if (!(initial && timeAxis.isConfigured)) {
            const timeAxisCfg = {
              weekStartDay: me.weekStartDay,
              startTime: me.startTime,
              endTime: me.endTime
            };

            if (initial) {
              if (timeAxis.count === 0 || startDate) {
                timeAxisCfg.startDate = startDate || new Date();
                timeAxisCfg.endDate = endDate;
              }
            } else {
              // if startDate is provided we use it and the provided endDate
              if (startDate) {
                timeAxisCfg.startDate = startDate;
                timeAxisCfg.endDate = endDate;

                // if both dates are provided we can calculate centerDate for the viewport
                if (!centerDate && endDate) {
                  // TODO: PORT infitieScroll stuff
                  // if (me.infiniteScroll && view.cachedScrollDate && view.cachedScrollDateIsCentered) {
                  //     centerDate = view.cachedScrollDate;
                  // } else {
                  centerDate = new Date((startDate.getTime() + endDate.getTime()) / 2);
                  //}
                }

                // when no start/end dates are provided we use the current timespan
              } else {
                timeAxisCfg.startDate = timeAxis.startDate;
                timeAxisCfg.endDate = endDate || timeAxis.endDate;

                if (!centerDate) {
                  // TODO: PORT inifiteScroll stuff
                  // if (me.infiniteScroll && view.cachedScrollDate && view.cachedScrollDateIsCentered) {
                  //     centerDate = view.cachedScrollDate;
                  // } else {
                  // TODO: PORT needed?
                  //centerDate = me.getViewportCenterDateCached();
                  centerDate = me.viewportCenterDate;
                  //}
                }
              }
            }

            timeAxis.isConfigured = false;
            timeAxis.viewPreset = preset;
            timeAxis.reconfigure(timeAxisCfg, true);

            me.timeAxisViewModel.reconfigure({
              // update preset name in viewmodel to simplify zooming sync for partner panels
              viewPreset: me.viewPreset,
              headerConfig: preset.headerConfig,
              columnLinesFor: preset.columnLinesFor || 'middle',
              // TODO: PORT rowHeightHorizontal??
              rowHeightHorizontal: me.readRowHeightFromPreset ? preset.rowHeight : me.rowHeight,
              tickSize: isHorizontal ? preset.tickWidth : preset.tickHeight || preset.tickWidth || 60
            });

            // Allow refresh to run after the reconfiguring
            me.resumeRefresh();
          }

          // TODO: PORT vertical later
          // if (isVertical) {
          //     me.setColumnWidth(me.resourceColumnWidth || preset.resourceColumnWidth || 100, true);
          // }

          me.refresh();

          // if view is rendered and scroll is not disabled by "notScroll" option
          if (!options.notScroll && me.rendered) {
            // and we have centerDate to scroll to
            if (centerDate) {
              // remember the central date we scroll to (it gets reset after user scroll)
              me.cachedCenterDate = centerDate;

              let x = null;

              // TODO: PORT vertical later
              // if (isVertical) {
              //     y = Math.max(Math.floor(view.getCoordinateFromDate(centerDate, true) - view.getViewContainerHeight() / 2), 0);
              //     me.viewPresetActiveScroll = { top : y };
              //     view.scrollVerticallyTo(y);
              // } else {
              x = Math.max(Math.floor(me.getCoordinateFromDate(centerDate, true) - me.timeAxisSubGrid.width / 2), 0);
              me.viewPresetActiveScroll = { left: x };

              // The horizontal scroll handler must not invalidate the cached center
              // when this scroll event rolls round on the next frame.
              me.scrollingToCenter = true;

              me.scrollHorizontallyTo(x, false);

              // Release the lock on scrolling invalidating the cached center.
              me.setTimeout(() => {
                me.scrollingToCenter = false;
              }, 100);
              //}

              // if we don't have a central date to scroll at we reset scroll (this is bw compatible behavior)
            } else {
              // TODO: PORT vertical later
              // if (isHorizontal) {
              me.scrollHorizontallyTo(0, false);
              //} else {
              //    view.scrollVerticallyTo(0);
              //}
            }
          }

          me.trigger('presetChange', { preset, startDate, endDate, centerDate });
        }
      }
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Scheduler/view/mixin/TimelineZoomable
 */

/**
 * Mixin providing "zooming" functionality.
 *
 * The zooming feature works by reconfiguring the time axis with the current zoom level values selected from the {@link #config-zoomLevels} array.
 * Zoom levels can be added and removed from the array to change the amount of available steps. Range of zooming in/out can be also
 * modified with {@link #config-maxZoomLevel} / {@link #config-minZoomLevel} properties.
 *
 * This mixin adds additional methods to the column : {@link #property-maxZoomLevel}, {@link #property-minZoomLevel}, {@link #function-zoomToLevel}, {@link #function-zoomIn},
 * {@link #function-zoomOut}, {@link #function-zoomInFull}, {@link #function-zoomOutFull}.
 *
 * **Notice**: Zooming doesn't work properly when `forceFit` option is set to true for the column or for filtered timeaxis.
 *
 * @mixin
 */
var TimelineZoomable = (Target) =>
  class TimelineZoomable extends (Target || Base) {
    static get defaultConfig() {
      return {
        /**
         * If true, you can zoom in and out on the the time axis using CTRL-key + mouse wheel.
         * @config {Boolean}
         * @default
         * @category Zoom
         */
        zoomOnMouseWheel: true,

        /**
         * True to zoom to time span when double clicking a time axis cell.
         * @config {Boolean}
         * @category Zoom
         */
        zoomOnTimeAxisDoubleClick: true,

        preventScrollZoom: false,

        /**
         * Predefined map of zoom levels for each preset in the ascending order. Zoom level is basically a
         * {@link Scheduler.preset.ViewPreset view preset}, which is based on another preset, with some values
         * overridden.
         *
         * Each element is an {Object} with the following parameters :
         *
         * - `preset` (String)      - {@link Scheduler.preset.ViewPreset} to be used for this zoom level. This must be a valid preset name registered in {@link Scheduler.preset.PresetManager preset manager}.
         * - `width` (Int)          - {@link Scheduler.preset.ViewPreset#config-tickWidth tickWidth} time column width value from the preset
         * - `increment` (Int)      - {@link Scheduler.preset.ViewPresetHeaderRow#config-increment increment} value from the bottom header row of the preset
         * - `resolution` (Int)     - {@link Scheduler.preset.ViewPreset#config-timeResolution increment} part of the `timeResolution` object in the preset
         * - `resolutionUnit` (String) (Optional) - {@link Scheduler.preset.ViewPreset#config-timeResolution unit} part of the `timeResolution` object in the preset
         *
         *  The `zoomLevels` config can be set in the scheduler like this:
         * ```javascript
         * let scheduler = new Scheduler({
         *   resourceStore : resourceStore,
         *   eventStore    : eventStore,
         *   viewPreset    : 'hourAndDay',
         *   zoomLevels: [
         *       { width: 50,    increment: 4,   resolution: 60, preset: 'hourAndDay', resolutionUnit: 'minute' },
         *       { width: 60,    increment: 3,   resolution: 60, preset: 'hourAndDay', resolutionUnit: 'minute' },
         *       { width: 80,    increment: 2,   resolution: 30, preset: 'hourAndDay', resolutionUnit: 'minute' },
         *       { width: 100,   increment: 1,   resolution: 15, preset: 'hourAndDay', resolutionUnit: 'minute' }
         *   ]
         * });
         * ```
         * In the case above:
         *
         * - The `width` specifies the amount of space in pixels for the bottom cell.
         * - The `increment` specifies the number of hours between each bottom cell.
         * - The `resolution` specifies the size of the slots in the bottom cell accordingly to the defined `resolutionUnit`.
         *
         * In the case above we have four zoomlevel steps within the `hourAndDay` preset. When zooming in we go up
         * in the zoomlevel array, when zooming out we go down in the zoomlevel array. In this case the zoomlevel
         * with `increment` set to 1 and `width` set to 100 is the most detailed level, the max level. While the
         * first item in the array is the minimal zoomlevel. In a higher zoomlevel the `resolution` can be set lower
         * to make the granularity of the cell smaller. That means smaller slots for the events to fit in.
         * @config {Object[]}
         * @category Zoom
         */
        zoomLevels: [
          //YEAR
          { width: 40, increment: 1, resolution: 1, preset: 'manyYears', resolutionUnit: 'YEAR' },
          { width: 80, increment: 1, resolution: 1, preset: 'manyYears', resolutionUnit: 'YEAR' },

          { width: 30, increment: 1, resolution: 1, preset: 'year', resolutionUnit: 'MONTH' },
          { width: 50, increment: 1, resolution: 1, preset: 'year', resolutionUnit: 'MONTH' },
          { width: 100, increment: 1, resolution: 1, preset: 'year', resolutionUnit: 'MONTH' },
          { width: 200, increment: 1, resolution: 1, preset: 'year', resolutionUnit: 'MONTH' },

          //MONTH
          { width: 100, increment: 1, resolution: 7, preset: 'monthAndYear', resolutionUnit: 'DAY' },
          { width: 30, increment: 1, resolution: 1, preset: 'weekDateAndMonth', resolutionUnit: 'DAY' },

          //WEEK
          { width: 50, increment: 1, resolution: 1, preset: 'weekAndMonth', resolutionUnit: 'DAY' },
          { width: 20, increment: 1, resolution: 1, preset: 'weekAndDayLetter' },

          //DAY
          { width: 54, increment: 1, resolution: 1, preset: 'weekAndDay', resolutionUnit: 'HOUR' },
          { width: 100, increment: 1, resolution: 1, preset: 'weekAndDay', resolutionUnit: 'HOUR' },

          //HOUR
          { width: 64, increment: 6, resolution: 30, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },
          { width: 100, increment: 6, resolution: 30, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },
          { width: 64, increment: 2, resolution: 30, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },
          { width: 64, increment: 1, resolution: 30, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },

          //MINUTE
          { width: 30, increment: 15, resolution: 5, preset: 'minuteAndHour' },
          { width: 60, increment: 15, resolution: 5, preset: 'minuteAndHour' },
          { width: 130, increment: 15, resolution: 5, preset: 'minuteAndHour' },
          { width: 60, increment: 5, resolution: 5, preset: 'minuteAndHour' },
          { width: 100, increment: 5, resolution: 5, preset: 'minuteAndHour' },

          //SECOND
          { width: 30, increment: 10, resolution: 5, preset: 'secondAndMinute' },
          { width: 60, increment: 10, resolution: 5, preset: 'secondAndMinute' },
          { width: 130, increment: 5, resolution: 5, preset: 'secondAndMinute' }
        ],

        /**
         * Minimal zoom level to which {@link #function-zoomOut} will work
         * @config {Number}
         * @category Zoom
         */
        minZoomLevel: true,

        /**
         * Maximal zoom level to which {@link #function-zoomIn} will work
         * @config {Number}
         * @category Zoom
         */
        maxZoomLevel: true,

        /**
         * Integer number indicating the size of timespan during zooming. When zooming, the timespan is adjusted to make the scrolling area `visibleZoomFactor` times
         * wider than the timeline area itself. Used in {@link #function-zoomToSpan} and {@link #function-zoomToLevel} functions.
         * @config {Number}
         * @default
         * @category Zoom
         */
        visibleZoomFactor: 5,

        /**
         * Whether the originally rendered timespan should be preserved while zooming. By default it is set to `false`,
         * meaning the timeline panel will adjust the currently rendered timespan to limit the amount of HTML content to render. When setting this option
         * to `true`, be careful not to allow to zoom a big timespan in seconds resolution for example. That will cause **a lot** of HTML content
         * to be rendered and affect performance. You can use {@link #config-minZoomLevel} and {@link #config-maxZoomLevel} config options for that.
         * @config {Boolean}
         * @default
         * @category Zoom
         */
        zoomKeepsOriginalTimespan: false
      };
    }

    construct(config) {
      const me = this;

      super.construct(config);

      if (me.zoomOnMouseWheel) {
        EventHelper.on({
          element: me.timeAxisSubGridElement,
          wheel: 'onWheel',
          thisObj: me,
          capture: true,
          passive: false
        });
      }

      if (me.zoomOnTimeAxisDoubleClick) {
        me.on('timeaxisheaderdblclick', ({ startDate, endDate }) => {
          if (!me.isVertical) {
            me.zoomToSpan({
              startDate,
              endDate
            });
          }
        });
      }
    }

    getZoomLevelUnit(zoomLevel) {
      return PresetManager.getPreset(zoomLevel.preset).bottomHeader.unit;
    }

    get maxZoomLevel() {
      return this._maxZoomLevel;
    }

    /**
     * Get/set the {@link #config-maxZoomLevel} value
     * @property {Number}
     * @category Zoom
     */
    set maxZoomLevel(level) {
      if (typeof level !== 'number') {
        level = this.zoomLevels.length - 1;
      }

      if (level < 0 || level >= this.zoomLevels.length) {
        throw new Error('Invalid range for `setMinZoomLevel`');
      }

      this._maxZoomLevel = level;
    }

    get minZoomLevel() {
      return this._minZoomLevel;
    }

    /**
     * Sets the {@link #config-minZoomLevel} value
     * @property {Number}
     * @category Zoom
     */
    set minZoomLevel(level) {
      if (typeof level !== 'number') {
        level = 0;
      }

      if (level < 0 || level >= this.zoomLevels.length) {
        throw new Error('Invalid range for `minZoomLevel`');
      }

      this._minZoomLevel = level;
    }

    presetToZoomLevel(presetName) {
      const preset = PresetManager.getPreset(presetName);

      return {
        preset: presetName,
        increment: preset.bottomHeader.increment || 1,
        resolution: preset.timeResolution.increment,
        resolutionUnit: preset.timeResolution.unit,
        width: preset.tickWidth
      };
    }

    calculateCurrentZoomLevel() {
      let me = this,
        zoomLevel = me.presetToZoomLevel(me.viewPreset.name),
        min = Number.MAX_VALUE,
        viewModel = me.timeAxisViewModel,
        actualWidth = viewModel.tickSize;

      zoomLevel.width = actualWidth;
      zoomLevel.increment = viewModel.bottomHeader.increment || 1;

      // when calculating current zoom level we should use tick width from defined zoomLevels
      // otherwise levels might be skipped
      for (let i = 0, l = me.zoomLevels.length; i < l; i++) {
        const curentLevel = me.zoomLevels[i];

        // search for a zoom level having the same preset...
        if (curentLevel.preset !== zoomLevel.preset) continue;

        // and the most close column width to the actual one
        const delta = Math.abs(curentLevel.width - actualWidth);
        if (delta < min) {
          min = delta;
          zoomLevel.actualWidth = curentLevel.actualWidth;
          zoomLevel.width = curentLevel.width;
        }
      }

      return zoomLevel;
    }

    /**
     * Get/set current zoom level
     * @property {Number}
     * @category Zoom
     */
    get zoomLevel() {
      const me = this,
        currentZoomLevel = me.calculateCurrentZoomLevel(),
        currentFactor = me.getMilliSecondsPerPixelForZoomLevel(currentZoomLevel),
        zoomLevels = me.zoomLevels;

      for (let i = 0; i < zoomLevels.length; i++) {
        const zoomLevelFactor = me.getMilliSecondsPerPixelForZoomLevel(zoomLevels[i]);

        if (zoomLevelFactor === currentFactor) return i;

        // current zoom level is outside of pre-defined zoom levels
        if (i === 0 && currentFactor > zoomLevelFactor) return -0.5;
        if (i === zoomLevels.length - 1 && currentFactor < zoomLevelFactor) return zoomLevels.length - 1 + 0.5;

        const nextLevelFactor = me.getMilliSecondsPerPixelForZoomLevel(zoomLevels[i + 1]);

        if (zoomLevelFactor > currentFactor && currentFactor > nextLevelFactor) return i + 0.5;
      }

      throw new Error("Can't find current zoom level index");
    }

    // noinspection JSAnnotator
    set zoomLevel(level) {
      this.zoomToLevel(level);
    }

    /*
     * @private
     * Returns number of milliseconds per pixel.
     * @param {Object} level Element from array of {@link #config-zoomLevels}.
     * @param {Boolean} ignoreActualWidth If true, then density will be calculated using default zoom level settings.
     * Otherwise density will be calculated for actual tick width.
     * @return {Number} Return number of milliseconds per pixel.
     */
    getMilliSecondsPerPixelForZoomLevel(level, ignoreActualWidth) {
      // trying to convert the unit + increment to a number of milliseconds
      // this number is not fixed (month can be 28, 30 or 31 day), but at least this conversion
      // will be consistent (should be no DST changes at year 1)
      return Math.round(
        (DateHelper.add(new Date(1, 0, 1), level.increment, this.getZoomLevelUnit(level)) - new Date(1, 0, 1)) /
          // `actualWidth` is a column width after view adjustments applied to it (see `calculateTickWidth`)
          // we use it if available to return the precise index value from `getCurrentZoomLevelIndex`
          (ignoreActualWidth ? level.width : level.actualWidth || level.width)
      );
    }

    /**
     * Zooms to passed view preset, saving center date. Method accepts config object as a first argument, which can be
     * reduced to primitive type (string,number) when no additional options required. e.g.:
     * ```
     * // zooming to preset
     * scheduler.zoomTo({ preset : 'hourAndDay' })
     * // shorthand
     * scheduler.zoomTo('hourAndDay')
     *
     * // zooming to level
     * scheduler.zoomTo({ level : 0 })
     * // shorthand
     * scheduler.zoomTo(0)
     * ```
     *
     * It is also possible to zoom to a time span by omitting `preset` and `level` configs, in which case scheduler sets
     * the time frame to a specified range and applies zoom level which allows to fit all columns to this range. The
     * given time span will be centered in the scheduling view (unless `centerDate` config provided). In the same time,
     * the start/end date of the whole time axis will be extended to allow scrolling for user.
     * ```
     * // zooming to time span
     * scheduler.zoomTo({ startDate : new Date(..), endDate : new Date(...) })
     *
     * ```
     *
     * @param {Object|String|Number} config Config object, preset name or zoom level index.
     * @param {String} config.preset Preset name to zoom to. Ignores level config in this case
     * @param {Number} config.level Zoom level to zoom to. Is ignored, if preset config is provided
     * @param {Date} config.startDate New time frame start. If provided along with end, view will be centered in this time
     * interval (unless `centerDate` is present)
     * @param {Date} config.endDate New time frame end
     * @param {Date} config.centerDate Date that should be kept in the center. Has priority over start and end params
     * @param {Number} config.width Lowest tick width. Might be increased automatically
     * @param {Number} [config.leftMargin] Amount of pixels to extend span start on (used, when zooming to span)
     * @param {Number} [config.rightMargin] Amount of pixels to extend span end on (used, when zooming to span)
     * @param {Number} [config.adjustStart] Amount of units to extend span start on (used, when zooming to span)
     * @param {Number} [config.adjustEnd] Amount of units to extend span end on (used, when zooming to span)
     * @category Zoom
     */
    zoomTo(config) {
      const me = this;

      if (typeof config === 'object') {
        if (config.preset) {
          const zoomLevel = me.presetToZoomLevel(config.preset);
          this.internalZoomToLevel(zoomLevel, config);
        } else if (config.level != null) {
          me.zoomToLevel(config.level, config);
        } else {
          me.zoomToSpan(config);
        }
      } else if (typeof config === 'number') {
        me.zoomToLevel(config);
      } else {
        const zoomLevel = me.presetToZoomLevel(config);
        this.internalZoomToLevel(zoomLevel);
      }
    }

    /**
     * Allows zooming to certain level of {@link #config-zoomLevels} array. Automatically limits zooming between {@link #config-maxZoomLevel}
     * and {@link #config-minZoomLevel}. Can also set time axis timespan to the supplied start and end dates.
     *
     * @param {Number} level Level to zoom to.
     * @param {Object} [options] Object, containing options for this method
     * @param {Date} options.startDate New time frame start. If provided along with end, view will be centered in this time
     * interval, ignoring centerDate config.
     * @param {Date} options.endDate New time frame end.
     * @param {Date} options.centerDate Date that should be kept in center. Is ignored when start and end are provided.
     * @param {Number} options.width Lowest tick width. Might be increased automatically
     * @return {Number} level Current zoom level or null if it hasn't changed.
     * @category Zoom
     * @internal
     */
    zoomToLevel(level, options = {}) {
      const me = this;

      level = Math.min(Math.max(level, me.minZoomLevel), me.maxZoomLevel);

      const currentZoomLevel = me.calculateCurrentZoomLevel(),
        currentFactor = me.getMilliSecondsPerPixelForZoomLevel(currentZoomLevel),
        nextZoomLevel = me.zoomLevels[level],
        nextFactor = me.getMilliSecondsPerPixelForZoomLevel(nextZoomLevel);

      if (currentFactor === nextFactor && !(options.startDate || options.endDate)) {
        // already at requested zoom level
        return null;
      }

      me.internalZoomToLevel(nextZoomLevel, options);

      return level;
    }

    /**
     * @param {Object} level Zoom level configuration
     * @param {String} level.preset View preset to zoom to
     * @param {Number} [level.width] Tick width for preset
     * @param {Number} [level.increment] Preset increment
     * @param {String} [level.resolutionUnit] Preset resolution unit
     * @param {Number} [level.resolution] Preset resolution unit increment
     * @param {Object} [options] Additional options
     * @param {Date} options.startDate New time frame start. If provided along with end, view will be centered in this time
     * interval (unless centerDate is present)
     * @param {Date} options.endDate New time frame end.
     * @param {Date} options.centerDate Date that should be kept in center. Has priority over start and end params.
     * @param {Number} options.width Lowest tick width. Might be increased automatically
     * @private
     */
    internalZoomToLevel(level, options = {}) {
      const me = this;

      // this event is used to prevent sync suspend during zooming
      me.trigger('beforeZoomChange', { level });

      let isVertical = me.isVertical,
        startDate = options.startDate,
        endDate = options.endDate,
        span = startDate && endDate ? { startDate, endDate } : null,
        centerDate =
          options.centerDate ||
          (span ? new Date((startDate.getTime() + endDate.getTime()) / 2) : me.viewportCenterDateCached),
        // // eslint-disable-next-line no-undef
        panelSize = me.timeAxisSubGrid.width,
        presetCopy = PresetManager.getPreset(level.preset).clone(),
        bottomHeader = presetCopy.bottomHeader;

      span = span || me.calculateOptimalDateRange(centerDate, panelSize, level);

      // clone doesn't copy the preset name
      presetCopy.name = level.preset;

      presetCopy[isVertical ? 'tickHeight' : 'tickWidth'] = options.width || level.width;

      bottomHeader.increment = level.increment;

      me.isZooming = true;

      presetCopy.increment = level.increment;
      presetCopy.timeResolution.unit = DateHelper.getUnitByName(
        level.resolutionUnit || presetCopy.timeResolution.unit || bottomHeader.unit
      );
      presetCopy.timeResolution.increment = level.resolution;

      me.setViewPreset(presetCopy, span.startDate || me.startDate, span.endDate || me.endDate, false, {
        centerDate: centerDate
      });

      // after switching the view preset the `width` config of the zoom level may change, because of adjustments
      // we will save the real value in the `actualWidth` property, so that `getCurrentZoomLevelIndex` method
      // will return the exact level index after zooming
      level.actualWidth = me.timeAxisViewModel.tickSize;

      me.isZooming = false;

      /**
       * Fires after zoom level change
       * @event zoomChange
       * @param {Scheduler.view.Scheduler} source The TimeAxisColumn object
       * @param {Number} level The index of the new zoom level
       * @param {Object} levelConfig An object containing the configuration properties of the new zoom level
       */
      me.trigger('zoomChange', { level: me.zoomLevels.indexOf(level), levelConfig: level });
    }

    /**
     * Changes the range of the scheduling chart to fit all the events in its event store.
     * @param {Object} [options] Options object for the zooming operation.
     * @param {Number} [options.leftMargin] Defines margin in pixel between the first event start date and first visible date
     * @param {Number} [options.rightMargin] Defines margin in pixel between the last event end date and last visible date
     */
    zoomToFit(options) {
      const eventStore = this.eventStore,
        span = eventStore.getTotalTimeSpan();

      options = Object.assign(
        {
          leftMargin: 0,
          rightMargin: 0
        },
        options,
        span
      );

      // Make sure we received a time span, event store might be empty
      if (options.startDate && options.endDate) {
        this.zoomToSpan(options);
      }
    }

    /**
     * Sets time frame to specified range and applies zoom level which allows to fit all columns to this range.
     *
     * The given time span will be centered in the scheduling view, in the same time, the start/end date of the whole time axis
     * will be extended in the same way as {@link #function-zoomToLevel} method does, to allow scrolling for user.
     *
     * @param {Object} config The time frame.
     * @param {Date} config.startDate The time frame start.
     * @param {Date} config.endDate The time frame end.
     * @param {Date} [config.centerDate] Date that should be kept in the center. Has priority over start and end params
     * @param {Number} [config.leftMargin] Amount of pixels to extend span start on
     * @param {Number} [config.rightMargin] Amount of pixels to extend span end on
     * @param {Number} [config.adjustStart] Amount of units to extend span start on
     * @param {Number} [config.adjustEnd] Amount of units to extend span end on
     *
     * @return {Number} level Current zoom level or null if it hasn't changed.
     * @category Zoom
     * @internal
     */
    zoomToSpan(config = {}) {
      if (config.leftMargin || config.rightMargin) {
        config.adjustStart = 0;
        config.adjustEnd = 0;
      }

      if (!config.leftMargin) config.leftMargin = 0;
      if (!config.rightMargin) config.rightMargin = 0;

      if (!config.startDate || !config.endDate) throw new Error('zoomToSpan: must provide startDate + endDate dates');

      let me = this,
        startDate = config.startDate,
        endDate = config.endDate,
        // this config enables old zoomToSpan behavior which we want to use for zoomToFit in Gantt
        needToAdjust = config.adjustStart >= 0 || config.adjustEnd >= 0;

      if (needToAdjust) {
        startDate = DateHelper.add(startDate, -config.adjustStart, me.timeAxis.mainUnit);
        endDate = DateHelper.add(endDate, config.adjustEnd, me.timeAxis.mainUnit);
      }

      if (startDate <= endDate) {
        // get scheduling view width
        const { availableSpace } = me.timeAxisViewModel;

        // if potential width of col is less than col width provided by zoom level
        //   - we'll zoom out panel until col width fit into width from zoom level
        // and if width of column is more than width from zoom level
        //   - we'll zoom in until col width fit won't fit into width from zoom level

        let currLevel = Math.floor(me.zoomLevel);

        // if we zoomed out even more than the highest zoom level - limit it to the highest zoom level
        if (currLevel === -1) currLevel = 0;

        const zoomLevels = me.zoomLevels;

        let diffMS = endDate - startDate || 1,
          msPerPixel = me.getMilliSecondsPerPixelForZoomLevel(zoomLevels[currLevel], true),
          // increment to get next zoom level:
          // -1 means that given timespan won't fit the available width in the current zoom level, we need to zoom out,
          // so that more content will "fit" into 1 px
          //
          // +1 mean that given timespan will already fit into available width in the current zoom level, but,
          // perhaps if we'll zoom in a bit more, the fitting will be better
          inc = diffMS / msPerPixel + config.leftMargin + config.rightMargin > availableSpace ? -1 : 1,
          candidateLevel = currLevel + inc,
          zoomLevel,
          levelToZoom = null;

        // loop over zoom levels
        while (candidateLevel >= 0 && candidateLevel <= zoomLevels.length - 1) {
          // get zoom level
          zoomLevel = zoomLevels[candidateLevel];

          msPerPixel = me.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);
          const spanWidth = diffMS / msPerPixel + config.leftMargin + config.rightMargin;

          // if zooming out
          if (inc === -1) {
            // if columns fit into available space, then all is fine, we've found appropriate zoom level
            if (spanWidth <= availableSpace) {
              levelToZoom = candidateLevel;
              // stop searching
              break;
            }
            // if zooming in
          } else {
            // if columns still fits into available space, we need to remember the candidate zoom level as a potential
            // resulting zoom level, the indication that we've found correct zoom level will be that timespan won't fit
            // into available view
            if (spanWidth <= availableSpace) {
              // if it's not currently active level
              if (currLevel !== candidateLevel - inc) {
                // remember this level as applicable
                levelToZoom = candidateLevel;
              }
            } else {
              // Sanity check to find the following case:
              // If we're already zoomed in at the appropriate level, but the current zoomLevel is "too small" to fit and had to be expanded,
              // there is an edge case where we should actually just stop and use the currently selected zoomLevel
              break;
            }
          }

          candidateLevel += inc;
        }

        // If we didn't find a large/small enough zoom level, use the lowest/highest level
        levelToZoom = levelToZoom != null ? levelToZoom : candidateLevel - inc;

        zoomLevel = zoomLevels[levelToZoom];

        const unitToZoom = PresetManager.getPreset(zoomLevel.preset).bottomHeader.unit;

        if (config.leftMargin || config.rightMargin) {
          // time axis doesn't yet know about new view preset (zoom level) so it cannot round/ceil date correctly
          startDate = new Date(startDate.getTime() - msPerPixel * config.leftMargin);
          endDate = new Date(endDate.getTime() + msPerPixel * config.rightMargin);
        }

        const tickCount = DateHelper.getDurationInUnit(startDate, endDate, unitToZoom, true) / zoomLevel.increment;

        if (tickCount === 0) {
          return null;
        }

        let customWidth = Math.floor(availableSpace / tickCount),
          centerDate = config.centerDate || new Date((startDate.getTime() + endDate.getTime()) / 2),
          range;

        if (needToAdjust) {
          range = {
            startDate,
            endDate
          };
        } else {
          range = me.calculateOptimalDateRange(centerDate, availableSpace, zoomLevel);
        }

        return me.zoomToLevel(
          levelToZoom,
          Object.assign(range, {
            width: customWidth,
            centerDate
          })
        );
      }

      return null;
    }

    /**
     * Zooms in the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view will zoom in by this value.
     * Otherwise a value of `1` will be used.
     *
     * @param {Number} levels (optional) amount of levels to zoom in
     *
     * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
     * @category Zoom
     */
    zoomIn(levels = 1) {
      const currentZoomLevelIndex = this.zoomLevel;

      if (currentZoomLevelIndex >= this.zoomLevels.length - 1) return null;

      return this.zoomToLevel(Math.floor(currentZoomLevelIndex) + levels);
    }

    /**
     * Zooms out the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view will zoom out by this value.
     * Otherwise a value of `1` will be used.
     *
     * @param {Number} levels (optional) amount of levels to zoom out
     *
     * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
     * @category Zoom
     */
    zoomOut(levels = 1) {
      const currentZoomLevelIndex = this.zoomLevel;

      if (currentZoomLevelIndex <= 0) return null;

      return this.zoomToLevel(Math.ceil(currentZoomLevelIndex) - levels);
    }

    /**
     * Zooms in the timeline to the {@link #config-maxZoomLevel} according to the array of zoom levels.
     *
     * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
     * @category Zoom
     */
    zoomInFull() {
      return this.zoomToLevel(this.maxZoomLevel);
    }

    /**
     * Zooms out the timeline to the {@link #config-minZoomLevel} according to the array of zoom levels.
     *
     * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
     * @category Zoom
     */
    zoomOutFull() {
      return this.zoomToLevel(this.minZoomLevel);
    }

    /*
     * Adjusts the timespan of the panel to the new zoom level. Used for performance reasons,
     * as rendering too many columns takes noticeable amount of time so their number is limited.
     * @category Zoom
     * @private
     */
    calculateOptimalDateRange(centerDate, panelSize, zoomLevel, userProvidedSpan) {
      // this line allows us to always use the `calculateOptimalDateRange` method when calculating date range for zooming
      // (even in case when user has provided own interval)
      // other methods may override/hook into `calculateOptimalDateRange` to insert own processing
      // (infinite scrolling feature does)
      if (userProvidedSpan) return userProvidedSpan;

      const timeAxis = this.timeAxis;

      if (this.zoomKeepsOriginalTimespan) {
        return {
          startDate: timeAxis.startDate,
          endDate: timeAxis.endDate
        };
      }

      const unit = this.getZoomLevelUnit(zoomLevel),
        difference = Math.ceil(((panelSize / zoomLevel.width) * zoomLevel.increment * this.visibleZoomFactor) / 2),
        startDate = DateHelper.add(centerDate, -difference, unit),
        endDate = DateHelper.add(centerDate, difference, unit);

      return {
        startDate: timeAxis.floorDate(startDate, false, unit, zoomLevel.increment),
        endDate: timeAxis.ceilDate(endDate, false, unit, zoomLevel.increment)
      };
    }

    onWheel(event) {
      const me = this;

      if (event.ctrlKey) {
        event.preventDefault();

        if (!me.preventScrollZoom) {
          if (event.deltaY > 0) {
            me.zoomOut();
          } else if (event.deltaY < 0) {
            me.zoomIn();
          }
          me.preventScrollZoom = true;
          me.setTimeout(() => (me.preventScrollZoom = false), 30);
        }
      }
    }

    /**
     * Changes the time axis timespan to the supplied start and end dates.
     * @param {Date} startDate The new start date
     * @param {Date} endDate The new end date. If not supplied, the {@link Scheduler.preset.ViewPreset#config-defaultSpan} property of the current view preset will be used to calculate the new end date.
     */
    setTimeSpan(startDate, endDate) {
      this.timeAxis.setTimeSpan(startDate, endDate);
    }

    /**
     * Moves the time axis by the passed amount and unit.
     *
     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shift} for more information.
     *
     * @param {Number} amount The number of units to jump
     * @param {String} [unit] The unit (Day, Week etc)
     */
    shift(amount, unit) {
      this.timeAxis.shift(amount, unit);
    }

    /**
     * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement`
     * config of the current view preset.
     *
     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shiftNext} for more information.
     *
     * @param {Number} [amount] The number of units to jump forward
     */
    shiftNext(amount) {
      this.timeAxis.shiftNext(amount);
    }

    /**
     * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` config of the current view preset.
     *
     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shiftPrevious} for more information.
     *
     * @param {Number} [amount] The number of units to jump backward
     */
    shiftPrevious(amount) {
      this.timeAxis.shiftPrevious(amount);
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Scheduler/view/mixin/TimelineEventRendering
 */

/**
 * Functions to handle event rendering (EventModel -> dom elements).
 *
 * @mixin
 */
var TimelineEventRendering = (Target) =>
  class TimelineEventRendering extends (Target || Base) {
    //region Default config

    static get defaultConfig() {
      return {
        /**
         * Controls how much space to leave between stacked event bars in px
         * @config {Number}
         * @default
         * @category Scheduled events
         */
        barMargin: 10,

        resourceMargin: null,

        /**
         * True to size events based on the rowHeight and barMargin settings. Set this to false if you want to
         * control height and top properties via CSS instead.
         * @config {Boolean}
         * @default
         * @category Scheduled events
         */
        managedEventSizing: true,

        /**
         * The CSS class added to an event/assignment when it is newly created
         * in the UI and unsynced with the server.
         * @config {String}
         * @default
         * @private
         * @category CSS
         */
        generatedIdCls: 'b-sch-dirty-new',

        /**
         * The CSS class added to an event when it has unsaved modifications
         * @config {String}
         * @default
         * @private
         * @category CSS
         */
        dirtyCls: 'b-sch-dirty',

        /**
         * The CSS class added to an event when it is currently committing changes
         * @config {String}
         * @default
         * @private
         * @category CSS
         */
        committingCls: 'b-sch-committing',

        /**
         * The CSS class added to an event/assignment when it ends outside of the visible time range.
         * @config {String}
         * @default
         * @private
         * @category CSS
         */
        endsOutsideViewCls: 'b-sch-event-endsoutside',

        /**
         * The CSS class added to an event/assignment when it starts outside of the visible time range.
         * @config {String}
         * @default
         * @private
         * @category CSS
         */
        startsOutsideViewCls: 'b-sch-event-startsoutside',

        /**
         * The CSS class added to an event/assignment when it is not draggable.
         * @config {String}
         * @default
         * @private
         * @category CSS
         */
        fixedEventCls: 'b-sch-event-fixed',

        /**
         * Event style used by default. Events and resources can specify their own style, with priority order being:
         * Event -> Resource -> Scheduler default. Determines the appearance of the event by assigning a CSS class
         * to it. Available styles are:
         * * plain (default), flat look
         * * border, has border in darker shade of events color
         * * colored, has colored text and wide left border in same color
         * * hollow, only border + text until hovered
         * * line, as a line with the text below it
         * * dashed, as a dashed line with the text below it
         * * minimal, as a thin line with small text above it
         * @config {String}
         * @default
         * @category Scheduled events
         */
        eventStyle: 'plain',

        /**
         * Event color used by default. Events and resources can specify their own color, with priority order being:
         * Event -> Resource -> Scheduler default. Available colors are:
         * * red
         * * pink
         * * purple
         * * violet
         * * indigo
         * * blue
         * * cyan
         * * teal
         * * green
         * * lime
         * * yellow
         * * orange
         * * gray
         * @config {String}
         * @default
         * @category Scheduled events
         */
        eventColor: 'green'
      };
    }

    //endregion

    //region Settings

    /**
     * Control how much space to leave between stacked event bars in px. Value will be constrained by half the row height.
     * @property {Number}
     * @category Scheduled events
     */
    get barMargin() {
      return this._barMargin;
    }

    set barMargin(margin) {
      const me = this;

      ObjectHelper.assertNumber(margin, 'barMargin');

      // bar margin should not exceed half of the row height
      if (me.isHorizontal && me.rowHeight) {
        margin = Math.min(Math.ceil(me.rowHeight / 2), margin);
      }

      if (me._barMargin !== margin) {
        me._barMargin = margin;
        if (me.rendered) {
          me.currentOrientation.onBeforeRowHeightChange();
          me.refreshWithTransition();
        }
      }
    }

    // Documented in SchedulerEventRendering to not show up in Gantt docs
    get resourceMargin() {
      return this._resourceMargin == null ? this.barMargin : this._resourceMargin;
    }

    set resourceMargin(margin) {
      const me = this;

      ObjectHelper.assertNumber(margin, 'resourceMargin');

      // bar margin should not exceed half of the row height
      if (me.isHorizontal && me.rowHeight) {
        margin = Math.min(Math.ceil(me.rowHeight / 2), margin);
      }

      if (me._resourceMargin !== margin) {
        me._resourceMargin = margin;
        if (me.rendered) {
          me.currentOrientation.onBeforeRowHeightChange();
          me.refreshWithTransition();
        }
      }
    }

    // /**
    //  * Distance between bars when using eventLayout pack
    //  * @property {Number}
    //  */
    // get barPackMargin() {
    //     return this._barPackMargin;
    // }
    //
    // set barPackMargin(margin) {
    //     if (this._barPackMargin !== margin) {
    //         this._barPackMargin = margin;
    //         this.refresh();
    //     }
    // }

    /**
     * Get/set the widths of all the time columns to the supplied value. Only applicable when {@link Scheduler.view.TimelineBase#config-forceFit} is set to false.
     * Deprecated in favor of {@link #property-tickSize}
     * @property {Number}
     * @deprecated 2.2
     * @category Scheduled events
     */
    set tickWidth(width) {
      this.tickSize = width;
    }

    get tickWidth() {
      return this.tickSize;
    }

    /**
     * Get/set the width/height (depending on mode) of all the time columns to the supplied value. Only applicable when
     * {@link Scheduler.view.TimelineBase#config-forceFit} is set to false.
     * @property {Number}
     * @category Scheduled events
     */
    set tickSize(width) {
      ObjectHelper.assertNumber(width, 'tickSize');

      this.timeAxisViewModel.tickSize = width;
    }

    get tickSize() {
      return this.timeAxisViewModel.tickSize;
    }

    /**
     * Predefined event colors, useful in combos etc.
     * @type {String}
     * @category Scheduled events
     */
    static get eventColors() {
      return [
        'red',
        'pink',
        'purple',
        'violet',
        'indigo',
        'blue',
        'cyan',
        'teal',
        'green',
        'lime',
        'yellow',
        'orange',
        'gray'
      ];
    }

    /**
     * Predefined event styles , useful in combos etc.
     * @type {String}
     * @category Scheduled events
     */
    static get eventStyles() {
      return ['plain', 'border', 'hollow', 'colored', 'line', 'dashed', 'minimal'];
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Scheduler/view/mixin/TimelineScroll
 */

/**
 * Functions for scrolling to events, dates etc.
 *
 * @mixin
 */
var TimelineScroll = (Target) =>
  class TimelineScroll extends (Target || Base) {
    //region Scroll to date

    /**
     * Scrolls the time line "tick" encapsulating the passed `Date` into view according to the passed options.
     * @param {Date} date The date to which to scroll the time line
     * @param {Object} [options] How to scroll.
     * @param {String} [options.block=nearest] How far to scroll the tick: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset=20] edgeOffset A margin *in pixels* around the tick to bring into view.
     * @param {Boolean/Number} [options.animate] Set to `true` to animate the scroll, or the number of milliseconds to animate over.
     * @returns {Promise} A Promise which resolves when the scrolling is complete.
     */
    scrollToDate(date, options = {}) {
      const me = this,
        scroller = me.timeAxisSubGrid.scrollable,
        scrollerViewport = scroller.viewport,
        localCoordinate = me.getCoordinateFromDate(date, true),
        target = me.isHorizontal
          ? new Rectangle(
              me.getCoordinateFromDate(date, false),
              scrollerViewport.y,
              me.timeAxisViewModel.tickSize,
              scrollerViewport.height
            )
          : new Rectangle(
              scrollerViewport.x,
              me.getCoordinateFromDate(date, false),
              scrollerViewport.width,
              me.timeAxisViewModel.tickSize
            );

      return me.scrollToCoordinate(localCoordinate, target, date, options);
    }

    /**
     * Scrolls to current time.
     * @param {Object} [options] How to scroll.
     * @param {String} [options.block=nearest] How far to scroll the tick: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset=20] edgeOffset A margin *in pixels* around the tick to bring into view.
     * @param {Boolean/Number} [options.animate] Set to `true` to animate the scroll, or the number of milliseconds to animate over.
     * @returns {Promise} A Promise which resolves when the scrolling is complete.
     */
    scrollToNow(options = {}) {
      return this.scrollToDate(new Date(), options);
    }

    /**
     * Used by {@link #function-scrollToDate} to scroll to correct coordinate.
     * @param {Number} localCoordinate Coordinate to scroll to
     * @param {Date} date Date to scroll to, used for reconfiguring the time axis
     * @param {Object} [options] How to scroll.
     * @param {String} [options.block=nearest] How far to scroll the tick: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset] edgeOffset A margin *in pixels* around the tick to bring into view.
     * @param {Boolean/Number} [options.animate] Set to `true` to animate the scroll, or the number of milliseconds to animate over.
     * @returns {Promise} A Promise which resolves when the scrolling is complete.
     * @private
     */
    scrollToCoordinate(localCoordinate, target, date, options = {}) {
      const me = this;

      // Not currently have this date in a timeaxis. Ignore negative scroll in weekview, it can be just 'filtered' with
      // startTime/endTime config
      if (localCoordinate < 0) {
        if (me.infiniteScroll) {
          // for infinite scroll we have a special formula to calculate adjustment borders
          // shiftToDate() will perform adjustment and then recall scrollToDate() again
          // eslint-disable-next-line no-undef
          view.shiftToDate(date, centered);
        } else {
          // adjust the timeaxis first
          const halfVisibleSpan = (me.timeAxis.endDate - me.timeAxis.startDate) / 2,
            newStartDate = new Date(date.getTime() - halfVisibleSpan),
            newEndDate = new Date(date.getTime() + halfVisibleSpan);

          // We're trying to reconfigure time span to current dates, which means we are as close to center as it
          // could be. Do nothing then.
          // covered by 1102_panel_api
          if (newStartDate - me.startDate !== 0 && newEndDate - me.endDate !== 0) {
            me.setTimeSpan(newStartDate, newEndDate);

            if (options.centered) {
              return me.scrollToDateCentered(date, options);
            } else {
              return me.scrollToDate(date, options);
            }
          }
        }

        return;
      }

      return me.timeAxisSubGrid.scrollable.scrollIntoView(target, options);
    }

    //endregion

    //region Relative scrolling
    // These methods are important to users because although they are mixed into the top level Grid/Scheduler,
    // for X scrolling the explicitly target the SubGrid that holds the scheduler.

    /**
     * Get/set horizontal scroll. Applies to the SubGrid that holds the scheduler
     * @property {Number}
     * @category Scrolling
     */
    set scrollLeft(left) {
      this.timeAxisSubGrid.scrollable.x = left;
    }

    /**
     * Get/set vertical scroll
     * @property {Number}
     * @category Scrolling
     */
    set scrollTop(top) {
      this.scrollable.y = top;
    }

    get scrollLeft() {
      return this.timeAxisSubGrid.scrollable.x;
    }

    get scrollTop() {
      return this.scrollable.y;
    }

    /**
     * Horizontal scrolling. Applies to the SubGrid that holds the scheduler
     * @param {Number} x
     * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
     * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
     * or the number of milliseconds to animate over, or an animation config object.
     * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
     * @param {String} [options.animate.easing] The name of an easing function.
     * @returns {Promise} A promise which is resolved when the scrolling has finished.
     */
    scrollHorizontallyTo(coordinate, options = true) {
      return this.timeAxisSubGrid.scrollable.scrollTo(coordinate, null, options);
    }

    /**
     * Vertical scrolling
     * @param {Number} y
     * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
     * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
     * or the number of milliseconds to animate over, or an animation config object.
     * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
     * @param {String} [options.animate.easing] The name of an easing function.
     * @returns {Promise} A promise which is resolved when the scrolling has finished.
     */
    scrollVerticallyTo(y, options = true) {
      return this.scrollable.scrollTo(null, y, options);
    }

    /**
     * Scrolls the subgrid that contains the scheduler
     * @param {Number} x
     * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
     * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
     * or the number of milliseconds to animate over, or an animation config object.
     * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
     * @param {String} [options.animate.easing] The name of an easing function.
     * @returns {Promise} A promise which is resolved when the scrolling has finished.
     */
    scrollTo(x, options = true) {
      return this.timeAxisSubGrid.scrollable.scrollTo(x, null, options);
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

const timeAxisColumnConfigs = [
  'viewPreset',
  'eventBarTextField',
  'eventRenderer',
  'eventRendererThisObj',
  'eventBodyTemplate'
];

/**
 * @module Scheduler/view/TimelineBase
 */

/**
 * Abstract base class used by timeline based components such as Scheduler and Gantt. Based on Grid, supplies a "locked"
 * region for columns and a "normal" for rendering of events etc.
 * @abstract
 *
 * @mixes Scheduler/view/mixin/TimelineDateMapper
 * @mixes Scheduler/view/mixin/TimelineDomEvents
 * @mixes Scheduler/view/mixin/TimelineEventRendering
 * @mixes Scheduler/view/mixin/TimelineScroll
 * @mixes Scheduler/view/mixin/TimelineViewPresets
 * @mixes Scheduler/view/mixin/TimelineZoomable
 *
 * @extends Grid/view/Grid
 */
class TimelineBase extends base(Grid).mixes(
  TimelineDateMapper,
  TimelineDomEvents,
  TimelineEventRendering,
  TimelineScroll,
  TimelineViewPresets,
  TimelineZoomable
) {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * A valid JS day index between 0-6 (0: Sunday, 1: Monday etc.) to be considered the start day of the week.
       * When omitted, the week start day is retrieved from the active locale class.
       * @config {Number}
       * @category Time axis
       */
      weekStartDay: DateHelper.weekStartDay,

      /**
       * An object with format `{ fromDay, toDay, fromHour, toHour }` that describes the working days and hours.
       * This object will be used to populate TimeAxis {@link Scheduler.data.TimeAxis#config-include} property.
       *
       * Using it results in a non-continuous time axis. Any ticks not covered by the working days and hours will
       * be excluded. Events within larger ticks (for example if using week as the unit for ticks) will be
       * stretched to fill the gap otherwise left by the non working hours.
       *
       * As with end dates, `toDay` and `toHour` are exclusive. Thus `toDay : 6` means that day 6 (saturday) will
       * not be included.
       *
       *
       * **NOTE:** When this feature is enabled {@link Scheduler.view.mixin.TimelineZoomable Zooming feature} is not supported. It's recommended to disable zooming controls:
       *
       * ```javascript
       * new Scheduler({
       *     zoomOnMouseWheel          : false,
       *     zoomOnTimeAxisDoubleClick : false,
       *     ...
       * });
       * ```
       *
       * @config {Object}
       * @category Time axis
       */
      workingTime: null,

      /**
       * The backing store providing the input date data for the timeline panel. Created automatically if none
       * supplied.
       * @config {Scheduler.data.TimeAxis}
       * @category Time axis
       */
      timeAxis: null,

      /**
       * The backing view model for the visual representation of the time axis.
       * Either a real instance or a simple config object.
       * @private
       * @config {Scheduler.view.model.TimeAxisViewModel|Object}
       * @category Time axis
       */
      timeAxisViewModel: null,

      /**
       * You can set this option to `false` to make the timeline panel start and end on the exact provided
       * {@link #config-startDate}/{@link #config-endDate} w/o adjusting them.
       * @config {Boolean}
       * @default
       * @category Time axis
       */
      autoAdjustTimeAxis: true,

      /**
       * The start date of the timeline. If omitted, and a TimeAxis has been set, the start date of the provided {@link Scheduler.data.TimeAxis} will be used.
       * If no TimeAxis has been configured, it'll use the start/end dates of the loaded event dataset. If no date information exists in the event data
       * set, it defaults to the current date and time.
       *
       * **Note:** If you need to set start and end date at the same time, use {@link Scheduler.view.mixin.TimelineZoomable#function-setTimeSpan} method.
       * @config {Date}
       * @category Common
       */
      startDate: null,

      /**
       * The end date of the timeline. If omitted, it will be calculated based on the {@link #config-startDate} setting and
       * the 'defaultSpan' property of the current {@link Scheduler.view.mixin.TimelineViewPresets#config-viewPreset}.
       *
       * **Note:** If you need to set start and end date at the same time, use {@link Scheduler.view.mixin.TimelineZoomable#function-setTimeSpan} method.
       * @config {Date}
       * @category Common
       */
      endDate: null,

      /**
       * true to snap to resolution increment while interacting with scheduled events.
       * @config {Boolean}
       * @default
       * @category Scheduled events
       */
      snap: false,

      /**
       * Affects drag drop and resizing of events when {@link #config-snap} is enabled. If set to `true`, dates will be snapped relative to event start.
       * e.g. for a zoom level with timeResolution = { unit: "s", increment: "20" }, an event that starts at 10:00:03 and is dragged would snap its start date to 10:00:23, 10:00:43 etc.
       * When set to `false`, dates will be snapped relative to the timeAxis startDate (tick start) - 10:00:03, 10:00:20, 10:00:40 etc.
       * @config {Boolean}
       * @default
       * @category Scheduled events
       */
      snapRelativeToEventStartDate: false,

      /**
       * Set to true to force the time columns to fit to the available horizontal space.
       * @config {Boolean}
       * @default
       * @category Time axis
       */
      forceFit: false,

      /**
       * CSS class to add to rendered events
       * @config {String}
       * @category CSS
       * @private
       */
      eventCls: null,

      /**
       * Returns dates that will constrain resize and drag operations. The method will be called with the Resource, and
       * for operations on existing events - the event. For drag create operation, the mousedown date will be passed as the second parameter
       * @return {Object} Constraining object
       * @return {Date} return.start Start date
       * @return {Date} return.end End date
       * @config {Number}
       * @category Scheduled events
       */
      getDateConstraints: null,

      /**
       * CSS class to add to cells in the timeaxis column
       * @config {String}
       * @category CSS
       * @private
       */
      timeCellCls: null,

      timeCellSelector: null,

      scheduledEventName: null,

      /**
       * Create event on double click if scheduler is not in read only mode.
       * Set to false to turn creating off.
       * @config {Boolean}
       * @default
       * @category Scheduled events
       */
      createEventOnDblClick: true,

      //dblClickTime : 200,

      /**
       * A CSS class to apply to each event in the view on mouseover.
       * @config {String}
       * @category CSS
       * @private
       */
      overScheduledEventClass: null,

      // allow the panel to prevent adding the hover CSS class in some cases - during drag drop operations
      preventOverCls: false,

      // The last hovered over event bar HTML node
      hoveredEventNode: null,

      // This setting is set to true by features that need it
      useBackgroundCanvas: false,

      /**
       * Set to `false` if you don't want event bar DOM updates to animate. Animations are disabled in IE11 by default.
       * @config {Boolean}
       * @default true
       * @category Scheduled events
       */
      enableEventAnimations: !BrowserHelper.isIE11,

      disableGridRowModelWarning: true,

      // does not look good with locked columns and also interferes with event animations
      animateRemovingRows: false,

      /**
       * Partners this Timeline panel with another Timeline in order to sync their region sizes (sub-grids like locked, normal will get the same width),
       * start and end dates, view preset, zoom level and scrolling position. All these values will be synced with the timeline defined as the `partner`.
       * @config {Scheduler.view.TimelineBase}
       * @category Time axis
       */
      partner: null,

      schedulerRegion: 'normal',

      transitionDuration: 200,
      // internal timer id reference
      animationTimeout: null,

      /**
       * How to handle milestones during event layout. Options are:
       * * default - Milestones do not affect event layout
       * * estimate - Milestone width is estimated by multiplying text length with Scheduler#milestoneCharWidth
       * * data - Milestone width is determined by checking EventModel#milestoneWidth
       * * measure - Milestone width is determined by measuring label width
       * Please note that currently text width is always determined using EventModel#name.
       * Also note that only 'default' is supported by eventStyles line, dashed and minimal.
       * @config {String}
       * @default
       * @category Scheduled events
       */
      milestoneLayoutMode: 'default',

      /**
       * Region to which columns are added when they have none specified
       * @config {string}
       * @default
       * @category Misc
       */
      defaultRegion: 'locked'
    };
  }

  //endregion

  //region Init

  construct(config = {}) {
    const me = this,
      region = config.schedulerRegion || 'normal', // Cannot rely on default value, too early
      { subGridConfigs = {} } = config;

    config.subGridConfigs = subGridConfigs;

    subGridConfigs[region] = subGridConfigs[region] || {};
    subGridConfigs[region].headerClass = Header$1;

    // If user have not specified a width or flex for scheduler region, default to flex=1
    if (!('flex' in subGridConfigs[region] || 'width' in subGridConfigs[region])) {
      subGridConfigs[region].flex = 1;
    }

    super.construct(config);

    // Buffer resize, since resize does full redraw it is costly
    me.onSchedulerViewportResize = me.throttle(me.onSchedulerViewportResize, 250);

    me.initDomEvents();

    me.currentOrientation.init();

    me.rowManager.on('refresh', () => {
      me.forceLayout = false;
    });

    if (me.loadMask && me.crudManager && me.crudManager.isLoading) {
      // Show loadmask if crud manager is already loading
      me.maskBody(me.loadMask);
    }
  }

  doDestroy() {
    const me = this,
      { currentOrientation } = this;

    if (currentOrientation) {
      currentOrientation.destroy();
    }

    // Break links between this TimeLine and any partners.
    if (me.partneredWith) {
      me.partneredWith.forEach((p) => {
        me.removePartner(p);
      });
      me.partneredWith.destroy();
    }
    super.doDestroy();
  }

  startConfigure(config) {
    super.startConfigure(config);

    // partner needs to be initialized first so that the various shared
    // configs are assigned first before we default them in.
    this._thisIsAUsedExpression(this.partner);
  }

  initSubGrids() {
    super.initSubGrids();

    const me = this,
      timeAxisSubGrid = (me.timeAxisSubGrid = me.timeAxisColumn.subGrid = me.subGrids[me.timeAxisColumn.region]);

    // Scheduler SubGrid doesn't accept external columns moving in
    timeAxisSubGrid.sealedColumns = true;

    timeAxisSubGrid.on({
      resize: me.onTimeAxisSubGridResize,
      thisObj: me
    });
  }

  /**
   * Overrides initScroll from Grid, listens for horizontal scroll to do virtual event rendering
   * @private
   */
  initScroll() {
    let me = this,
      frameCount = 0;

    super.initScroll();

    me.on('horizontalscroll', ({ subGrid, scrollLeft }) => {
      if (me.rendered && subGrid === me.timeAxisSubGrid) {
        me.onSchedulerHorizontalScroll(subGrid, scrollLeft);
      }
      frameCount++;
    });

    if (me.testPerformance === 'horizontal') {
      setTimeout(() => {
        let start = performance.now(), // eslint-disable-line no-undef
          scrollSpeed = 5,
          direction = 1;

        let scrollInterval = setInterval(() => {
          scrollSpeed = scrollSpeed + 5;

          me.scrollLeft += (10 + Math.floor(scrollSpeed)) * direction;

          if (direction === 1 && me.scrollLeft > 5500) {
            direction = -1;
            scrollSpeed = 5;
          }

          if (direction === -1 && me.scrollLeft <= 0) {
            let done = performance.now(), // eslint-disable-line no-undef
              elapsed = done - start;

            let timePerFrame = elapsed / frameCount,
              fps = 1000 / timePerFrame;

            fps = Math.round(fps * 10) / 10;

            clearInterval(scrollInterval);

            console.log(me.eventPositionMode, me.eventScrollMode, fps + 'fps');
          }
        }, 0);
      }, 500);
    }
  }

  //endregion

  //region Config getters/setters

  /**
   * Returns `true` if any of the events/tasks or feature injected elements (such as ResourceTimeRanges) are within
   * the {@link #config-timeAxis}
   * @property {Boolean}
   * @readonly
   */
  get hasVisibleEvents() {
    return (
      !this.noFeatureElementsInAxis() || this.eventStore.storage.values.some((t) => this.timeAxis.isTimeSpanInAxis(t))
    );
  }

  // Template function to be chained in features to determine if any elements are in time axis (needed since we cannot
  // currently chain getters). Negated to not break chain. First feature that has elements visible returns false,
  // which prevents other features from being queried.
  noFeatureElementsInAxis() {}

  // Private getter used to piece togheter event names such as beforeEventDrag / beforeTaskDrag. Could also be used
  // in templates.
  get capitalizedEventName() {
    if (!this._capitalizedEventName) {
      this._capitalizedEventName = StringHelper.capitalizeFirstLetter(this.scheduledEventName);
    }

    return this._capitalizedEventName;
  }

  set partner(partner) {
    const me = this,
      partneredWith = me.partneredWith || (me.partneredWith = new Collection());

    me._partner = partner;

    if (!partneredWith.includes(partner)) {
      // Each must know about the other so that they can sync others upon region resize
      partneredWith.add(partner);

      (partner.partneredWith || (partner.partneredWith = new Collection())).add(me);

      partner.on({
        presetchange: 'onPartnerPresetChange',
        thisObj: me
      });
      me.on({
        presetchange: 'onPartnerPresetChange',
        thisObj: partner
      });

      me.setConfig({
        viewPreset: partner.viewPreset,
        timeAxis: partner.timeAxis,
        timeAxisViewModel: partner.timeAxisViewModel
      });

      // When initScroll comes round, make sure it syncs with the partner
      me.initScroll = FunctionHelper.createSequence(
        me.initScroll,
        () => {
          me.scrollable.addPartner(partner.scrollable, 'x');
        },
        me
      );
    }
  }

  removePartner(partner) {
    const me = this,
      partneredWith = me.partneredWith;

    if (partneredWith && partneredWith.includes(partner)) {
      partneredWith.remove(partner);
      partner.partneredWith.remove(me);
      partner.scrollable.removePartner(me.scrollable);
      partner.un({
        presetchange: 'onPartnerPresetChange',
        thisObj: me
      });
      me.un({
        presetchange: 'onPartnerPresetChange',
        thisObj: partner
      });
    }
  }

  onPartnerPresetChange({ preset, startDate, endDate, centerDate }) {
    if (this.viewPreset !== preset) {
      // Passing more params directly to make zoom behave identically. See #8764
      this.setViewPreset(preset, startDate, endDate, false, { centerDate });
    }
  }

  get partner() {
    return this._partner;
  }

  get timeAxisColumn() {
    return this.columns && this._timeAxisColumn;
  }

  get columns() {
    // Maintainer. If we do not implement a getter to go along with our setter, this
    // property becomes unreadable at this class level.
    return super.columns;
  }

  set columns(columns) {
    const me = this;

    let timeAxisColumnIndex = columns && columns.length,
      timeAxisColumnConfig = {},
      timeAxisColumn,
      value;

    // No columns means destroy
    if (columns) {
      columns.forEach((col, index) => {
        if (col.type === 'timeAxis') {
          timeAxisColumnIndex = index;
          timeAxisColumnConfig = col;
        }
      });

      // TODO : This is scheduler specific, override `set columns` instead
      // No additional columns allowed in vertical mode, but store the specified set in case we toggle mode later
      if (me.isVertical) {
        me._horizontalColumns = columns;

        columns = [
          {
            type: 'verticalTimeAxis',
            locked: true,
            timeline: me
          },
          columns[timeAxisColumnIndex]
        ];

        timeAxisColumnIndex = 1;
      } else {
        // We're going to mutate this array which we do not own, so copy it first.
        columns = columns.slice();
      }

      // Fix up the timeAxisColumn config in place
      timeAxisColumnConfig = columns[timeAxisColumnIndex] = Object.assign(
        {
          type: 'timeAxis',
          locked: false,
          timeline: me,
          cellCls: me.timeCellCls,
          mode: me.mode
        },
        timeAxisColumnConfig
      );

      // Pass these configs into the timeAxisColumnConfig
      timeAxisColumnConfigs.forEach((configName) => {
        value = me[configName];
        if (value != null) {
          timeAxisColumnConfig[configName] = value;
        }
      });
    }

    // Invoke Grid's setter. Will create a ColumnStore which is returned by the columns setter.
    super.columns = columns;

    if (columns) {
      timeAxisColumn = me._timeAxisColumn = me.columns.getAt(timeAxisColumnIndex);

      // Set up event relaying early
      timeAxisColumn.relayAll(me);
    }
  }

  set eventCls(eventCls) {
    const me = this;

    me._eventCls = eventCls;
    if (!me.eventSelector) {
      me.eventSelector = `.${eventCls}-wrap`;
      me.unreleasedEventSelector = `${me.eventSelector}:not(.b-sch-released)`;
    }
    if (!me.eventInnerSelector) {
      me.eventInnerSelector = '.' + eventCls;
    }
  }

  get eventCls() {
    return this._eventCls;
  }

  set timeAxisViewModel(timeAxisViewModel) {
    const me = this,
      tavmListeners = {
        update: 'onTimeAxisViewModelUpdate',
        prio: 100,
        thisObj: me
      };

    if (me.partner && !timeAxisViewModel) {
      return;
    }

    if (timeAxisViewModel instanceof TimeAxisViewModel) {
      timeAxisViewModel.on(tavmListeners);
    } else {
      timeAxisViewModel = Object.assign(
        {
          mode: me._mode,
          snap: me.snap,
          forceFit: me.forceFit,
          timeAxis: me.timeAxis,
          listeners: tavmListeners
        },
        timeAxisViewModel
      );

      timeAxisViewModel = new TimeAxisViewModel(timeAxisViewModel);
    }

    me._timeAxisViewModel = timeAxisViewModel;
  }

  /**
   * The internal view model, describing the visual representation of the time axis.
   * @property {Scheduler.view.model.TimeAxisViewModel}
   * @readonly
   */
  get timeAxisViewModel() {
    if (!this._timeAxisViewModel) {
      this.timeAxisViewModel = null;
    }
    return this._timeAxisViewModel;
  }

  set timeAxis(timeAxis) {
    const me = this;

    if (me.partner && !timeAxis) {
      return;
    }

    me.timeAxisDetacher && me.timeAxisDetacher();

    if (!(timeAxis instanceof TimeAxis)) {
      timeAxis = ObjectHelper.assign(
        {
          viewPreset: me.viewPreset,
          autoAdjust: me.autoAdjustTimeAxis,
          mode: 'plain',
          weekStartDay: me.weekStartDay
        },
        timeAxis
      );

      if (me.startDate) {
        timeAxis.startDate = me.startDate;
      }
      if (me.endDate) {
        timeAxis.endDate = me.endDate;
      }

      if (me.workingTime) {
        me.applyWorkingTime(timeAxis);
      }

      timeAxis = new TimeAxis(timeAxis);
    }

    // Inform about reconfiguring the timeaxis, to allow users to react to start & end date changes
    me.timeAxisDetacher = timeAxis.on({
      thisObj: me,
      reconfigure({ config }) {
        /**
         * Fired when the timeaxis has changed, for example by zooming or configuring a new time span.
         * @event timeAxisChange
         * @param {Scheduler.view.Scheduler} source - This Scheduler
         * @param {Object} config Config object used to reconfigure the time axis.
         * @param {Date} config.start New start date (if supplied)
         * @param {Date} config.end New end date (if supplied)
         */
        me.trigger('timeAxisChange', { config });
      }
    });

    me._timeAxis = timeAxis;
  }

  get timeAxis() {
    if (!this._timeAxis) {
      this.timeAxis = null;
    }
    return this._timeAxis;
  }

  /**
   * Get/set working time. Assign `null` to stop using working time. See {@link #config-workingTime} config for details.
   * @property {Object}
   */
  set workingTime(config) {
    this._workingTime = config;

    if (!this.isConfiguring) {
      this.applyWorkingTime(this.timeAxis);
    }
  }

  get workingTime() {
    return this._workingTime;
  }

  // Translates the workingTime configs into TimeAxis#include rules, applies them and then refreshes the header and
  // redraws the events
  applyWorkingTime(timeAxis) {
    const me = this,
      config = me._workingTime;

    if (config) {
      let hour = null;
      // Only use valid values
      if (
        config.fromHour >= 0 &&
        config.fromHour < 24 &&
        config.toHour > config.fromHour &&
        config.toHour <= 24 &&
        config.toHour - config.fromHour < 24
      ) {
        hour = { from: config.fromHour, to: config.toHour };
      }

      let day = null;
      // Only use valid values
      if (
        config.fromDay >= 0 &&
        config.fromDay < 7 &&
        config.toDay > config.fromDay &&
        config.toDay <= 7 &&
        config.toDay - config.fromDay < 7
      ) {
        day = { from: config.fromDay, to: config.toDay };
      }

      if (hour || day) {
        timeAxis.include = {
          hour,
          day
        };
      } else {
        // No valid rules, restore timeAxis
        timeAxis.include = null;
      }
    } else {
      // No rules, restore timeAxis
      timeAxis.include = null;
    }

    if (me.rendered) {
      // Refreshing header, which also recalculate tickSize and header data
      me.timeAxisColumn.refreshHeader();
      // Update column lines
      if (me.features.columnLines) {
        me.features.columnLines.drawLines();
      }

      // Animate event changes
      me.refreshWithTransition();
    }
  }

  /**
   * Get/set startDate. Defaults to current date if none specified.
   *
   * **Note:** If you need to set start and end date at the same time, use {@link Scheduler.view.mixin.TimelineZoomable#function-setTimeSpan} method.
   * @property {Date}
   * @category Common
   */
  set startDate(date) {
    this.setStartDate(date);
  }

  /**
   * Sets the timeline start date.
   *
   * **Note:**
   * - If you need to set start and end date at the same time, use {@link Scheduler.view.mixin.TimelineZoomable#function-setTimeSpan} method.
   * - If keepDuration is false and new start date is greater than end date, it will throw an exception.
   *
   * @param {Date} date The new start date
   * @param {Boolean} keepDuration Pass `true` to keep the duration of the timeline ("move" the timeline),
   * `false` to change the duration ("resize" the timeline). Defaults to `true`.
   */
  setStartDate(date, keepDuration = true) {
    const me = this,
      ta = me._timeAxis || {},
      { startDate, endDate, mainUnit } = ta;

    if (me._timeAxis && endDate) {
      if (date) {
        let calcEndDate = endDate;

        if (keepDuration && startDate) {
          const diff = DateHelper.diff(startDate, endDate, mainUnit, true);
          calcEndDate = DateHelper.add(date, diff, mainUnit);
        }

        ta.setTimeSpan(date, calcEndDate);
      }
    } else {
      me._tempStartDate = date;
    }
  }

  get startDate() {
    const me = this;

    if (me._timeAxis) {
      return me._timeAxis.startDate;
    }

    return me._tempStartDate || new Date();
  }

  /**
   * Get/set endDate. Defaults to startDate + default span of the used ViewPreset.
   *
   * **Note:** If you need to set start and end date at the same time, use {@link Scheduler.view.mixin.TimelineZoomable#function-setTimeSpan} method.
   * @property {Date}
   * @category Common
   */
  set endDate(date) {
    this.setEndDate(date);
  }

  /**
   * Sets the timeline end date
   *
   * **Note:**
   * - If you need to set start and end date at the same time, use {@link Scheduler.view.mixin.TimelineZoomable#function-setTimeSpan} method.
   * - If keepDuration is false and new end date is less than start date, it will throw an exception.
   *
   * @param {Date} date The new end date
   * @param {Boolean} keepDuration Pass `true` to keep the duration of the timeline ("move" the timeline),
   * `false` to change the duration ("resize" the timeline). Defaults to `false`.
   */
  setEndDate(date, keepDuration = false) {
    const me = this,
      ta = me._timeAxis || {},
      { startDate, endDate, mainUnit } = ta;

    if (me._timeAxis && startDate) {
      if (date) {
        let calcStartDate = startDate;

        if (keepDuration && endDate) {
          const diff = DateHelper.diff(startDate, endDate, mainUnit, true);
          calcStartDate = DateHelper.add(date, -diff, mainUnit);
        }

        ta.setTimeSpan(calcStartDate, date);
      }
    } else {
      me._tempEndDate = date;
    }
  }

  get endDate() {
    const me = this;

    if (me._timeAxis) {
      return me._timeAxis.endDate;
    }

    return me._tempEndDate || DateHelper.add(me.startDate, me.viewPreset.defaultSpan, me.viewPreset.mainHeader.unit);
  }

  get features() {
    return super.features;
  }

  // add region resize by default
  set features(features) {
    features = features === true ? {} : features;

    if (!('regionResize' in features)) {
      features.regionResize = true;
    }

    super.features = features;
  }

  get eventStyle() {
    return this._eventStyle;
  }

  set eventStyle(style) {
    const me = this;

    me._eventStyle = style;

    if (me.rendered) {
      me.refreshWithTransition();
    }
  }

  get eventColor() {
    return this._eventColor;
  }

  set eventColor(color) {
    const me = this;

    me._eventColor = color;

    if (me.rendered) {
      me.refreshWithTransition();
    }
  }

  //endregion

  //region Event handlers

  onLocaleChange() {
    // Clear events in case they use date as part of displayed info
    //        this.currentOrientation.cache.clear();

    super.onLocaleChange();
    this.timeAxisColumn.refreshHeader();
  }

  /**
   * This is a template method called by Widget when the encapsulating Scheduler SubGrid size.
   * Width changes *might* affect the Scheduler SubGrid, and *that* will trigger its
   * handler below, if that is the case. Here, we are only interested in the height changing because the
   * encapsulating grid is what dictates the scrolling viewport height.
   * @param {HTMLElement} element
   * @param {Number} width
   * @param {Number} height
   * @param {Number} oldWidth
   * @param {Number} oldHeight
   * @private
   */
  onInternalResize(element, width, height, oldWidth, oldHeight) {
    // Cache before its updated by super call.
    const oldSchedulerBodyRect = this._bodyRectangle;

    super.onInternalResize(element, width, height, oldWidth, oldHeight);

    // The Scheduler (The Grid) dictates the viewport height.
    if (oldSchedulerBodyRect && height !== oldHeight) {
      this.onSchedulerViewportResize(
        oldSchedulerBodyRect.width,
        this.bodyContainer.offsetHeight,
        oldSchedulerBodyRect.width,
        oldSchedulerBodyRect.height
      );
    }
  }

  /**
   * This is an event handler triggered when the Scheduler SubGrid changes size.
   * Its height changes when content height changes, and that is not what we are
   * interested in here. If the *width* changes, that means the visible viewport
   * has changed size.
   * @param {HTMLElement} element
   * @param {Number} width
   * @param {Number} height
   * @param {Number} oldWidth
   * @param {Number} oldHeight
   * @private
   */
  onTimeAxisSubGridResize({ width, height, oldWidth, oldHeight }) {
    // The timeAxisSubGrid dictates the viewport width.
    if (width !== oldWidth) {
      const schedulerBodyRect = this._bodyRectangle;

      this.onSchedulerViewportResize(width, schedulerBodyRect.height, oldWidth, schedulerBodyRect.height);
    }
  }

  // Note: This function is throttled in construct(), since it will do a full redraw per call
  onSchedulerViewportResize(width, height, oldWidth, oldHeight) {
    const me = this,
      subGrid = me.timeAxisSubGrid;

    if (me.rendered) {
      me.currentOrientation.onViewportResize(width, height, oldWidth, oldHeight);

      // Ignore resize caused by toggling vertical scrollbar visibility, since those might otherwise lead to an
      // infinite loop when the difference between on/off causes horizontal scrolling to also toggle
      if (me._lastOverflow == null || me._lastOverflow === subGrid.overflowingHorizontally) {
        // Responding by triggering a layout in the same frame seems to trigger an infinite resize
        // loop when using ResizeObserver, so push the response out into the next frame.
        me.setTimeout(() => {
          me.timeAxisViewModel.availableSpace = me.isHorizontal ? subGrid.width : subGrid.height;
        }, 0);

        me.partneredWith &&
          !me.isSyncingFromPartner &&
          me.partneredWith.forEach((p) => {
            if (!p.isSyncingFromPartner) {
              p.isSyncingFromPartner = true;
              me.eachSubGrid((subGrid) => {
                const partnerSubGrid = p.subGrids[subGrid.region];

                // If there is a difference, sync the partner SubGrid state
                if (partnerSubGrid.width !== subGrid.width) {
                  if (subGrid.collapsed) {
                    partnerSubGrid.collapse();
                  } else {
                    if (partnerSubGrid.collapsed) {
                      partnerSubGrid.expand();
                    }
                    // When using flexed subgrid, make sure flex values has prio over width
                    if (subGrid.flex) {
                      // If flex values match, resize should be fine without changing anything
                      if (subGrid.flex !== partnerSubGrid.flex) {
                        partnerSubGrid.flex = subGrid.flex;
                      }
                    } else {
                      partnerSubGrid.width = subGrid.width;
                    }
                  }
                }
              });
              p.isSyncingFromPartner = false;
            }
          });
      }

      // NOTE: Moved out of the if-statement above since that prevented event from being triggered in all
      // scenarios where size has changed

      /**
       * Fired when the *scheduler* viewport (not the overall Scheduler element) changes size.
       * This happens when the grid changes height, or when the subgrid which encapsulates the
       * scheduler column changes width.
       * @event timelineViewportResize
       * @param {Common.widget.Widget} source - This Scheduler
       * @param {Number} width The new width
       * @param {Number} height The new height
       * @param {Number} oldWidth The old width
       * @param {Number} oldHeight The old height
       */
      me.trigger('timelineViewportResize', { width, height, oldWidth, oldHeight });

      me._lastOverflow = subGrid.overflowingHorizontally;
    }
  }

  onTimeAxisViewModelUpdate() {
    this.updateCanvasSize();

    if (this.isHorizontal) {
      // might also have changed total width of timeaxiscolumn, make sure scrollers are in sync
      // TODO: should this be detected by resizeobserver instead? but it is the actual column changing size and not the subgrid so might not make sense
      this.callEachSubGrid('refreshFakeScroll');
      this.refreshVirtualScrollbars();
    }
  }

  //endregion

  //region Mode

  get currentOrientation() {
    throw new Error('Implement in subclass');
  }

  // Horizontal is the default, overridden in scheduler
  get isHorizontal() {
    return true;
  }

  //endregion

  //region Canvases and elements

  get backgroundCanvas() {
    return this._backgroundCanvas;
  }

  get foregroundCanvas() {
    return this._foregroundCanvas;
  }

  get svgCanvas() {
    const me = this;
    if (!me._svgCanvas) {
      const svg = (me._svgCanvas = document.createElementNS('http://www.w3.org/2000/svg', 'svg'));
      me.foregroundCanvas.appendChild(svg);
      me.trigger('svgCanvasCreated');
    }
    return me._svgCanvas;
  }

  get timeAxisSubGridElement() {
    return this.timeAxisColumn && this.timeAxisColumn.subGridElement;
  }

  updateCanvasSize() {
    const me = this;

    if (me.isHorizontal) {
      if (me.backgroundCanvas) {
        me.backgroundCanvas.style.width = `${me.timeAxisViewModel.totalSize}px`;
      }

      me.foregroundCanvas.style.width = `${me.timeAxisViewModel.totalSize}px`;
    } else {
      if (me.backgroundCanvas) {
        me.backgroundCanvas.style.width = DomHelper.setLength(me.timeAxisColumn.width);
      }

      me.foregroundCanvas.style.width = DomHelper.setLength(me.timeAxisColumn.width);
    }
  }

  //endregion

  //region Grid overrides

  refresh(forceLayout = true, refreshMoreFn = null) {
    const me = this;

    if (me.rendered && !me.refreshSuspended) {
      if (me.hasVisibleEvents) {
        me.refreshRows(false, forceLayout);
        if (refreshMoreFn) {
          refreshMoreFn();
        }
      }
      // Even if there are no events in our timeline, Features
      // assume there will be a refresh event from the RowManager
      // after a refresh request so fire it here.
      else {
        me.rowManager.trigger('refresh');
      }
    }
  }

  render(element) {
    const me = this,
      schedulerEl = me.timeAxisSubGridElement;

    if (me.useBackgroundCanvas) {
      me._backgroundCanvas = DomHelper.createElement({
        className: 'b-sch-background-canvas',
        parent: schedulerEl,
        nextSibling: schedulerEl.firstElementChild
      });
    }

    const fgCanvas = (me._foregroundCanvas = DomHelper.createElement({
      className: 'b-sch-foreground-canvas',
      style: `font-size:${me.rowHeight - me.barMargin * 2}px`,
      parent: schedulerEl
    }));

    me.timeAxisSubGrid.insertRowsBefore = fgCanvas;

    super.render(element);
  }

  // TODO: refreshRows -> refresh in grid?
  refreshRows(returnToTop = false, reLayoutEvents = true) {
    const me = this;

    if (me.isConfiguring) {
      return;
    }

    me.currentOrientation.refreshRows(reLayoutEvents);

    super.refreshRows(returnToTop);
  }

  // TODO: Dont think we have this in grid any longer??
  reRender(skipPreRenderRefresh = false) {
    this.refreshFromRerender = true;
    super.reRender(skipPreRenderRefresh);
    this.initDomEvents();
  }

  //endregion

  //region Other

  getDateConstraints() {}

  // duration = false prevents transition
  runWithTransition(fn, duration) {
    const me = this;

    // Do not attempt to enter animating state if we are not visible
    if (me.isVisible) {
      // Allow calling with true/false to keep code simpler in other places
      if (duration == null || duration === true) {
        duration = this.transitionDuration;
      }

      // Ask Grid superclass to enter the animated state if requested and enabled.
      if (duration && me.enableEventAnimations) {
        me.isAnimating = true;
        me.setTimeout(me.exitTransition, duration);
      }
    }

    fn();
  }

  exitTransition() {
    this.isAnimating = false;
    this.trigger('transitionend');
  }

  /**
   * Refreshes the grid with transitions enabled.
   */
  refreshWithTransition(forceLayout) {
    this.runWithTransition(() => this.refresh(forceLayout));
  }

  /**
   * Returns an object representing the visible date range, with `startDate` and `endDate` properties
   * @return {Object} The date range
   * @return {Date} return.startDate Start date
   * @return {Date} return.endDate End date
   */
  getVisibleDateRange() {
    return this.currentOrientation.getVisibleDateRange();
  }
  //endregion
}
TimelineBase._$name = 'TimelineBase';

// extends locale from grid
//const locale = Object.assign(gridLocale, {
const locale$2 = {
  ExcelExporter: {
    'No resource assigned': 'No resource assigned'
  },

  ResourceInfoColumn: {
    eventCountText: function(data) {
      return data + ' event' + (data !== 1 ? 's' : '');
    }
  },

  Dependencies: {
    from: 'From',
    to: 'To',
    valid: 'Valid',
    invalid: 'Invalid',
    Checking: 'Checking…'
  },

  DependencyEdit: {
    From: 'From',
    To: 'To',
    Type: 'Type',
    Lag: 'Lag',
    'Edit dependency': 'Edit dependency',
    Save: 'Save',
    Delete: 'Delete',
    Cancel: 'Cancel',
    StartToStart: 'Start to Start',
    StartToEnd: 'Start to End',
    EndToStart: 'End to Start',
    EndToEnd: 'End to End'
  },

  EventEdit: {
    Name: 'Name',
    Resource: 'Resource',
    Start: 'Start',
    End: 'End',
    Save: 'Save',
    Delete: 'Delete',
    Cancel: 'Cancel',
    'Edit Event': 'Edit event'
  },

  Scheduler: {
    'Add event': 'Add event',
    'Delete event': 'Delete event',
    'Unassign event': 'Unassign event'
  },

  HeaderContextMenu: {
    pickZoomLevel: 'Zoom',
    activeDateRange: 'Date range',
    startText: 'Start date',
    endText: 'End date',
    todayText: 'Today'
  },

  EventFilter: {
    filterEvents: 'Filter tasks',
    byName: 'By name'
  },

  TimeRanges: {
    showCurrentTimeLine: 'Show current timeline'
  },

  PresetManager: {
    minuteAndHour: {
      topDateFormat: 'ddd MM/DD, hA'
    },
    hourAndDay: {
      topDateFormat: 'ddd MM/DD'
    },
    weekAndDay: {
      displayDateFormat: 'hh:mm A'
    }
  }
};

// cannot use Object.assign above in IE11. also dont want to have polyfill in locale
for (let i in locale$1) {
  locale$2[i] = locale$1[i];
}

LocaleManagerSingelton.registerLocale('En', { desc: 'English', locale: locale$2 });

/**
 * @module Scheduler/view/mixin/SchedulerDom
 */

/**
 * Mixin with EventModel and ResourceModel <-> HTMLElement mapping functions
 *
 * @mixin
 */
var SchedulerDom = (Target) =>
  class SchedulerDom extends (Target || Base) {
    //region Get

    /**
     * Returns a single HTMLElement representing an event record assigned to a specific resource.
     * @param {Scheduler.model.AssignmentModel} assignmentRecord An assignment record
     * @return {HTMLElement} The element representing the event record
     */
    getElementFromAssignmentRecord(assignmentRecord) {
      return this.currentOrientation.getElementFromEventRecord(assignmentRecord.event, assignmentRecord.resource);
    }

    /**
     * Returns a single HTMLElement representing an event record assigned to a specific resource.
     * @param {Scheduler.model.EventModel} eventRecord An event record
     * @param {Scheduler.model.ResourceModel} resourceRecord A resource record
     * @return {HTMLElement} The element representing the event record
     */
    getElementFromEventRecord(eventRecord, resourceRecord) {
      return this.currentOrientation.getElementFromEventRecord(eventRecord, resourceRecord);
    }

    /**
     * Returns all the HTMLElements representing an event record.
     *
     * @param {Scheduler.model.EventModel} eventRecord An event record
     * @param {Scheduler.model.ResourceModel} [resourceRecord] A resource record
     *
     * @return {HTMLElement[]} The element(s) representing the event record
     */
    getElementsFromEventRecord(eventRecord, resourceRecord) {
      return this.currentOrientation.getElementsFromEventRecord(eventRecord, resourceRecord);
    }

    /**
     * Returns the event id for a DOM id
     * @private
     * @param {String} id The id of the DOM node
     * @return {String} An event record (internal) id
     */
    getEventIdFromDomNodeId(id) {
      const eventId = id.substring(this.eventPrefix.length).split('-')[0];

      // id format is "PREFIX"-eventid-resourceid[-part]
      // do not want - from other sources in it, replace with ._.
      // TODO: come up with something risk free
      return eventId && eventId.replace(/\._\./g, '-');
    }

    /**
     * Returns the event record for a DOM id
     * @param {String} id The id of the DOM node
     * @return {Scheduler.model.EventModel} The event record
     */
    getEventRecordFromDomId(id) {
      id = this.getEventIdFromDomNodeId(id);
      return this.eventStore.getById(id);
    }

    /**
     * Returns a resource id for a DOM id
     * @private
     * @param {String} id An id of an event DOM node
     * @return {String} A resource record (internal) id
     */
    getResourceIdFromDomNodeId(id) {
      const eventId = id.substring(this.eventPrefix.length).split('-')[1];

      // id format is "PREFIX"-eventid-resourceid[-part]
      // do not want - from other sources in it, replace with ._.
      // TODO: come up with something risk free
      return eventId && eventId.replace(/\._\./g, '-');
    }

    /**
     * Returns a resource record for a DOM id
     * @param {String} id An id of an event DOM node
     * @return {Scheduler.model.ResourceModel} A resource record
     */
    getResourceRecordFromDomId(id) {
      id = this.getResourceIdFromDomNodeId(id);
      return this.resourceStore.getById(id);
    }

    //endregion

    //region Resolve

    /**
     * Resolves the resource based on a dom element or event. In vertical mode, if resolving from an element higher up in
     * the hierarchy than event elements, then it is required to supply an coordinates since resources are virtual
     * columns.
     * @param {HTMLElement|Event} elementOrEvent The HTML element or DOM event to resolve a resource from
     * @param {Number[]} [xy] X and Y coordinates, required in some cases in vertical mode, disregarded in horizontal
     * @return {Scheduler.model.ResourceModel} The resource corresponding to the element, or null if not found.
     */
    resolveResourceRecord(elementOrEvent, xy) {
      return this.currentOrientation.resolveRowRecord(elementOrEvent, xy);
    }

    /**
     * Returns the event record for a DOM element
     * @param {HTMLElement} element The DOM node to lookup
     * @return {Scheduler.model.EventModel} The event record
     */
    resolveEventRecord(element) {
      element = DomHelper.up(element, this.eventSelector);

      if (element) {
        if (element.dataset.eventId) {
          return this.eventStore.getById(element.dataset.eventId);
        }

        if (element.dataset.assignmentId) {
          return this.assignmentStore.getById(element.dataset.assignmentId).event;
        }
      }

      return null;
    }

    // Used by shared features to resolve an event or task
    resolveTimeSpanRecord(element) {
      return this.resolveEventRecord(element);
    }

    /**
     * Returns an assignment record for a DOM element
     * @param {HTMLElement} element The DOM node to lookup
     * @return {Scheduler.model.AssignmentModel} The assignment record
     */
    resolveAssignmentRecord(element) {
      const { assignmentStore } = this.eventStore;

      let assignment = null;

      if (assignmentStore) {
        const eventElement = DomHelper.up(element, this.eventSelector),
          event = this.resolveEventRecord(eventElement),
          resource = this.resolveResourceRecord(eventElement);

        if (event && resource) {
          assignment = assignmentStore.getAssignmentForEventAndResource(event, resource);
        }
      }

      return assignment;
    }

    //endregion

    // Decide if a record is inside a collapsed tree node, or inside a collapsed group (using grouping feature)
    isRowVisible(resourceRecord) {
      // records in collapsed groups/brances etc are removed from processedRecords
      return this.store.indexOf(resourceRecord) >= 0;
    }

    /**
     * Determines width of a milestones label. How width is determined is decided by configuring Scheduler#milestoneLayoutMode.
     * Please note that currently text width is always determined using EventModel#name.
     * @param {Scheduler.model.EventModel} eventRecord
     * @returns {Number}
     */
    getMilestoneLabelWidth(eventRecord) {
      const me = this,
        mode = me.milestoneLayoutMode;

      if (mode === 'measure') {
        const element =
          me.milestoneMeasureElement ||
          (me.milestoneMeasureElement = DomHelper.createElement({
            className: 'b-sch-event-wrap b-milestone-wrap b-measure',
            children: [
              {
                className: 'b-sch-event b-milestone',
                html: `<label></label>`
              }
            ],
            parent: me.foregroundCanvas
          }));

        element.firstElementChild.firstElementChild.innerHTML = eventRecord.name;

        return element.offsetWidth;
      }

      if (mode === 'estimate') {
        return Math.max(eventRecord.name.length * me.milestoneCharWidth, me.milestoneMinWidth);
      }

      if (mode === 'data') {
        return Math.max(eventRecord.milestoneWidth, me.milestoneMinWidth);
      }

      return 0;
    }

    set milestoneLayoutMode(mode) {
      const me = this;

      me._milestoneLayoutMode = mode;

      me.element.classList[mode !== 'default' ? 'add' : 'remove']('b-sch-layout-milestones');
      me.refresh();
    }

    get milestoneLayoutMode() {
      return this._milestoneLayoutMode;
    }

    set milestoneAlign(align) {
      this._milestoneAlign = align;

      this.refresh();
    }

    get milestoneAlign() {
      return this._milestoneAlign;
    }

    set milestoneCharWidth(width) {
      this._milestoneCharWidth = width;

      this.refresh();
    }

    get milestoneCharWidth() {
      return this._milestoneCharWidth;
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Scheduler/view/mixin/SchedulerDomEvents
 */

/**
 * Mixin that handles dom events (click etc) for scheduler and rendered events.
 *
 * @mixin
 */
var SchedulerDomEvents = (Target) =>
  class SchedulerDomEvents extends (Target || Base) {
    //region Events

    /**
     * Triggered when user clicks an empty area in the schedule.
     * @event scheduleClick
     * @param {Scheduler.view.TimelineBase} source This TimelineBase
     * @param {Date} date Date at mouse position
     * @param {Grid.row.Row} row Clicked row
     * @param {Number} index Index of clicked resource
     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered when user clicks an empty area in the schedule.
     * @event scheduleDblClick
     * @param {Scheduler.view.TimelineBase} source This TimelineBase
     * @param {Date} date Date at mouse position
     * @param {Grid.row.Row} row Double clicked row
     * @param {Number} index Index of double clicked resource
     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered when user right clicks an empty area in the schedule.
     * @event scheduleContextMenu
     * @param {Scheduler.view.TimelineBase} source This TimelineBase
     * @param {Date} date Date at mouse position
     * @param {Grid.row.Row} row Clicked row
     * @param {Number} index Index of clicked resource
     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered for mouse down on an event.
     * @event eventMouseDown
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.EventModel} eventRecord Event record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered for mouse up on an event.
     * @event eventMouseUp
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.EventModel} eventRecord Event record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered for click on an event.
     * @event eventClick
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.EventModel} eventRecord Event record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered for double click on an event.
     * @event eventDblClick
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.EventModel} eventRecord Event record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered for right click on an event.
     * @event eventContextMenu
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.EventModel} eventRecord Event record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered for mouse over on an event.
     * @event eventMouseOver
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.EventModel} eventRecord Event record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered for mouse out from an event.
     * @event eventMouseOut
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.EventModel} eventRecord Event record
     * @param {MouseEvent} event Browser event
     */

    //endregion

    //region Event handling

    getTimeSpanMouseEventParams(eventElement, event) {
      return {
        eventRecord: this.resolveEventRecord(eventElement),
        resourceRecord: this.resolveResourceRecord(eventElement),
        assignmentRecord: this.resolveAssignmentRecord(eventElement),
        eventElement,
        event
      };
    }

    getScheduleMouseEventParams(cellData, event) {
      const resourceRecord = this.isVertical ? this.resolveResourceRecord(event) : this.store.getById(cellData.id);

      return {
        resourceRecord
      };
    }

    /**
     * Relays keydown events as eventkeydown if we have a selected task.
     * @private
     */
    onElementKeyDown(event) {
      super.onElementKeyDown(event);

      const me = this;

      if (me.selectedEvents.length) {
        me.trigger(me.scheduledEventName + 'KeyDown', { eventRecord: me.selectedEvents });
      }
    }

    /**
     * Relays keyup events as eventkeyup if we have a selected task.
     * @private
     */
    onElementKeyUp(event) {
      super.onElementKeyUp(event);

      const me = this;

      if (me.selectedEvents.length) {
        me.trigger(me.scheduledEventName + 'KeyUp', { eventRecord: me.selectedEvents });
      }
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Scheduler/view/mixin/SchedulerDragResize
 */

/**
 * Mixin for triggering event editor on drag creation etc.
 * @private
 * @mixin
 */
var SchedulerDragResize = (Target) =>
  class SchedulerDragResize extends (Target || Base) {
    construct(config) {
      const me = this;

      super.construct(config);

      if (me.hasFeature('eventDragCreate')) {
        me.on({
          dragcreateend: me.internalOnDragCreateEnd,
          thisObj: me
        });
      }
    }

    internalOnDragCreateEnd({ newEventRecord: eventRecord, resourceRecord }) {
      const me = this;

      // If an event editor is defined, it has to manage how/if/when the event is added to the event store
      if (!me.eventEdit) {
        const resourceRecords = resourceRecord ? [resourceRecord] : [];

        // resources **Deprecated** Use `resourceRecords` instead
        if (me.trigger('beforeEventAdd', { eventRecord, resourceRecords, resources: resourceRecords }) !== false) {
          me.onEventCreated(eventRecord);
          me.eventStore.add(eventRecord);

          eventRecord.assign(resourceRecord);
        }
      }
    }

    // Empty but provided so that you can override it to supply default record values etc.
    onEventCreated(newEventRecord) {}

    get eventEditor() {
      return this._eventEditor;
    }

    set eventEditor(editor) {
      this._eventEditor = editor;
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Scheduler/eventlayout/HorizontalLayout
 */

/**
 * Base class for HorizontalLayoutPack & HorizontalLayoutStack. Should not be used directly, instead specify
 * {@link Scheduler.view.mixin.SchedulerEventRendering#config-eventLayout} in Scheduler config (stack, pack or none):
 * @example
 * let scheduler = new Scheduler({
 *   eventLayout: 'stack'
 * });
 * @abstract
 * @private
 */
class HorizontalLayout extends Base {
  static get defaultConfig() {
    return {
      nbrOfBandsByResource: {},
      bandIndexToPxConvertFn: null,
      bandIndexToPxConvertThisObj: null
    };
  }

  clearCache(resource) {
    if (resource) {
      delete this.nbrOfBandsByResource[resource.id];
    } else {
      this.nbrOfBandsByResource = {};
    }
  }

  // Input:
  // 1. Resource record
  // 2. Array of Event models, or a function to call to receive such event records lazily
  getNumberOfBands(resource, resourceEventsOrFn) {
    const nbrOfBandsByResource = this.nbrOfBandsByResource;

    if (nbrOfBandsByResource.hasOwnProperty(resource.id)) {
      return nbrOfBandsByResource[resource.id];
    }

    const resourceEvents = typeof resourceEventsOrFn === 'function' ? resourceEventsOrFn() : resourceEventsOrFn,
      eventsData = resourceEvents.map((event) => ({
        start: event.startDate,
        end: event.endDate,
        event: event
      }));

    return this.applyLayout(eventsData, resource);
  }

  // TODO DOC
  applyLayout(events, resource) {
    const rowEvents = events.slice(),
      // return a number of bands required
      newNbrBands = this.layoutEventsInBands(rowEvents);

    return (this.nbrOfBandsByResource[resource.id] = newNbrBands);
  }
}
HorizontalLayout._$name = 'HorizontalLayout';

/**
 * @module Scheduler/eventlayout/HorizontalLayoutStack
 */

/**
 * Handles layout of events within a row (resource) in horizontal mode. Stacks events, increasing row height when to fit
 * all overlapping events.
 *
 * This layout is used by default in horizontal mode.
 *
 * @extends Scheduler/eventlayout/HorizontalLayout
 * @private
 */
class HorizontalLayoutStack extends HorizontalLayout {
  // Input: Array of event layout data
  layoutEventsInBands(events) {
    let verticalPosition = 0;

    do {
      let event = events[0];

      while (event) {
        // Apply band height to the event cfg
        event.top = this.bandIndexToPxConvertFn.call(
          this.bandIndexToPxConvertThisObj || this,
          verticalPosition,
          event.event
        );

        // Remove it from the array and continue searching
        events.splice(events.indexOf(event), 1);

        event = this.findClosestSuccessor(event, events);
      }

      verticalPosition++;
    } while (events.length > 0);

    // Done!
    return verticalPosition;
  }

  // TODO: optimize this for better performance with many events per resource
  findClosestSuccessor(eventRenderData, events) {
    let minGap = Infinity,
      closest,
      eventEnd = eventRenderData.endMs,
      gap,
      isMilestone = eventRenderData.event.duration === 0,
      evt;

    for (let i = 0, l = events.length; i < l; i++) {
      evt = events[i];
      gap = evt.startMs - eventEnd;

      if (
        gap >= 0 &&
        gap < minGap &&
        // Two milestones should not overlap
        (gap > 0 || evt.endMs - evt.startMs > 0 || !isMilestone)
      ) {
        closest = evt;
        minGap = gap;
      }
    }
    return closest;
  }
}
HorizontalLayoutStack._$name = 'HorizontalLayoutStack';

/**
 * @module Scheduler/eventlayout/PackMixin
 */

/**
 * Mixin holding functionality shared between HorizontalLayoutPack and VerticalLayout.
 *
 * @mixin
 * @private
 */
var PackMixin = (Target) =>
  class PackMixin extends (Target || Base) {
    static get defaultConfig() {
      return {
        coordProp: 'top',
        sizeProp: 'height'
      };
    }

    // Packs the events to consume as little space as possible
    applyLayout(events, applyClusterFn) {
      const me = this,
        { coordProp, sizeProp } = me;

      let slot, firstInCluster, cluster, j;

      for (let i = 0, l = events.length; i < l; i++) {
        firstInCluster = events[i];

        slot = me.findStartSlot(events, firstInCluster);

        cluster = me.getCluster(events, i);

        if (cluster.length > 1) {
          firstInCluster[coordProp] = slot.start;
          firstInCluster[sizeProp] = slot.end - slot.start;

          // If there are multiple slots and events in the cluster have multiple start dates, group all same-start events into first slot
          j = 1;

          while (j < cluster.length - 1 && cluster[j + 1].start - firstInCluster.start === 0) {
            j++;
          }

          // See if there's more than 1 slot available for this cluster, if so - first group in cluster consumes the entire first slot
          const nextSlot = me.findStartSlot(events, cluster[j]);

          if (nextSlot && nextSlot.start < 0.8) {
            cluster.length = j;
          }
        }

        const clusterSize = cluster.length,
          slotSize = (slot.end - slot.start) / clusterSize;

        // Apply fraction values
        for (j = 0; j < clusterSize; j++) {
          applyClusterFn(cluster[j], j, slot, slotSize);
        }

        i += clusterSize - 1;
      }
    }

    findStartSlot(events, event) {
      const { sizeProp, coordProp } = this,
        priorOverlappers = this.getPriorOverlappingEvents(events, event);

      let i;

      if (priorOverlappers.length === 0) {
        return {
          start: 0,
          end: 1
        };
      }

      for (i = 0; i < priorOverlappers.length; i++) {
        if (i === 0 && priorOverlappers[0][coordProp] > 0) {
          return {
            start: 0,
            end: priorOverlappers[0][coordProp]
          };
        } else if (
          priorOverlappers[i][coordProp] + priorOverlappers[i][sizeProp] <
          (i < priorOverlappers.length - 1 ? priorOverlappers[i + 1][coordProp] : 1)
        ) {
          return {
            start: priorOverlappers[i][coordProp] + priorOverlappers[i][sizeProp],
            end: i < priorOverlappers.length - 1 ? priorOverlappers[i + 1][coordProp] : 1
          };
        }
      }

      return false;
    }

    getPriorOverlappingEvents(events, event) {
      const start = event.start,
        end = event.end,
        overlappers = [];

      for (let i = 0, l = events.indexOf(event); i < l; i++) {
        if (DateHelper.intersectSpans(start, end, events[i].start, events[i].end)) {
          overlappers.push(events[i]);
        }
      }

      overlappers.sort(this.sortOverlappers.bind(this));

      return overlappers;
    }

    sortOverlappers(e1, e2) {
      return e1[this.coordProp] < e2[this.coordProp] ? -1 : 1;
    }

    getCluster(events, startIndex) {
      const startEvent = events[startIndex];

      if (startIndex >= events.length - 1) {
        return [startEvent];
      }

      const evts = [startEvent],
        l = events.length;

      let { start, end } = startEvent,
        i = startIndex + 1;

      while (i < l && DateHelper.intersectSpans(start, end, events[i].start, events[i].end)) {
        evts.push(events[i]);
        start = DateHelper.max(start, events[i].start);
        end = DateHelper.min(events[i].end, end);
        i++;
      }

      return evts;
    }
  };

/**
 * @module Scheduler/eventlayout/HorizontalLayoutPack
 */

/**
 * Handles layout of events within a row (resource) in horizontal mode. Packs events (adjusts their height) to fit
 * available row height
 *
 * @extends Scheduler/eventlayout/HorizontalLayout
 * @mixes Scheduler/eventlayout/PackMixin
 * @private
 */
class HorizontalLayoutPack extends PackMixin(HorizontalLayout) {
  // Packs the events to consume as little space as possible
  applyLayout(events) {
    super.applyLayout(events, (event, j, slot, slotSize) => {
      event.height = slotSize;
      event.top = slot.start + j * slotSize;
    });

    events.forEach((event) => {
      Object.assign(
        event,
        this.bandIndexToPxConvertFn.call(
          this.bandIndexToPxConvertThisObj || this,
          event.top,
          event.height,
          null,
          event.event
        )
      );
    });
  }
}
HorizontalLayoutPack._$name = 'HorizontalLayoutPack';

/**
 * @module Scheduler/view/mixin/SchedulerEventRendering
 */

const hyphenRe = /-/g;

/**
 * Functions to handle event rendering (EventModel -> dom elements).
 *
 * @mixin
 */
var SchedulerEventRendering = (Target) =>
  class SchedulerEventRendering extends (Target || Base) {
    //region Default config

    static get defaultConfig() {
      return {
        /**
         * An empty function by default, but provided so that you can override it. This function is called each time
         * an event is rendered into the schedule to render the contents of the event. It's called with the event,
         * its resource and a tplData object which allows you to populate data placeholders inside the event
         * template. **IMPORTANT** You should never modify any data on the EventModel inside this method.
         * By default, the DOM markup of an event bar includes placeholders for 'cls' and 'style'. The cls property is a
         * {@link Common.helper.util.DomClassList} which will be added to the event element. The style property is an inline style declaration for
         * the event element.
         *
         * ```javascript
         * eventRenderer({eventRecord, resourceRecord, tplData}) {
         *   tplData.style = 'color:white';                 // You can use inline styles too.
         *
         *   // Property names with truthy values are added to the resulting elements CSS class.
         *   tplData.cls.isImportant = this.isImportant(eventRecord);
         *   tplData.cls.isModified = eventRecord.isModified;
         *
         *   // Remove a class name by setting the property to false
         *   tplData.cls[scheduler.generatedIdCls] = false;
         *
         *   // Or, you can treat it as a string, but this is less efficient, especially
         *   // if your renderer wants to *remove* classes that may be there.
         *   tplData.cls += ' extra-class'
         *
         *   return DateHelper.format(eventRecord.startDate, 'YYYY-MM-DD') + ': ' + eventRecord.name;
         * }
         * ```
         *
         * @param {Object} detail An object containing the information needed to render an Event.
         * @param {Scheduler.model.EventModel} detail.eventRecord The event record.
         * @param {Scheduler.model.ResourceModel} detail.resourceRecord The resource record.
         * @param {Scheduler.model.AssignmentModel} detail.assignmentRecord The assignment record, if using an AssignmentStore.
         * @param {Object} detail.tplData An object containing details about the event rendering.
         * @param {Scheduler.model.EventModel} detail.tplData.event The event record.
         * @param {Common.helper.util.DomClassList} detail.tplData.cls An object whose property names represent the CSS class names
         * to be added to the event's element. Set a property's value to truthy or falsy to add or remove the class
         * name based on the property name. Using this technique, you do not have to know whether the class is already
         * there, or deal with concatenation.
         * @param {Common.helper.util.DomClassList} detail.tplData.iconCls An object whose property names represent the CSS class
         * names to be added to an event icon element.
         * @param {Number} detail.tplData.left Vertical offset position (in pixels) on the time axis.
         * @param {Number} detail.tplData.width Width in pixels of the event element.
         * @param {Number} detail.tplData.height Height in pixels of the event element.
         * @param {String} detail.tplData.eventStyle The `eventStyle` of the event. Use this to apply custom styles to the event DOM element
         * @param {String} detail.tplData.eventColor The `eventColor` of the event. Use this to set a custom color for the rendererd event
         * @returns {String|Object} A simple string, or a custom object which will be applied to the {@link #config-eventBodyTemplate}, creating the actual HTML
         * @config {function}
         * @category Scheduled events
         */
        eventRenderer: null,

        /**
         * `this` reference for the {@link #config-eventRenderer} function
         * @config {Object}
         * @category Scheduled events
         */
        eventRendererThisObj: null,

        eventPrefix: '',

        /**
         * How to handle overlapping events. Valid values are:
         * - stack, adjusts row height (only horizontal)
         * - pack, adjusts event height
         * - mixed, allows two events to overlap, more packs (only vertical)
         * - none, allows events to overlap
         * @config {String}
         * @default
         * @category Scheduled events
         */
        eventLayout: 'stack',

        /**
         * The class responsible for the packing horizontal event layout process.
         * Override this to take control over the layout process.
         * @config {Scheduler.eventlayout.HorizontalLayout}
         * @default
         * @private
         * @category Misc
         */
        horizontalLayoutPackClass: HorizontalLayoutPack,

        /**
         * The class name responsible for the stacking horizontal event layout process.
         * Override this to take control over the layout process.
         * @config {Scheduler.eventlayout.HorizontalLayout}
         * @default
         * @private
         * @category Misc
         */
        horizontalLayoutStackClass: HorizontalLayoutStack,

        /**
         * Override this method to provide a custom sort function to sort any overlapping events. By default,
         * overlapping events are laid out based on the start date. If the start date is equal, events with earlier
         * end date go first.
         *
         * Here's a sample sort function, sorting on start- and end date. If this function returns -1, then event a
         * is placed above event b.
         * ```javascript
         * horizontalEventSorterFn(a, b) {
         *
         *   let startA = a.startDate, endA = a.endDate;
         *   let startB = b.startDate, endB = b.endDate;
         *
         *   let sameStart = (startA - startB === 0);
         *
         *   if (sameStart) {
         *     return endA > endB ? -1 : 1;
         *   } else {
         *     return (startA < startB) ? -1 : 1;
         *   }
         * }
         * ```
         * @param  {Scheduler.model.EventModel} a
         * @param  {Scheduler.model.EventModel} b
         * @return {Number}
         * @config {function}
         * @category Misc
         */
        horizontalEventSorterFn: null,

        /**
         * Field from EventModel displayed as text in the bar when rendering
         * @config {String}
         * @default
         * @category Scheduled events
         */
        eventBarTextField: 'name',

        /**
         * The template used to generate the markup of your events in the scheduler. To 'populate' the
         * eventBodyTemplate with data, use the {@link #config-eventRenderer} method
         * @config {function}
         * @category Scheduled events
         */
        eventBodyTemplate: null,

        eventPositionMode: 'translate',
        eventScrollMode: 'move',

        /**
         * Specify `true` to force rendered events to fill entire ticks. This only affects rendering, events retain
         * their set start and end dates on the data level. When enabling this config you should probably also
         * disable EventDrag and EventResize, otherwise their behaviour will not be what a user expects.
         * @config {Boolean}
         * @default
         * @category Scheduled events
         */
        fillTicks: false,

        /**
         * By default scheduler fades events in on load. Specify `false` to prevent this animation or specify one
         * of the available animation types to use it (`true` equals `'fade-in'`):
         * * fade-in (default)
         * * slide-from-left
         * * slide-from-top
         * ```
         * // Slide events in from the left on load
         * scheduler = new Scheduler({
         *     useInitialAnimation : 'slide-from-left'
         * });
         * ```
         * @config {Boolean|String}
         * @default
         * @category Misc
         */
        useInitialAnimation: true,

        /**
         * A config object used to configure the resource columns in vertical mode.
         * See {@link Scheduler.view.ResourceHeader} for more details on available properties.
         *
         * ```
         * new Scheduler({
         *   resourceColumns : {
         *     columnWidth : 100,
         *     headerRenderer({ resourceRecord }) => `${resourceRecord.id} - ${resourceRecord.name}`
         *   }
         * })
         * ```
         * @config {Object}
         * @category Resources
         */
        resourceColumns: null,

        /**
         * Path to load resource images from. Used by the resource header in vertical mode and the
         * {@link Scheduler.column.ResourceInfoColumn} in horizontal mode. Set this to display miniature
         * images for each resource using their 'imageUrl` field. If set and a resource has not `imageUrl` specified
         * it will try using the resources name with `.jpg` appended.
         *
         * **NOTE**: The path should end with a `/`:
         *
         * ```
         * new Scheduler({
         *   resourceImagePath : 'images/resources/'
         * });
         * ```
         * @config {String}
         * @category Resources
         */
        resourceImagePath: null,

        /**
         * Generic resource image, used when `imageUrl` or `name.jpg` for a resource is invalid
         * @config {String}
         * @category Resources
         */
        defaultResourceImageName: 'none.png',

        /**
         * Control how much space to leave between the first event/last event and the resources edge (top/bottom
         * margin within the resource row in horizontal mode, left/right margin within the resource column in
         * vertical mode), in px. Defaults to the value of {@link Scheduler.view.mixin.TimelineEventRendering#config-barMargin}.
         * @config {Number}
         * @category Scheduled events
         */
        resourceMargin: null,

        // Used to animate events on first render
        isFirstRender: true
      };
    }

    //endregion

    //region Init

    get eventPrefix() {
      return this._eventPrefix;
    }

    set eventPrefix(eventPrefix) {
      this._eventPrefix = eventPrefix || this.id + '-';
    }

    //endregion

    //region Settings

    get layouts() {
      const me = this;

      if (!me._eventLayout) {
        me._eventLayout = {};

        // pack, fit all events in available height by adjusting their height
        if (me.horizontalLayoutPackClass) {
          me._eventLayout.horizontalPack = new me.horizontalLayoutPackClass(
            Object.assign(
              // this is required for table layout
              {
                scheduler: me,
                timeAxisViewModel: me.timeAxisViewModel,
                bandIndexToPxConvertFn: me.horizontal.layoutEventVerticallyPack,
                bandIndexToPxConvertThisObj: me.horizontal
              },
              me.horizontalEventSorterFn ? { sortEvents: this.horizontalEventSorterFn } : {}
            )
          );
        }

        // stack, adjust row height to fit all events
        if (me.horizontalLayoutStackClass) {
          me._eventLayout.horizontalStack = new me.horizontalLayoutStackClass(
            Object.assign(
              // this is required for table layout
              {
                scheduler: me,
                timeAxisViewModel: me.timeAxisViewModel,
                bandIndexToPxConvertFn: me.horizontal.layoutEventVerticallyStack,
                bandIndexToPxConvertThisObj: me.horizontal
              },
              me.horizontalEventSorterFn ? { sortEvents: this.horizontalEventSorterFn } : {}
            )
          );
        }
      }

      return me._eventLayout;
    }

    /**
     * Get/set overlap mode. See config, valid values are stack (horizontal), pack, mixed (vertical) and none
     * @property {String}
     * @category Scheduled events
     */
    get eventLayout() {
      return this._overlapMode;
    }

    set eventLayout(eventLayout) {
      const me = this;

      if (eventLayout != me._overlapMode) {
        me.element.classList.remove(`b-eventlayout-${me._overlapMode}`);
        me._overlapMode = eventLayout;

        me.runWithTransition(() => {
          me.element.classList.add(`b-eventlayout-${me._overlapMode}`);
          me.refresh();
        });
      }
    }

    /**
     * Get/set fillTicks setting. If set to true it forces the rendered events to fill entire ticks.
     * @property {String}
     * @category Scheduled events
     */
    get fillTicks() {
      return this._fillTicks;
    }

    set fillTicks(fill) {
      const me = this;

      if (fill != me._fillTicks) {
        me._fillTicks = fill;
        me.refreshWithTransition();
      }
    }

    /**
     * Control how much space to leave between the first event/last event and the resources edge (top/bottom margin within
     * the resource row in horizontal mode, left/right margin within the resource column in vertical mode),
     * in px. Defaults to the value of {@link Scheduler.view.mixin.TimelineEventRendering#config-barMargin}.
     * @member {Number} resourceMargin
     * @category Scheduled events
     */

    /**
     * Gets currently used event layout class. The event layout class decides the vertical placement of the events
     * within a resource. Returns null if no eventLayout is used (if Scheduler#eventLayout is set to "none")
     * @internal
     * @returns {*}
     * @readonly
     * @category Scheduled events
     */
    get currentEventLayout() {
      const me = this;

      if (!me.isHorizontal) return null;

      switch (me.eventLayout) {
        case 'stack':
          return me.layouts.horizontalStack;
        case 'pack':
          return me.layouts.horizontalPack;
        default:
          return null;
      }
    }

    get useInitialAnimation() {
      return this._useInitialAnimation;
    }

    set useInitialAnimation(name) {
      const me = this;

      if (me._useInitialAnimation) {
        me.element.classList.remove(`b-initial-${me._useInitialAnimation}`);
      }

      me._useInitialAnimation = name === true ? 'fade-in' : name;

      if (name) {
        me.element.classList.add(`b-initial-${me._useInitialAnimation}`);
      }
    }

    set isFirstRender(value) {
      const me = this;

      me._isFirstRender = value;

      if (!me._firstRenderDone && value) {
        me._firstRenderDone = me.createOnFrame(() => {
          me._isFirstRender = false;
          me._firstRenderDone = null;
        });
      }
    }

    get isFirstRender() {
      return this._isFirstRender;
    }
    //endregion

    //region Resource header/columns

    // NOTE: The configs below are initially applied to the resource header in `TimeAxisColumn#set mode`

    set resourceColumns(config) {
      this._resourceColumns = config;
    }

    /**
     * Use it to manipulate resource column properties at runtime.
     * @property {Scheduler.view.ResourceHeader}
     * @readonly
     */
    get resourceColumns() {
      return (this.timeAxisColumn && this.timeAxisColumn.resourceColumns) || this._resourceColumns;
    }

    /**
     * Get resource column width. Only applies to vertical mode. To set it, assign to
     * `scheduler.resourceColumns.columnWidth`.
     * @property {Number}
     * @readonly
     */
    get resourceColumnWidth() {
      return this.resourceColumns ? this.resourceColumns.columnWidth : null;
    }

    //endregion

    //region Event rendering

    // Chainable function called with the events to render for a specific resource. Allows features to add/remove.
    // Chained by ResourceTimeRanges
    getEventsToRender(resource, events) {
      return events;
    }

    /**
     * Rerenders events for specified resource (by rerendering the entire row).
     * @param {Scheduler.model.ResourceModel} resourceRecord
     */
    repaintEventsForResource(resourceRecord /*, refreshSelections*/) {
      const me = this;

      if (me.isHorizontal) {
        me.currentOrientation.cache.clearRow(resourceRecord.id);

        const row = me.getRowFor(resourceRecord);
        if (row) {
          // Update the affected row, if it changes height RowManger will take care of translating the rest of the rows
          row.render();
        }
      }

      // TODO: PORT selection model not ported yet
      // if (refreshSelections) {
      //     const sm     = me.getEventSelectionModel(),
      //           events = me.getEventStore().getEventsForResource(resourceRecord);
      //
      //     events.forEach(ev =>
      //         sm.forEachEventRelatedSelection(ev, selectedRecord =>
      //             me.onEventBarSelect(selectedRecord, true)
      //         )
      //     );
      // }
    }

    /**
     * Rerenders the events for all resources connected to the specified event
     * @param {Scheduler.model.EventModel} eventRecord
     * @private
     */
    repaintEvent(eventRecord) {
      const resources = this.eventStore.getResourcesForEvent(eventRecord);
      resources.forEach((resourceRecord) => this.repaintEventsForResource(resourceRecord));
    }

    //endregion

    //region Template

    /**
     * Generates data used in the template when rendering an event. For example which css classes to use. Also applies
     * #eventBodyTemplate and calls the {@link #config-eventRenderer}.
     * @private
     * @param {Scheduler.model.EventModel} eventRecord Event to generate data for
     * @param {Scheduler.model.ResourceModel} resourceRecord Events resource
     * @returns {Object} Data to use in event template, or `undefined` if the event is outside of the rendered zone.
     */
    generateTplData(eventRecord, resourceRecord) {
      const me = this,
        // generateTplData calculates layout for events which are outside of the vertical viewport
        // because the RowManager needs to know a row height.
        renderData = me.currentOrientation.getTimeSpanRenderData(eventRecord, resourceRecord, { viewport: true });

      let eventContent = '';

      if (renderData) {
        let resizable = eventRecord.isResizable;
        if (renderData.startsOutsideView) {
          if (resizable === true) resizable = 'end';
          else if (resizable === 'start') resizable = false;
        }
        if (renderData.endsOutsideView) {
          if (resizable === true) resizable = 'start';
          else if (resizable === 'end') resizable = false;
        }

        // Event record cls properties are now DomClassList instances, so clone them
        // so that they can be manipulated here and by renderers.
        // Truthy value means the key will be added as a class name.
        // ResourceTimeRanges applies custom cls to wrapper.
        const clsList = eventRecord.isResourceTimeRange ? new DomClassList() : eventRecord.cls.clone(),
          wrapperClsList = eventRecord.isResourceTimeRange ? eventRecord.cls.clone() : new DomClassList();

        Object.assign(clsList, {
          [resourceRecord.cls]: resourceRecord.cls,
          [me.generatedIdCls]: eventRecord.hasGeneratedId,
          [me.dirtyCls]: eventRecord.modifications,
          [me.committingCls]: eventRecord.isCommitting,
          [me.endsOutsideViewCls]: renderData.endsOutsideView,
          [me.startsOutsideViewCls]: renderData.startsOutsideView,
          'b-clipped-start': renderData.clippedStart,
          'b-clipped-end': renderData.clippedEnd
        });
        Object.assign(wrapperClsList, {
          [`${me.eventCls}-parent`]: resourceRecord.isParent
        });

        // Event specifics, things that do not apply to ResourceTimeRanges
        if (eventRecord.isEvent || eventRecord.isTask) {
          Object.assign(clsList, {
            [me.eventCls]: 1,
            'b-milestone': eventRecord.isMilestone,
            'b-sch-event-narrow': renderData.width < 10,
            [me.fixedEventCls]: eventRecord.isDraggable === false,
            [`b-sch-event-resizable-${resizable}`]: Boolean(me.features.eventResize),
            [me.eventSelectedCls]: me.isEventSelected(eventRecord)
          });

          renderData.eventId = eventRecord.id;
          // this is important for getElement(s)FromEventRecord()
          renderData.id = me.getEventRenderId(eventRecord, resourceRecord);

          // If id has changed we want to reuse the element for the old id, to not steal some other events element
          // and to allow any other changes from the server to be animated
          if ('id' in eventRecord.meta.modified) {
            renderData.oldId = me.getEventRenderId(eventRecord.meta.modified.id, resourceRecord);
          }

          Object.assign(wrapperClsList, {
            [`${me.eventCls}-wrap`]: 1,
            'b-milestone-wrap': eventRecord.isMilestone
          });

          const eventStyle = eventRecord.eventStyle || resourceRecord.eventStyle || me.eventStyle,
            eventColor = eventRecord.eventColor || resourceRecord.eventColor || me.eventColor;

          renderData.eventColor = eventColor;
          renderData.eventStyle = eventStyle;

          // Using multi assignment? Supply AssignmentModel to rendering process also. Might not be available
          // if adding a new event and using EventEdit, since it might be converting a dragproxy prior to adding
          // to store. Not needed in that case anyway
          if (me.assignmentStore && eventRecord.assignments) {
            renderData.assignment = eventRecord.assignments.find((a) => a.resourceId === resourceRecord.id);
          }
        }

        // If not using a wrapping div, this cls will be added to event div for correct rendering
        renderData.wrapperCls = wrapperClsList;

        renderData.cls = clsList;
        renderData.iconCls = new DomClassList(eventRecord.get(me.eventBarIconClsField) || eventRecord.iconCls);

        // ResourceTimeRanges applies custom style to the wrapper
        if (eventRecord.isResourceTimeRange) {
          renderData.style = '';
          renderData.wrapperStyle = eventRecord.style || '';
        }
        // Others to inner
        else {
          renderData.style = eventRecord.style || '';
        }

        renderData.resource = resourceRecord;
        renderData.resourceId = renderData.rowId;

        if (eventRecord.isEvent || eventRecord.isTask) {
          if (me.eventRenderer) {
            // User has specified a renderer fn, either to return a simple string, or an object intended for the eventBodyTemplate
            const value = me.eventRenderer.call(me.eventRendererThisObj || me, {
              eventRecord,
              resourceRecord,
              assignmentRecord: renderData.assignment,
              tplData: renderData
            });

            // If the user's renderer coerced it into a string, recreate a DomClassList.
            if (typeof renderData.cls === 'string') {
              renderData.cls = new DomClassList(renderData.cls);
            }

            if (typeof renderData.wrapperCls === 'string') {
              renderData.wrapperCls = new DomClassList(renderData.wrapperCls);
            }

            // Same goes for iconCls
            if (typeof renderData.iconCls === 'string') {
              renderData.iconCls = new DomClassList(renderData.iconCls);
            }

            eventContent =
              (me.eventBodyTemplate && me.eventBodyTemplate(value)) || (value == null ? '' : String(value));
          } else if (me.eventBodyTemplate) {
            // User has specified an eventBodyTemplate, but no renderer - just apply the entire event record data.
            eventContent = me.eventBodyTemplate(eventRecord);
          } else if (me.eventBarTextField) {
            // User has specified a field in the data model to read from
            eventContent = eventRecord.data[me.eventBarTextField] || '';
          }

          if (!me.eventBodyTemplate) {
            // Give milestone a dedicated label element so we can use padding
            if (eventRecord.isMilestone && eventContent) {
              eventContent = `<label>${eventContent}</label>`;
            }

            if (renderData.iconCls && renderData.iconCls.length) {
              eventContent = `<i class="${renderData.iconCls}"></i>${eventContent}`;
            }
          }

          // renderers have last say on style & color
          renderData.wrapperCls[`b-sch-style-${renderData.eventStyle}`] = renderData.eventStyle;

          if (renderData.eventColor && renderData.eventColor.startsWith('#')) {
            renderData.style = `background-color:${renderData.eventColor};` + renderData.style;
          } else {
            renderData.wrapperCls[`b-sch-color-${renderData.eventColor}`] = renderData.eventColor;
          }
        }

        // If there are any iconCls entries...
        renderData.cls['b-sch-event-withicon'] = renderData.iconCls.length;

        // html, use templates fragment
        if (eventContent.includes('<')) {
          // Create content as a DocumentFragment which may now be exposed to Features.
          renderData.body = DomHelper.createElementFromTemplate(eventContent, {
            fragment: true
          });
        }
        // plain text, create fragment with the text in it
        else {
          renderData.body = document.createDocumentFragment();
          renderData.body.textContent = eventContent;
        }

        // For comparison in sync, cheaper than comparing DocumentFragments
        renderData.eventContent = eventContent;

        // Method which features may chain in to
        me.onEventDataGenerated(renderData);
      }

      return renderData;
    }

    /**
     * A method which may be chained by features. It is called when an event's render
     * data is calculated so that features may update the style, class list or body.
     * @param {Object} eventData
     */
    onEventDataGenerated(eventData) {}

    /**
     * Generates the element `id` for an event element. This is used when
     * recycling an event div which has been moved from one resource to
     * another. The event is assigned its new render id *before* being
     * returned to the free pool, so that when the render engine requests
     * a div from the free pool, the same div will be returned.
     * @param {Scheduler.model.EventModel|String|Number} eventRecord Event record or id
     * @param {Scheduler.model.ResourceModel} resourceRecord
     * @private
     */
    getEventRenderId(eventRecord, resourceRecord) {
      // Replacing and - in the id with ._. to not break `getResourceIdFromDomNodeId()`
      const eventId = eventRecord instanceof TimeSpan ? eventRecord.id.toString() : eventRecord.toString(),
        eventIdWithoutDash = eventId.replace(hyphenRe, '._.'),
        resourceIdWithoutDash = resourceRecord.id.toString().replace(hyphenRe, '._.');
      // TODO: use DomHelper.makeValidId or StringHelper.createId. Cannot currently since they strip out ids that only contains numbers
      return this.eventPrefix + `${eventIdWithoutDash}-${resourceIdWithoutDash}-x`;
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Scheduler/view/mixin/SchedulerStores
 */

const MAX_VALUE = Math.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1,
  checkResources = {
    add: 1,
    update: 1,
    remove: 1,
    filter: 1
  };

/**
 * Functions for store assignment and store event listeners
 *
 * @mixin
 */
var SchedulerStores = (Target) =>
  class SchedulerStores extends (Target || Base) {
    //region Default config

    static get defaultConfig() {
      return {
        /**
         * The {@link Scheduler.data.EventStore} holding the events to be rendered into the scheduler (required)
         * @config {Scheduler.data.EventStore}
         * @category Data
         */
        eventStore: null,

        /**
         * The {@link Scheduler.data.ResourceStore} holding the resources to be rendered into the scheduler (required)
         * @config {Scheduler.data.ResourceStore}
         * @category Data
         */
        resourceStore: null,

        /**
         * The optional {@link Scheduler.data.AssignmentStore}, holding assigments between resources and events.
         * Required for multi assignments.
         * @config {Scheduler.data.AssignmentStore}
         * @category Data
         */
        assignmentStore: null,

        dependencyStore: null,

        /**
         * Overridden to *not* auto create a store at the Scheduler level.
         * The store is the {@link #config-resourceStore} which is either configured in
         * or acquired from the {@link #config-crudManager}.
         * @config {Common.data.Store}
         * @private
         */
        store: null,

        /**
         * The name of the start date parameter that will be passed to in every `eventStore` load request.
         * @config {String}
         * @category Data
         */
        startParamName: 'startDate',

        /**
         * The name of the end date parameter that will be passed to in every `eventStore` load request.
         * @config {String}
         * @category Data
         */
        endParamName: 'endDate',

        /**
         * true to apply start and end dates of the current view to any `eventStore` load requests.
         * @config {Boolean}
         * @category Data
         */
        passStartEndParameters: false,

        /**
         * Supply a CrudManager config object if you want to use CrudManager for handling data
         * @config {Object}
         * @category Data
         */
        crudManager: null,

        /**
         * Inline events, will be loaded into an internally created EventStore
         * @config {Scheduler.model.EventModel[]|Object[]}
         * @category Data
         */
        events: null,

        /**
         * Inline resources, will be loaded into an internally created ResourceStore
         * @config {Scheduler.model.ResourceModel[]|Object[]}
         * @category Data
         */
        resources: null,

        /**
         * Inline assignments, will be loaded into an internally created AssignmentStore
         * @config {Scheduler.model.AssignmentModel[]|Object[]}
         * @category Data
         */
        assignments: null,

        /**
         * Configure with `true` to also remove the event when removing the last assignment
         * @config {Boolean}
         * @default
         * @category Misc
         */
        removeUnassignedEvent: true
      };
    }

    //endregion

    onStoreDataChange({ source: store, action }) {
      this.currentOrientation.clearEvents();

      super.onStoreDataChange(...arguments);
    }

    // Wrap w/ transition refreshFromRowOnStoreAdd() inherited from Grid
    refreshFromRowOnStoreAdd(row, { isExpand }) {
      const args = arguments;

      this.runWithTransition(() => super.refreshFromRowOnStoreAdd(row, ...args), !isExpand);
    }

    onStoreAdd({ source: store, records, isChild }) {
      const me = this,
        { rowManager } = me;

      // If it was an appendChild to a parent that is not expanded,
      // do nothing
      if (isChild && !records[0].parent.isExpanded(me)) {
        return;
      }

      rowManager.calculateRowCount(false, true, true);

      const endIndex = Math.max(
        rowManager.topIndex + rowManager.rowCount,
        Math.min(rowManager.visibleRowCount, store.count)
      );

      // Need to find topmost resource because we have to update from there downwards
      records = records.sort((lhs, rhs) => {
        return store.indexOf(lhs) - store.indexOf(rhs);
      });
      let firstUpdatedIndex = store.indexOf(records[0]);

      // If the update is below the rendered block, ignore it
      if (firstUpdatedIndex < endIndex) {
        // Start updating from the first affected record, or the rendered block
        // top if the record is above the rendered block.
        firstUpdatedIndex = Math.max(firstUpdatedIndex, rowManager.topIndex);

        // Clear events on every row below the first record
        for (let i = firstUpdatedIndex; i < endIndex; i++) {
          me.currentOrientation.onRowRecordUpdate({ record: store.getAt(i) });
        }
      } else {
        // Still might have changed total height
        rowManager.estimateTotalHeight();
      }

      super.onStoreAdd(...arguments);
    }

    /**
     * Overrides event handler in Grid, to pass on to current orientation class
     * @private
     */
    onStoreUpdateRecord() {
      // need to update events when resource changes (might use data in renderers, templates)
      if (!this.suspendStoreRedraw) {
        this.currentOrientation.onRowRecordUpdate(...arguments);
        super.onStoreUpdateRecord(...arguments);
      }
    }

    onStoreRemove() {
      this.currentOrientation.onRowRecordRemove(...arguments);
      super.onStoreRemove(...arguments);
    }

    onStoreRemoveAll() {
      this.currentOrientation.clearEvents();
      super.onStoreRemoveAll();
    }

    //region destroy

    // Cleanup, destroys stores if Scheduler.destroyStores is true.
    doDestroy() {
      super.doDestroy();

      const me = this;
      if (me.destroyStores) {
        // TODO: Use me.destroyMembers when available.
        if (me.assignmentStore) me.assignmentStore.destroy();
        if (me.resourceStore) me.resourceStore.destroy();
        if (me.dependencyStore) me.dependencyStore.destroy();
        if (me.eventStore) me.eventStore.destroy();
      }
    }

    //endregion

    //region Row store

    get store() {
      const me = this;
      // Spin up the resourceStore if possible.
      // If there are configured resources, this will load them too.
      me._thisIsAUsedExpression(me.resources);

      // Vertical uses a dummy store
      if (!me._store && me.isVertical) {
        // TODO: Make this store readonly, since we are using single cell approach
        me._store = new Store({
          data: [{ id: 'verticalTimeAxisRow' }]
        });
      }

      return super.store;
    }

    set store(store) {
      super.store = store;
    }

    //endregion

    //region ResourceStore

    /**
     * Get/set resources, applies to the assigned ResourceStore
     * @property {Scheduler.model.ResourceModel[]|Object[]}
     * @category Data
     */
    get resources() {
      const resourceStore = this.resourceStore;

      return resourceStore && resourceStore.records;
    }

    set resources(resources) {
      this.resourceStore.data = resources;
    }

    /**
     * Get/set the resource store instance
     * @property {Scheduler.data.ResourceStore}
     * @category Data
     */
    get resourceStore() {
      const me = this;

      // If there's a CrudManager, it injects its resourceStore.
      // If not, we create our own instance.
      if (!me._resourceStore) {
        if (!me.crudManager || !me.crudManager.resourceStore) {
          me.resourceStore = new ResourceStore();
        }
      }

      return me._resourceStore;
    }

    set resourceStore(newResourceStore) {
      const me = this,
        oldResourceStore = me._resourceStore;

      if (newResourceStore === oldResourceStore) {
        return;
      }

      if (!(newResourceStore instanceof ResourceStore)) {
        newResourceStore = new ResourceStore(newResourceStore);
      }

      if (oldResourceStore) {
        const isBackingRowStore = oldResourceStore === me.store;

        me._resourceStore = newResourceStore;

        // Reconfigure grid if resourceStore is backing the rows
        if (newResourceStore && me.isHorizontal) {
          if (isBackingRowStore) {
            me.store = me.resourceStore;
            me.store.metaMapId = me.id;
          } else {
            me.refresh();
          }
        }
      } else {
        me._resourceStore = newResourceStore;
      }

      if (newResourceStore) {
        // In vertical, resource store is not the row store but should toggle the load mask
        if (me.isVertical) {
          newResourceStore.on('load', () => me.unmaskBody());
        }

        me.trigger('resourceStoreChange', { newResourceStore, oldResourceStore });
      }

      if (me.isHorizontal && !me._store) {
        me.store = newResourceStore;
      }
    }

    //endregion

    //region EventStore

    /**
     * Get/set events, applies to the assigned EventStore
     * @property {Scheduler.model.EventModel[]|Object[]}
     * @category Data
     */
    get events() {
      return this._eventStore.records;
    }

    set events(events) {
      this.eventStore.data = events;
    }

    /**
     * Get/set the event store instance
     * @property {Scheduler.data.EventStore}
     * @category Data
     */
    get eventStore() {
      const me = this;

      // If there's a CrudManager, we use its eventStore.
      // If not, we create our own instance.
      if (!me._eventStore) {
        if (!me.crudManager || !me.crudManager.eventStore) {
          me.eventStore = new EventStore({
            resourceStore: me.resourceStore
          });
        }
      }

      return this._eventStore;
    }

    set eventStore(newEventStore) {
      const me = this,
        oldEventStore = me._eventStore;

      let triggerLoad = false;

      if (newEventStore === oldEventStore) {
        return;
      }

      let resourceStore = me.resourceStore;

      // Reconfiguring
      if (oldEventStore) {
        const oldEventStore = me.eventStore,
          assignmentStore = me.assignmentStore,
          dependencyStore = me.dependencyStore;

        if (newEventStore === oldEventStore) {
          return;
        }

        me.eventStoreDetacher && me.eventStoreDetacher();

        me._eventStore = newEventStore;

        if (resourceStore) {
          //resourceStore.eventStore = newEventStore;
          if (!newEventStore.resourceStore) {
            newEventStore.resourceStore = resourceStore;
          }
        }

        if (assignmentStore && newEventStore && !newEventStore.assignmentStore) {
          newEventStore.assignmentStore = assignmentStore;
        }

        if (dependencyStore && newEventStore && !newEventStore.dependencyStore) {
          newEventStore.dependencyStore = dependencyStore;
        }

        me.timeAxisViewModel.eventStore = newEventStore;

        if (newEventStore) {
          me.trigger('eventStoreChange', { newEventStore, oldEventStore });

          me.refresh();
        }
      } else {
        if (newEventStore.isEventStore) {
          if (resourceStore && newEventStore.resourceStore !== resourceStore) {
            // Sanity check.
            // An eventStore cannot be shared between two Schedulers with different
            // resourceStores. Prevent this Scheduler being handed an eventStore that
            // is already attached to another resourceStore
            if (newEventStore.resourceStore) {
              throw new Error(
                `eventStore ${newEventStore.id} is already linked to resourceStore ${newEventStore.resourceStore.id}`
              );
            }
            newEventStore.resourceStore = resourceStore;
          }
        } else {
          triggerLoad = newEventStore.autoLoad;
          newEventStore.autoLoad = false;

          newEventStore = new EventStore(
            Object.assign(
              {
                resourceStore: me.resourceStore
              },
              newEventStore
            )
          );
        }
        me._eventStore = newEventStore;
      }

      if (newEventStore) {
        const listenerCfg = {
          thisObj: me,
          detachable: true,

          // There is no separate dataset event any more.
          // It's a refresh event with action: 'dataset'
          change: 'onInternalEventStoreChange',
          clearchanges: 'onEventClearChanges',
          beforecommit: 'onEventBeforeCommit',
          commit: 'onEventCommit',
          beforeRemove: 'onBeforeEventRemove',
          refresh: 'onEventStoreRefresh',
          exception: 'onEventException'

          // TODO: PORT saving tree for later
          // If the eventStore is a TreeStore
          //nodeinsert : me.onEventAdd,
          //nodeappend : me.onEventAdd
        };

        if (me.passStartEndParameters) {
          listenerCfg.beforeload = me.applyStartEndParameters;
        }

        me.eventStoreDetacher && me.eventStoreDetacher();

        // TODO: PORT don't have autoDestroy yet
        /*if (me.eventStore) {
             if (eventStore !== me.eventStore && me.eventStore.autoDestroy) {
             me.eventStore.destroy();
             }
             }*/

        me.eventStoreDetacher = newEventStore.on(listenerCfg);

        if (newEventStore.assignmentStore) {
          me.assignmentStore = newEventStore.assignmentStore;
        }

        if (triggerLoad) {
          newEventStore.load().catch(() => {});
        }
      }

      // flag checked when adding events, to trigger full render first time
      if (me.eventStore.count > 0) {
        me.eventsRendered = true;
      }
    }

    //endregion

    //region AssignmentStore

    /**
     * Get/set assignments, applies to the assigned AssignmentStore
     * @property {Scheduler.model.AssignmentModel[]|Object[]}
     * @category Data
     */
    get assignments() {
      return this.assignmentStore && this.assignmentStore.records;
    }

    set assignments(assignments) {
      // Creating AssignmentStore here and not in `get assignmentStore` since it is optional, but if user assigns
      // assignments we can be sure one is needed.
      if (!this.assignmentStore) {
        this.eventStore.assignmentStore = this.assignmentStore = new AssignmentStore();
      }

      this.assignmentStore.data = assignments;
    }

    /**
     * Get/set the assignment store instance
     * @property {Scheduler.data.AssignmentStore}
     * @category Data
     */
    get assignmentStore() {
      const me = this,
        eventStore = me.eventStore;

      return eventStore && eventStore.assignmentStore;
    }

    set assignmentStore(newAssignmentStore) {
      const me = this,
        oldAssignmentStore = me.assignmentStore;

      if (me.eventStore.assignmentStore !== newAssignmentStore) {
        me.eventStore.assignmentStore = newAssignmentStore;
      }

      me.assignmentStoreDetacher && me.assignmentStoreDetacher();

      if (newAssignmentStore) {
        // In case there is an assignment store used
        me.assignmentStoreDetacher = newAssignmentStore.on({
          thisObj: me,
          //refresh    : me.onEventDataRefresh,
          refresh: me.onAssignmentRefresh,
          update: me.onAssignmentUpdate,
          add: me.onAssignmentAdd,
          beforeRemove: {
            fn: me.onBeforeAssignmentRemove,
            // We must go last in case an app vetoes a remove
            // by returning false from a handler.
            prio: -1000
          },
          remove: me.onAssignmentRemove,
          filter: me.onAssignmentFilter,
          removeall: me.onAssignmentRemoveAll
        });

        me.trigger('assignmentStoreChange', { newAssignmentStore, oldAssignmentStore });
        me.refresh();
      }
    }

    //endregion

    //region DependencyStore

    /**
     * Get/set the dependency store instance
     * @property {Scheduler.data.DependencyStore}
     * @category Data
     */
    get dependencyStore() {
      const me = this,
        eventStore = me.eventStore;

      return (eventStore && eventStore.dependencyStore) || me._dependencyStore;
    }

    set dependencyStore(newDependencyStore) {
      const me = this;

      if (!me.isConfigured) {
        me._dependencyStore = newDependencyStore;
      } else {
        const oldDependencyStore = me.dependencyStore;

        me.eventStore.dependencyStore = newDependencyStore;

        if (newDependencyStore) {
          me.trigger('dependencyStoreChange', { newDependencyStore, oldDependencyStore });
          me.refresh();
        }
      }
    }

    //endregion

    //region CrudManager

    /**
     * Get/set the CrudManager instance
     * @property {Scheduler.data.CrudManager}
     * @category Data
     */
    get crudManager() {
      return this._crudManager;
    }

    set crudManager(crudManager) {
      const me = this;

      if (!(crudManager instanceof CrudManager)) {
        // CrudManager injects itself into is Scheduler's _crudManager property
        // because code it triggers needs to access it through its getter.
        crudManager = new CrudManager(
          Object.assign(
            {
              scheduler: me
            },
            crudManager
          )
        );
      } else {
        me._crudManager = crudManager;
      }
    }

    //endregion

    //region Events

    /**
     * Calls appropriate functions for current event layout when the event store is modified.
     * @private
     */
    // Named as Internal to avoid naming collision with wrappers that relay events
    onInternalEventStoreChange(params) {
      const me = this;

      // Too early, bail out
      if (!me._mode) {
        return;
      }

      if (me.isVertical) {
        me.currentOrientation.onEventStoreChange(params);
      } else {
        // TODO: Move this to horizontal

        const layout = me.currentOrientation,
          // ResourceTimeRanges also calls this fn, using its store as source. It is "compatible" with eventStore
          eventStore = params.source,
          { rowManager, resourceStore } = me,
          { action, changes, isCollapse } = params,
          events = params.records || (params.record ? [params.record] : null),
          resources = [];

        let rows = new Set(),
          useTransition = false,
          len,
          i;

        if (!me.rendered) {
          return;
        }

        // Ignore update caused by collapse or removing associated resource, will be handled by resource removal code
        if (isCollapse || (action === 'update' && events.length && events[0].meta.removingResource)) {
          return;
        }

        // resource timeranges feature embeds into regular events drawing procedure
        // which means in some cases we should repaint all rows
        const skipRows = action === 'filter' && me.hasFeature('resourceTimeRanges');

        // If events were changed
        if (!skipRows && checkResources[action] && events) {
          // For event resource change, the "from" resource is part of the changed resource set.
          if (changes && 'resourceId' in changes && changes.resourceId.oldValue != null) {
            const prevResource = resourceStore.getById(changes.resourceId.oldValue),
              prevRow = prevResource && rowManager.getRowFor(prevResource);

            // Old resource might not exist in store, https://app.assembla.com/spaces/bryntum/tickets/7070.
            // Happens for example when dropping from another scheduler.
            if (prevRow) {
              resources.push(prevResource);
              rows.add(prevRow);
            }
          }

          // We are only interested in associated resources which exist in the store and are in the rendered block.
          for (i = 0, len = events.length; i < len; i++) {
            resources.push(
              ...eventStore.getResourcesForEvent(events[i]).filter((resource) => {
                if (resource) {
                  const row = rowManager.getRowFor(resource);
                  if (row) {
                    rows.add(row);
                    return true;
                  }
                }
                return false;
              })
            );
          }

          if (resources.length) {
            // Sort rows if more than one
            if (rows.size > 1) {
              rows = new Set([...rows].sort((a, b) => a.dataIndex - b.dataIndex));
            }
            // If all affected rows are outside of the rendered range, do nothing
            else if (!rows.size) {
              return;
            }
          }
          // No resources in the rendered block were visible (or all events filtered out, in which case a full redraw
          // is performed). Nothing to update in the UI, but the dataset height might have changed.
          else if (!(action === 'filter' && !events.length)) {
            rowManager.estimateTotalHeight();
            return;
          }
          params.resources = resources;
        }

        switch (action) {
          case 'dataset':
            layout.onEventDataset();
            break;
          case 'add':
            layout.onEventAdd(params);
            useTransition = true;
            break;
          case 'update':
            layout.onEventUpdate(params);
            useTransition = true;
            break;
          case 'remove':
            layout.onEventRemove(params);
            useTransition = true;
            break;
          case 'removeall':
            layout.onEventRemoveAll();
            break;
          case 'filter':
            layout.onEventFilter(params);
            break;
          case 'clearchanges':
            layout.onEventClearChanges(params);
            break;
        }

        me.runWithTransition(() => {
          if (rows.size) {
            // Render the affected rows.
            rowManager.renderRows(rows);
          }
          // No specific rows affected, for example a dataset. Draw all
          else {
            // TODO: change to refresh() when merged to master
            rowManager.renderFromRow();
          }
        }, useTransition);
      }
    }

    /**
     * If events are changed in batch, endBatch fires refresh, so we must refresh the view
     * @private
     */
    onEventStoreRefresh({ action }) {
      if (action === 'batch' && this.rowManager.rowCount) {
        this.currentOrientation.onEventDataset();
        // TODO: Run with transition?
        this.refresh();
      }
    }

    /**
     * Moves focus before the currently active event is removed.
     * @private
     */
    onBeforeEventRemove({ records }) {
      const me = this;

      // Active event is being removed.
      if (me.activeEvent && records.includes(me.activeEvent)) {
        let moveTo;

        // If being done by a keyboard gesture then look for a close target
        // until we find an existing record, not scheduled for removal.
        // Otherwise, per Mats, push focus outside of the Scheduler.
        if (GlobalEvents.lastInteractionType === 'key') {
          for (let i = 0, l = records.length; i < l && (!moveTo || records.includes(moveTo)); i++) {
            if (me.eventStore.getResourcesForEvent(records[i]).length) {
              const event = records[i],
                from = event.assignments && event.assignments.length ? event.assignments[0] : event;
              moveTo = me.getNext(from, true) || me.getPrevious(from, true);
            }
          }
        }

        // Move focus away from the element which will soon have no
        // backing data.
        if (moveTo) {
          me.navigateTo(moveTo);
        }
        // Focus must exit the Scheduler's subgrid, otherwise, if a navigation
        // key gesture is delivered before the outgoing event's element has faded
        // out and been removed, navigation will be attempted from a deleted
        // event. Animated hiding is problematic.
        //
        // We cannot just revertFocus() because that might move focus back to an
        // element in a floating EventEditor which is not yet faded out and
        // been removed. Animated hiding is problematic.
        //
        // We cannot focus scheduler.timeAxisColumn.element because the browser
        // would scroll it in some way if we have horizontal overflow.
        //
        // The only thing we can know about to focus here is the Scheduler itself.
        else {
          me.element.focus();
        }
      }
    }

    /**
     * Refreshes committed events, to remove dirty/committing flag.
     * CSS is added
     * @private
     */
    onEventCommit({ changes }) {
      [...changes.added, ...changes.modified].forEach((eventRecord) => this.repaintEvent(eventRecord));
    }

    /**
     * Adds the committing flag to changed events before commit.
     * @private
     */
    onEventBeforeCommit({ changes }) {
      // Committing sets a flag in meta that during eventrendering applies a CSS class. But to not mess up drag and
      // drop between resources no redraw is performed before committing, so class is never applied to the element(s).
      // Applying here instead
      [...changes.added, ...changes.modified].forEach((eventRecord) =>
        this.getElementsFromEventRecord(eventRecord).forEach((element) => element.classList.add(this.committingCls))
      );
    }

    // Clear committing flag
    onEventException({ action }) {
      if (action === 'commit') {
        const { changes } = this.eventStore;
        [...changes.added, ...changes.modified, ...changes.removed].forEach((eventRecord) =>
          this.repaintEvent(eventRecord)
        );
      }
    }

    /**
     * Refreshes scheduler when event changes are cleared.
     * @private
     */
    onEventClearChanges() {
      this.refresh();
    }

    /**
     * Refreshes scheduler when data is assigned to the assigment store
     * @private
     */
    onAssignmentRefresh(event) {
      if (this.isHorizontal && (event.action === 'dataset' || event.action === 'batch')) {
        this.refresh();
      }
    }

    /**
     * Repaints affected resources when assignments are added.
     * @private
     */
    onAssignmentAdd({ records }) {
      if (this.isHorizontal) {
        records.forEach((assignment) => {
          const resource = assignment.resource;
          resource && this.repaintEventsForResource(resource);
        });
      }
    }

    /**
     * Repaints affected resources when assignments are updated.
     * @private
     */
    onAssignmentUpdate({ record, changes }) {
      if (this.isHorizontal) {
        // TODO: Move to HorizontalEventMapper
        const { rowManager } = this,
          layoutCache = this.currentOrientation.cache,
          oldResourceId = 'resourceId' in changes && changes.resourceId.oldValue,
          newResourceId = record.resourceId;

        let row,
          fromRow = MAX_VALUE;

        if (oldResourceId != null && (row = rowManager.getRowFor(oldResourceId))) {
          layoutCache.clearRow(oldResourceId);
          fromRow = Math.min(fromRow, row.index);
        }

        if (newResourceId && (row = rowManager.getRowFor(newResourceId))) {
          layoutCache.clearRow(newResourceId);
          fromRow = Math.min(fromRow, row.index);
        }

        // Render from the first mutated row in the rendered block;
        if (fromRow !== MAX_VALUE) {
          rowManager.renderFromRow(rowManager.rows[fromRow]);
        }
      }
    }

    onBeforeAssignmentRemove({ source, records }) {
      // Bail out if caused by the remove below
      if (source.isRemovingEvent) {
        return;
      }

      const me = this,
        events = records.reduce((result, assignment) => {
          const event = assignment.event;

          if (event && !event.placeHolder && !result.includes(event)) {
            result.push(event);
          }

          return result;
        }, []);

      let moveTo;

      // Deassigning the active assignment
      if (me.activeEvent && events.includes(me.activeEvent)) {
        // If being done by a keyboard gesture then look for a close target
        // until we find an existing record, not scheduled for removal.
        // Otherwise, per Mats, push focus outside of the Scheduler.
        if (GlobalEvents.lastInteractionType === 'key') {
          // Look for a close target until we find an existing record, not scheduled for removal
          for (let i = 0, l = records.length; i < l && (!moveTo || records.includes(moveTo)); i++) {
            if (me.eventStore.getResourcesForEvent(records[i].event).length) {
              const event = records[i],
                from = event.assignments && event.assignments.length ? event.assignments[0] : event;

              moveTo = me.getNext(from) || me.getPrevious(from);
            }
          }
        }

        // Move focus away from the element which will soon have no
        // backing data.
        if (moveTo) {
          me.navigateTo(moveTo);
        }
        // Focus must exit the Scheduler's subgrid, otherwise, if a navigation
        // key gesture is delivered before the outgoing event's element has faded
        // out and been removed, navigation will be attempted from a deleted
        // event. Animated hiding is problematic.
        //
        // We cannot just revertFocus() because that might move focus back to an
        // element in a floating EventEditor which is not yet faded out and
        // been removed. Animated hiding is problematic.
        //
        // We cannot focus scheduler.timeAxisColumn.element because the browser
        // would scroll it in some way if we have horizontal overflow.
        //
        // The only thing we can know about to focus here is the Scheduler itself.
        else {
          me.element.focus();
        }
      }

      if (me.removeUnassignedEvent && !me.isRemoving) {
        // Collect all events that will unassigned after the remove
        const toRemove = events.reduce((result, eventRecord) => {
          let assignmentCount = eventRecord.assignments ? eventRecord.assignments.length : 0;

          assignmentCount -= records.filter((r) => r.event === eventRecord).length;

          if (!assignmentCount) {
            result.push(eventRecord);
          }

          return result;
        }, []);

        // And remove them
        me.eventStore.remove(toRemove);
      }
    }

    /**
     * Repaints affected resources when assignments are removed.
     * @private
     */
    onAssignmentRemove({ records }) {
      if (this.isHorizontal) {
        records.forEach((assignment) => {
          const resource = assignment.resource;
          resource && this.repaintEventsForResource(resource);
        });
      }
    }

    /**
     * Repaints resources when all assignments are removed.
     * @private
     */
    onAssignmentRemoveAll() {
      if (this.isHorizontal) {
        this.refresh();
      }
    }

    /**
     * Refreshes scheduler when assignment store is filtered.
     */
    onAssignmentFilter() {
      if (this.isHorizontal) {
        this.refresh();
      }
    }

    //endregion

    //region Other functions

    /**
     * Applies the start and end date to each event store request (formatted in the same way as the start date, defined in the EventStore Model class).
     * @category Data
     */
    applyStartEndParameters({ source: eventStore, params }) {
      const me = this,
        dateFormat = eventStore.modelClass.fieldMap.startDate.dateFormat;

      params[me.startParamName] = DateHelper.format(me.startDate, dateFormat);
      params[me.endParamName] = DateHelper.format(me.endDate, dateFormat);
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Scheduler/view/mixin/SchedulerScroll
 */

const immediatePromise$5 = new Promise((resolve) => resolve()),
  defaultScrollOptions$3 = {
    block: 'nearest',
    edgeOffset: 20
  };

/**
 * Functions for scrolling to events, dates etc.
 *
 * @mixin
 */
var SchedulerScroll = (Target) =>
  class SchedulerScroll extends (Target || Base) {
    //region Scroll to event

    /**
     * Scrolls an event record into the viewport.
     * If the resource store is a tree store, this method will also expand all relevant parent nodes to locate the event.
     *
     * @param {Scheduler.model.EventModel} eventRec the event record to scroll into view
     * @param {Object} [options] How to scroll.
     * @param {String} [options.block=nearest] How far to scroll the event: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset=20] edgeOffset A margin *in pixels* around the event to bring into view.
     * @param {Boolean/Number} [options.animate] Set to `true` to animate the scroll, or the number of milliseconds to animate over.
     * @param {Boolean} [options.highlight] Set to `true` to highlight the event element when it is in view.
     * @param {Boolean} [options.focus] Set to `true` to focus the event element when it is in view.
     * @returns {Promise} A Promise which resolves when the scrolling is complete.
     *
     * This function is not applicable for events with multiple assignments, please use #scrollResourceEventIntoView instead.
     */
    scrollEventIntoView(eventRec, options = defaultScrollOptions$3) {
      const me = this,
        resources = eventRec.resources || [eventRec];

      if (resources.length > 1) {
        throw new Error(
          'scrollEventIntoView() is not applicable for events with multiple assignments, please use scrollResourceEventIntoView() instead.'
        );
      }

      if (!resources.length) {
        console.warn('You have asked to scroll to an event which is not assigned to a resource');
        return immediatePromise$5;
      }

      return me.scrollResourceEventIntoView(resources[0], eventRec, null, options);
    }

    /**
     * Scrolls a resource event record into the viewport.
     *
     * If the resource store is a tree store, this method will also expand all relevant parent nodes
     * to locate the event.
     *
     * @param {Scheduler.model.ResourceModel} resourceRec A resource record an event record is assigned to
     * @param {Scheduler.model.EventModel} eventRec An event record to scroll into view
     * @param {Number} index DOM node index, applicable only for weekview
     * @param {Object} [options] How to scroll.
     * @param {String} [options.block=nearest] How far to scroll the event: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset=20] edgeOffset A margin *in pixels* around the event to bring into view.
     * @param {Boolean/Number} [options.animate] Set to `true` to animate the scroll, or the number of milliseconds to animate over.
     * @param {Boolean} [options.extendTimeAxis=true] By default, if the requested event is outside the time axis, the time axis is extended.
     * @param {Boolean} [options.highlight] Set to `true` to highlight the event element when it is in view.
     * @param {Boolean} [options.focus] Set to `true` to focus the event element when it is in view.
     * @returns {Promise} A Promise which resolves when the scrolling is complete.
     */
    scrollResourceEventIntoView(resourceRec, eventRec, index, options = defaultScrollOptions$3) {
      const me = this,
        eventStart = eventRec.startDate,
        eventEnd = eventRec.endDate,
        eventIsOutside = (eventStart < me.timeAxis.startDate) | ((eventEnd > me.timeAxis.endDate) << 1);

      let el;

      if (options.edgeOffset == null) {
        options.edgeOffset = 20;
      }

      // Make sure event is within TimeAxis time span unless extendTimeAxis passed as false.
      // The EventEdit feature passes false because it must not mutate the TimeAxis.
      // Bitwise flag:
      //  1 === start is before TimeAxis start.
      //  2 === end is after TimeAxis end.
      if (eventIsOutside && options.extendTimeAxis !== false) {
        let currentTimeSpanRange = me.timeAxis.endDate - me.timeAxis.startDate,
          startAnchorPoint,
          endAnchorPoint;

        // Event is too wide, expand the range to encompass it.
        if (eventIsOutside === 3) {
          me.timeAxis.setTimeSpan(
            new Date(eventStart.valueOf() - currentTimeSpanRange / 2),
            new Date(eventEnd.getTime() + currentTimeSpanRange / 2)
          );
        }
        // Event is partially or wholly outside but will fit.
        // Move the TimeAxis to include it. Attempt to maintain visual position.
        else {
          startAnchorPoint =
            eventIsOutside & 1
              ? me.getCoordinateFromDate(eventRec.endDate)
              : me.getCoordinateFromDate(eventRec.startDate);

          // Event starts before
          if (eventIsOutside & 1) {
            me.timeAxis.setTimeSpan(new Date(eventStart), new Date(eventStart.valueOf() + currentTimeSpanRange));
          }
          // Event ends after
          else {
            me.timeAxis.setTimeSpan(new Date(eventEnd.valueOf() - currentTimeSpanRange), new Date(eventEnd));
          }
          // Restore view to same relative scroll position.
          endAnchorPoint =
            eventIsOutside & 1
              ? me.getCoordinateFromDate(eventRec.endDate)
              : me.getCoordinateFromDate(eventRec.startDate);

          me.timeAxisSubGrid.scrollable.scrollBy(endAnchorPoint - startAnchorPoint);
        }
      }

      // Establishing element to scroll to
      el = me.getElementFromEventRecord(eventRec, resourceRec);

      if (el) {
        // It's usually the event wrapper that holds focus
        if (!DomHelper.isFocusable(el)) {
          el = el.parentNode;
        }

        const scroller = me.timeAxisSubGrid.scrollable;

        // Scroll into view with animation and highlighting if needed.
        // Mute scroll events during the scroll so that event rendering doesn't replace
        // the target element.
        return scroller.scrollIntoView(
          el,
          ObjectHelper.assign(
            {
              silent: true
            },
            options
          )
        );
      } else if (eventIsOutside && options.extendTimeAxis === false) {
        console.warn(
          'You have asked to scroll to an event which is outside the current view and extending timeaxis is disabled'
        );
        return immediatePromise$5;
      } else if (!me.eventStore.isAvailable(eventRec)) {
        console.warn('You have asked to scroll to an event which is not available');
        return immediatePromise$5;
      } else {
        // Event not rendered, scroll to calculated location
        return me.scrollUnrenderedEventIntoView(resourceRec, eventRec, options);
      }
    }

    /**
     * Scrolls an unrendered event into view. Internal function used from #scrollResourceEventIntoView.
     * @private
     */
    scrollUnrenderedEventIntoView(resourceRec, eventRec, options = defaultScrollOptions$3) {
      if (options.edgeOffset == null) {
        options.edgeOffset = 20;
      }

      const me = this,
        scroller = me.timeAxisSubGrid.scrollable,
        box = me.getResourceEventBox(eventRec, resourceRec), // TODO: have all "box" type objects use Rectangle
        scrollerViewport = scroller.viewport,
        targetRect = new Rectangle(box.start, box.top, box.end - box.start, box.bottom - box.top).translate(
          scrollerViewport.x - scroller.x,
          scrollerViewport.y - scroller.y
        ),
        result = scroller.scrollIntoView(targetRect, Object.assign({}, options, { highlight: false }));

      if (options.highlight || options.focus) {
        const detatcher = me.on({
          eventrepaint({ scheduler, eventRecord, resourceRecord, element }) {
            if (eventRecord === eventRec) {
              detatcher();
              result.then(() => {
                options.highlight && DomHelper.highlight(element);
                options.focus && element.focus();
              });
            }
          }
        });
      }

      return result;
    }

    /**
     * Scrolls the specified resource into view, works for both horizontal and vertical modes.
     * @param {Scheduler.model.ResourceModel} resourceRecord A resource record an event record is assigned to
     * @param {Object} [options] How to scroll.
     * @param {String} [options.column] Field name or ID of the column, or the Column instance to scroll to (in horizontal mode).
     * @param {String} [options.block] How far to scroll the element: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset] edgeOffset A margin around the element or rectangle to bring into view.
     * @param {Boolean|Number} [options.animate] Set to `true` to animate the scroll, or the number of milliseconds to animate over.
     * @param {Boolean} [options.highlight] Set to `true` to highlight the element when it is in view.
     * @returns {Promise} A promise which is resolved when the scrolling has finished.
     */
    scrollResourceIntoView(resourceRecord, options = defaultScrollOptions$3) {
      if (this.isVertical) {
        return this.currentOrientation.scrollResourceIntoView(resourceRecord, options);
      } else {
        return this.scrollRowIntoView(resourceRecord, options);
      }
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Scheduler/view/mixin/SchedulerRegions
 */

/**
 * Functions to get regions (bounding boxes) for scheduler, events etc.
 *
 * @mixin
 */
var SchedulerRegions = (Target) =>
  class SchedulerRegions extends (Target || Base) {
    //region Orientation depended regions

    /**
     * Gets the region represented by the schedule and optionally only for a single resource. The view will ask the scheduler for
     * the resource availability by calling getResourceAvailability. By overriding that method you can constrain events differently for
     * different resources.
     * @param {Scheduler.model.ResourceModel} resourceRecord (optional) The resource record
     * @param {Scheduler.model.EventModel} eventRecord (optional) The event record
     * @return {Object} The region of the schedule
     */
    getScheduleRegion(resourceRecord, eventRecord, local = true) {
      return this.currentOrientation.getScheduleRegion(resourceRecord, eventRecord, local);
    }

    /**
     * Gets the region representing the passed resource and optionally just for a certain date interval.
     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record
     * @param {Date} startDate A start date constraining the region
     * @param {Date} endDate An end date constraining the region
     * @return {Object} The region of the resource
     */
    getResourceRegion(resourceRecord, startDate, endDate) {
      return this.currentOrientation.getRowRegion(resourceRecord, startDate, endDate);
    }

    /**
     * Gets the start and end dates for an element Region
     * @param {Common.helper.util.Rectangle} rect The rectangle to map to start and end dates
     * @param {String} roundingMethod The rounding method to use
     * @returns {Object} an object containing start/end properties
     */
    getStartEndDatesFromRectangle(rect, roundingMethod) {
      return this.currentOrientation.getStartEndDatesFromRectangle(rect, roundingMethod);
    }

    //endregion

    //region ResourceEventBox

    /**
     * Get the region for a specified resources specified event.
     * @param {Scheduler.model.EventModel} eventRecord
     * @param {Scheduler.model.ResourceModel} resourceRecord
     * @param {Boolean} includeOutside Specify true to get boxes for events outside of the rendered zone in both dimensions. This option is used when calculating
     * dependency lines, and we need to include routes from events which may be outside the rendered zone.
     * @returns {*}
     */
    getResourceEventBox(eventRecord, resourceRecord, includeOutside = false) {
      // event caches its position when rendered, return it if available
      const me = this,
        // Vertical always returns a box here
        cached = me.currentOrientation.getResourceEventBox(eventRecord.id, resourceRecord.id);

      if (cached) {
        return cached;
      }

      // TODO: Move to HorizontalEventMapper
      const viewStartDate = me.timeAxis.startDate,
        viewEndDate = me.timeAxis.endDate,
        eventStartDate = eventRecord.startDate,
        eventEndDate = eventRecord.endDate;

      /* eslint-disable */
      let result = null,
        eventLayout,
        rowEventsLayoutData,
        eventRecordData,
        rowElement,
        rowTop,
        eventElements,
        eventElement,
        eventElOffsets,
        eventElBox;
      /* eslint-enable */

      // Checking if event record is within current time axis timespan and is visible, i.e. it's not rendered
      // within a collapsed row (scheduler supports resource tree store as well as flat resource store).
      if (
        eventStartDate &&
        eventEndDate &&
        (includeOutside || DateHelper.intersectSpans(eventStartDate, eventEndDate, viewStartDate, viewEndDate)) &&
        this.isRowVisible(resourceRecord)
      ) {
        rowElement = me.getRowFor(resourceRecord);

        // If resource row is rendered and displayed
        if (rowElement) {
          // Managed event sizing means that the view is responsible for event height setting, the oposite case
          // is when event height is controlled by CSS's top and height properties.

          // Fast case: managed event sizing on, querying the view for box position and dimensions
          if (me.managedEventSizing) {
            eventLayout = me.currentEventLayout;

            // Preparing events layout data for event layout instance to process
            rowEventsLayoutData = me.eventStore.getEventsForResource(resourceRecord).reduce((result, event) => {
              const eventBox = me[me.mode].getTimeSpanRenderData(event, resourceRecord, includeOutside);

              if (eventBox) {
                result.push(eventBox);
              }
              return result;
            }, []);

            // Processing event layout data injecting event vertical position into each item of `rowEventsLayoutData`
            // This layout application takes into account view's `dynamicRowHeight` property
            eventLayout && eventLayout.applyLayout(rowEventsLayoutData, resourceRecord);

            // Now we are to find our particular event data inside all events data for the given row record
            eventRecordData = rowEventsLayoutData.find((eventData) => eventData.event == eventRecord);

            // We must find our event record corresponding layout data object here, but just to make sure
            if (eventRecordData) {
              // We have event record data with coordinates within the row node, but we need
              // those coordinates to be translated relative to view's viewport top.

              rowTop = me.getRecordCoords(resourceRecord, true).y;

              // Finally we have all the data needed to calculated the event record box
              result = {
                layout: true,
                start: eventRecordData.hasOwnProperty('left') ? eventRecordData.left : eventRecordData.right, // it depends on view's `rtl` configuration
                end:
                  (eventRecordData.hasOwnProperty('left') ? eventRecordData.left : eventRecordData.right) +
                  eventRecordData.width,
                top: rowTop + eventRecordData.top,
                bottom: rowTop + eventRecordData.top + eventRecordData.height
              };
            }
          }
          // Slow case: managed event sizing off, querying the DOM for box position and dimensions
          else {
            eventElements = me.getElementsFromEventRecord(
              eventRecord,
              eventRecord !== resourceRecord && resourceRecord
            );

            // We must have at one and only one element here, but just to make sure
            if (eventElements.length) {
              eventElement = eventElements[0];
              // TODO: PORT getOffsetsTo and getBox
              eventElOffsets = eventElement.getOffsetsTo(me.getEl());
              eventElBox = eventElement.getBox();

              result = {
                layout: true,
                start: eventElOffsets[0],
                end: eventElOffsets[0] + eventElBox.width,
                top: eventElOffsets[1],
                bottom: eventElOffsets[1] + eventElBox.height
              };
            }
          }
        }
        // Resource row is not rendered, and it's not collapsed. We are to calculate event record box approximately.
        else {
          result = {
            layout: false,
            start: me.getCoordinateFromDate(Math.max(eventRecord.startDateMS, me.timeAxis.startMS)),
            end: me.getCoordinateFromDate(Math.min(eventRecord.endDateMS, me.timeAxis.endMS))
            // top and bottom to go
          };

          // Request local record coordinates within the scroll range.
          const recordCoords = me.rowManager.getRecordCoords(resourceRecord, true);
          // faster than Object.assign...
          result.top = recordCoords.y + me.barMargin;
          result.height = Math.max(me.rowManager.rowHeight - 2 * me.barMargin, 1);
          result.bottom = result.top + result.height;
        }

        // Some boxes might need special adjustments
        if (result) {
          result = me.adjustItemBox(eventRecord, result);
        }
      }

      return result;
    }

    //endregion

    //region Item box

    /**
     * Gets box for displayed item designated by the record. If several boxes are displayed for the given item
     * then the method returns all of them. Box coordinates are in view coordinate system.
     *
     * Boxes outside scheduling view timeaxis timespan and inside collapsed rows (if row defining store is a tree store)
     * will not be returned. Boxes outside scheduling view vertical visible area (i.e. boxes above currently visible
     * top row or below currently visible bottom row) will be calculated approximately.
     *
     * @param {Scheduler.model.EventModel} event
     * @return {Object|Object[]}
     * @return {Boolean} return.rendered Whether the box was calculated for the rendered scheduled record or was
     *                                   approximatelly calculated for the scheduled record outside of the current
     *                                   vertical view area.
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @return {String} return.relPos if the item is not rendered then provides a view relative position one of 'before', 'after'
     * @internal
     */
    getItemBox(event, includeOutside = false) {
      return event.resources.map((resource) => this.getResourceEventBox(event, resource, includeOutside));
    }

    /**
     * Adjusts event record box if needed
     *
     * @param {Scheduler.model.EventModel} eventRecord
     * @param {Object} eventRecordBox
     * @return {Number} eventRecordBox.top
     * @return {Number} eventRecordBox.bottom
     * @return {Number} eventRecordBox.start
     * @return {Number} eventRecordBox.end
     * @return {Object}
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @internal
     */
    adjustItemBox(eventRecord, eventRecordBox) {
      const viewStartMS = this.timeAxis.startMS,
        viewEndMS = this.timeAxis.endMS,
        eventStartMS = eventRecord.startDateMS,
        eventEndMS = eventRecord.endDateMS,
        width = this.timeAxisViewModel.totalSize,
        OUTSIDE_VIEW_OFFSET = 40; // To make sure non-relevant dependency lines aren't seen

      // adjust event box to render dependency lines for events that are outside of the view
      if (viewStartMS > eventStartMS) eventRecordBox.start = -OUTSIDE_VIEW_OFFSET;
      if (viewStartMS > eventEndMS) eventRecordBox.end = -OUTSIDE_VIEW_OFFSET;
      if (viewEndMS < eventStartMS) eventRecordBox.start = width + OUTSIDE_VIEW_OFFSET;
      if (viewEndMS < eventEndMS) eventRecordBox.end = width + OUTSIDE_VIEW_OFFSET;

      return eventRecordBox;
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Scheduler/view/mixin/SchedulerState
 */

const copyProperties = [
  'eventLayout',
  'barMargin',
  'mode',
  'tickSize',
  'zoomLevel',
  'eventColor',
  'eventStyle',
  'fillTicks'
];

/**
 * Mixin for Scheduler that handles state. It serializes the following scheduler properties:
 *
 * * eventLayout
 * * barMargin
 * * mode
 * * tickSize
 * * zoomLevel
 * * eventColor
 * * eventStyle
 *
 * See {@link Grid.view.mixin.GridState} and {@link Common.mixin.State} for more information on state.
 *
 * @mixin
 */
var SchedulerState = (Target) =>
  class SchedulerState extends (Target || Base) {
    /**
     * Get schedulers current state for serialization. State includes rowHeight, headerHeight, readOnly, selectedCell,
     * selectedRecordId, column states and store state.
     * @returns {Object} State object to be serialized
     * @private
     */
    getState() {
      return ObjectHelper.copyProperties(super.getState(), this, copyProperties);
    }

    /**
     * Apply previously stored state.
     * @param {Object} state
     * @private
     */
    applyState(state) {
      ObjectHelper.copyProperties(this, state, copyProperties);

      super.applyState(state);
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Scheduler/view/mixin/EventSelection
 */

/**
 * Mixin that tracks event or assignment selection by clicking on one or more events in the scheduler.
 * @mixin
 */
var EventSelection = (Target) =>
  class EventSelection extends (Target || Base) {
    //region Default config

    static get defaultConfig() {
      return {
        /**
         * Configure as `true` to allow `CTRL+click` to select multiple events in the scheduler.
         * @config {Boolean}
         * @category Selection
         */
        multiEventSelect: false,

        /**
         * Configure as `true`, or set property to `true` to disable event selection.
         * @config {Boolean}
         * @category Selection
         */
        eventSelectionDisabled: false,

        /**
         * CSS class to add to selected events.
         * @config {String}
         * @default
         * @category CSS
         * @private
         */
        eventSelectedCls: 'b-sch-event-selected',

        /**
         * Configure as `true` to trigger `selectionChange` when removing a selected event/assignment.
         * @config {Boolean}
         * @default
         * @category Selection
         */
        triggerSelectionChangeOnRemove: false,

        /**
         * This flag controls whether Scheduler should maintain its selection of events when loading a new dataset (if selected event ids are included in the newly loaded dataset).
         * @config {Boolean}
         * @default
         * @category Selection
         */
        maintainSelectionOnDatasetChange: true,

        /**
         * CSS class to add to other instances of a selected event, to highlight them.
         * @config {String}
         * @default
         * @category CSS
         * @private
         */
        eventAssignHighlightCls: 'b-sch-event-assign-selected',

        /**
         * Collection to store selection.
         * @config {Common.util.Collection}
         * @private
         */
        selectedCollection: {}
      };
    }

    //endregion

    //region Events

    /**
     * Fired any time there is a change to the events selected in the Scheduler.
     * @event eventSelectionChange
     * @param {String} action One of the actions 'select', 'deselect', 'update', 'clear'
     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} selected An array of the Events or Assignments added to the selection.
     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} deselected An array of the Events or Assignments removed from the selection.
     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} selection The new selection.
     */

    //endregion

    //region Init

    afterConstruct() {
      super.afterConstruct();

      this.navigator.on({
        navigate: 'onEventNavigate',
        thisObj: this
      });
    }

    //endregion

    //region Selected Collection

    set selectedCollection(selectedCollection) {
      if (!(selectedCollection instanceof Collection)) {
        selectedCollection = new Collection(selectedCollection);
      }
      this._selectedCollection = selectedCollection;

      // Fire row change events from onSelectedCollectionChange
      selectedCollection.on({
        change: 'onSelectedCollectionChange',
        thisObj: this
      });
    }

    get selectedCollection() {
      return this._selectedCollection;
    }

    //endregion

    //region Modify selection

    /**
     * The {@link Scheduler.model.EventModel events} or {@link Scheduler.model.AssignmentModel assignments} which are selected.
     * @returns {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]}
     * @category Selection
     */
    get selectedEvents() {
      return this.selectedCollection.values;
    }

    set selectedEvents(events) {
      // Replace the entire selected collection with the new record set
      this.selectedCollection.splice(0, this.selectedCollection.count, events || []);
    }

    /**
     * Returns `true` if the {@link Scheduler.model.EventModel event} or {@link Scheduler.model.AssignmentModel assignment} is selected.
     * @param {Scheduler.model.EventModel|Scheduler.model.AssignmentModel} event The event or assignment
     * @category Selection
     */
    isEventSelected(event) {
      return this.selectedCollection.includes(event);
    }

    /**
     * Selects the passed {@link Scheduler.model.EventModel event} or {@link Scheduler.model.AssignmentModel assignment}
     * *if it is not selected*.
     * @param {Scheduler.model.EventModel|Scheduler.model.AssignmentModel} event The event or assignment to select. When using multi assignment, supply an AssignmentModel
     * @param {Boolean} [preserveSelection=false] Pass `true` to preserve any other selected events or assignments
     * @category Selection
     */
    selectEvent(event, preserveSelection = false) {
      // If there event is already selected, this is a no-op.
      // In this case, selection must not be cleared even in the absence of preserveSelection
      if (!this.isEventSelected(event)) {
        preserveSelection ? this.selectedCollection.add(event) : (this.selectedEvents = event);
      }
    }

    /**
     * Deselects the passed {@link Scheduler.model.EventModel event} or {@link Scheduler.model.AssignmentModel assignment}
     * *if it is selected*.
     * @param {Scheduler.model.EventModel|Scheduler.model.AssignmentModel} event The event or assignment to deselect. When using multi assignment, supply an AssignmentModel
     * @category Selection
     */
    deselectEvent(event, preserveSelection = false) {
      if (this.isEventSelected(event)) {
        this.selectedCollection.remove(event);
      }
    }

    /**
     * Adds {@link Scheduler.model.EventModel events} or {@link Scheduler.model.AssignmentModel assignments} to the selection.
     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} events Events or assignments to be deselected
     * @category Selection
     */
    selectEvents(events) {
      this.selectedCollection.add(events);
    }

    /**
     * Removes {@link Scheduler.model.EventModel events} or {@link Scheduler.model.AssignmentModel assignments} from the selection.
     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} events Events or assignments  to be deselected
     * @category Selection
     */
    deselectEvents(events) {
      this.selectedCollection.remove(events);
    }

    /**
     * Deselects all {@link Scheduler.model.EventModel events} or {@link Scheduler.model.AssignmentModel assignments}.
     * @category Selection
     */
    clearEventSelection() {
      this.selectedEvents = [];
    }

    setEventSelectedCls(className) {
      this.eventSelectedCls = className;
    }

    //endregion

    //region Events

    /**
     * Responds to mutations of the underlying selection Collection.
     * Keeps the UI synced, eventSelectionChange event is fired when `me.silent` is falsy.
     * @private
     */
    onSelectedCollectionChange({ added, removed }) {
      const me = this,
        selection = me.selectedEvents,
        selected = added || [],
        deselected = removed || [];

      function updateSelection(record, select) {
        const resourceRecord = record.isTask ? record : record.resource,
          eventRecord = record.isAssignment ? record.event : record;

        if (eventRecord) {
          const element = me.getElementFromEventRecord(eventRecord, resourceRecord);

          me.currentOrientation.toggleCls(eventRecord, resourceRecord, me.eventSelectedCls, select);

          if (record.isAssignment) {
            me.getElementsFromEventRecord(eventRecord).forEach((el) => {
              if (el !== element) {
                el.classList[select ? 'add' : 'remove'](me.eventAssignHighlightCls);
              }
            });
          }
        }
      }

      selected.forEach((record) => updateSelection(record, true));
      deselected.forEach((record) => updateSelection(record, false));

      if (!me.silent) {
        me.trigger('eventSelectionChange', {
          action:
            selection.length > 0
              ? selected.length > 0 && deselected.length > 0
                ? 'update'
                : selected.length > 0
                ? 'select'
                : 'deselect'
              : 'clear',
          selection,
          selected,
          deselected
        });
      }
    }

    /**
     * Store data change listener to remove events from selection which are no longer in the store.
     * @private
     */
    onInternalEventStoreChange({ action, records: events, source: eventStore }) {
      super.onInternalEventStoreChange(...arguments);

      const me = this;
      me.silent = !me.triggerSelectionChangeOnRemove;

      if (action === 'remove') {
        me.deselectEvents(events);
      } else if (action === 'dataset') {
        if (!me.maintainSelectionOnDatasetChange) {
          me.clearEventSelection();
        } else {
          me.selectedEvents = me.selectedEvents.filter((event) => eventStore.includes(event));
        }
      }
      me.silent = false;
    }

    /**
     * Assignment change listener to remove events from selection which are no longer in the assignments.
     * @private
     */
    onAssignmentRemove({ records: assignments }) {
      super.onAssignmentRemove(...arguments);

      const me = this;
      me.silent = !me.triggerSelectionChangeOnRemove;
      me.deselectEvents(assignments);
      me.silent = false;
    }

    /**
     * Mouse listener to update selection.
     * @private
     */
    onEventSelectionClick(event, clickedRecord) {
      const me = this;

      // Multi selection: CTRL means preserve selection, just add or remove the event.
      // Single selection: CTRL deselects already selected event
      if (me.isEventSelected(clickedRecord)) {
        event.ctrlKey && me.deselectEvent(clickedRecord, me.multiEventSelect);
      } else {
        me.selectEvent(clickedRecord, event.ctrlKey && me.multiEventSelect);
      }
    }

    /**
     * Navigation listener to update selection.
     * @private
     */
    onEventNavigate({ event, item }) {
      if (!this.eventSelectionDisabled) {
        const me = this,
          record =
            item &&
            (item.nodeType === 1
              ? me.assignmentStore
                ? me.resolveAssignmentRecord(item)
                : me.resolveEventRecord(item)
              : item);
        if (record) {
          me.onEventSelectionClick(event, record);
        }
        // Click outside of an event/assignment;
        else {
          me.clearEventSelection();
        }
      }
    }

    //endregion

    //region Getters/Setters

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}

    //endregion
  };

/**
 * @module Scheduler/view/mixin/EventNavigation
 */

const sortByStartDate = (l, r) => l.startDate - r.startDate,
  preventDefault = (e) => e.preventDefault();

/**
 * Mixin that tracks event or assignment selection by clicking on one or more events in the scheduler.
 * @mixin
 */
var EventNavigation = (Target) =>
  class EventNavigation extends (Target || Base) {
    //region Default config

    static get defaultConfig() {
      return {
        /**
         * A config object to use when creating the {@link Common.helper.util.Navigator}
         * to use to perform keyboard navigation in the timeline.
         * @config {Object}
         * @default
         */
        navigator: null,

        /**
         * A CSS class name to add to focused events.
         * @config {String}
         * @default
         * @category CSS
         * @private
         */
        focusCls: 'b-active',

        /**
         * Allow using [Delete] and [Backspace] to remove events/assignments
         * @config {Boolean}
         * @default
         * @category Misc
         */
        enableDeleteKey: true
      };
    }

    //endregion

    //region Events

    //endregion

    construct(config) {
      const me = this,
        onDeleteKey = FunctionHelper.createThrottled(me.onDeleteKey, 500, me);

      me.isInTimeAxis = me.isInTimeAxis.bind(me);

      super.construct(config);

      const navigatorConfig = ObjectHelper.merge(
        {
          ownerCmp: me,
          target: me.timeAxisSubGridElement,
          processEvent: me.processEvent,
          itemSelector: `.${me.eventCls}-wrap`,
          focusCls: me.focusCls,
          navigatePrevious: FunctionHelper.createThrottled(me.navigatePrevious, 200, me, null, preventDefault),
          navigateNext: FunctionHelper.createThrottled(me.navigateNext, 200, me, null, preventDefault),
          allowCtrlKey: true,
          scrollSilently: true,
          keys: {
            Space: 'onSpaceKey',
            Enter: 'onEnterKey',
            Delete: onDeleteKey,
            Backspace: onDeleteKey
          }
        },
        me.navigator
      );

      me.navigator = new Navigator(navigatorConfig);
    }

    doDestroy() {
      this.navigator.destroy();
      super.doDestroy();
    }

    isInTimeAxis(record) {
      // If event is hidden by workingTime configs, horizontal mapper would raise a flag on instance meta
      // We still need to check if time span is included in axis
      return !record.instanceMeta(this).excluded && this.timeAxis.isTimeSpanInAxis(record);
    }

    /*
     * Override of GridNavigation#focusCell method to handle the TimeAxisColumn.
     * Not needed until we implement full keyboard accessibiliy.
     */
    accessibleFocusCell(cellSelector, options) {
      const me = this;

      cellSelector = me.normalizeCellContext(cellSelector);

      if (cellSelector.columnId === me.timeAxisColumn.id);
      else {
        return super.focusCell(cellSelector, options);
      }
    }

    getPrevious(eventOrAssignmentRecord, isDelete) {
      const me = this,
        resourceStore = me.resourceStore,
        isAssignment = eventOrAssignmentRecord.isAssignment;

      // TODO: https://app.assembla.com/spaces/bryntum/tickets/6526 this class should not know about Gantt.
      if (eventOrAssignmentRecord.isTask) {
        return me.eventStore.getAt(me.eventStore.indexOf(eventOrAssignmentRecord) - 1);
      }

      let resourceRecord =
          eventOrAssignmentRecord.resource || me.eventStore.getResourcesForEvent(eventOrAssignmentRecord)[0],
        resourceEvents = resourceRecord
          .getEvents()
          .filter(me.isInTimeAxis)
          .sort(sortByStartDate),
        eventRecord = isAssignment ? eventOrAssignmentRecord.event : eventOrAssignmentRecord,
        previousEvent = resourceEvents[resourceEvents.indexOf(eventRecord) - 1];

      // At first event for resource, traverse up the resource store.
      if (!previousEvent) {
        // If we are deleting an event, skip other instances of the event which we may encounter
        // due to multi-assignment.
        for (
          let rowIdx = resourceStore.indexOf(resourceRecord) - 1;
          (!previousEvent || (isDelete && previousEvent === eventRecord)) && rowIdx >= 0;
          rowIdx--
        ) {
          resourceRecord = resourceStore.getAt(rowIdx);
          let events = resourceRecord
            .getEvents()
            .filter(me.isInTimeAxis)
            .sort(sortByStartDate);
          previousEvent = events.length && events[events.length - 1];
        }
      }

      // If an assignment was passed, return one
      return isAssignment
        ? me.assignmentStore.getAssignmentForEventAndResource(previousEvent, resourceRecord)
        : previousEvent;
    }

    navigatePrevious(keyEvent) {
      const me = this,
        previousEvent = me.getPrevious(keyEvent.assignmentRecord || keyEvent.eventRecord);

      keyEvent.preventDefault();
      if (previousEvent) {
        if (!keyEvent.ctrlKey) {
          me.clearEventSelection();
        }
        me.navigateTo(previousEvent, keyEvent);
      }
    }

    getNext(eventOrAssignmentRecord, isDelete) {
      const me = this,
        resourceStore = me.resourceStore,
        isAssignment = eventOrAssignmentRecord.isAssignment;

      // TODO: https://app.assembla.com/spaces/bryntum/tickets/6526 this class should not know about Gantt.
      if (eventOrAssignmentRecord.isTask) {
        return me.eventStore.getAt(me.eventStore.indexOf(eventOrAssignmentRecord) + 1);
      }

      let resourceRecord = isAssignment ? eventOrAssignmentRecord.resource : eventOrAssignmentRecord.resources[0], //|| me.eventStore.getResourcesForEvent(eventOrAssignmentRecord)[0],
        resourceEvents = resourceRecord
          .getEvents()
          .filter(me.isInTimeAxis)
          .sort(sortByStartDate),
        eventRecord = isAssignment ? eventOrAssignmentRecord.event : eventOrAssignmentRecord,
        nextEvent = resourceEvents[resourceEvents.indexOf(eventRecord) + 1];

      // At last event for resource, traverse down the resource store
      if (!nextEvent) {
        // If we are deleting an event, skip other instances of the event which we may encounter
        // due to multi-assignment.
        for (
          let rowIdx = resourceStore.indexOf(resourceRecord) + 1;
          (!nextEvent || (isDelete && nextEvent === eventRecord)) && rowIdx < resourceStore.count;
          rowIdx++
        ) {
          resourceRecord = resourceStore.getAt(rowIdx);
          nextEvent = resourceRecord
            .getEvents()
            .filter(me.isInTimeAxis)
            .sort(sortByStartDate)[0];
        }
      }

      // If an assignment was passed, return one
      return isAssignment ? me.assignmentStore.getAssignmentForEventAndResource(nextEvent, resourceRecord) : nextEvent;
    }

    navigateNext(keyEvent) {
      const me = this,
        nextEvent = me.getNext(keyEvent.assignmentRecord || keyEvent.eventRecord);

      keyEvent.preventDefault();
      if (nextEvent) {
        if (!keyEvent.ctrlKey) {
          me.clearEventSelection();
        }
        me.navigateTo(nextEvent, keyEvent);
      }
    }

    navigateTo(targetEvent, uiEvent = {}) {
      const me = this;

      if (targetEvent) {
        // No key processing during scroll
        me.navigator.disabled = true;

        const resource = targetEvent.resource;
        me.scrollResourceEventIntoView(resource, targetEvent.isAssignment ? targetEvent.event : targetEvent, null, {
          animate: 100
        }).then(() => {
          // Panel can be destroyed before promise is resolved
          if (!me.isDestroyed) {
            me.navigator.disabled = false;
            me.activeEvent = targetEvent;
            me.navigator.trigger('navigate', {
              event: uiEvent,
              item: DomHelper.up(me.getElementFromEventRecord(targetEvent, resource), me.navigator.itemSelector)
            });
          }
        });
      }
    }

    set activeEvent(eventOrAssignmentRec) {
      const eventEl = this.getElementFromEventRecord(
        eventOrAssignmentRec.isAssignment ? eventOrAssignmentRec.event : eventOrAssignmentRec,
        eventOrAssignmentRec.resource
      );

      this.navigator.activeItem = eventEl.parentNode;
    }

    get activeEvent() {
      const activeItem = this.navigator.activeItem;

      if (activeItem) {
        return this.resolveEventRecord(activeItem);
      }
    }

    processEvent(keyEvent) {
      const me = this,
        eventElement = DomHelper.up(keyEvent.target, me.eventSelector);

      if (!me.navigator.disabled && eventElement) {
        keyEvent.assignmentRecord = me.resolveAssignmentRecord(eventElement);
        keyEvent.eventRecord = me.resolveEventRecord(eventElement);
        keyEvent.resourceRecord = me.resolveResourceRecord(eventElement);
      }
      return keyEvent;
    }

    onSpaceKey(keyEvent) {
      const targetPoint = Rectangle.from(keyEvent.target).center,
        contextmenuEvent = new MouseEvent(
          'contextmenu',
          Object.assign(
            {
              clientX: targetPoint.x,
              clientY: targetPoint.y
            },
            keyEvent
          )
        );

      Object.defineProperty(contextmenuEvent, 'target', {
        get() {
          return keyEvent.target;
        }
      });
      this.onElementContextMenu(contextmenuEvent);
    }

    onDeleteKey(keyEvent) {
      const record = keyEvent.assignmentRecord || keyEvent.eventRecord;

      if (!this.readOnly && this.enableDeleteKey && record) {
        this.removeRecords([record]);
      }
    }

    removeRecords(records) {
      if (!this.readOnly && records.length) {
        records.forEach((r) => r.remove());
      }
    }

    onEnterKey(keyEvent) {
      // Empty, to be chained by features (used by EventEdit)
    }

    get isActionableLocation() {
      // Override from grid if the Navigator's location is an event (or task if we're in Gantt)
      // Being focused on a task/event means that it's *not* actionable. It's not valid to report
      // that we're "inside" the cell in a TimeLine, so ESC must not attempt to focus the cell.
      if (!this.navigator.activeItem) {
        return super.isActionableLocation;
      }
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
  };

/**
 * @module Scheduler/view/orientation/BaseHorizontalMapper
 */

const emptyObject$3 = {},
  elRange = document.createRange();

function isEventElAvailable(element) {
  return !(element.classList.contains('b-dragging') || element.classList.contains('b-resizing'));
}

/**
 * Base class for task & event rendering in horizontal mode, used by Scheduler and Gantt
 * @private
 * @abstract
 */
class BaseHorizontalMapper extends Delayable(Base) {
  //region Init

  construct(view) {
    const me = this;

    me.view = view;
    me.innerElCls = `${view.eventCls}`;

    me.availableDivs = new Bag();
    me.reservedIds = {};
    me.divCount = 0;
  }

  init() {
    const me = this;

    me.view.rowManager.on({
      beforetranslaterow: me.onBeforeTranslateRow,
      translaterow: me.onTranslateRow,
      beforerowheight: me.onBeforeRowHeightChange,
      thisObj: me
    });

    me.view.on({
      beforetogglenode: me.onBeforeToggleNode,
      togglenode: me.onToggleNode,
      beforetoggleallnodes: me.onBeforeToggleAllNodes,
      toggleallnodes: me.onToggleAllNodes,
      thisObj: me
    });
  }

  //endregion

  //region Helpers

  get column() {
    return this.view.timeAxisColumn;
  }

  get timeAxis() {
    return this.view.timeAxis;
  }

  get timeAxisViewModel() {
    return this.view.timeAxisViewModel;
  }

  translateToPageCoordinate(x) {
    const element = this.column.subGridElement;
    return x + element.getBoundingClientRect().left - element.scrollLeft;
  }

  //endregion

  //Region View hooks

  refreshRows(reLayoutEvents) {
    if (reLayoutEvents) {
      this.cache.clear(this.refreshFromRerender);
      this.view.refreshFromRerender = false;
    }
  }

  // If we dragged an event outside of its rendered block, it will have been released
  // but releaseTimeSpanDiv won't hide it if it has b-dragging, so we have to
  // hide it now.
  onDragAbort(context) {
    if (this.view.currentOrientation.availableDivs.includes(context.element)) {
      context.element.classList.add('b-sch-released');
    }
  }

  onLocaleChange() {
    // Clear events in case they use date as part of displayed info
    this.cache.clear();
  }

  //endregion

  //region Layout & render

  /**
   * Converts a start/endDate into a MS value used when rendering the timeSpan
   * @private
   * @abstract
   */
  calculateMS(timespanRecord) {
    throw new Error('Implement in subclass');
  }

  /**
   * Gets timespan coordinates etc. Relative to containing row. If the timespan is outside of the zone in
   * which timespans are rendered, that is outside of the TimeAxis, or outside of the vertical zone in which timespans
   * are rendered, then `undefined` is returned.
   * @private
   * @param {Scheduler.model.TimeSpan} timeSpan TimeSpan record
   * @param {Common.data.Model} rowRecord Row record
   * @param {Boolean|Object} includeOutside Specify true to get boxes for timespans outside of the rendered zone in both
   * dimensions. This option is used when calculating dependency lines, and we need to include routes from timespans
   * which may be outside the rendered zone.
   * @param {Boolean} includeOutside.timeAxis Pass as `true` to include timespans outside of the TimeAxis's bounds
   * @param {Boolean} includeOutside.viewport Pass as `true` to include timespans outside of the vertical timespan viewport's bounds.
   * @returns {{event/task: *, left: number, width: number, start: (Date), end: (Date), startMs: number, endMs: number, startsOutsideView: boolean, endsOutsideView: boolean}}
   */
  getTimeSpanRenderData(timeSpan, rowRecord, includeOutside = false) {
    const me = this,
      { timeAxis } = me,
      includeOutsideTimeAxis = includeOutside === true || includeOutside.timeAxis,
      includeOutsideViewport = includeOutside === true || includeOutside.viewport;

    // If timespan is outside the TimeAxis, give up trying to calculate a layout (Unless we're including timespans
    // outside our zone)
    if (includeOutsideTimeAxis || timeAxis.isTimeSpanInAxis(timeSpan)) {
      const view = me.view,
        row = view.getRowById(rowRecord);

      // If row is outside the rendered block, we cannot compute a timespan layout.
      if (row) {
        // TODO: buffer size as config
        const scrollTop = view.scrollable.y,
          viewportTop = Math.max(scrollTop - 50, 0),
          viewportBottom = Math.min(scrollTop + view._bodyRectangle.height + 50, view.virtualScrollHeight);

        // If the row is outside the zone in which we render timespans, give up trying to calculate a
        // layout (Unless we're including timespans outside our zone)
        if (
          includeOutsideViewport ||
          (row.top < viewportBottom && row.top + (row.height || row.lastHeight) >= viewportTop)
        ) {
          const pxPerMinute = me.timeAxisViewModel.getSingleUnitInPixels('minute'),
            timespanStart = timeSpan.startDate,
            timespanEnd = timeSpan.endDate || timespanStart, // Allow timespans to be rendered even when they are missing an end date
            viewStartMS = timeAxis.startMS,
            viewEndMS = timeAxis.endMS,
            { startMS, endMS, durationMS } = me.calculateMS(timeSpan),
            startsOutsideView = startMS < viewStartMS,
            endsOutsideView = endMS > viewEndMS,
            durationMinutes = durationMS / (1000 * 60),
            width = endsOutsideView ? pxPerMinute * durationMinutes : null; //view.getCoordinateFromDate(viewStartMS + durationMS),

          let endX,
            startX,
            clippedStart = false,
            clippedEnd = false;

          if (endsOutsideView) {
            endX = view.getCoordinateFromDate(startMS) + width;
          } else {
            endX = view.getCoordinateFromDate(endMS, {
              local: true,
              respectExclusion: true,
              isEnd: true
            });

            clippedEnd = endX === -1;
          }

          // If event starts outside of view, estimate where.
          if (startsOutsideView) {
            startX = ((startMS - viewStartMS) / (1000 * 60)) * pxPerMinute;
          }
          // Starts in view, calculate exactly
          else {
            // If end date is included in time axis but start date is not (when using time axis exclusions), snap start date to next included data
            startX = view.getCoordinateFromDate(startMS, {
              local: true,
              respectExclusion: true,
              isEnd: false,
              snapToNextIncluded: !clippedEnd
            });

            clippedStart = startX === -1;
          }

          if (clippedEnd && !clippedStart) {
            // We know where to start but not where to end, snap it (the opposite is already handled by the
            // snapToNextIncluded flag when calculating startX above)
            endX = view.getCoordinateFromDate(endMS, {
              local: true,
              respectExclusion: true,
              isEnd: true,
              snapToNextIncluded: true
            });
          }

          if (clippedStart && clippedEnd) {
            // Both ends excluded, but there might be some part in between that should be displayed...
            startX = view.getCoordinateFromDate(startMS, {
              local: true,
              respectExclusion: true,
              isEnd: false,
              snapToNextIncluded: true,
              max: endMS
            });

            endX = view.getCoordinateFromDate(endMS, {
              local: true,
              respectExclusion: true,
              isEnd: true,
              snapToNextIncluded: true,
              min: startMS
            });

            if (startX === endX) {
              // Raise flag on instance meta to avoid duplicating this logic
              timeSpan.instanceMeta(view).excluded = true;
              // Excluded by time axis exclusion rules, render nothing
              return null;
            }
          }

          const data = {
            [me.view.scheduledEventName]: timeSpan,
            left: Math.min(startX, endX),
            width: Math.abs(endX - startX),
            start: timespanStart,
            end: timespanEnd,
            startMs: startMS,
            endMs: endMS,
            rowId: rowRecord.id,
            startsOutsideView,
            endsOutsideView,
            clippedStart,
            clippedEnd,
            row
          };

          // If filling ticks we need to also keep datas MS values, since they are used for sorting timespans
          if (me.view.fillTicks) {
            data.dataStartMs = data.start.getTime();
            data.dataEndMs = data.end.getTime();
          }

          // in ExtScheduler this is only checked when managedEventSizing is true, but we need top because of positioning
          data.top = Math.max(0, view.resourceMargin);

          if (view.managedEventSizing) {
            // Timespan height should be at least 1px
            data.height = Math.max(view.rowManager.rowHeight - 2 * view.resourceMargin, 1);
          }

          return data;
        }
      }
    }
  }

  onTranslateRow({ source: row }) {}

  onBeforeRowHeightChange(event) {
    const view = this.view,
      newHeight = event ? event.height : this.rowHeight;

    this.cache.clear();

    // TODO: should move out of here to scheduler
    if (view.foregroundCanvas) {
      view.element.classList.add('b-notransition');
      view.foregroundCanvas.style.fontSize = `${newHeight - view.resourceMargin * 2}px`;

      // We must force a style recalculation so that the next measurement of milestoneWidth
      // gets the new value.
      this._thisIsAUsedExpression(window.getComputedStyle(view.foregroundCanvas).fontSize);
      view.element.classList.remove('b-notransition');
    }

    // The Dependencies feature will have to recalculate its milestoneWidth when it is refreshed next.
    view.milestoneWidth = null;
  }

  onBeforeTranslateRow({ row }) {
    // Triggered before row is repurposed with new record on scroll.
    // Clear layout for the outgoing record.
    this.cache.clearRow(row.id);
  }

  onViewportResize() {
    // Force layout even if scroll positions have not changed.
    this.lastUpdateScrollPos = null;

    // Update the layout.
    this.update();
  }

  // /**
  //  * Called when all rows are rerendered, following a sort operation etc.
  //  * @private
  //  */
  // onBeforeFullRender() {
  //     this.cache.clear();
  // }

  positionTimeSpan(el, x, y) {
    const mode = this.view.eventPositionMode || 'translate';

    switch (mode) {
      case 'position':
        el.style.left = `${x}px`;
        el.style.top = `${y}px`;
        return;
      case 'translate':
        el.style.transform = `translate(${x}px,${y}px)`;
        return;
      case 'translate3d':
        el.style.transform = `translate3d(${x}px,${y}px,0)`;
    }
  }

  getTimeSpanDiv(timeSpanData) {
    const me = this,
      { availableDivs } = me,
      { id, oldId } = timeSpanData;

    if (me.view.eventScrollMode === 'move') {
      let wrapperElement;

      // Allow a TimeSpan to reuse the last div that was assigned to it so that transitions may be used when
      // editing an event. Will fallback to old id, to cover cases where id has changed since last update
      if (id) {
        wrapperElement = availableDivs.get(id) || availableDivs.get(oldId);
      }

      // Do not return it if it's in use by drag/drop or resize
      if (wrapperElement && !isEventElAvailable(wrapperElement)) {
        wrapperElement = null;
      }

      // No element which matches the requested element id available.
      // Just allocate one from the cache which is not being dragged or resized.
      if (!wrapperElement) {
        wrapperElement = availableDivs.find(isEventElAvailable);
      }

      if (wrapperElement) {
        availableDivs.remove(wrapperElement);
        wrapperElement.classList.remove('b-sch-released');
      }
      return wrapperElement;
    }
    return null;
  }

  releaseTimeSpanDiv(div, remainVisible = false) {
    const me = this,
      divStyle = div.style;

    if (me.view.eventScrollMode === 'move') {
      me.availableDivs.add(div);
      if (!remainVisible && isEventElAvailable(div)) {
        div.classList.add('b-sch-released');
      }
    } else {
      if (!remainVisible) {
        divStyle.opacity = 0;
        divStyle.pointerEvents = 'none';
        me.setTimeout(() => {
          div.remove();
          divStyle.opacity = 1;
          divStyle.pointerEvents = '';
        }, 200);
      }
    }
  }

  updateElementId(element, newId) {
    const { availableDivs } = this;

    // Change the id, and move it to the end so that it won't be immediately
    // be consumed by the next request for an element, but is more likely to
    // remain to be found by its original owner TimeSpan
    if (availableDivs.includes(element)) {
      availableDivs.changeId(element, newId);
      // Used to be Collection.move(). Deleting and adding to end of Bags Set to mimic
      availableDivs.items.delete(element);
      availableDivs.items.add(element);
    }
  }

  triggerPaint(data, element) {
    throw new Error('Implement in subclass');
  }

  // forceNewElement is true for newly added events, to not "steal" an element that might be needed later on in the
  // same row (which triggers a transition from that location to the new)
  renderTimeSpan(data, cache, renderedTimeSpan, forceNewElement = false) {
    const me = this,
      view = me.view;

    let { cls, id } = data,
      wrapperElement = cache && cache.div,
      changedDiv = false,
      isDragCreateProxy,
      trigger = false,
      isRepaint = false,
      innerElement = cache && cache.eventEl;

    // TODO: this fn should not need to be called for events already in view, unless there is some update. might give a little better performance

    // No div assigned, reuse one if possible and such mode is used
    if (!forceNewElement && !wrapperElement && (wrapperElement = me.getTimeSpanDiv(data))) {
      // changedDiv means that we're using somebody else's element.
      changedDiv = wrapperElement.id !== id;
    }

    isDragCreateProxy = wrapperElement && wrapperElement.classList.contains('b-sch-dragcreator-proxy');

    // No div assigned or reusing some other TimeSpan's released div
    if (!wrapperElement || changedDiv) {
      // Reusing another TimeSpan's released element.
      // It needs to be emptied.
      if (changedDiv) {
        // If there's no .b-sch-event, then it could be a resourceTimeRange element
        // so just use firstElementChild.
        innerElement = wrapperElement.innerElement || wrapperElement.firstElementChild;
        innerElement.innerHTML = '';
        innerElement.style.cssText = '';
        if (innerElement.nextSibling) {
          elRange.setStartAfter(innerElement);
          elRange.setEndAfter(wrapperElement.lastChild);
          elRange.deleteContents();
        }
      }
      // New element needed
      else {
        [wrapperElement, innerElement] = DomHelper.createElement(
          {
            tabIndex: 0,

            // adding inner div which will be rendered as the event
            children: [
              {
                className: `${me.innerElCls}`
              }
            ]
          },
          true
        );
        // To not have to retrieve it from DOM later
        wrapperElement.innerElement = innerElement;
      }

      wrapperElement.id = id;
      // Add event/task id to wrappers dataset
      if (data[view.scheduledEventName + 'Id']) {
        wrapperElement.dataset[view.scheduledEventName + 'Id'] = data[view.scheduledEventName + 'Id'];
      }

      DomHelper.syncClassList(wrapperElement, data.wrapperCls);

      if (wrapperElement.parentNode !== view.foregroundCanvas) {
        view.foregroundCanvas.appendChild(wrapperElement);
      }

      // set all attributes
      DomHelper.syncClassList(innerElement, cls);
      if (data.style || data.internalStyle) {
        innerElement.style.cssText = (data.internalStyle || '') + (data.style || '');
      }

      // Only update content if the data block has new content in it
      if (data.body) {
        // Clone because this operation has to be repeatable
        innerElement.appendChild(data.body.cloneNode(true));
      }

      // positioning and sizing wrapper
      wrapperElement.style.cssText = `width:${data.width}px;height:${data.height}px;${data.wrapperStyle || ''}`;
      me.positionTimeSpan(wrapperElement, data.left, data.top);

      trigger = true;
    }
    // Reusing TimeSpan's own div - it's a repaint
    else {
      // has div, update attributes if needed.
      const old = renderedTimeSpan && cache.div ? renderedTimeSpan : emptyObject$3;

      innerElement = wrapperElement.querySelector(`.${me.innerElCls}`) || wrapperElement.firstElementChild;

      // We are updating an existing event here, it may have lifecycle classes
      // such as resizing, or terminals visible etc.
      // Surgically update the class list of the elements.
      DomHelper.syncClassList(wrapperElement, data.wrapperCls);
      DomHelper.syncClassList(innerElement, data.cls);

      // TODO: have to apply style on each update when specified, or store it and check if changed
      if (data.style) {
        innerElement.style.cssText = data.style;
      }
      // Clear style, might have changed from having a style to not having
      else {
        innerElement.style.cssText = '';
      }

      // Only update content if the data block has new content in it
      if (data.body) {
        const oldInnerHTML = innerElement.innerHTML,
          // TODO: Not in use? Should be used by labels? Percent bar in gantt? Store them in an array to avoid QSA
          featureEls = innerElement.featureEls; //innerElement.querySelectorAll('[data-feature]');

        if (featureEls) {
          featureEls.forEach((featureEl) => data.body.appendChild(featureEl));
        }
        innerElement.innerHTML = '';

        // Clone because this operation has to be repeatable
        innerElement.appendChild(data.body.cloneNode(true));

        // trigger only if content changed
        trigger = innerElement.innerHTML !== oldInnerHTML;
      }

      // Wrapper element gets the focus class.
      if (document.activeElement && document.activeElement.id === data.id) {
        wrapperElement.classList.add(view.focusCls);
      }

      // updates to wrapper
      isRepaint = true;

      if (data.wrapperStyle) {
        wrapperElement.style.cssText += data.wrapperStyle;
      }

      if (old.left !== data.left || old.top !== data.top || data.style) {
        me.positionTimeSpan(wrapperElement, data.left, data.top);
        trigger = true;
      }
      if (old.width !== data.width || data.style) {
        wrapperElement.style.width = `${data.width}px`;
        trigger = true;
      }
      if (old.height !== data.height || data.style) {
        wrapperElement.style.height = `${data.height}px`;
        trigger = true;
      }
    }

    cache.div = wrapperElement;
    cache.eventEl = innerElement;

    if (trigger) {
      // If we are rendering to a drag-create proxy, it's not a repaint
      if (isRepaint && isDragCreateProxy) {
        isRepaint = false;
        wrapperElement.classList.remove('b-sch-dragcreator-proxy');
      }
      // trigger paint or repaint, for features to hook into
      me.triggerPaint(data, wrapperElement, isRepaint);
    }

    return wrapperElement;
  }

  /**
   * Adds an element for recycling to the event element recycling cache for the passed Event/Task if
   * there is no cache entry. Use this to prevent cache misses and the re-use by
   * event rendering of elements for other events which means that the element would have to be heavily
   * modified.
   * @param {Scheduler.model.TimeSpan} timeSpanRecord The event/task to create an element recycling cache entry for.
   * @param {Scheduler.model.ResourceModel} [resourceRecord] The associated resource record.
   * @param {HTMLElement} [element] The element to add to the element recycling cache under that id.
   */
  cacheTimeSpanElement(timeSpanRecord, resourceRecord, element) {
    const me = this,
      { availableDivs, view } = me,
      timeSpanRecordId = view.getEventRenderId(timeSpanRecord, resourceRecord);

    if (!availableDivs.includes(timeSpanRecordId)) {
      if (element) {
        element.id = timeSpanRecordId;
        view.foregroundCanvas.appendChild(element);
      } else {
        element = DomHelper.createElement({
          id: timeSpanRecordId,
          tabIndex: 0,

          // adding inner div which will be rendered as the event
          children: [
            {
              className: `${me.innerElCls}`
            }
          ]
        });
      }
      availableDivs.add(element);
    }
  }

  updateRowTimeSpans(row, rowRecord, forceLayout = false, fromHorizontalScroll = false) {}

  renderer(renderData) {}

  updateFromHorizontalScroll(scrollLeft) {
    const me = this,
      view = me.view,
      width = view.timeAxisSubGrid.width,
      startDate = view.getDateFromX(Math.max(0, scrollLeft - 100)),
      endDate = view.getDateFromX(scrollLeft + width + 100) || view.timeAxis.endDate,
      x = me.view.timeAxisSubGrid.scrollable.x,
      lastUpdateScrollPos = me.lastUpdateScrollPos;

    // TODO: make buffer width a config, add in correct unit
    me.viewportStart = startDate && startDate.getTime();
    me.viewportEnd = endDate && endDate.getTime();

    // Only rerender all events if we have scrolled horizontally by at least half
    // of the buffer zone above which is 100 pixels.
    if (!lastUpdateScrollPos || Math.abs(x - lastUpdateScrollPos.x) > 50) {
      me.update();
    }
  }

  update() {
    const me = this,
      view = me.view;

    me.lastUpdateScrollPos = {
      x: view.timeAxisSubGrid.scrollable.x,
      y: view.scrollable.y
    };

    for (const row of view.rowManager) {
      const cell = row.getCell(view.timeAxisColumn.id),
        cellData = DomDataStore.get(cell),
        record = view.store.getById(cellData.id);

      if (record) {
        me.updateRowTimeSpans(cellData.row, record, false, true);
      }
    }
  }

  //endregion

  //region Dates

  getDateFromXY(xy, roundingMethod, local) {
    let coord = xy[0];

    if (!local) {
      coord = this.translateToScheduleCoordinate(coord);
    }

    return this.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
  }

  translateToScheduleCoordinate(x) {
    const pos = x - this.column.subGridElement.getBoundingClientRect().left;

    return pos + this.view.scrollLeft;
  }

  //endregion

  //region Store events

  /**
   * User toggled a node in a tree grid, events needs to be redrawn since they might appear/disappear
   * @private
   */
  onBeforeToggleNode({ record }) {
    const me = this,
      childCount = record.children && record.children.length;

    // If there are no children to toggle, we must not clear below the
    // toggling line because there's going to be no upcoming data change to fix it.
    if (childCount) {
      // The node being toggled doesn't need events clearing.
      // It just has its expand/collapse icon toggled.
      let currentRowRecord = me.view.store.getNext(record);

      while (currentRowRecord && me.view.getRowFor(currentRowRecord)) {
        me.cache.clearRow(currentRowRecord.id);
        currentRowRecord = me.view.store.getNext(currentRowRecord.id);
      }
    }

    // Flag to force drawing all events within row buffer, needed since expanding rows do not give them their
    // height right away
    me.togglingNode = true;
  }

  onToggleNode() {
    // Ignore when toggling all nodes
    if (!this.togglingAllNodes) {
      this.togglingNode = false;
    }
  }

  onBeforeToggleAllNodes() {
    this.cache.clear();
    this.togglingAllNodes = this.togglingNode = true;
  }

  onToggleAllNodes() {
    this.togglingAllNodes = this.togglingNode = false;
  }

  // Row updated, clear cache keeping div to animate changes
  onRowRecordUpdate({ record }) {
    this.cache.clearRow(record.id, false, true);
  }

  // Row removed (resource/task), clear cache
  onRowRecordRemove({ records }) {
    // Records might be parents, always traversing makes sure children are also cleared. For leafs, traverse only
    // affects the node itself. If a parent and its children are removed at once, it will still work since clearing
    // cache again has no side effects
    records.forEach((record) => record.traverse((r) => this.cache.clearRow(r.id)));
  }

  //endregion

  //region Region

  /**
   * Gets the Region, relative to the timeline view element, representing the passed row and optionally just for a
   * certain date interval.
   * @param {Common.data.Model} rowRecord The row record
   * @param {Date} startDate A start date constraining the region
   * @param {Date} endDate An end date constraining the region
   * @return {Rectangle} The Rectangle which encapsulates the row
   */
  getRowRegion(rowRecord, startDate, endDate) {
    const { view, column } = this,
      row = view.getRowById(rowRecord.id);

    // might not be rendered
    if (!row) {
      return null;
    }

    let rowElement = row.getElement(column.region),
      taStart = this.timeAxis.startDate,
      taEnd = this.timeAxis.endDate,
      start = startDate ? DateHelper.max(taStart, startDate) : taStart,
      end = endDate ? DateHelper.min(taEnd, endDate) : taEnd,
      startX = view.getCoordinateFromDate(start),
      endX = view.getCoordinateFromDate(end, true, true),
      y = row.top + view.verticalScroller.scrollTop,
      x = Math.min(startX, endX),
      bottom = y + rowElement.offsetHeight;

    return new Rectangle(x, y, Math.max(startX, endX) - x, bottom - y);
  }

  /**
   * Gets the start and end dates for an element rectangle
   * @param {Rectangle} rect The Rectangle to map to start and end dates
   * @param {String} roundingMethod The rounding method to use
   * @returns {Object} an object containing start/end properties
   */
  getStartEndDatesFromRectangle(rect, roundingMethod) {
    const view = this.view,
      leftDate = view.getDateFromCoordinate(rect.x, roundingMethod, true),
      rightDate = view.getDateFromCoordinate(rect.right, roundingMethod, true);

    if (leftDate && rightDate) {
      return {
        start: DateHelper.min(leftDate, rightDate),
        end: DateHelper.max(leftDate, rightDate)
      };
    }

    return null;
  }

  getVisibleDateRange() {
    const view = this.view,
      scrollPos = view.timeAxisSubGrid.scrollable.x,
      width = view.timeAxisSubGrid.width;

    return {
      startDate: view.getDateFromX(scrollPos),
      endDate: view.getDateFromX(scrollPos + width) || view.timeAxis.endDate
    };
  }

  //endregion

  //region Dependency connectors

  /**
   * Gets displaying item start side
   *
   * @param {Scheduler.model.EventModel} eventRecord
   * @return {String} 'left' / 'right' / 'top' / 'bottom'
   */
  getConnectorStartSide(eventRecord) {}

  /**
   * Gets displaying item end side
   *
   * @param {Scheduler.model.EventModel} eventRecord
   * @return {String} 'left' / 'right' / 'top' / 'bottom'
   */
  getConnectorEndSide(eventRecord) {}

  //endregion
}
BaseHorizontalMapper._$name = 'BaseHorizontalMapper';

class HorizontalEventMapperCache {
  constructor(mapper) {
    const me = this;

    me.mapper = mapper;

    // caching layout calculations
    me.renderedEventsMap = {};
    me.rowLayoutCache = {};
  }

  /**
   * Clear event & row layout cache (removes cached layout for all resources and events)
   * @internal
   */
  clear(removeDivs = false) {
    const me = this;

    me.renderedEventsMap = {};
    Object.keys(me.rowLayoutCache).forEach((resourceId) => me.clearRow(resourceId, removeDivs ? 'immediate' : false));
  }

  //region Render data

  addRenderedEvents(resourceId, data) {
    this.renderedEventsMap[resourceId] = data;
  }

  addRenderedEvent(eventData) {
    // If the resource is not layed out (outside of rendered block)
    // then this is a no-op.
    if (eventData.resourceId in this.renderedEventsMap) {
      const resourceRenderedEvents =
        this.renderedEventsMap[eventData.resourceId] || (this.renderedEventsMap[eventData.resourceId] = {});

      resourceRenderedEvents[eventData.id] = eventData;
    }
  }

  getRenderedTimeSpan(resourceId, eventElementId) {
    const resourceRenderedEvents = this.renderedEventsMap[resourceId];

    return resourceRenderedEvents && resourceRenderedEvents[eventElementId];
  }

  clearRenderedTimeSpan(resourceId, eventElementId) {
    const resourceRenderedEvents = this.renderedEventsMap[resourceId];

    if (resourceRenderedEvents) {
      const result = this.renderedEventsMap[resourceId][eventElementId];

      delete this.renderedEventsMap[resourceId][eventElementId];
      return result;
    }
  }

  getRenderedEvents(resourceId) {
    return this.renderedEventsMap[resourceId];
  }

  clearRenderedEvents(resourceId) {
    this.renderedEventsMap[resourceId] = null;
  }

  //endregion

  //region TimeSpans

  getTimeSpan(timeSpanId, rowId) {
    const resourceCache = this.rowLayoutCache[rowId],
      timeSpanCache = resourceCache && resourceCache[timeSpanId];

    if (!timeSpanCache) return null;

    return timeSpanCache.layoutCache;
  }

  /**
   * Clears the event layout for the passed event and resource. Will usually preserve
   * the event DIVs for recycling unless `removeDiv` is passed. If preserving them,
   * it will hide the div unless `remainVisible` is passed.
   * @param {*} eventId ID of event
   * @param {*} resourceId ID of resource
   * @param {*} removeDiv Defaults to false
   * @param {*} remainVisible Defaults to false
   * @private
   */
  clearEvent(eventId, resourceId, removeDiv = false, remainVisible = false) {
    const me = this,
      eventCache = me.getTimeSpan(eventId, resourceId);

    if (!eventCache) return null;

    if (eventCache.div) {
      me.mapper.clearDiv(eventCache.div, removeDiv, remainVisible);
    }

    me.rowLayoutCache[resourceId][eventId].layoutCache = null;
  }

  //endregion

  //region Row

  getRow(resourceId) {
    return this.rowLayoutCache[resourceId];
  }

  addRow(resourceId, data) {
    this.rowLayoutCache[resourceId] = data;
  }

  clearRow(resourceId, removeDivs = false, remainVisible = false) {
    const me = this,
      resourceCache = me.rowLayoutCache[resourceId];

    if (!resourceCache) return;

    if (me.renderedEventsMap[resourceId]) delete me.renderedEventsMap[resourceId];

    Object.keys(resourceCache).forEach((eventId) => {
      if (eventId !== '_allEvents' && eventId !== '_rowHeight') {
        me.clearEvent(eventId, resourceId, removeDivs, remainVisible);
      }
    });
    delete me.rowLayoutCache[resourceId];
  }

  //endregion
}
HorizontalEventMapperCache._$name = 'HorizontalEventMapperCache';

/**
 * @module Scheduler/view/orientation/HorizontalEventMapper
 */

const getStartEnd = (view, timeAxis, date, dateMS, useEnd) => {
  if (view.fillTicks) {
    const tickIndex = Math.floor(timeAxis.getTickFromDate(date)),
      tick = timeAxis.getAt(tickIndex);

    if (tick) {
      return tick[useEnd ? 'endDate' : 'startDate'].getTime();
    }
  }

  return dateMS;
};

/**
 * Handles rendering of events when scheduler uses horizontal mode. The need to interact with this class should be
 * minimal, most functions are called from Scheduler or its mixins.
 * @private
 */
class HorizontalEventMapper extends BaseHorizontalMapper {
  //region Init

  construct(scheduler) {
    this.scheduler = scheduler;

    super.construct(scheduler);

    this.cache = new HorizontalEventMapperCache(this);
  }

  init() {
    const me = this;

    super.init();

    this.scheduler.on({
      togglegroup: me.onToggleGroup,
      rowremove: me.onRowRemove,
      prio: 2,
      thisObj: me
    });
  }

  //endregion

  //region Div reusage

  // called from cache when removing events
  clearDiv(div, remove, remainVisible) {
    const me = this,
      divStyle = div.style;

    if (!remove || remainVisible) {
      me.releaseTimeSpanDiv(div, remainVisible);
    }
    // For example when adding events we remove all existing immediately to not have the new event transition into
    // place by from reusing an existing element. Also want to remove right away when not using event animations.
    else if (remove === 'immediate' || !me.scheduler.enableEventAnimations) {
      div.remove();
    } else {
      // The div doesn't get removed until the opacity transition has done.
      // Avoid id collisions if the event is rerendered immediately.
      // Can't set it to "" because of test requirements.
      div.id = IdHelper.generateId('obsolete-event');
      divStyle.opacity = 0;
      divStyle.pointerEvents = 'none';
      me.setTimeout(() => {
        div.remove();
        divStyle.opacity = 1;
        divStyle.pointerEvents = '';
      }, 200);
    }
  }

  // called from cache when removing events
  clearAllDivs() {
    const me = this;
    me.availableDivs.forEach((div) => div.remove());
    me.availableDivs.clear();
  }

  clearEvents() {
    this.cache.clear(true);
  }

  /**
   * Releases elements for events no longer in view.
   */
  releaseEvent(rowId, timeSpanElementId, remainVisible = false) {
    const me = this,
      timeSpanData = me.cache.getRenderedTimeSpan(rowId, timeSpanElementId),
      cache = timeSpanData && me.cache.getTimeSpan(timeSpanData.eventId, rowId);

    if (cache && cache.div) {
      // release div. remember for reuse, if such mode is used
      me.releaseTimeSpanDiv(cache.div, remainVisible);
      cache.div = cache.eventEl = null;
    }
    return me.cache.clearRenderedTimeSpan(rowId, timeSpanElementId);
  }
  //endregion

  //region Elements

  getElementFromEventRecord(
    eventRecord,
    resourceRecord = this.scheduler.eventStore.getResourcesForEvent(eventRecord)[0]
  ) {
    if (resourceRecord) {
      const renderedRowEvents = this.cache.getRenderedEvents(resourceRecord.id);

      if (renderedRowEvents) {
        const layoutId = this.scheduler.getEventRenderId(eventRecord, resourceRecord),
          layout = renderedRowEvents[layoutId],
          layoutCache = layout && layout.layoutCache;

        return layoutCache && layoutCache.eventEl;
      }
    }
  }

  getElementsFromEventRecord(eventRecord, resourceRecord) {
    const me = this;

    // Single event instance, as array
    if (resourceRecord) {
      return [me.getElementFromEventRecord(eventRecord, resourceRecord)];
    }
    // All instances
    else {
      return me.scheduler.eventStore.getResourcesForEvent(eventRecord).reduce((result, resourceRecord) => {
        const el = me.getElementFromEventRecord(eventRecord, resourceRecord);
        if (el) {
          result.push(el);
        }
        return result;
      }, []);
    }
  }

  resolveRowRecord(elementOrEvent) {
    const me = this,
      { view } = me,
      element = elementOrEvent instanceof Event ? elementOrEvent.target : elementOrEvent,
      // Fix for FF on Linux having text nodes as event.target
      el = element.nodeType === 3 ? element.parentElement : element,
      eventNode = (el.matches(view.eventSelector) && el) || DomHelper.up(el, view.eventSelector);

    if (eventNode) {
      return view.getResourceRecordFromDomId(eventNode.id);
    }

    return view.getRecordFromElement(el);
  }

  toggleCls(eventRecord, resourceRecord, cls, add = true) {
    if (!resourceRecord) {
      return;
    }

    const eventLayout = this.cache.getRenderedTimeSpan(
        resourceRecord.id,
        this.scheduler.getEventRenderId(eventRecord, resourceRecord)
      ),
      element = this.getElementFromEventRecord(eventRecord, resourceRecord);

    if (eventLayout) {
      eventLayout.cls[cls] = add ? 1 : 0;
    }

    if (element) {
      element.classList[add ? 'add' : 'remove'](cls);
    }
  }

  //endregion

  //region Region

  getResourceEventBox(eventId, resourceId) {
    const cached = this.cache.getTimeSpan(eventId, resourceId);
    if (cached) {
      return cached;
    }
  }

  /**
   * Gets the region, relative to the page, represented by the schedule and optionally only for a single resource. This method will call getDateConstraints to
   * allow for additional resource/event based constraints. By overriding that method you can constrain events differently for
   * different resources.
   * @param {Common.data.Model} rowRecord (optional) The row record
   * @param {Scheduler.model.EventModel} eventRecord (optional) The event record
   * @return {Object} The region of the schedule
   */
  getScheduleRegion(rowRecord, eventRecord, local = true) {
    let me = this,
      view = me.view,
      column = me.column,
      region;

    if (rowRecord) {
      const eventElement = eventRecord && me.getElementsFromEventRecord(eventRecord, rowRecord)[0];

      region = Rectangle.from(view.getRowById(rowRecord.id).getElement('locked'));

      if (eventElement) {
        const eventRegion = Rectangle.from(eventElement, column.subGridElement);

        region.y = eventRegion.y;
        region.bottom = eventRegion.bottom;
      } else {
        region.y = region.y + view.resourceMargin;
        region.bottom = region.bottom - view.resourceMargin;
      }
    } else {
      // TODO: This is what the bizarre function that was removed here did.
      // The coordinate space needs to be sorted out here!
      region = Rectangle.from(column.subGridElement).moveTo(null, 0);
      region.width = column.subGridElement.scrollWidth;

      region.y = region.y + view.resourceMargin;
      region.bottom = region.bottom - view.resourceMargin;
    }

    let taStart = me.timeAxis.startDate,
      taEnd = me.timeAxis.endDate,
      dateConstraints = view.getDateConstraints(rowRecord, eventRecord) || {
        start: taStart,
        end: taEnd
      },
      startX = view.getCoordinateFromDate(DateHelper.max(taStart, dateConstraints.start)),
      //startX          = this.translateToPageCoordinate(scheduler.getCoordinateFromDate(DateHelper.max(taStart, dateConstraints.start))),
      endX = view.getCoordinateFromDate(DateHelper.min(taEnd, dateConstraints.end)),
      //endX            = this.translateToPageCoordinate(scheduler.getCoordinateFromDate(DateHelper.min(taEnd, dateConstraints.end))),
      top = region.y,
      bottom = region.bottom;

    if (!local) {
      startX = me.translateToPageCoordinate(startX);
      endX = me.translateToPageCoordinate(endX);
    }

    return { top, right: Math.max(startX, endX), bottom, left: Math.min(startX, endX) };
  }

  getResoureEventBox(eventId, resourceId) {
    return this.cache.getTimeSpan(eventId, resourceId);
  }

  //endregion

  //region Layout & render

  //region Stack & pack

  layoutEventVerticallyStack(bandIndex) {
    const { resourceMargin, rowHeight, barMargin } = this.scheduler;
    return bandIndex === 0
      ? resourceMargin
      : resourceMargin + bandIndex * (rowHeight - resourceMargin * 2) + bandIndex * barMargin;
  }

  layoutEventVerticallyPack(topFraction, heightFraction) {
    const { resourceMargin, rowHeight, barMargin } = this.scheduler,
      // TODO reduce grid row borders when available, https://app.assembla.com/spaces/bryntum/tickets/5840-measure-grid-row-border-at-first-render/details#
      availableHeight = rowHeight - 2 * resourceMargin,
      count = 1 / heightFraction,
      bandIndex = topFraction * count, // "y" within row
      height = (availableHeight - (count - 1) * barMargin) * heightFraction,
      top = resourceMargin + bandIndex * height + bandIndex * barMargin;

    return {
      top,
      height
    };
  }

  //endregion

  /**
   * Converts a start/endDate into a MS value used when rendering the event. If scheduler is configured with
   * `fillTicks: true` the value returned will be snapped to tick start/end.
   * @private
   * @param {Scheduler.model.EventModel} eventRecord
   * @returns {Object} Object of format { startMS, endMS, durationMS }
   */
  calculateMS(eventRecord) {
    const me = this,
      view = me.view;

    let startMS = getStartEnd(view, me.timeAxis, eventRecord.startDate, eventRecord.startDateMS, false),
      endMS = getStartEnd(view, me.timeAxis, eventRecord.endDate, eventRecord.endDateMS, true),
      durationMS = endMS - startMS;

    if (view.milestoneLayoutMode !== 'default' && durationMS === 0) {
      const pxPerMinute = me.timeAxisViewModel.getSingleUnitInPixels('minute'),
        lengthInPx = view.getMilestoneLabelWidth(eventRecord),
        duration = lengthInPx * (1 / pxPerMinute);

      durationMS = duration * 60 * 1000;

      switch (view.milestoneAlign) {
        case 'start':
        case 'left':
          endMS = startMS + durationMS;
          break;
        case 'end':
        case 'right':
          endMS = startMS;
          startMS = endMS - durationMS;
          break;
        default:
          // using center as default
          endMS = startMS + durationMS / 2;
          startMS = endMS - durationMS;
          break;
      }
    }

    return {
      startMS,
      endMS,
      durationMS
    };
  }

  /**
   * Layouts events on a row, caching on each event and the entire result on the resource
   * @private
   * @param {Scheduler.view.Scheduler} scheduler
   * @param {Scheduler.model.ResourceModel} resource
   * @param {Grid.row.Row} row
   * @returns {Boolean} Returns false if no events on row, otherwise true
   */
  layoutEvents(scheduler, resource, row) {
    const me = this,
      { timeAxis } = me,
      { eventStore } = scheduler,
      resourceId = resource.id,
      resourceEvents = eventStore.getEventsForResource(resourceId),
      // When using an AssignmentStore we will get all events for the resource even if the EventStore is filtered,
      // handle this be excluding "invisible" events here
      availableEvents = eventStore.isFiltered
        ? resourceEvents.filter((eventRecord) => eventStore.indexOf(eventRecord) > -1)
        : resourceEvents,
      // Call a chainable template function on scheduler to allow features to add additional "events" to render
      // Currently used by ResourceZones
      allEvents = scheduler.getEventsToRender(resource, availableEvents) || [],
      events = allEvents.filter((e) => timeAxis.isTimeSpanInAxis(e)),
      // Generate layout data for events belonging to current row which are within the TimeAxis
      eventsTplData = events.reduce((result, event) => {
        const eventBox = scheduler.generateTplData(event, resource);

        // Collect layouts of visible events
        if (eventBox) {
          result.push(eventBox);
        }
        // Release events that are no longer visible
        else if (me.cache.getRenderedEvents(resourceId)) {
          me.releaseEvent(resourceId, scheduler.getEventRenderId(event, resource));
        }

        return result;
      }, []);

    // If there are no events within the rendering zone, clear the resource layout cache.
    // Return false to indicate that there's nothing to render.
    if (!eventsTplData.length) {
      me.cache.clearRenderedEvents(resourceId);
      return false;
    }

    // Ensure the events are rendered in natural order so that navigation works.
    eventsTplData.sort(me.eventSorter);

    let rowHeight = scheduler.rowHeight;

    const layout = scheduler.currentEventLayout,
      // Only events and tasks should be considered during layout (not resource time ranges if any)
      layoutEventData = eventsTplData.filter((d) => d.event.isEvent || d.event.isTask);

    // Event data is now gathered, calculate layout properties for each event
    if (scheduler.eventLayout === 'stack') {
      const nbrOfBandsRequired = layout.applyLayout(layoutEventData, resource),
        heightPerEvent = scheduler.rowHeight - scheduler.resourceMargin * 2;

      rowHeight =
        nbrOfBandsRequired * heightPerEvent +
        (nbrOfBandsRequired - 1) * scheduler.barMargin +
        scheduler.resourceMargin * 2;
    } else if (scheduler.eventLayout === 'pack') {
      layout.applyLayout(layoutEventData, resource);
    }

    let absoluteTop = row.top;

    // adjust row top, when it is rendered on top (since in that case top is not known until height is set)
    if (rowHeight !== row.height && row.estimatedTop) {
      absoluteTop = row.top + row.height - rowHeight;
    }

    const cache = {
      _allEvents: eventsTplData,
      _rowHeight: rowHeight
    };

    // cache boxes
    eventsTplData.forEach((data) => {
      const layout = me.cache.getTimeSpan(data.eventId, resourceId),
        relativeTop = data.top;

      data.top += absoluteTop;
      data.rowTop = absoluteTop;

      // ResourceTimeRanges sets this flag to fill the entire row (can't use 100% since it is not actually in the row).
      // Also cant set it in ResourceTimeRanges#onEventDataGenerated since it is called prior to laying out
      if (data.fillSize) {
        data.height = rowHeight;
      }

      // TODO: Include directly in data instead, to simplify cache a wee bit
      // cache layout to not have to recalculate every time
      data.layoutCache = {
        layout: true,
        // reuse div if already assigned (for example when resizing an event)
        div: layout && layout.div,
        eventEl: layout && layout.eventEl,
        width: data.width,
        height: data.height,
        start: data.left,
        end: data.left + data.width,
        relativeTop: relativeTop,
        top: data.top,
        relativeBottom: relativeTop + data.height,
        bottom: data.top + data.height
      };

      cache[data.eventId] = data;
    });

    me.cache.addRow(resourceId, cache);
    //me.resourceLayoutCache[resourceId] = eventsTplData;

    return true;
  }

  // Earlier start dates are above later tasks
  // If same start date, longer tasks float to top
  // If same start + duration, sort by name
  eventSorter(a, b) {
    const startA = a.dataStartMs || a.startMs, // dataXX are used if configured with fillTicks
      endA = a.dataEndMs || a.endMs,
      startB = b.dataStartMs || b.startMs,
      endB = b.dataEndMs || b.endMs,
      sameStart = startA === startB;

    if (sameStart) {
      if (endA - endB === 0) {
        return a.event.name < b.event.name ? -1 : 1;
      }
      return endA > endB ? -1 : 1;
    }

    return startA < startB ? -1 : 1;
  }

  /**
   * Called when rows are translated. Since events "float" on top of everything they must be adjusted if translation
   * changes.
   * @private
   */
  onTranslateRow({ row }) {
    this.matchRowTranslation(row);
  }

  /**
   * Renders a single event, creating a div for it if needed or updates an existing div.
   * @private
   * @param data
   */
  renderEvent(data) {
    const me = this,
      eventIdProperty = me.view.scheduledEventName + 'Id',
      eventId = data[eventIdProperty],
      layoutCache = me.cache.getTimeSpan(eventId, data.resourceId),
      renderedEvents = me.cache.getRenderedEvents(data.resourceId),
      meta = data.event.instanceMeta(me.scheduler),
      // Event might be flagged to require a new element in onEventAdd, but if it is a drag proxy it should still
      // reuse an existing element (it will be correctly linked to the drag proxy element)
      wrapperElement = me.renderTimeSpan(
        data,
        layoutCache,
        renderedEvents[data.id],
        meta.requireElement && !meta.fromDragProxy
      );

    if (data.assignment) {
      wrapperElement.dataset.assignmentId = data.assignment.id;
    }

    // Add event/task id to wrappers dataset
    // Otherwise event element won't have event id property in it's dataset and scheduler
    // won't be able to resolve event by element reference (#8943)
    if (eventId) {
      wrapperElement.dataset[eventIdProperty] = eventId;
    }

    renderedEvents[data.id] = data;

    if (meta.requireElement) {
      delete meta.requireElement;
      delete meta.fromDragProxy;
    }

    // This event is documented on Scheduler
    me.scheduler.trigger('renderEvent', {
      eventRecord: data.event,
      resourceRecord: data.resource,
      assignmentRecord: data.assignment,
      element: wrapperElement,
      tplData: data
    });
  }

  // Overrides fn from baseclass to trigger a paint event with correct params
  triggerPaint(data, element, isRepaint = false) {
    const { scheduler } = this;

    scheduler.trigger(isRepaint ? 'eventRepaint' : 'eventPaint', {
      scheduler,
      eventRecord: data.event,
      resourceRecord: data.resource,
      element
    });
  }

  // We only have to ask this question in the horizontal axis.
  // Vertical rendering is driven fully by the Grid's RowManager
  // rendering and derendering rows.
  isEventInView(eventLayout) {
    // Milestones need to be visible at start & end
    if (eventLayout.startMs === eventLayout.endMs) {
      return eventLayout.startMs <= this.viewportEnd && eventLayout.endMs > this.viewportStart;
    }

    // But normal events do not
    return eventLayout.startMs < this.viewportEnd && eventLayout.endMs > this.viewportStart;
  }

  // Displays events that are in view, hides/recycles those that are no longer
  updateRowTimeSpans(row, resource, forceLayout = false, fromHorizontalScroll = false) {
    const me = this,
      scheduler = me.scheduler,
      resourceId = resource.id;

    let renderedEvents = me.cache.getRenderedEvents(resourceId),
      resourceLayoutCache = me.cache.getRow(resourceId);

    // no need to relayout events if only scrolling horizontally
    if ((scheduler.forceLayout || forceLayout || !resourceLayoutCache) && !me.layoutEvents(scheduler, resource, row)) {
      return (resourceLayoutCache && resourceLayoutCache._rowHeight) || 0;
    }

    // might have been updated above
    resourceLayoutCache = me.cache.getRow(resourceId);

    if (!resourceLayoutCache) return 0;

    const eventsInView = resourceLayoutCache._allEvents.filter(
      (evt) =>
        // Keep events flagged by for example EventDrag
        evt.event.instanceMeta(scheduler).retainElement ||
        // Assignment might also be flagged if used
        (evt.assignment && evt.assignment.instanceMeta(scheduler).retainElement) ||
        // And keep events actually in view :)
        me.isEventInView(evt)
    );

    if (!renderedEvents) {
      renderedEvents = {};
      me.cache.addRenderedEvents(resourceId, renderedEvents);
    }

    // Add events not already in dom or refresh those that are
    for (let i = 0; i < eventsInView.length; i++) {
      const data = eventsInView[i];

      // There are multiple pathways that might lead to the first render of events. This is the first reliable
      // place were we can determine that something will be rendered
      scheduler._firstRenderDone && scheduler._firstRenderDone();

      // Do not render events whose element is retained, or if scrolling horizontally already has an element
      if (
        (!fromHorizontalScroll && !data.event.instanceMeta(scheduler).retainElement) ||
        (fromHorizontalScroll && !data.layoutCache.div)
      ) {
        const animation = scheduler.isFirstRender && data.top < scheduler.bodyHeight && scheduler.useInitialAnimation;

        if (animation) {
          data.wrapperCls.add('b-first-render');
          data.internalStyle = `animation-delay: ${data.row.index / 20}s;`;
        }

        me.renderEvent(data);

        data.wrapperCls['b-first-render'] = null;
      }
    }

    // Remove already rendered events that are now outside of view
    const renderedEventIds = Object.keys(renderedEvents);
    for (let i = 0; i < renderedEventIds.length; i++) {
      const eventId = renderedEventIds[i];
      if (!eventsInView.some((e) => e.id === eventId)) {
        me.releaseEvent(resourceId, eventId);
      }
    }

    return resourceLayoutCache._rowHeight;
  }

  renderer(renderData) {
    // Render the resource's events.
    renderData.size.height = this.updateRowTimeSpans(renderData.row, renderData.record);
  }

  //endregion

  //region Store events

  matchRowTranslation(row) {
    const me = this,
      // Cannot check row.id because translation happens before render, id might not be updated.
      recordId = me.scheduler.store.getAt(row.dataIndex).id,
      resourceCache = me.cache.getRow(recordId),
      first = resourceCache && resourceCache._allEvents.length > 0 && resourceCache._allEvents[0];

    // only update events whose resource has changed top
    if (first && first.rowTop !== row.top) {
      const deltaY = row.top - first.rowTop;
      resourceCache._allEvents.forEach((data) => {
        const eventLayout = data.layoutCache;
        eventLayout.top += deltaY;
        eventLayout.bottom += deltaY;
        if (eventLayout.div) {
          me.positionTimeSpan(eventLayout.div, eventLayout.start, eventLayout.top);
        }

        data.top += deltaY;
        data.rowTop = row.top;
      });
    }
  }

  onTimeAxisViewModelUpdate() {
    // if we do not clear cache, refresh will happen and will use older cache
    // caught by test 012_dragdrop
    this.cache.clear();

    // TODO: this always happen, unnecessary to perform layout prior to this?

    // always update view bounds and redraw events
    this.updateFromHorizontalScroll(this.scheduler.timeAxisSubGrid.scrollable.x);
  }

  // resource removed, move all affected events up
  onRowRemove({ isCollapse }) {
    const { scheduler } = this;

    if (!isCollapse) {
      scheduler.runWithTransition(() => {
        scheduler.rowManager.forEach((row) => this.matchRowTranslation(row));
      });
    }
  }

  /**
   * User toggled a group in a grouped grid, events needs to be redrawn since they might appear/disappear
   * @private
   */
  onToggleGroup({ groupRecord, collapse }) {
    let store = this.scheduler.store,
      // First record in next group
      recordIndex = store.indexOf(groupRecord) + (collapse ? 1 : groupRecord.groupChildren.length);

    // Handle this group
    if (collapse) {
      // Collapsing -> events in the group will be hidden, remove them from cache
      groupRecord.groupChildren.forEach((child) => {
        this.cache.clearRow(child.id);
      });
    }

    // TODO: this should not need to loop til the end, since only events in view are drawn. will be costly with large amount of resources
    // Loop starting at the next group
    for (; recordIndex < store.count; recordIndex++) {
      this.cache.clearRow(store.getAt(recordIndex).id);
    }
  }

  onEventDataset() {
    // Previously dataset would use onEventAdd, but if we get fewer events than we had some will stick around
    // just for the fun of it. Better clear all
    this.cache.clear(true);
  }

  onEventAdd({ records, resources }) {
    let me = this,
      startDate,
      endDate;

    //        me.scheduler.rowManager.averageRowHeight = null; // force recalculation, since moving events might have affected row height

    records.forEach((event) => {
      startDate = event.startDate;
      endDate = event.endDate;

      if (startDate && endDate && me.timeAxis.timeSpanInAxis(startDate, endDate)) {
        const eventResources = event.resources;
        // Flag that this event needs a new element, it should not steal some other released events element because
        // that might lead to a transition. Only set if event will be in view
        if (eventResources && eventResources.some((resource) => me.scheduler.getRowFor(resource))) {
          event.instanceMeta(me.scheduler).requireElement = true;
        }

        // TODO: this does not make sense when adding multiple events, resources are then not tied to the event
        // repaint row only if event is in time axis
        resources.forEach((resource) => {
          this.cache.clearRow(resource.id, false, true);
        });
      }
    });
  }

  onEventRemove({ records, resources }) {
    const me = this;

    // Remove the divs fully since creation now adopts the proxy to use as the event div
    resources.forEach(
      (resource) => me.cache.clearRow(resource.id, true)
      //scheduler.store.getIndex(resource) >= 0 && scheduler.repaintEventsForResource(resource)
    );
  }

  onEventUpdate({ source: eventStore, record: eventRecord, changes = {}, resources }) {
    const me = this,
      resourceWasChanged = 'resourceId' in changes;

    // A change happened to an event missing a resource, do nothing
    if (!resourceWasChanged && !resources.length) return;

    // Moved to another resource, invalidate both old and new (only applies when not using an AssignmentStore)
    if (resourceWasChanged) {
      const oldResource = eventStore.resourceStore.getById(changes.resourceId.oldValue),
        newResource = eventRecord.resource,
        eventRenderedAfterUpdate = newResource && !newResource.placeHolder,
        isVisible = eventRecord.resource && Boolean(me.getTimeSpanRenderData(eventRecord, eventRecord.resource));

      // invalidate old and new resource event layouts
      if (oldResource) {
        const oldLayout = me.cache.getTimeSpan(eventRecord.id, oldResource.id);

        // If the event is layed out for oldResource, that resources needs to be redrawn
        if (oldLayout) {
          // If it's to be rerendered after the change, set the div's
          // id so that after it's returned to the cache, it will be plucked
          // out by the renderer to be reused.
          if (eventRenderedAfterUpdate) {
            // If it has an element, release the div, but release it under the id for
            // which it *will* be used when the cleared resource rows are rerendered.
            if (oldLayout.div && newResource) {
              oldLayout.div.id = me.scheduler.getEventRenderId(eventRecord, newResource);
            }
            me.cache.clearRow(oldResource.id, false, eventRenderedAfterUpdate);
          }
          // If it's not going to be rerendered, dump the div completely
          else {
            me.cache.clearEvent(eventRecord.id, changes.resourceId.oldValue, true);
          }
        }
      }
      // Event was added first and then assigned to a resource (or similar scenario). There will be no div tied to
      // the event and it might reuse an element reserved for some other event (which will transition in to place)
      // TODO: Rework element reusage to always process events with existing elements first and then "new",
      //   when done this workaround and the one in onEventAdd() can be removed
      else if (eventRenderedAfterUpdate) {
        eventRecord.instanceMeta(me.scheduler).requireElement = true;
      }

      eventRenderedAfterUpdate && me.cache.clearRow(newResource.id, false, isVisible);

      // TODO: Not so sure we should throw the average away on account of a single row that might change height,
      //  check if it works good without this/make gradual adjustment
      me.scheduler.rowManager.averageRowHeight = null; // force recalculation, since moving events might have affected row height
    }
    // start or end date changed, need to update layout
    else if ('startDate' in changes || 'endDate' in changes) {
      resources.forEach((resourceRecord) => {
        // Moving events on a row with multiple events might affect those other events, or the height of the row
        // which affects everything below
        if (me.scheduler.eventStore.getEventsForResource(resourceRecord).length > 1) {
          // TODO: Not so sure we should throw the average away on account of a single row that might change height,
          //  check if it works good without this/make gradual adjustment
          me.scheduler.rowManager.averageRowHeight = null;
        }
      });
    }

    resources.forEach((resourceRecord) => {
      const eventLayoutData = me.getTimeSpanRenderData(eventRecord, resourceRecord),
        isVisible = Boolean(eventLayoutData && me.isEventInView(eventLayoutData));

      // Clear cache, avoiding to hide the element if visible
      me.cache.clearRow(resourceRecord.id, false, isVisible);
    });
  }

  onEventClearChanges() {
    this.cache.clear();
  }

  onEventFilter() {
    this.cache.clear();
  }

  onEventRemoveAll() {
    this.view.rowManager.averageRowHeight = null; // force recalculation, since moving events might have affected row height
    this.cache.clear(true);
  }

  //endregion

  //region Dependency connectors

  /**
   * Gets displaying item start side
   *
   * @param {Scheduler.model.EventModel} eventRecord
   * @return {String} 'left' / 'right' / 'top' / 'bottom'
   */
  getConnectorStartSide(eventRecord) {
    return 'left';
  }

  /**
   * Gets displaying item end side
   *
   * @param {Scheduler.model.EventModel} eventRecord
   * @return {String} 'left' / 'right' / 'top' / 'bottom'
   */
  getConnectorEndSide(eventRecord) {
    return 'right';
  }

  //endregion
}
HorizontalEventMapper._$name = 'HorizontalEventMapper';

/**
 * @module Scheduler/eventlayout/VerticalLayout
 */

/**
 * Assists with event layout in vertical mode, handles `eventLayout: none|pack|mixed`
 * @private
 * @mixes Scheduler/eventlayout/PackMixin
 */
class VerticalLayout extends PackMixin() {
  static get defaultConfig() {
    return {
      coordProp: 'leftFactor',
      sizeProp: 'widthFactor'
    };
  }

  // Try to pack the events to consume as little space as possible
  applyLayout(events, columnWidth, resourceMargin, barMargin, columnIndex) {
    super.applyLayout(events, (tplData, clusterIndex, slot, slotSize) => {
      // Stretch events to fill available width
      if (this.scheduler.eventLayout === 'none') {
        tplData.width = columnWidth - resourceMargin * 2;
        tplData.left += resourceMargin;
      } else {
        // Fractions of resource column
        tplData.widthFactor = slotSize;

        const leftFactor = (tplData.leftFactor = slot.start + clusterIndex * slotSize),
          // Number of "columns" in the current slot
          packColumnCount = Math.round(1 / slotSize),
          // Index among those columns for current event
          packColumnIndex = leftFactor / slotSize,
          // Width with all bar margins subtracted
          availableWidth = columnWidth - resourceMargin * 2 - barMargin * (packColumnCount - 1);

        // Allowing two events to overlap? Slightly offset the second
        if (this.scheduler.eventLayout === 'mixed' && packColumnCount === 2) {
          tplData.left += (leftFactor * columnWidth) / 5 + barMargin;
          tplData.width = columnWidth - (leftFactor * columnWidth) / 5 - barMargin * 2;
          tplData.zIndex = 5 + packColumnIndex;
        }
        // Pack by default
        else {
          // Fractional width
          tplData.width = slotSize * availableWidth;
          // Translate to absolute position
          tplData.left += leftFactor * availableWidth + resourceMargin + barMargin * packColumnIndex;
        }
      }
    });
  }
}
VerticalLayout._$name = 'VerticalLayout';

const releaseEventActions = {
    releaseElement: 1, // Not used at all at the moment
    reuseElement: 1 // Used by some other element
  },
  renderEventActions = {
    newElement: 1,
    reuseOwnElement: 1,
    reuseElement: 1
  };

class VerticalEventMapper extends Delayable(Base) {
  //region Config & Init

  static get properties() {
    return {
      eventMap: {},
      resourceMap: {},
      releasedElements: {}
    };
  }

  construct(scheduler) {
    this.scheduler = scheduler;
    this.timeAxisViewModel = scheduler.timeAxisViewModel;
    this.verticalLayout = new VerticalLayout({ scheduler });

    super.construct({});
  }

  init() {
    const me = this,
      { scheduler } = me;

    // Resource header/columns
    me.resourceColumns = scheduler.timeAxisColumn.resourceColumns;
    // Vertical time axis
    me.timeView = scheduler.timeView;

    scheduler.element.classList.add('b-sch-vertical');

    scheduler.on({
      assignmentstorechange: me.onChangeAssignmentStore,
      resourcestorechange: me.onChangeResourceStore,
      thisObj: me
    });

    me.resourceColumns.on({
      columnWidthChange: me.onResourceColumnWidthChange,
      thisObj: me
    });

    me.resourceStore = scheduler.resourceStore;
    me.assignmentStore = scheduler.assignmentStore;

    me.initialized = true;
    me.renderer();

    me.resourceColumns.availableWidth = scheduler.timeAxisSubGrid.width;
  }

  //endregion

  //region Elements <-> Records

  resolveRowRecord(elementOrEvent, xy) {
    const me = this,
      { scheduler } = me,
      event = elementOrEvent instanceof Event ? elementOrEvent : null,
      element = event ? event.target : elementOrEvent,
      coords = event ? [event.offsetX, event.offsetY] : xy,
      // Fix for FF on Linux having text nodes as event.target
      el = element.nodeType === 3 ? element.parentElement : element,
      eventElement = DomHelper.up(el, scheduler.eventSelector);

    if (eventElement) {
      return scheduler.resourceStore.getById(eventElement.dataset.resourceId);
    }

    // Need to be inside schedule at least
    if (!DomHelper.up(element, '.b-sch-timeaxis-cell')) {
      return null;
    }

    const index = Math.floor(coords[0] / me.resourceColumns.columnWidth);

    return scheduler.resourceStore.getAt(index);
  }

  getElementFromEventRecord(eventRecord, resourceRecord) {
    // All elements for event + optionally assigned resource
    const elements = this.getElementsFromEventRecord(eventRecord, resourceRecord);
    // Return first one
    return elements.length ? elements[0] : null;
  }

  getElementsFromEventRecord(eventRecord) {
    // Holds resources for which the event is drawn
    const map = this.eventMap[eventRecord.id];
    // Return the elements for those
    return Object.values(map).map((data) => data.element);
  }

  toggleCls(eventRecord, resourceRecord, cls, add = true) {
    const eventData = ObjectHelper.getPath(this.eventMap, `${eventRecord.id}.${resourceRecord.id}`);

    if (eventData) {
      eventData.tplData.cls[cls] = add ? 1 : 0;

      if (eventData.element) {
        eventData.element.querySelector(this.scheduler.eventInnerSelector).classList[add ? 'add' : 'remove'](cls);
      }
    }
  }

  //endregion

  //region Coordinate <-> Date

  getDateFromXY(xy, roundingMethod, local) {
    let coord = xy[1];

    if (!local) {
      coord = this.translateToScheduleCoordinate(coord);
    }

    return this.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
  }

  translateToScheduleCoordinate(y) {
    return y - this.scheduler._bodyRectangle.y + this.scheduler.scrollTop;
  }

  translateToPageCoordinate(y) {
    return y + this.scheduler._bodyRectangle.y - this.scheduler.scrollTop;
  }

  //endregion

  //region Regions

  getResourceEventBox(eventId, resourceId) {
    let { tplData } = ObjectHelper.getPath(this.eventMap, `${eventId}.${resourceId}`) || {};

    if (!tplData) {
      // Never been in view, lay it out
      this.layoutResource(this.scheduler.resourceStore.getById(resourceId));

      // Have another go at getting the layout data
      tplData = ObjectHelper.getPath(this.eventMap, `${eventId}.${resourceId}`).tplData;
    }

    return tplData
      ? {
          start: tplData.left,
          end: tplData.left + tplData.width,
          top: tplData.top,
          bottom: tplData.bottom
        }
      : null;
  }

  getScheduleRegion(resourceRecord, eventRecord, local) {
    const me = this,
      { scheduler } = me;

    let region = Rectangle.from(scheduler.timeAxisSubGridElement);

    if (resourceRecord) {
      // TODO: How to account for eventRecord here?
      region.left = me.resourceStore.indexOf(resourceRecord) * scheduler.resourceColumnWidth;
      region.right = region.left + scheduler.resourceColumnWidth;
    }

    const start = scheduler.timeAxis.startDate,
      end = scheduler.timeAxis.endDate,
      dateConstraints = scheduler.getDateConstraints(resourceRecord, eventRecord) || {
        start,
        end
      },
      startY = scheduler.getCoordinateFromDate(DateHelper.max(start, dateConstraints.start)),
      endY = scheduler.getCoordinateFromDate(DateHelper.min(end, dateConstraints.end));

    if (!local) {
      region.top = me.translateToPageCoordinate(startY);
      region.bottom = me.translateToPageCoordinate(endY);
    } else {
      region.top = startY;
      region.bottom = endY;
    }

    return region;
  }

  getRowRegion(resourceRecord, startDate, endDate) {
    const me = this,
      { scheduler } = me,
      x = me.resourceStore.indexOf(resourceRecord) * scheduler.resourceColumnWidth,
      taStart = scheduler.timeAxis.startDate,
      taEnd = scheduler.timeAxis.endDate,
      start = startDate ? DateHelper.max(taStart, startDate) : taStart,
      end = endDate ? DateHelper.min(taEnd, endDate) : taEnd,
      startY = scheduler.getCoordinateFromDate(start),
      endY = scheduler.getCoordinateFromDate(end, true, true),
      y = Math.min(startY, endY),
      height = Math.abs(startY - endY);

    return new Rectangle(x, y, scheduler.resourceColumnWidth, height);
  }

  //endregion

  //region Events

  // Column width changed, rerender fully
  onResourceColumnWidthChange({ width, oldWidth }) {
    const me = this,
      { scheduler } = me;

    // Fix width of column & header
    me.resourceColumns.width = scheduler.timeAxisColumn.width = me.resourceStore.count * width;
    me.clearAll();

    // Only transition large changes, otherwise it is janky when dragging slider in demo
    scheduler.runWithTransition(() => me.renderer(), Math.abs(width - oldWidth) > 30);

    // Not detected by resizeobserver? Need to call this for virtual scrolling to react to update
    //        scheduler.callEachSubGrid('refreshFakeScroll');
    //        scheduler.refreshVirtualScrollbars();
  }

  //endregion

  //region EventStore

  onEventStoreChange({ source, action, records, record, replaced, changes }) {
    const me = this,
      eventRecords = records || (record ? [record] : []),
      resourceIds = new Set();

    let transition = true;

    eventRecords.forEach((eventRecord) => {
      eventRecord.resources.forEach((resourceRecord) => resourceIds.add(resourceRecord.id));
    });

    switch (action) {
      // No-ops
      case 'sort':
      case 'group':
      case 'move':
        // Order in EventStore does not matter, so these actions are no-ops
        return;

      case 'dataset':
        me.clearAll();
        transition = false;
        break;

      case 'add':
      case 'remove':
      case 'updateMultiple':
        // Clear all affected resources
        me.clearResources(resourceIds);
        break;

      case 'replace':
        // Gather resources from both the old record and the new one
        replaced.forEach(([oldEvent, newEvent]) => {
          oldEvent.resources.map((resourceRecord) => resourceIds.add(resourceRecord.id));
          newEvent.resources.map((resourceRecord) => resourceIds.add(resourceRecord.id));
        });
        // And clear them
        me.clearResources(resourceIds);
        break;

      case 'removeall':
      case 'filter':
        // Clear all when filtering for simplicity. If that turns out to give bad performance, one would need to
        // figure out which events was filtered out and only clear their resources.
        me.clearAll();
        break;

      case 'update':
        // Removing a resource will unassign events, triggering an update. Ignore this case, since it will be
        // handled by the resource store listener
        if (record.meta.removingResource) {
          return;
        }

        let processed = false;

        // Potentially affecting more elements in the same resource
        if ('startDate' in changes || 'endDate' in changes || 'duration' in changes) {
          me.clearResources(resourceIds);
          processed = true;
        }

        // Moved between resources, redraw both ends (new value already extracted above)
        if ('resourceId' in changes) {
          resourceIds.add(changes.resourceId.oldValue);
          me.clearResources(resourceIds);
          processed = true;
        }

        // "Internal" change, not affecting layout
        if (!processed) {
          const eventDatas = Object.values(me.eventMap[record.id]);
          eventDatas.forEach((eventData) => {
            // Update layout/contents
            const { tplData } = eventData;
            eventData.tplData = me.scheduler.generateTplData(tplData.eventRecord, tplData.resourceRecord);
            eventData.tplData.left = tplData.left;
            eventData.tplData.width = tplData.width;
          });
        }
        break;
    }

    me.scheduler.runWithTransition(() => me.renderer(), transition);
  }

  //endregion

  //region ResourceStore

  // Hook up resource store for the mapper and the resource header
  set resourceStore(store) {
    const me = this;

    me.resourceStoreDetacher && me.resourceStoreDetacher();

    me.resourceColumns.resourceStore = me._resourceStore = store;

    me.resourceStoreDetacher = store.on({
      change: me.onResourceStoreChange,
      refresh: me.onResourceStoreRefresh,
      thisObj: me,
      prio: 1 // Call before others to clear cache before redraw
    });
  }

  get resourceStore() {
    return this._resourceStore;
  }

  onChangeResourceStore({ newResourceStore }) {
    const me = this;

    // Invalidate resource range and events
    me.firstResource = me.lastResource = null;
    me.clearAll();

    me.resourceStore = newResourceStore;

    me.renderer();
  }

  onResourceStoreChange({ source: resourceStore, action, records, record }) {
    const me = this,
      resourceRecords = records || (record ? [record] : []);

    let transition = true;

    // Invalidate resource range
    me.firstResource = me.lastResource = null;

    switch (action) {
      case 'add':
        // Make sure all existing events following added resources are offset correctly
        const firstIndex = resourceRecords.reduce(
          (index, record) => Math.min(index, resourceStore.indexOf(record)),
          resourceStore.count
        );

        for (let i = firstIndex; i < resourceStore.count; i++) {
          me.clearResources([resourceStore.getAt(i).id]);
        }

        return; // Will be redrawn from column width change

      case 'remove':
      case 'removeall':
        // Cannot tell from which index a record was removed, update all.
        me.clearAll();
        return; // Will be redrawn from column width change

      case 'replace':
      case 'update':
        // Only the invalidation above needed
        break;

      case 'filter':
        // All filtered out resources needs clearing and so does those not filtered out since they might have
        // moved horizontally when others hide
        me.clearAll();
        break;
    }

    me.scheduler.runWithTransition(() => me.renderer(), transition);
  }

  onResourceStoreRefresh({ action }) {
    const me = this;

    if (action === 'group') {
      throw new Error('Grouping of resources not supported in vertical mode');
    }

    if (action === 'sort') {
      // Invalidate resource range
      me.firstResource = me.lastResource = null;
      me.clearAll();
      me.scheduler.runWithTransition(() => me.renderer());
    }
  }

  //endregion

  //region AssignmentStore

  // Hook up assignment store for the mapper
  set assignmentStore(store) {
    const me = this;

    me.assignmentStoreDetacher && me.assignmentStoreDetacher();

    me._assignmentStore = store;

    if (store) {
      me.assignmentStoreDetacher = store.on({
        change: me.onAssignmentStoreChange,
        thisObj: me
      });
    }
  }

  get assignmentStore() {
    return this._assignmentStore;
  }

  onChangeAssignmentStore({ newAssignmentStore }) {
    this.assignmentStore = newAssignmentStore;
  }

  onAssignmentStoreChange({ action, records, replaced, record, changes }) {
    const me = this,
      assignmentRecords = records || (record ? [record] : []),
      resourceIds = new Set(assignmentRecords.map((assignmentRecord) => assignmentRecord.resourceId));

    let transition = true;

    switch (action) {
      case 'add':
      case 'remove':
      case 'updateMultiple':
        me.clearResources(resourceIds);
        break;

      case 'filter':
      case 'removeall':
        me.clearAll();
        break;

      case 'replace':
        // Gather resources from both the old record and the new one
        replaced.forEach(([oldAssignment, newAssignment]) => {
          resourceIds.add(oldAssignment.resourceId);
          resourceIds.add(newAssignment.resourceId);
        });
        // And clear them
        me.clearResources(resourceIds);
        break;

      case 'update':
        // When reassigning, clear old resource also
        if ('resourceId' in changes) {
          resourceIds.add(changes.resourceId.oldValue);
        }
        me.clearResources(resourceIds);
        break;
    }

    me.scheduler.runWithTransition(() => me.renderer(), transition);
  }

  //endregion

  //region View hooks

  refreshRows(reLayoutEvents) {
    if (reLayoutEvents) {
      this.clearAll();
      this.scheduler.refreshFromRerender = false;
    }
  }
  updateFromHorizontalScroll(scrollLeft) {
    if (scrollLeft !== this.prevScrollLeft) {
      this.renderer();
      this.prevScrollLeft = scrollLeft;
    }
  }

  updateFromVerticalScroll() {
    this.renderer();
  }

  scrollResourceIntoView(resourceRecord, options) {
    const { scheduler } = this,
      x = scheduler.resourceStore.indexOf(resourceRecord) * scheduler.resourceColumnWidth;

    return scheduler.scrollHorizontallyTo(x, options);
  }

  // Called when viewport size changes
  onViewportResize(width) {
    this.resourceColumns.availableWidth = width;
    this.renderer();
  }

  // Clear events in case they use date as part of displayed info
  onLocaleChange() {
    this.clearAll();
  }

  // No need to do anything special
  onDragAbort() {}

  onBeforeRowHeightChange() {}

  onTimeAxisViewModelUpdate() {}

  clearEvents() {}

  updateElementId() {}

  releaseTimeSpanDiv() {}

  //endregion

  //region Rendering

  // Resources in view + buffer
  get resourceRange() {
    const { scheduler, resourceStore } = this;

    if (!resourceStore || !resourceStore.count) {
      return { firstResource: -1, lastResource: -1 };
    }

    return {
      firstResource: Math.max(Math.floor(scheduler.scrollLeft / scheduler.resourceColumnWidth) - 1, 0),
      lastResource: Math.min(
        Math.floor((scheduler.scrollLeft + scheduler.timeAxisSubGrid.width) / scheduler.resourceColumnWidth) + 1,
        resourceStore.count - 1
      )
    };
  }

  // Dates in view + buffer
  get dateRange() {
    const { scheduler } = this;

    let bottomDate = scheduler.getDateFromCoordinate(
      Math.min(
        scheduler.scrollTop + scheduler.bodyHeight + scheduler.tickSize - 1,
        (scheduler.virtualScrollHeight || scheduler.scrollable.scrollHeight) - 1
      )
    );

    // Might end up below time axis (out of ticks)
    // TODO: Change call order on refresh to make sure this is not needed?
    if (!bottomDate) {
      bottomDate = scheduler.timeAxis.last.endDate;
    }

    return {
      topDate: scheduler.getDateFromCoordinate(Math.max(scheduler.scrollTop - scheduler.tickSize, 0)),
      bottomDate
    };
  }

  getTimeSpanRenderData(eventRecord, resourceRecord, includeOutside = false) {
    const me = this,
      { scheduler } = me,
      { startDate, endDate } = eventRecord,
      top = scheduler.getCoordinateFromDate(startDate),
      // Preliminary values for left & width, used for proxy. Will be changed on layout
      left = me.resourceStore.indexOf(resourceRecord) * scheduler.resourceColumnWidth,
      width = scheduler.resourceColumnWidth - scheduler.resourceMargin * 2,
      startDateMS = startDate.getTime(),
      endDateMS = endDate.getTime();

    let bottom = scheduler.getCoordinateFromDate(endDate),
      height = bottom - top;

    // Below, estimate height
    if (bottom === -1) {
      height = Math.round((endDateMS - startDateMS) * scheduler.timeAxisViewModel.getSingleUnitInPixels('ms'));
      bottom = top + height;
    }

    return {
      eventRecord,
      resourceRecord,
      left,
      top,
      bottom,
      width,
      height,
      startDate,
      endDate,
      startDateMS,
      endDateMS,

      // to match horizontal, TODO: should change there
      start: startDate,
      end: endDate,
      startMs: startDateMS,
      endMs: endDateMS
    };
  }

  // Earlier start dates are above later tasks
  // If same start date, longer tasks float to top
  // If same start + duration, sort by name
  eventSorter(a, b) {
    const startA = a.dataStartMs || a.startDateMS, // dataXX are used if configured with fillTicks
      endA = a.dataEndMs || a.endDateMS,
      startB = b.dataStartMs || b.startDateMS,
      endB = b.dataEndMs || b.endDateMS,
      sameStart = startA === startB;

    if (sameStart) {
      if (endA - endB === 0) {
        return a.eventRecord.name < b.eventRecord.name ? -1 : 1;
      }
      return endA > endB ? -1 : 1;
    }

    return startA < startB ? -1 : 1;
  }

  // Calculate the layout for all events assigned to a resource. Since we are never stacking, the layout of one
  // resource will never affect the others
  layoutResource(resourceRecord) {
    const me = this,
      { scheduler } = me,
      // Cache per resource
      cache = (me.resourceMap[resourceRecord.id] = {}),
      // Resource "column"
      resourceIndex = scheduler.resourceStore.indexOf(resourceRecord);

    // All events for the resource
    let events = scheduler.eventStore.getEventsForResource(resourceRecord);

    // Hook for features to inject additional timespans to render
    events = scheduler.getEventsToRender(resourceRecord, events);

    // Generate template data for all events, used for rendering and layout
    const layoutData = events.reduce((toLayout, eventRecord) => {
      const tplData = scheduler.generateTplData(eventRecord, resourceRecord),
        // Elements will be appended to eventData during syncing
        eventData = { tplData };

      // Cache per event, { e1 : { r1 : { xxx }, r2 : ... }, e2 : ... }
      // Uses tplData.eventId in favor of eventRecord.id to work with ResourceTimeRanges
      ObjectHelper.setPath(me.eventMap, `${tplData.eventId}.${resourceRecord.id}`, eventData);

      // Cache per resource
      cache[tplData.eventId] = eventData;

      // Position ResourceTimeRanges directly, they do not affect the layout of others
      if (tplData.fillSize) {
        tplData.left = resourceIndex * scheduler.resourceColumnWidth;
        tplData.width = scheduler.resourceColumnWidth;
      }
      // Anything not flagged with `fillSize` should take part in layout
      else {
        toLayout.push(tplData);
      }

      return toLayout;
    }, []);

    // Ensure the events are rendered in natural order so that navigation works.
    layoutData.sort(me.eventSorter);

    // Apply per resource event layout (pack, overlap or mixed)
    me.verticalLayout.applyLayout(
      layoutData,
      scheduler.resourceColumnWidth,
      scheduler.resourceMargin,
      scheduler.barMargin,
      resourceIndex
    );

    return cache;
  }

  // Render a single event, aborting if already in DOM. To update an event, first release its element and then render
  // it again. The element will be reused and updated. Keeps code simpler
  renderEvent(eventData) {
    // No point in rendering event that already has an element
    const data = eventData.tplData,
      { resourceRecord, eventRecord } = data,
      // Event element config, applied to existing element or used to create a new one below
      elementConfig = {
        className: data.wrapperCls,
        tabIndex: '0',
        children: [
          {
            className: data.cls,
            style: (data.internalStyle || '') + (data.style || ''),
            // Clone to be repeatable
            html: data.body.cloneNode(true),
            // Used for comparison, cheaper than comparing fragment from above
            compareHtml: data.eventContent
          }
        ],
        style: {
          transform: `translate(${data.left}px, ${data.top}px)`,
          // DomHelper appends px to dimensions when using numbers
          height: data.height,
          width: data.width,
          zIndex: data.zIndex
        },
        dataset: {
          resourceId: resourceRecord.id,
          eventId: data.eventId, // Not using eventRecord.id to distinguish between Event and ResourceTimeRange
          // Sync using assignment id in multi assignment mode or event id in single assignment mode
          syncId: data.assignment ? data.assignment.id : data.eventId
        },
        // Will not be part of DOM, but attached to the element
        elementData: eventData,
        // Dragging etc. flags element as retained, to not reuse/release it during that operation
        retainElement: eventRecord.instanceMeta(this.scheduler).retainElement
      };

    // Do not want to spam dataset with empty prop when not using assignments
    if (data.assignment) {
      elementConfig.dataset.assignmentId = data.assignment.id;
    }

    return elementConfig;
  }

  renderResource(resourceRecord) {
    const me = this,
      // Date at top and bottom for determining which events to include
      { topDateMS, bottomDateMS } = me,
      // Will hold element configs
      syncConfigs = [];

    let resourceEntry = me.resourceMap[resourceRecord.id];

    // Layout all events for the resource unless already done
    if (!resourceEntry) {
      resourceEntry = me.layoutResource(resourceRecord);
    }

    // Iterate over all events for the resource
    for (let eventId in resourceEntry) {
      const eventData = resourceEntry[eventId];
      // Only collect configs for those actually in view
      if (eventData.tplData.endDateMS >= topDateMS && eventData.tplData.startDateMS <= bottomDateMS) {
        syncConfigs.push(me.renderEvent(eventData));
      }
    }

    return syncConfigs;
  }

  // Single cell so only one call to this renderer, determine which events are in view and draw them.
  // Drawing on scroll is triggered by `updateFromVerticalScroll()` and `updateFromHorizontalScroll()`
  renderer() {
    const me = this,
      { scheduler } = me,
      { resourceStore } = scheduler,
      // Determine resource range to draw events for
      { firstResource, lastResource } = me.resourceRange,
      // Date at top and bottom for determining which events to include
      { topDate, bottomDate } = me.dateRange,
      syncConfigs = [];

    if (!me.initialized) {
      return;
    }

    // Update current time range, reflecting the change on the vertical time axis header
    if (!DateHelper.isEqual(topDate, me.topDate) || !DateHelper.isEqual(bottomDate, me.bottomDate)) {
      // Calculated values used by `renderResource()`
      me.topDate = topDate;
      me.bottomDate = bottomDate;
      me.topDateMS = topDate.getTime();
      me.bottomDateMS = bottomDate.getTime();

      me.timeView.range = { topDate, bottomDate };
    }

    if (firstResource !== -1 && lastResource !== -1) {
      // Collect all events for resources in view
      for (let i = firstResource; i <= lastResource; i++) {
        syncConfigs.push.apply(syncConfigs, me.renderResource(resourceStore.getAt(i)));
      }
    }

    DomHelper.sync({
      elementConfig: {
        onlyChildren: true,
        children: syncConfigs
      },
      targetElement: scheduler.foregroundCanvas,
      useSyncId: true,

      // Called by DomHelper when it creates, releases or reuses elements
      callback({ action, config, oldConfig, element }) {
        // If element is an event wrap, trigger appropriate events
        if (config && config.className && config.className[scheduler.eventCls + '-wrap']) {
          const // Some actions are considered first a release and then a render (reusing another element).
            // This gives clients code a chance to clean up before reusing an element
            isRelease = releaseEventActions[action],
            isRender = renderEventActions[action];

          // If we are reusing an element that was previously released we should not trigger again
          if (isRelease && oldConfig) {
            const data = oldConfig.elementData.tplData,
              event = {
                tplData: data,
                assignmentRecord: data.assignment,
                eventRecord: data.eventRecord,
                resourceRecord: data.resourceRecord,
                element
              };
            // This event is documented on Scheduler
            scheduler.trigger('releaseEvent', event);
          }

          if (isRender) {
            const data = config.elementData.tplData,
              event = {
                tplData: data,
                assignmentRecord: data.assignment,
                eventRecord: data.eventRecord,
                resourceRecord: data.resourceRecord,
                element
              };

            // Store element to allow easy mapping from record
            element.elementData.element = element;

            event.reusingElement = action === 'reuseElement';
            // This event is documented on Scheduler
            scheduler.trigger('renderEvent', event);
          }

          // No changes during sync, but might need to hook up element again in case cache was cleared
          if (action === 'none') {
            config.elementData.element = element;
          }
        }
      }
    });

    // Change in displayed resources?
    if (me.firstResource !== firstResource || me.lastResource !== lastResource) {
      // Update header to match
      me.resourceColumns.range = { firstResource, lastResource };

      // Store which resources are currently in view
      me.firstResource = firstResource;
      me.lastResource = lastResource;
    }
  }

  //endregion

  //region Cache

  // Clears cached resource layout
  clearResources(resourceIds) {
    resourceIds.forEach((resourceId) => {
      if (this.resourceMap[resourceId]) {
        Object.keys(this.resourceMap[resourceId]).forEach((eventId) => {
          delete this.eventMap[eventId][resourceId];
        });

        delete this.resourceMap[resourceId];
      }
    });
  }

  clearAll() {
    this.resourceMap = {};
    this.eventMap = {};
  }

  //endregion
}
VerticalEventMapper._$name = 'VerticalEventMapper';

let tpl = TemplateHelper.tpl;

/**
 * @module Scheduler/view/HorizontalTimeAxis
 */

/**
 * A visual representation of the time axis described in the {@link Scheduler.preset.ViewPreset#config-headerConfig headerConfig}.
 * Normally you should not interact with this class directly.
 *
 * @mixes Common/mixin/Events
 * @private
 */
class HorizontalTimeAxis extends Base {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * The minimum width for a bottom row header cell to be considered 'compact', which adds a special CSS class
       * to the row (for special styling).
       * @config {Number}
       * @default
       */
      compactCellWidthThreshold: 15
    };
  }

  //endregion

  //region Init

  headerHtmlRowTpl(data) {
    return tpl`${data.levels.map(
      (level) => tpl`<div class="b-sch-header-row b-sch-header-row-${level.position}" headerPosition="${
        level.position
      }">
                ${level.cells.map(
                  (cell, i) => `<div class="b-sch-header-timeaxis-cell ${cell.headerCellCls}  ${
                    cell.align ? 'b-align-' + cell.align : ''
                  }">${cell.value}</div>
                `
                )}
            </div>`
    )}`;
  }

  //Needed to be CSP compliant
  fixHtmlHeaderStyles(element, levels) {
    levels.forEach((level) => {
      const nodes = DomHelper.children(element, '[headerPosition=' + level.position + '] .b-sch-header-timeaxis-cell');

      nodes.forEach((node, index) => {
        node.style.width = node.style.minWidth = `${level.cells[index].width}px`;
      });
    });
  }

  //endregion

  //region Html & rendering

  // Produces the tables and cells based on the header row config in the active viewPreset
  renderTo(element) {
    const me = this,
      columnConfig = me.model.columnConfig,
      levels = [];

    if (columnConfig.top) {
      levels.push({
        position: 'top',
        cells: columnConfig.top
      });
    }

    if (columnConfig.middle) {
      levels.push({
        position: 'middle',
        cells: columnConfig.middle,
        cls: !columnConfig.bottom && me.model.tickSize <= me.compactCellWidthThreshold ? 'b-sch-header-row-compact' : ''
      });
    }

    if (columnConfig.bottom) {
      levels.push({
        position: 'bottom',
        cells: columnConfig.bottom,
        cls: me.model.tickSize <= me.compactCellWidthThreshold ? 'b-sch-header-row-compact' : ''
      });
    }

    element.innerHTML = me.headerHtmlRowTpl({ levels });

    // TODO clean up when this is fixed: https://app.assembla.com/spaces/bryntum/tickets/8413-horizontaltimeaxis-should-not-completely-overwrite-contents-of-column-el/details#
    const parentEl = element.parentElement;

    [1, 2, 3].forEach((i) => parentEl.classList.remove(`b-sch-timeaxiscolumn-levels-${i}`));

    parentEl.classList.add(`b-sch-timeaxiscolumn-levels-${levels.length}`);

    me.fixHtmlHeaderStyles(element, levels);
  }
  //endregion
}
HorizontalTimeAxis._$name = 'HorizontalTimeAxis';

/**
 * @module Scheduler/view/ResourceHeader
 */

/**
 * Header widget that renders resource column headers and acts as the interaction point for resource columns in vertical
 * mode. Note that it uses virtual rendering and element reusage to gain performance, only headers in view are available
 * in DOM. Because of this you should avoid direct element manipulation, any such changes can be discarded at any time.
 *
 * By default it displays resources `name` and also applies its `iconCls` if any, like this:
 *
 * ```
 * <i class="iconCls">name</i>
 * ```
 *
 * If Scheduler is configured with a {@link Scheduler.view.mixin.SchedulerEventRendering#config-resourceImagePath} the
 * header will render miniatures for the resources, using {@link Scheduler.model.ResourceModel#field-imageUrl} with
 * fallback to {@link Scheduler.model.ResourceModel#field-name} + .jpg for unset values.
 *
 * The contents and styling of the resource cells in the header can be customized using {@link #config-headerRenderer}:
 *
 * ```
 * new Scheduler({
 *     mode            : 'vertical',
 *     resourceColumns : {
 *         headerRenderer : ({ resourceRecord }) => `Hello ${resourceRecord.name}`
 *     }
 * }
 *```
 *
 * The width of the resource columns is determined by the {@link #config-columnWidth} config.
 *
 * @extends Common/widget/Widget
 */
class ResourceHeader extends Widget {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Resource store used to render resource headers. Assigned from Scheduler.
       * @config {Scheduler.data.ResourceStore}
       * @private
       */
      resourceStore: null,

      // TODO: Read this value from CSS as we do with rowHeight?
      /**
       * Width for each resource column
       * @config {Number}
       */
      columnWidth: 150,

      /**
       * Custom header renderer function. Can be used to manipulate the element config used to create the element
       * for the header:
       *
       * ```
       * new Scheduler({
       *   resourceColumns : {
       *     headerRenderer({ elementConfig, resourceRecord }) {
       *       elementConfig.dataset.myExtraData = 'extra';
       *       elementConfig.style.fontWeight = 'bold';
       *     }
       *   }
       * });
       * ```
       *
       * See {@link Common.helper.DomHelper#function-createElement-static DomHelper#createElement()} for more information.
       * Please take care to not break the default configs :)
       *
       * Or as a template by returning HTML from the function:
       *
       * ```
       * new Scheduler({
       *   resourceColumns : {
       *     headerRenderer : ({ resourceRecord }) => `
       *       <div class="my-custom-template">
       *       ${resourceRecord.firstName} {resourceRecord.surname}
       *       </div>
       *     `
       *   }
       * });
       * ```
       *
       * NOTE: When using `headerRenderer` no default internal markup is applied to the resource header cell,
       * `iconCls` and `imageUrl` will have no effect unless you supply custom markup for them.
       *
       * @config {Function}
       * @param {Object} params Object containing the params below
       * @param {Scheduler.model.ResourceModel} resourceRecord Resource whose header is being rendered
       * @param {Object} elementConfig A {@link Common.helper.DomHelper#function-createElement-static} config object used to create the element for the resource
       */
      headerRenderer: null,

      /**
       * Automatically resize resource columns to **fill** available width. Set to `false` to always respect the
       * configured `columnWidth`
       * @config {Boolean}
       * @default
       */
      fillWidth: true,

      /**
       * Automatically resize resource columns to always **fit** available width
       * @config {Boolean}
       * @default
       */
      fitWidth: false,

      // Copied from Scheduler#resourceImagePath on creation in TimeAxisColumn.js
      imagePath: null,

      // Copied from Scheduler#resourceImagePath on creation in TimeAxisColumn.js
      defaultImageName: null
    };
  }

  static get properties() {
    return {
      firstResource: -1,
      lastResource: -1
    };
  }

  //endregion

  //region Init

  construct(config) {
    super.construct(config);

    const me = this;

    if (me.imagePath != null) {
      const missingImgUrl = (me.missingImgUrl = `${me.imagePath}${me.defaultImageName}`);

      // Apply default image on load errors
      EventHelper.on({
        element: me.element,
        delegate: '.b-resource-image',
        capture: true,
        error(event) {
          const { target } = event;

          if (target.src !== target._lastMissingUrl) {
            target._lastMissingUrl = target.src;

            target.src = missingImgUrl;
          }
        }
      });

      // Need to gain some height when displaying images
      me.element.classList.add('b-has-images');
    }
  }

  //endregion

  //region ResourceStore

  set resourceStore(store) {
    const me = this;

    if (store !== me._resourceStore) {
      me.resourceStoreDetacher && me.resourceStoreDetacher();

      me._resourceStore = store;

      me.resourceStoreDatacher = store.on({
        change: 'onResourceStoreDataChange',
        thisObj: me
      });
    }
  }

  get resourceStore() {
    return this._resourceStore;
  }

  // Redraw resource headers on any data change
  onResourceStoreDataChange({ action }) {
    const me = this,
      width = me.resourceStore.count * me.columnWidth;

    if (width !== me.width) {
      me.element.style.width = width + 'px';
      // During setup, silently set the width. It will then render correctly. After setup, let the world know...
      me.column.set('width', width, me.column.grid.isConfiguring);
    }

    if (action === 'removeall') {
      // Keep nothing
      me.element.innerHTML = '';
    }

    if (action === 'remove' || action === 'add' || action === 'filter') {
      me.refreshWidths();
    }
  }

  //endregion

  //region Properties

  get columnWidth() {
    return this._columnWidth;
  }

  set columnWidth(width) {
    const me = this;

    if (width !== me._columnWidth) {
      const oldWidth = me._columnWidth;
      me._columnWidth = width;

      // Flag set in refreshWidths, do not want to create a loop
      if (!me.refreshingWidths) {
        me._originalColumnWidth = width;

        me.refreshWidths();
      }

      if (!me.isConfiguring) {
        me.refresh();
        // Cannot trigger with requested width, might have changed because of fit/fill
        me.trigger('columnWidthChange', { width: me._columnWidth, oldWidth });
      }
    }
  }

  /**
   * Assign to toggle resource columns **fill* mode. `true` means they will stretch (grow) to fill viewport, `false`
   * that they will respect their configured `columnWidth`.
   * @property {Boolean}
   */
  get fillWidth() {
    return this._fillWidth;
  }

  set fillWidth(fill) {
    this._fillWidth = fill;

    this.refreshWidths();
  }

  /**
   * Assign to toggle resource columns **fit* mode. `true` means they will grow or shrink to always fit viewport,
   * `false` that they will respect their configured `columnWidth`.
   * @property {Boolean}
   */
  get fitWidth() {
    return this._fitWidth;
  }

  set fitWidth(fit) {
    this._fitWidth = fit;

    this.refreshWidths();
  }

  get imagePath() {
    return this._imagePath;
  }

  set imagePath(path) {
    this._imagePath = path;

    this.refresh();
  }

  //endregion

  //region Fit to width

  get availableWidth() {
    return this._availableWidth;
  }

  set availableWidth(width) {
    this._availableWidth = width;

    this.refreshWidths();
  }

  // Updates the column widths according to fill and fit settings
  refreshWidths() {
    const me = this,
      { availableWidth, _originalColumnWidth } = me,
      count = me.resourceStore && me.resourceStore.count;

    // Bail out if availableWidth not yet set or resource store not assigned/loaded
    if (!availableWidth || !count) {
      return;
    }

    me.refreshingWidths = true;

    const // Fit width if configured to do so or if configured to fill and used width is less than available width
      fit = me.fitWidth || (me.fillWidth && _originalColumnWidth * count < availableWidth),
      useWidth = fit ? Math.floor(availableWidth / count) : _originalColumnWidth,
      shouldAnimate = me.column.grid.enableEventAnimations && Math.abs(me._columnWidth - useWidth) > 30;

    DomHelper.addTemporaryClass(me.element, 'b-animating', shouldAnimate ? 300 : 0);

    me.columnWidth = useWidth;

    me.refreshingWidths = false;
  }

  //endregion

  //region Rendering

  // Visual resource range, set by VerticalEventMapper
  set range(range) {
    const me = this;

    me.firstResource = range.firstResource;
    me.lastResource = range.lastResource;

    me.refresh();
  }

  /**
   * Refreshes the visible headers
   */
  refresh() {
    const me = this,
      { firstResource, lastResource } = me;

    // Bail out if we are configuring or have no resources to show
    if (
      me.column.grid.isConfiguring ||
      firstResource === -1 ||
      lastResource === -1 ||
      lastResource >= me.resourceStore.count
    ) {
      return;
    }

    const configs = [];

    // Gather element configs for resource headers in view
    for (let i = firstResource; i <= lastResource; i++) {
      const resourceRecord = me.resourceStore.getAt(i),
        elementConfig = {
          // Might look like overkill to use DomClassList here, but can be used in headerRenderer
          className: new DomClassList({
            'b-resourceheader-cell': 1
          }),
          dataset: {
            resourceId: resourceRecord.id
          },
          style: {
            left: i * me.columnWidth,
            width: me.columnWidth
          },
          children: []
        };

      // Let a configured headerRenderer have a go at it before applying
      if (me.headerRenderer) {
        const value = me.headerRenderer({ elementConfig, resourceRecord });
        if (value != null) {
          elementConfig.html = value;
        }
      }
      // No headerRenderer, apply default markup
      else {
        // Optionally displaying a miniature image
        if (me.imagePath != null) {
          const imgSrc = resourceRecord.name
            ? me.imagePath + (resourceRecord.imageUrl || resourceRecord.name.toLowerCase() + '.jpg')
            : me.missingImgUrl;

          elementConfig.children.push({
            tag: 'img',
            className: 'b-resource-image',
            src: imgSrc
          });
        }

        // Optionally displaying an icon
        if (resourceRecord.iconCls) {
          elementConfig.children.push({
            tag: 'i',
            className: resourceRecord.iconCls
          });
        }

        // By default showing resource name
        elementConfig.children.push({
          tag: 'span',
          className: 'b-resource-name',
          html: resourceRecord.name
        });
      }

      configs.push(elementConfig);
    }

    // Sync changes to the header
    DomHelper.sync({
      elementConfig: {
        onlyChildren: true,
        children: configs
      },
      targetElement: me.element,
      useSyncId: 'resourceId'
      // TODO: Add callback here to trigger events when rendering/derendering header cells. Sooner or later
      //  someone is going to ask for a way to render JSX or what not to the header
    });
  }

  //endregion
}
ResourceHeader._$name = 'ResourceHeader';

/**
 * @module Scheduler/column/TimeAxisColumn
 */

/**
 * A column containing the timeline "viewport", in which events, dependencies etc are drawn. Normally you do not need
 * to interact with or create this column, it is handled by Scheduler/Gantt.
 *
 * @extends Grid/column/Column
 */
class TimeAxisColumn extends Events(Column) {
  // region Events
  /**
   * Fires after a click on a time axis cell
   * @event timeAxisHeaderClick
   * @param {Scheduler.column.TimeAxisColumn} column The column object
   * @param {Date} startDate The start date of the header cell
   * @param {Date} endDate The start date of the header cell
   * @param {Event} event The event object
   */

  /**
   * Fires after a double click on a time axis cell
   * @event timeAxisHeaderDblClick
   * @param {Scheduler.column.TimeAxisColumn} column The column object
   * @param {Date} startDate The start date of the header cell
   * @param {Date} endDate The end date of the header cell
   * @param {Event} event The event object
   */

  /**
   * Fires after a right click on a time axis cell
   * @event timeAxisHeaderContextMenu
   * @param {Scheduler.column.TimeAxisColumn} column The column object
   * @param {Date} startDate The start date of the header cell
   * @param {Date} endDate The start date of the header cell
   * @param {Event} event The event object
   */
  //endregion

  //region Init

  constructor(data, store) {
    super(...arguments);

    const me = this;

    me.initialRender = true;
    me.thisObj = me;
    me.timeAxisViewModel = me.timeline.timeAxisViewModel;
    // A bit hacky, because mode is a field and not a config
    // eslint-disable-next-line no-self-assign
    me.mode = me.mode;
  }

  static get autoExposeFields() {
    return true;
  }

  // endregion

  //region Config

  static get fields() {
    return ['mode'];
  }

  static get defaults() {
    return {
      /**
       * Set to false to prevent this column header from being dragged.
       * @config {Boolean} draggable
       * @category Interaction
       * @default false
       */
      draggable: false,

      /**
       * Set to false to prevent grouping by this column.
       * @config {Boolean} groupable
       * @category Interaction
       * @default false
       */
      groupable: false,

      /**
       * Allow column visibility to be toggled through UI.
       * @config {Boolean} hideable
       * @default false
       * @category Interaction
       */
      hideable: false,

      /**
       * Show column picker for the column.
       * @config {Boolean} showColumnPicker
       * @default false
       * @category Menu
       */
      showColumnPicker: false,

      /**
       * Allow filtering data in the column (if Filter feature is enabled)
       * @config {Boolean} filterable
       * @default false
       * @category Interaction
       */
      filterable: false,

      /**
       * Allow sorting of data in the column
       * @config {Boolean} sortable
       * @category Interaction
       * @default false
       */
      sortable: false,

      /**
       * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.
       * @config {Boolean} resizable
       * @default false
       * @category Interaction
       */
      resizable: false,

      /**
       * Allow searching in the column (respected by QuickFind and Search features)
       * @config {Boolean} searchable
       * @default false
       * @category Interaction
       */
      searchable: false,

      /**
       * Specifies if this column should be editable, and define which editor to use for editing cells in the column (if CellEdit feature is enabled)
       * @config {String} editor
       * @default false
       * @category Interaction
       */
      editor: false,

      /**
       * false to prevent showing a context menu on the cell elements in this column
       * @config {Boolean} enableCellContextMenu
       * @default false
       * @category Menu
       */
      enableCellContextMenu: false,

      /**
       * Renderer function for cell tooltips header (used with CellTooltip feature). Specify false to prevent
       * tooltip for that column.
       * @param {HTMLElement} cellElement Cell element
       * @param {Common.data.Model} record Record for cell row
       * @param {Grid.column.Column} column Cell column
       * @param {CellTooltip} cellTooltip Feature instance, used to set tooltip content async
       * @param {MouseEvent} event The event that triggered the tooltip
       * @config {Function} tooltipRenderer
       * @category Rendering
       * @default false
       */
      tooltipRenderer: false,

      /**
       * CSS class added to the header of this column
       * @config {String} cls
       * @category Rendering
       * @default 'b-sch-timeaxiscolumn'
       */
      cls: 'b-sch-timeaxiscolumn',

      // needs to have width specified, flex-basis messes measurements up
      needWidth: true,

      mode: null,

      region: 'normal'
    };
  }

  static get type() {
    return 'timeAxis';
  }

  set mode(mode) {
    const me = this,
      { timeline } = me;

    me.set('mode', mode);

    // In horizontal mode this column has a time axis header on top, with timeline ticks
    if (mode === 'horizontal') {
      me.timeAxisView = new HorizontalTimeAxis({
        model: me.timeAxisViewModel,
        timeAxis: timeline.timeAxis,
        compactCellWidthThreshold: me.compactCellWidthThreshold
      });
    }
    // In vertical mode, it instead displays resources at top
    else if (mode === 'vertical') {
      // TODO: Most other vertical stuff is handled in VerticalEventMapper, move there?
      me.resourceColumns = new ResourceHeader(
        Object.assign(
          {
            column: me,
            resourceStore: timeline.resourceStore,
            imagePath: timeline.resourceImagePath,
            defaultImageName: timeline.defaultResourceImageName
          },
          timeline.resourceColumns || {}
        )
      );
    }
  }

  get mode() {
    return this.get('mode');
  }

  // TODO: define all configs as fields and set below to false...

  /**
   * Get the SubGrid to which this column belongs
   * @property {Grid.view.SubGrid}
   * @private
   */
  set subGrid(subGrid) {
    const me = this;

    me._subGrid = subGrid;

    subGrid.on({
      paint: me.onTimelinePaint,
      thisObj: me,
      once: true
    });
  }

  get subGrid() {
    return this._subGrid;
  }

  /**
   * Get the element for the SubGrid to which this column belongs
   * @property {HTMLElement}
   * @readonly
   * @private
   */
  get subGridElement() {
    return this.subGrid.element;
  }

  //endregion

  //region Events

  onViewModelUpdate({ source: viewModel }) {
    const me = this;

    if (me.mode === 'horizontal') {
      // render the time axis view into the column header element
      me.refreshHeader(true);

      me.width = viewModel.totalSize;

      if (!me.isPainting) {
        me.timeline.refresh();
      }
    } else if (me.mode === 'vertical') {
      if (!me.isPainting) {
        // Refresh to rerender cells, in the process updating the vertical timeaxis to reflect view model changes
        me.timeline.refreshRows();
      }
    }
  }

  // Called on paint. SubGrid has its width so this is the earliest time to configure the TimeAxisViewModel with
  // correct width
  onTimelinePaint() {
    const me = this;

    if (!me.subGrid.insertRowsBefore) {
      return;
    }

    me.isPainting = true;

    me.timeAxisViewModel.on({
      update: me.onViewModelUpdate,
      thisObj: me
    });

    // Upon paint we need to pass the forceUpdate flag in case we are sharing the TimAxisViewModel
    // with another Timeline which will already have done this.
    if (BrowserHelper.isIE11) {
      // subGrid in IE11 doesn't have height at this point, but container element does so we take it from there
      // TODO: make flex element inherit height from parent (min-height: 100% doesn't work)
      me.timeAxisViewModel.update(
        me.mode === 'vertical' ? me.subGrid.element.parentElement.offsetHeight : me.subGrid.width,
        false,
        true
      );
    } else {
      me.timeAxisViewModel.update(me.mode === 'vertical' ? me.subGrid.height : me.subGrid.width, false, true);
    }

    me.subGridElement.classList.add('b-timeline-subgrid');

    EventHelper.on({
      element: me.element,
      thisObj: me,
      click: 'onContainerElementClick',
      dblclick: 'onContainerElementClick',
      contextmenu: 'onContainerElementClick'
    });

    if (me.mode === 'vertical') {
      me.refreshHeader();
    }

    me.isPainting = false;
  }

  //endregion

  //region Rendering

  /**
   * Refreshes the columns header contents (which is either a HorizontalTimeAxis or a ResourceHeader). Useful if you
   * have rendered some extra meta data that depends on external data such as the EventStore or ResourceStore.
   */
  refreshHeader(internal) {
    const me = this,
      { element } = me;

    if (element) {
      if (me.mode === 'horizontal') {
        // Force timeAxisViewModel to regenerate its column config, which calls header renderers etc.
        !internal && me.timeAxisViewModel.update(null, true);
        me.timeAxisView.renderTo(element);
      } else if (me.mode === 'vertical') {
        if (!me.resourceColumns.currentElement) {
          // Do not need the normal header markup
          element.innerHTML = '';
          me.resourceColumns.render(element);
        }

        // Vertical's resourceColumns is redrawn with the events, no need here
      }
    }
  }

  renderer(renderData) {
    return this.timeline.currentOrientation.renderer(renderData);
  }

  //endregion

  // region DOM events
  onContainerElementClick(event) {
    const target = event.target;

    if (target.matches('.b-sch-header-timeaxis-cell')) {
      const index = Array.from(target.parentElement.children).indexOf(target),
        position = target.parentElement.getAttribute('headerPosition'),
        headerConfig = this.timeAxisViewModel.columnConfig[position][index];

      this.trigger('timeAxisHeader' + StringHelper.capitalizeFirstLetter(event.type), {
        startDate: headerConfig.start,
        endDate: headerConfig.end,
        event
      });
    }
  }
  // endregion
}

ColumnStore.registerColumnType(TimeAxisColumn);
TimeAxisColumn._$name = 'TimeAxisColumn';

/**
 * @module Scheduler/view/VerticalTimeAxis
 */

function isLastLevel(level, levels) {
  return level === levels.length - 1;
}

function isLastCell(level, cell) {
  return cell === level.cells[level.cells.length - 1];
}

/**
 * Widget that renders a vertical time axis. Only renders ticks in view. Used in vertical mode.
 * @extends Common/widget/Widget
 * @private
 */
class VerticalTimeAxis extends Widget {
  static get properties() {
    return {
      topDate: null,
      bottomDate: null,
      levels: []
    };
  }

  // Generates element configs for all levels defined by the current ViewPreset
  buildCells() {
    const me = this;

    // noinspection JSSuspiciousNameCombination
    return {
      className: 'b-widget b-verticaltimeaxis',
      style: {
        height: me._height
      },
      children: me.levels.map((level, i) => ({
        className: new DomClassList({
          'b-sch-header-row': 1,
          [`b-sch-header-row-${level.position}`]: 1,
          'b-lowest': isLastLevel(i, me.levels)
        }),
        dataset: {
          tickIndex: i,
          headerPosition: level.position
        },
        // Only include cells in view
        children: level.cells
          .filter((cell) => cell.start < me.bottomDate && cell.end > me.topDate)
          .map((cell) => ({
            className: new DomClassList({
              'b-sch-header-timeaxis-cell': 1,
              [cell.headerCellCls]: cell.headerCellCls,
              [`b-align-${cell.align}`]: cell.align,
              'b-last': isLastCell(level, cell)
            }),
            dataset: {
              tickIndex: cell.index
            },
            style: {
              // DomHelper appends px to numeric dimensions
              top: cell.coord,
              height: cell.width,
              minHeight: cell.width
            },
            children: [
              {
                className: 'b-sch-header-text',
                html: cell.value
              }
            ]
          }))
      }))
    };
  }

  render(targetElement) {
    super.render(targetElement);

    this.refresh(true);
  }

  get height() {
    return this._height;
  }

  // Set visible date range
  set range(range) {
    this.topDate = range.topDate;
    this.bottomDate = range.bottomDate;
    this.refresh();
  }

  /**
   * Refresh the UI
   * @param {Boolean} [rebuild] Specify `true` to force a rebuild of the underlying header level definitions
   */
  refresh(rebuild = !this.levels.length) {
    const me = this,
      { columnConfig } = me.timeAxisViewModel,
      { levels } = me;

    if (rebuild) {
      levels.length = 0;

      if (columnConfig.top) {
        levels.push({
          position: 'top',
          cells: columnConfig.top
        });
      }

      if (columnConfig.middle) {
        levels.push({
          position: 'middle',
          cells: columnConfig.middle
        });
      }

      if (columnConfig.bottom) {
        levels.push({
          position: 'bottom',
          cells: columnConfig.bottom
        });
      }

      me._height = levels[0].cells.reduce((sum, cell) => (sum += cell.width), 0);
    }

    if (!me.topDate || !me.bottomDate) {
      return;
    }

    // Boil down levels to only show what is in view
    DomHelper.sync({
      elementConfig: me.buildCells(),
      targetElement: me.element,
      useSyncId: 'tickIndex'
    });
  }
}
VerticalTimeAxis._$name = 'VerticalTimeAxis';

class VerticalTimeAxisColumn extends Column {
  static get type() {
    return 'verticalTimeAxis';
  }

  static get defaults() {
    return {
      /**
       * Set to false to prevent this column header from being dragged.
       * @config {Boolean} draggable
       * @category Interaction
       * @default false
       * @hide
       */
      draggable: false,

      /**
       * Set to false to prevent grouping by this column.
       * @config {Boolean} groupable
       * @category Interaction
       * @default false
       * @hide
       */
      groupable: false,

      /**
       * Allow column visibility to be toggled through UI.
       * @config {Boolean} hideable
       * @default false
       * @category Interaction
       * @hide
       */
      hideable: false,

      /**
       * Show column picker for the column.
       * @config {Boolean} showColumnPicker
       * @default false
       * @category Menu
       * @hide
       */
      showColumnPicker: false,

      /**
       * Allow filtering data in the column (if Filter feature is enabled)
       * @config {Boolean} filterable
       * @default false
       * @category Interaction
       * @hide
       */
      filterable: false,

      /**
       * Allow sorting of data in the column
       * @config {Boolean} sortable
       * @category Interaction
       * @default false
       * @hide
       */
      sortable: false,

      // /**
      //  * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.
      //  * @config {Boolean} resizable
      //  * @default false
      //  * @category Interaction
      //  * @hide
      //  */
      // resizable : false,

      /**
       * Allow searching in the column (respected by QuickFind and Search features)
       * @config {Boolean} searchable
       * @default false
       * @category Interaction
       * @hide
       */
      searchable: false,

      /**
       * Specifies if this column should be editable, and define which editor to use for editing cells in the column (if CellEdit feature is enabled)
       * @config {String} editor
       * @default false
       * @category Interaction
       * @hide
       */
      editor: false,

      /**
       * false to prevent showing a context menu on the cell elements in this column
       * @config {Boolean} enableCellContextMenu
       * @default false
       * @category Menu
       * @hide
       */
      enableCellContextMenu: false,

      /**
       * Renderer function for cell tooltips header (used with CellTooltip feature). Specify false to prevent
       * tooltip for that column.
       * @param {HTMLElement} cellElement Cell element
       * @param {Common.data.Model} record Record for cell row
       * @param {Grid.column.Column} column Cell column
       * @param {CellTooltip} cellTooltip Feature instance, used to set tooltip content async
       * @param {MouseEvent} event The event that triggered the tooltip
       * @config {Function} tooltipRenderer
       * @category Rendering
       * @default false
       * @hide
       */
      tooltipRenderer: false,

      cellCls: 'b-verticaltimeaxiscolumn'
    };
  }

  constructor(data, store) {
    super(...arguments);

    this.timeAxisViewModel = data.timeline.timeAxisViewModel;
  }

  renderer({ cellElement, size }) {
    const me = this;

    if (!me.view) {
      // I feel a bit bad about assigning this here, but it works...
      me.grid.timeView = me.view = new VerticalTimeAxis({
        timeAxisViewModel: me.timeAxisViewModel
      });
    }

    me.view.render(cellElement);

    size.height = me.view.height;
  }
}

ColumnStore.registerColumnType(VerticalTimeAxisColumn);
VerticalTimeAxisColumn._$name = 'VerticalTimeAxisColumn';

/**
 * @module Scheduler/feature/HeaderContextMenu
 */

/**
 * Adds scheduler specific menu items to the timeline header context menu.
 * By default the menu has the following items:
 * * Filter tasks (if {@link Scheduler.feature.EventFilter EventFilter} is enabled)
 * * Zoom
 * * Date range
 * Can be populated by other features.
 *
 *  * To add extra items to the menu:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         headerContextMenu : {
 *             // Extra items
 *             extraItems : [
 *                 {
 *                     text : 'Extra',
 *                     icon : 'b-fa b-fa-fw b-fa-flag',
 *                     onItem() {
 *                         ...
 *                     }
 *                 }
 *             ]
 *         }
 *     }
 * });
 * ```
 *
 * Manipulate existing menu items in the timeaxis header menu:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         headerContextMenu : {
 *             // Process items before menu is shown
 *             processItems({ items }) {
 *                  // Push an extra item
 *                 items.push({
 *                     text : 'Cool action',
 *                     onItem() {
 *                           // ...
 *                     }
 *                  }
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * This feature is **enabled** by default
 *
 * @extends Common/mixin/InstancePlugin
 * @externalexample scheduler/HeaderContextMenu.js
 * @demo basic
 */
class HeaderContextMenu extends InstancePlugin {
  static get defaultConfig() {
    return {
      /**
       * An array of additional items to add to the menu
       * @config {Object[]}
       * @default
       */
      extraItems: null,

      /**
       * A function called before displaying the menu that allows manipulations of its items. Called with a
       * single parameter with format { eventRecord, resourceRecord, eventElement, items }.
       *
       * ```javascript
       * features : {
       *     headerContextMenu : {
       *         processItems({ items }) {
       *             // Add or remove items here as needed
       *             items.push({ text: 'Some action', icon : 'b-fa b-fa-fw b-fa-ban' })
       *         }
       *     }
       * }
       * ```
       *
       * @config {Function}
       */
      processItems: null
    };
  }

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['getHeaderMenuItems']
    };
  }

  construct(scheduler, config) {
    super.construct(scheduler, config);

    this.scheduler = scheduler;
  }

  /**
   * Populates the header context menu items.
   * @param column Column for which the menu will be shown
   * @param items Array of menu items
   * @internal
   */
  getHeaderMenuItems(column, items) {
    const me = this,
      { scheduler } = me,
      { timeAxis } = scheduler,
      dateStep = {
        magnitude: timeAxis.shiftIncrement,
        unit: timeAxis.shiftUnit
      };

    if (column.type !== 'timeAxis') {
      return;
    }

    items.push({
      text: me.L('pickZoomLevel'),
      icon: 'b-fw-icon b-icon-search-plus',
      disabled: !scheduler.zoomLevels.length,
      menu: {
        type: 'popup',
        items: [
          {
            type: 'slider',
            showValue: false,
            listeners: {
              input: me.onZoomSliderChange,
              thisObj: me
            },
            // set width for IE11
            minWidth: 130
          }
        ],
        onBeforeShow({ source: menu }) {
          const [zoom] = menu.items;

          zoom.min = scheduler.minZoomLevel;
          zoom.max = scheduler.maxZoomLevel;
          zoom.value = scheduler.zoomLevel;
        }
      }
    });

    me.startDateField = new DateField({
      label: me.L('startText'),
      labelWidth: '6em',
      required: true,
      step: dateStep,
      listeners: {
        change: me.onRangeDateFieldChange,
        thisObj: me
      }
    });

    me.endDateField = new DateField({
      label: me.L('endText'),
      labelWidth: '6em',
      required: true,
      step: dateStep,
      listeners: {
        change: me.onRangeDateFieldChange,
        thisObj: me
      }
    });

    items.push({
      text: me.L('activeDateRange'),
      icon: 'b-fw-icon b-icon-calendar',
      menu: {
        type: 'popup',
        width: '20em',
        items: [
          me.startDateField,
          me.endDateField,
          {
            type: 'button',
            cls: 'b-left-nav-btn',
            icon: 'b-icon b-icon-prev',
            color: 'b-blue b-raised',
            flex: 1,
            margin: 0,
            listeners: {
              click: me.onLeftShiftBtnClick,
              thisObj: me
            }
          },
          {
            type: 'button',
            cls: 'b-today-nav-btn',
            color: 'b-blue b-raised',
            text: me.L('todayText'),
            flex: 4,
            margin: '0 8',
            listeners: {
              click: me.onTodayBtnClick,
              thisObj: me
            }
          },
          {
            type: 'button',
            cls: 'b-right-nav-btn',
            icon: 'b-icon b-icon-next',
            color: 'b-blue b-raised',
            flex: 1,
            listeners: {
              click: me.onRightShiftBtnClick,
              thisObj: me
            }
          }
        ],
        onBeforeShow: () => me.initDates()
      }
    });

    if (me.extraItems) {
      items.push.apply(items, me.extraItems);
    }

    let context = { items },
      { processItems } = me;

    // Allow user to process the items
    if (processItems) {
      processItems(context);
    }
  }

  onZoomSliderChange({ value }) {
    this.scheduler.zoomLevel = value;
  }

  initDates() {
    const me = this;

    me.startDateField.suspendEvents();
    me.endDateField.suspendEvents();

    // The actual scheduler start dates may include time, but our Date field cannot currently handle
    // a time portion and throws it away, so when we need the value from an unchanged field, we need
    // to use the initialValue set from the timeAxis values.
    // Until our DateField can optionally include a time value, this is the solution.
    me.startDateField.value = me.startDateFieldInitialValue = me.scheduler.startDate;
    me.endDateField.value = me.endDateFieldInitialValue = me.scheduler.endDate;

    me.startDateField.resumeEvents();
    me.endDateField.resumeEvents();
  }

  onRangeDateFieldChange({ source }) {
    const me = this,
      startDateChanged = source === me.startDateField,
      { client } = me,
      { timeResolution } = client,
      { scrollable } = client.timeAxisSubGrid,
      startDate =
        me.startDateFieldInitialValue && !startDateChanged ? me.startDateFieldInitialValue : me.startDateField.value,
      viewportStartDate = client.getDateFromX(scrollable.x);

    let endDate = me.endDateFieldInitialValue && startDateChanged ? me.endDateFieldInitialValue : me.endDateField.value;

    // When either of the fields is changed, we no longer use its initialValue from the timeAxis start or end
    // so that gets nulled to indicate that it's unavailable and the real field value is to be used.
    if (startDateChanged) {
      me.startDateFieldInitialValue = null;
    } else {
      me.endDateFieldInitialValue = null;
    }

    // Because the start and end dates are exclusive, avoid a zero
    // length time axis by incrementing the end by one tick unit
    // if they are the same.
    if (!(endDate - startDate)) {
      endDate = DateHelper.add(endDate, timeResolution.increment, timeResolution.unit);
    }
    // if start date got bigger than end date set end date to start date plus one tick
    else if (endDate < startDate) {
      endDate = DateHelper.add(startDate, timeResolution.increment, timeResolution.unit);
    }

    me.scheduler.timeAxis.setTimeSpan(startDate, endDate);

    // Keep the visual start time the same
    scrollable.x = client.getCoordinateFromDate(viewportStartDate, true);

    me.initDates();
  }

  onLeftShiftBtnClick() {
    const me = this;

    me.scheduler.timeAxis.shiftPrevious();
    me.initDates();
  }

  onTodayBtnClick() {
    const me = this,
      today = DateHelper.clearTime(new Date());

    me.scheduler.timeAxis.setTimeSpan(today, DateHelper.add(today, 1, 'day'));
    me.initDates();
  }

  onRightShiftBtnClick() {
    const me = this;

    me.scheduler.timeAxis.shiftNext();
    me.initDates();
  }
}

HeaderContextMenu.featureClass = '';

HeaderContextMenu._$name = 'HeaderContextMenu';
GridFeatureManager.registerFeature(HeaderContextMenu, true, ['Scheduler', 'Gantt']);

/**
 * @module Scheduler/feature/ScheduleContextMenu
 */

/**
 * Displays a context menu for empty parts of the schedule. Items are populated in the first place
 * by configurations of this Feature, then by other features and/or application code.
 *
 * To add extra items (Array notation):
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         scheduleContextMenu : {
 *             // Extra items for all events
 *             items : [
 *                 {
 *                     text : 'Extra',
 *                     icon : 'b-fa b-fa-fw b-fa-flag',
 *                     onItem({date, resourceRecord, items}) {
 *                         // Custom date based action
 *                     }
 *                 }
 *             ]
 *         }
 *     }
 * });
 * ```
 *
 * To add extra items (Object notation):
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         scheduleContextMenu : {
 *             // Extra items for all events
 *             items : {
 *                 extraItem : {
 *                     text : 'Extra',
 *                     icon : 'b-fa b-fa-fw b-fa-flag',
 *                     onItem({date, resourceRecord, items}) {
 *                         // Custom date based action
 *                     }
 *                 }
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * To remove existing items:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         scheduleContextMenu : {
 *             items : {
 *                 addEvent : false
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * Manipulate existing menu items:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         scheduleContextMenu : {
 *             // Process items before menu is shown
 *             processItems({date, resourceRecord, items}) {
 *                  // Push an extra item for ancient times
 *                  if (date < new Date(2018, 11, 17)) {
 *                      items.modernize = {
 *                          text : 'Modernize',
 *                          ontItem({date}) {
 *                              // Custom date based action
 *                          }
 *                      };
 *                  }
 *
 *                  // Do not show menu for Sundays
 *                  if (date.getDay() === 0) {
 *                      return false;
 *                  }
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * This feature is **enabled** by default
 *
 * @extends Scheduler/feature/base/TimeSpanRecordContextMenuBase
 */
class ScheduleContextMenu extends TimeSpanRecordContextMenuBase {
  //region Config
  static get defaultConfig() {
    return {
      /**
       * An array of extra menu items to add to the context menu
       *
       * ```javascript
       * const scheduler = new Scheduler({
       *     features : {
       *         scheduleContextMenu : {
       *             // Extra items for all events
       *             items : [
       *                 {
       *                     text : 'Add meeting',
       *                     icon : 'b-fa b-fa-fw b-fa-calendar-plus',
       *                     onItem({ date, resourceRecord }) {
       *                         scheduler.eventStore.add({
       *                             name : 'Meeting',
       *                             startDate : date,
       *                             duration: 2,
       *                             resourceId : resourceRecord.id
       *                         });
       *                     }
       *                 }
       *             ]
       *         }
       *     }
       * });
       * ```
       *
       * or items config to add extra items to the context menu or hide default items
       *
       * ```javascript
       * features : {
       *     scheduleContextMenu : {
       *         items : {
       *             // Add custom 'Add meeting' item
       *             addMeeting : {
       *                 text : 'Add meeting',
       *                 icon : 'b-fa b-fa-fw b-fa-calendar-plus',
       *                 onItem({ date, resourceRecord }) {
       *                     scheduler.eventStore.add({
       *                         name : 'Meeting',
       *                         startDate : date,
       *                         duration: 2,
       *                         resourceId : resourceRecord.id
       *                     });
       *                 }
       *             },
       *             // Hide default 'Add event' item
       *             addEvent : false
       *         }
       *     }
       * }
       * ```
       *
       * @config {Object|Object[]}
       */
      items: null,

      /**
       * A function called before displaying the menu that allows manipulations of its items.
       * Called with a single parameter with format { date, resourceRecord, items }.
       * Returning `false` from this function prevents the menu from being shown.
       *
       * ```javascript
       * const scheduler = new Scheduler({
       *     features : {
       *         scheduleContextMenu : {
       *             // Process items before menu is shown
       *             processItems({date, resourceRecord, items}) {
       *                  // Push an extra item for ancient times
       *                  if (date < new Date(2018, 11, 17)) {
       *                      items.modernize = {
       *                          text : 'Modernize',
       *                          ontItem({date}) {
       *                              // Custom date based action
       *                          }
       *                      };
       *                  }
       *
       *                  // Do not show menu for Sundays
       *                  if (date.getDay() === 0) {
       *                      return false;
       *                  }
       *             }
       *         }
       *     }
       * });
       * ```
       *
       * @config {Function}
       */
      processItems: null,

      /**
       * This is a preconfigured set of {@link Common.widget.Container#config-namedItems} used to create the default context menu.
       *
       * The provided defaultItems setting is
       *
       *```javascript
       *    {
       *        addEvent : true
       *    }
       *```
       *
       * The `namedItems` provided by this feature are listed below. These are the property
       * names which you may configure in the feature's {@link #config-items} config:
       *
       * - `addEvent` Add an event for at the resource and time indicated by the `contextmenu` event.
       *
       * To remove existing items, set corresponding keys to `false`
       *
       * ```javascript
       * const scheduler = new Scheduler({
       *     features : {
       *         scheduleContextMenu : {
       *             items : {
       *                 addEvent : false
       *             }
       *         }
       *     }
       * });
       * ```
       *
       * @config {Object}
       */
      defaultItems: {
        addEvent: true
      }
    };
  }

  //endregion

  //region Events

  /**
   * Fired from scheduler before the context menu is shown for an event. Allows manipulation of the items
   * to show in the same way as in `processItems`. Returning false from a listener prevents the menu from
   * being shown.
   * @event scheduleContextMenuBeforeShow
   * @preventable
   * @param {Scheduler.view.Scheduler} source
   * @param {Object} items Menu item configs
   * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered
   * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
   * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used
   * @param {HTMLElement} eventElement
   */

  /**
   * Fired from scheduler when an item is selected in the context menu.
   * @event scheduleContextMenuItem
   * @param {Scheduler.view.Scheduler} source
   * @param {Common.widget.MenuItem} item
   * @param {Scheduler.model.EventModel} eventRecord
   * @param {Scheduler.model.ResourceModel} resourceRecord
   * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used
   * @param {HTMLElement} eventElement
   */

  /**
   * Fired from scheduler after showing the context menu for an event
   * @event scheduleContextMenuShow
   * @preventable
   * @param {Scheduler.view.Scheduler} source
   * @param {Common.widget.Menu} menu The menu
   * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered
   * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
   * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used
   * @param {HTMLElement} eventElement
   */

  //endregion

  //region Init

  construct(scheduler, config) {
    super.construct(scheduler, config);

    this.scheduler = scheduler;
  }

  //endregion

  //region Events

  onElementContextMenu(event) {
    const scheduler = this.scheduler,
      cellData = scheduler.getEventData(event),
      isTimeAxisColumn = cellData
        ? scheduler.columns.getById(cellData.columnId) === scheduler.timeAxisColumn
        : scheduler.timeAxisSubGrid.element === event.target,
      // For vertical mode the resource must be resolved from the event
      resourceRecord = scheduler.resolveResourceRecord(event) || scheduler.resourceStore.last;

    if (isTimeAxisColumn) {
      this.showContextMenu({
        menuType: 'schedule',
        date: scheduler.getDateFromDomEvent(event, 'floor'),
        resourceRecord,
        event
      });

      event.preventDefault();
    }
  }

  //endregion

  get namedItems() {
    const client = this.client;

    if (!this._namedItems) {
      this._namedItems = {
        addEvent: {
          text: client.L('Add event', null),
          icon: 'b-icon b-icon-add',
          disabled: client.resourceStore.count === 0,
          weight: 100,
          onItem({ date, resourceRecord }) {
            client.internalAddEvent(date, resourceRecord, client.getRowFor(resourceRecord));
          }
        }
      };
    }

    return this._namedItems;
  }
}

ScheduleContextMenu.featureClass = '';

ScheduleContextMenu._$name = 'ScheduleContextMenu';
GridFeatureManager.registerFeature(ScheduleContextMenu, true, 'Scheduler');

/**
 * @module Scheduler/feature/ScheduleTooltip
 */

/**
 * Feature that displays a tooltip containing the time at the mouse position when hovering empty parts of the schedule. To not show the tooltip, just disable this feature:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         scheduleTooltip : false
 *     }
 * });
 * ```
 *
 * @extends Common/mixin/InstancePlugin
 * @demo basic
 * @externalexample scheduler/ScheduleTooltip.js
 */
class ScheduleTooltip extends InstancePlugin {
  //region Config

  static get defaultConfig() {
    return {
      messageTemplate: (data) => `<div class="b-sch-hovertip-msg">${data.message}</div>`
    };
  }

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['render']
    };
  }

  //endregion

  //region Init

  /**
   * Called when scheduler is rendered. Sets up drag and drop and hover tooltip.
   * @private
   */
  render() {
    const me = this,
      scheduler = me.client;

    // TODO: render should not ever be called twice.
    if (me.hoverTip) {
      me.hoverTip.destroy();
    }

    let reshowListener;

    const tip = (me.hoverTip = new Tooltip({
      id: `${scheduler.id}-schedule-tip`,
      cls: 'b-sch-scheduletip',
      allowOver: true,
      hoverDelay: 0,
      hideDelay: 100,
      showOnHover: true,
      forElement: scheduler.timeAxisSubGridElement,
      anchorToTarget: false,
      trackMouse: true,
      forSelector:
        '.b-scheduler:not(.b-animating):not(.b-dragging-event):not(.b-dragcreating) .b-timeline-subgrid > :not(.b-sch-foreground-canvas):not(.b-group-footer):not(.b-group-row) *',
      // Do not constrain at all, want it to be able to go outside of the viewport to not get in the way
      constrainTo: null,
      getHtml: me.getHoverTipHtml.bind(me),
      onDocumentMouseDown(event) {
        // Click on the scheduler hides until the very next
        // non-button-pressed mouse move!
        if (tip.forElement.contains(event.event.target)) {
          reshowListener = EventHelper.on({
            element: scheduler.timeAxisSubGridElement,
            mousemove: (e) => tip.internalOnPointerOver(e),
            capture: true
          });
        }

        const hideAnimation = tip.hideAnimation;
        tip.hideAnimation = false;
        tip.constructor.prototype.onDocumentMouseDown.call(tip, event);
        tip.hideAnimation = hideAnimation;
      },
      listeners: {
        pointerover: ({ event }) => {
          const buttonsPressed = 'buttons' in event ? event.buttons > 0 : event.which > 0; // fallback for Safari which doesn't support 'buttons'

          // This is the non-button-pressed mousemove
          // after the document mousedown
          if (!buttonsPressed && reshowListener) {
            reshowListener();
          }

          // Never any tooltip while interaction is ongoing and a mouse button is pressed
          return !me.disabled && !scheduler.readOnly && !buttonsPressed;
        }
      }
    }));

    // Do this to make tip CSP compliant. Not possible to have inline styles
    const tipMouseMove = tip.onMouseMove;
    tip.onMouseMove = (event) => {
      tipMouseMove.call(tip, event);
      me.onTipMove(tip, event);
    };

    me.clockTemplate = new ClockTemplate({
      timeAxisViewModel: scheduler.timeAxisViewModel
    });
  }

  doDestroy() {
    const me = this;
    me.clockTemplate && me.clockTemplate.destroy();
    me.hoverTip && me.hoverTip.destroy();
    super.doDestroy();
  }

  //endregion

  //region Contents

  onTipMove(tip, event) {
    this.clockTemplate.updateDateIndicator(tip.element, this.lastTime);
  }

  /**
   * Gets html to display in hover tooltip (tooltip displayed on empty parts of scheduler)
   */
  getHoverTipHtml({ tip, event }) {
    const me = this,
      scheduler = me.client,
      time = event && scheduler.getDateFromDomEvent(event, 'floor', true);

    let html = me.lastHtml;

    if (time) {
      const resourceRecord = scheduler.resolveResourceRecord(event);

      if (time - me.lastTime !== 0 || resourceRecord !== me.lastResource) {
        me.lastResource = resourceRecord;
        html = me.lastHtml = me.updateHoverTip(time, event);
      }
    } else {
      tip.hide();
      me.lastTime = null;
      me.lastResource = null;
    }

    return html;
  }

  /**
   * Called from getHoverTipHtml(), fills templates used.
   * @private
   */
  updateHoverTip(date, event) {
    if (date) {
      const me = this,
        clockHtml = me.clockTemplate.template({
          date: date,
          text: me.client.getFormattedDate(date)
        }),
        messageHtml = me.messageTemplate({
          message: me.getText(date, event) || ''
        });

      me.lastTime = date;

      return clockHtml + messageHtml;
    }
  }

  /**
   * Override this to render custom text to default hover tip
   * @param {Date} date
   * @param {Event} event Browser event
   * @return {String}
   */
  getText(date, event) {}

  //endregion

  /**
   * Disable this feature
   * @property {Boolean}
   */
  get disabled() {
    return this._disabled;
  }

  set disabled(disabled) {
    this._disabled = disabled;
  }
}

// TODO: Refactor SASS so thet auto-generated class name of 'b-' + cls.name.toLowerCase() can be used.
ScheduleTooltip.featureClass = 'b-scheduletip';

ScheduleTooltip._$name = 'ScheduleTooltip';
GridFeatureManager.registerFeature(ScheduleTooltip, true, 'Scheduler');

/**
 * @module Scheduler/view/Scheduler
 */

/**
 * The Scheduler widget is a very powerful and performant UI component that displays an arbitrary number of "locked"
 * columns with a schedule occupying the remaining space. The schedule has a timeaxis at the top, one row per resource
 * and any number of events per resource.
 *
 * ## Intro
 * The Scheduler widget has a wide range of features and a large API to allow users to work with it efficiently in the
 * browser.
 *
 * The timeaxis displayed at the top of the Scheduler is configured using a {@link Scheduler.view.TimelineBase#config-startDate},
 * {@link Scheduler.view.TimelineBase#config-endDate} and a {@link Scheduler.view.mixin.TimelineViewPresets#config-viewPreset}. The dates
 * determine the outer limits of the range shown in the timeaxis while the {@link Scheduler.preset.ViewPreset} decides
 * the appearance and which dates are actually shown. The Scheduler ships with a selection of predefined view presets,
 * which can be found in {@link Scheduler.preset.PresetManager}.
 *
 * The Scheduler uses a {@link Scheduler.data.ResourceStore} to hold resources and an {@link Scheduler.data.EventStore}
 * to hold events. You can use inline data or load data using ajax, see the "Working with data" guides for more
 * information.
 *
 * The simplest schedule configured with inline data would look like this:
 *
 *      let scheduler = new Scheduler({
 *          appendTo : document.body,
 *
 *          startDate  : new Date(2018,4,6),
 *          endDate    : new Date(2018,4,12),
 *          viewPreset : 'dayAndWeek',
 *
 *           columns : [
 *              { field : 'name', text : 'Name', width: 100 }
 *          ],
 *
 *          resources : [
 *              { id : 1, name : 'Bernard' },
 *              { id : 2, name : 'Bianca' }
 *          ],
 *
 *          events : [
 *              { id : 1, resourceId : 1, name : 'Interview', startDate : '2018-05-06', endDate : '2018-05-07' },
 *              { id : 2, resourceId : 1, name : 'Press conference', startDate : '2018-05-08', endDate : '2018-05-09' },
 *              { id : 3, resourceId : 2, name : 'Audition', startDate : '2018-05-06', endDate : '2018-05-08' },
 *              { id : 4, resourceId : 2, name : 'Script deadline', startDate : '2018-05-11', endDate : '2018-05-11' }
 *          ]
 *      });
 *
 * {@inlineexample scheduler/Simplest.js}
 * ## Inheriting from Bryntum Grid
 * Bryntum Scheduler inherits from Bryntum Grid, meaning that most features available for the grid are also available
 * for the scheduler. Common features include columns, cell editing, context menus, row grouping, sorting and more.
 *
 * For more information on configuring columns, filtering, search etc. please see the {@link Grid.view.Grid Grid API docs}.
 * {@region Loading data}
 * As mentioned above Bryntum Scheduler uses an {@link Scheduler.data.EventStore} and a {@link Scheduler.data.ResourceStore}
 * to hold its data. Data is expected to be in JSON format and can be assigned inline (from memory) using the
 * {@link Scheduler.view.mixin.SchedulerStores#config-events} and
 * {@link Scheduler.view.mixin.SchedulerStores#config-resources} shortcuts:
 * ```
 * let scheduler = new Scheduler({
 *    events : myArrayOfEventData,
 *    resources : myArrayOfResourceData
 * });
 * ```
 * If you need to give additional store configuration, you can also specify store configs or instances:
 * ```
 * let resourceStore = new ResourceStore({
 *   // ResourceStore config object
 * })
 *
 * let scheduler = new Scheduler({
 *    // EventStore config object
 *    eventStore : {
 *       ...
 *    },
 *
 *    // Already existing ResourceStore instance
 *    resourceStore
 * });
 * ```
 * To use Ajax to fetch data from a server, specify {@link Common.data.AjaxStore#config-readUrl}:
 * ```
 * let scheduler = new Scheduler({
 *    eventStore : {
 *        readUrl  : 'backend/read_events.php',
 *        autoLoad : true
 *    }
 * });
 * // If you do not specify autoLoad, trigger loading manually:
 * scheduler.eventStore.load();
 * ```
 * For more information, see the "Working with data" guides.
 * {@endregion}
 * {@region Event styling}
 * Bryntum Schedulers appearance can be affected in a few different ways:
 *
 * * Switching themes
 * * Choosing event styles and colors
 * * Using renderer functions
 *
 * ### Switching themes
 * Scheduler ships with four different themes, simply include the css file for the theme you would like to use on your
 * page. The themes are located in the `/build` folder. For example to include the light theme:
 * ```
 * <link rel="stylesheet" href="build/scheduler.light.css" id="bryntum-theme">
 * ```
 * Included themes are (from left to right) light, default, dark and material:
 *
 * <img src="../examples/basic/meta/thumb.light.png" alt="Light theme" width="300" style="margin-right: .5rem">
 * <img src="../examples/basic/meta/thumb.default.png" alt="Default theme" width="300" style="margin-right: .5rem">
 * <img src="../examples/basic/meta/thumb.dark.png" alt="Dark theme" width="300" style="margin-right: .5rem">
 * <img src="../examples/basic/meta/thumb.material.png" alt="Material theme" width="300">
 *
 * ### Choosing event styles and colors
 * The style and color of each event can be changed by assigning to the `eventStyle` and `eventColor` configs. These
 * configs are available at 3 different levels:
 *
 * * Scheduler level, affects all events (see {@link Scheduler.view.mixin.TimelineEventRendering#config-eventStyle} and {@link Scheduler.view.mixin.TimelineEventRendering#config-eventColor}).
 * * Resource level, affects all events assigned to that resource (see {@link Scheduler.model.ResourceModel#field-eventStyle}
 * and {@link Scheduler.model.ResourceModel#field-eventColor}).
 * * Event level, affects that event (see {@link Scheduler.model.EventModel#field-eventStyle} and
 * {@link Scheduler.model.EventModel#field-eventColor}).
 *
 * {@inlineexample scheduler/Styles.js}
 *
 * For available styles, see {@link Scheduler.view.mixin/TimelineEventRendering#config-eventStyle}. For colors,
 * {@link Scheduler.view.mixin/TimelineEventRendering#config-eventColor}. Also take a look at the
 * <a href="../examples/eventstyles" target="_blank">eventstyles demo</a>.
 *
 * ### Using render functions
 * Render function can be used to manipulate the rendering of rows (resources) and events. For information on row
 * renderers, see {@link Grid.column.Column#config-renderer}.
 *
 * Event rendering can be manipulated by specifying an {@link Scheduler.view.mixin/SchedulerEventRendering#config-eventRenderer} function. The function is called
 * for each event before it is rendered to DOM. By using its arguments you can add CSS classes, modify styling and
 * determine the contents of the event:
 * ```
 * let scheduler = new Scheduler({
 *
 *   events    : [...],
 *   resources : [...],
 *
 *   ...,
 *
 *   eventRenderer({resourceRecord, eventRecord, tplData}) {
 *      // add css class to the event
 *      tplData.cls.add('my-css-class');
 *
 *      // use an icon
 *      tplData.iconCls = 'b-fa b-fa-some-nice-icon';
 *
 *      // returnvalue is used as events text
 *      return `${resourceRecord.name}: ${eventRecord.name}`;
 *   }
 * });
 * ```
 * {@endregion}
 * {@region Event manipulation}
 * You can programmatically manipulate the events using data operations, see the "Working with data" guides for more
 * information. Events are reactive, changes reflect on the UI automatically. A small example on manipulating events:
 * ```
 * // change startDate of first event
 * scheduler.eventStore.first.startDate = new Date(2018,5,10);
 *
 * // remove last event
 * scheduler.eventStore.last.remove();
 *
 * // reassign an event
 * scheduler.eventStore.getById(10).resourceId = 2;
 * ```
 *
 * You can also allow your users to manipulate the events using the following features:
 *
 * * {@link Scheduler.feature.EventDrag}, drag and drop events within the schedule
 * * {@link Scheduler.feature.EventDragCreate}, create new events by click-dragging an empty area
 * * {@link Scheduler.feature.EventEdit}, show an event editing form
 * * {@link Scheduler.feature.SimpleEventEdit}, edit the event name easily
 * * {@link Scheduler.feature.EventResize}, resize events by dragging resize handles
 *
 * All of the features mentioned above are enabled by default.
 * {@endregion}
 *
 * {@region Default configs}
 * There is a myriad of configs and features available for Scheduler (browse the API docs to find them), some of them on
 * by default and some of them requiring extra configuration. The code below tries to illustrate the major things that
 * are used by default:
 *
 * ```javascript
 * let scheduler = new Scheduler({
 *    // The following features are enabled by default:
 *    features : {
 *        cellEdit            : true, // Cell editing in the columns part
 *        columnLines         : true, // Column lines in the schedule part
 *        columnPicker        : true, // Header context menu item to toggle visible columns
 *        columnReorder       : true, // Reorder columns in grid part using drag and drop
 *        columnResize        : true, // Resize columns in grid part using the mouse
 *        contextMenu         : true, // Context menu for cells and headers in the grid part
 *        eventContextMenu    : true, // Context menu for events
 *        eventDrag           : true, // Dragging events
 *        eventDragCreate     : true, // Drag creating events
 *        eventEdit           : true, // Event editor dialog
 *        eventFilter         : true, // Filtering events using header context menu
 *        eventResize         : true, // Resizing events using the mouse
 *        eventTooltip        : true, // Tooltips for events
 *        group               : true, // Row grouping
 *        headerContextMenu   : true, // Header context menu for schedule part
 *        scheduleContextMenu : true, // Context menu for empty parts of the schedule
 *        scheduleTooltip     : true, // Tooltip for empty parts of the schedule
 *        sort                : true  // Row sorting
 *    },
 *
 *    // From Grid
 *    animateRemovingRows       : false, // Rows will not slide out on removal
 *    autoHeight                : false, // Grid needs to have a height supplied through CSS (strongly recommended) or by specifying `height
 *    columnLines               : true,  // Grid part, themes might override it to hide lines anyway
 *    emptyText                 : 'No rows to display',
 *    enableTextSelection       : false, // Not allowed to select text in cells by default,
 *    fillLastColumn            : true,  // By default the last column is stretched to fill the grid
 *    fullRowRefresh            : true,  // Refreshes entire row when a cell value changes
 *    loadMask                  : 'Loading...',
 *    resizeToFitIncludesHeader : true,  // Also measure header when auto resizing columns
 *    responsiveLevels : {
 *      small : 400,
 *      medium : 600,
 *      large : '*'
 *    },
 *    rowHeight                 : 60,    // Scheduler specifies a default rowHeight in pixels
 *    showDirty                 : false, // No indicator for changed cells
 *    showRemoveInContextMenu   : true   // Context menu has "Remove row" item,
 *
 *    // Scheduler specific
 *    autoAdjustTimeAxis             : true,      // startDate & endDate will be adjusted to display a suitable range
 *    allowOverlap                   : true,      // Events are allowed to overlap (overlays, stacks or packs depending on eventLayout)
 *    barMargin                      : 10,        // Space above + below each event
 *    createEventOnDblClick          : true,      // Allow creating new events by double clicking empty space
 *    enableDeleteKey                : true,      // Allow deleting events with delete / backspace keys
 *    enableEventAnimations          : true,      // Animate event changes
 *    eventBarTextField              : 'name',    // Field on EventModel to display in events
 *    eventColor                     : 'green',   // Use green as default color for events
 *    eventLayout                    : 'stack',   // Stack overlapping events by default
 *    eventStyle                     : 'plain',   // Use plain as default style for events
 *    managedEventSizing             : true,      // Calculate event sizes based on rowHeight & barMargin
 *    milestoneCharWidth             : 10,
 *    milestoneLayoutMode            : 'default',
 *    removeUnassignedEvent          : true,      // Remove event when all assignments for it are removed
 *    useInitialAnimation            : true,      // Fade in events initially
 *    viewPreset                     : 'weekAndDayLetter',
 *    zoomOnMouseWheel               : true,
 *    zoomOnTimeAxisDoubleClick      : true
 * });
 * ```
 * {@endregion}
 *
 * {@region Performance}
 * To make scheduler performance as good as possible it only renders the events and resources that are within view (plus
 * an additional buffer). Since adding to and removing from DOM comes with a performance penalty the elements are
 * instead repositioned and reused as you scroll. A side effect of this is that you cannot do direct DOM element
 * manipulation in a reliable way, instead you should use row and event renderer functions to achive what you want (see
 * the section on event styling above).
 *
 * To put the scheduler to the test, try our <a href="../examples/bigdataset" target="_blank">bigdataset demo</a>.
 * {@endregion}
 *
 * @mixes Scheduler/view/mixin/EventNavigation
 * @mixes Scheduler/view/mixin/EventSelection
 * @mixes Scheduler/view/mixin/SchedulerDom
 * @mixes Scheduler/view/mixin/SchedulerDomEvents
 * @mixes Scheduler/view/mixin/SchedulerEventRendering
 * @mixes Scheduler/view/mixin/SchedulerRegions
 * @mixes Scheduler/view/mixin/SchedulerScroll
 * @mixes Scheduler/view/mixin/SchedulerState
 * @mixes Scheduler/view/mixin/SchedulerStores
 * @mixes Scheduler/view/mixin/TimelineDateMapper
 * @mixes Scheduler/view/mixin/TimelineDomEvents
 * @mixes Scheduler/view/mixin/TimelineEventRendering
 * @mixes Scheduler/view/mixin/TimelineScroll
 * @mixes Scheduler/view/mixin/TimelineViewPresets
 * @mixes Scheduler/view/mixin/TimelineZoomable
 *
 * @extends Scheduler/view/TimelineBase
 */
// SchedulerDragResize not included as @mixes above on purpose, since it is private
class Scheduler extends base(TimelineBase).mixes(
  SchedulerDom,
  SchedulerDomEvents,
  SchedulerDragResize,
  SchedulerStores,
  SchedulerScroll,
  SchedulerState,
  SchedulerEventRendering,
  SchedulerRegions,
  EventSelection,
  EventNavigation
) {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Scheduler mode. Supported values: horizontal, vertical
       * @config {String} mode
       * @default
       */
      mode: 'horizontal',

      /**
       * CSS class to add to rendered events
       * @config {String}
       * @category CSS
       * @private
       * @default
       */
      eventCls: 'b-sch-event',

      /**
       * CSS class to add to cells in the timeaxis column
       * @config {String}
       * @category CSS
       * @private
       * @default
       */
      timeCellCls: 'b-sch-timeaxis-cell',

      timeCellSelector: '.b-sch-timeaxis-cell',

      scheduledEventName: 'event',

      /**
       * A CSS class to apply to each event in the view on mouseover (defaults to 'b-sch-event-hover').
       * @config {String}
       * @default
       * @category CSS
       * @private
       */
      overScheduledEventClass: 'b-sch-event-hover',

      /**
       * Set to false if you don't want to allow events overlapping (defaults to true).
       * @config {Boolean}
       * @default
       * @category Scheduled events
       */
      allowOverlap: true,

      /**
       * The height in pixels of Scheduler rows.
       * @config {Boolean}
       * @default
       */
      rowHeight: 60,

      /**
       * Factor representing the avarge char width in pixels used to determine milestone width when configured
       * with `milestoneLayoutMode: 'estimate'`.
       * @config {Number}
       * @default
       */
      milestoneCharWidth: 10,

      /**
       * How to align milestones in relation to their startDate. Only applies when using a `milestoneLayoutMode`
       * other than `default`. Valid values are:
       * * start
       * * center (default)
       * * end
       */
      milestoneAlign: 'center',

      // This is determined by styling, in the future it should be measured
      milestoneMinWidth: 40
    };
  }

  //endregion

  //region Events

  /**
   * Fired after rendering an event, when its element is available in DOM.
   * @event renderEvent
   * @param {Scheduler.view.Scheduler} source This Scheduler
   * @param {Scheduler.model.EventModel} eventRecord The event record
   * @param {Scheduler.model.ResourceModel} resourceRecord The resource record
   * @param {Scheduler.model.AssignmentModel} assignmentRecord The assignment record, if using an AssignmentStore
   * @param {Object} tplData An object containing details about the event rendering, see {@link Scheduler.view.mixin.SchedulerEventRendering#config-eventRenderer} for details
   * @param {HTMLElement} element The events element
   */

  //endregion

  //region Functions injected by features

  // For documentation & typings purposes

  /**
   * Opens an {@link Scheduler.view.EventEditor EventEditor} to edit the passed event.
   *
   * *NOTE: Only available when the {@link Scheduler/feature/EventEdit EventEdit} feature is enabled.*
   *
   * @function editEvent
   * @param {Scheduler.model.EventModel} eventRecord Event to edit
   * @param {Scheduler.model.ResourceModel} [resourceRecord] The Resource record for the event.
   * This parameter is needed if the event is newly created for a resource and has not been assigned, or when using
   * multi assignment.
   * @param {HTMLElement} [element] Element to anchor editor to (defaults to events element)
   * @category Feature shortcuts
   */

  //endregion

  //region Init

  construct(config = {}) {
    const me = this;

    super.construct(config);

    if (me.createEventOnDblClick) {
      me.on('scheduledblclick', me.onSchedulerDblClick);
    }
  }

  //endregion

  //region Config getters/setters

  // Overrides TimelineBase to supply eventStore as its store (which is only used in passed events)
  set timeAxisViewModel(timeAxisViewModel) {
    super.timeAxisViewModel = timeAxisViewModel;

    if (this.eventStore) {
      this.timeAxisViewModel.eventStore = this.eventStore;
    }
  }

  get timeAxisViewModel() {
    return super.timeAxisViewModel;
  }

  // Placeholder getter/setter for mixins, please make any changes needed to SchedulerStores#store instead
  get store() {
    return super.store;
  }

  set store(store) {
    super.store = store;
  }

  //endregion

  //region Event handlers

  onLocaleChange() {
    this.currentOrientation.onLocaleChange();

    super.onLocaleChange();
  }

  onSchedulerHorizontalScroll(subGrid, scrollLeft) {
    // rerender cells in scheduler column on horizontal scroll to display events in view
    this.currentOrientation.updateFromHorizontalScroll(scrollLeft);

    super.onSchedulerHorizontalScroll(subGrid, scrollLeft);
  }

  onSchedulerDblClick({ date: startDate, resourceRecord, row }) {
    const me = this;

    if (me.readOnly || resourceRecord.meta.specialRow) {
      return;
    }

    me.internalAddEvent(startDate, resourceRecord, row);
  }

  onTimeAxisViewModelUpdate() {
    super.onTimeAxisViewModelUpdate();

    this.currentOrientation.onTimeAxisViewModelUpdate();
  }

  onColumnsChanged({ action, changes, record: column }) {
    // TODO: Have ResourceHeader call this directly instead of relying on event?
    if (column === this.timeAxisColumn && 'width' in changes) {
      this.updateCanvasSize();
    }

    super.onColumnsChanged(...arguments);
  }

  // Only used in vertical mode
  onVerticalScroll({ scrollTop }) {
    this.currentOrientation.updateFromVerticalScroll(scrollTop);
  }

  //endregion

  //region Mode

  /**
   * Checks if scheduler is in horizontal mode
   * @returns {Boolean}
   * @readonly
   * @category Common
   * @private
   */
  get isHorizontal() {
    return this.mode === 'horizontal';
  }

  /**
   * Checks if scheduler is in vertical mode
   * @returns {Boolean}
   * @readonly
   * @category Common
   * @private
   */
  get isVertical() {
    return this.mode === 'vertical';
  }

  /**
   * Get/set mode (horizontal/vertical)
   * @property {String}
   * @private
   * @category Common
   */
  get mode() {
    return this._mode;
  }

  set mode(mode) {
    const me = this;

    me._mode = mode;

    if (!me[mode]) {
      if (mode === 'horizontal') {
        me.horizontal = new HorizontalEventMapper(me);
        if (me.rendered) {
          me.horizontal.init();
        }

        me.un('scroll', me.onVerticalScroll, me);
      } else if (mode === 'vertical') {
        // Zooming is not yet supported in vertical mode, disable it
        me.zoomOnTimeAxisDoubleClick = me.zoomOnMouseWheel = false;

        me.vertical = new VerticalEventMapper(me);
        if (me.rendered) {
          me.vertical.init();
        }

        me.on('scroll', me.onVerticalScroll, me);
      }
    }
  }

  get currentOrientation() {
    return this[this.mode];
  }

  //endregion

  //region Dom event dummies

  // this is ugly, but needed since super cannot be called from SchedulerDomEvents mixin...

  onElementKeyDown(event) {
    super.onElementKeyDown(event);
  }

  onElementKeyUp(event) {
    super.onElementKeyUp(event);
  }

  onElementMouseOver(event) {
    super.onElementMouseOver(event);
  }

  onElementMouseOut(event) {
    super.onElementMouseOut(event);
  }

  //endregion

  //region Context menu

  /**
   * A chainable function which Features may hook to add their own event context menu items
   * when context menu is invoked on an event.
   * @param {Object} params An object containing the available contextual information.
   * @param {Scheduler.model.EventModel} params.eventRecord The context event.
   * @param {Scheduler.model.ResourceModel} params.resourceRecord The context resource
   * @param {Scheduler.model.AssignmentModel} params.assignmentRecord The context assignment if any.
   * @param {HTMLElement} params.eventElement The context event's DOM element.
   * @param {Event} params.event The triggering DOM `contextmenu` event.
   */
  getEventMenuItems() {}

  /**
   * A chainable function which Features may hook to add their own Scheduler context menu items
   * when context menu is invoked on the scheduler, but not on an event.
   * @param {Object} params An object containing the available contextual information.
   * @param {Scheduler.model.ResourceModel} params.resourceRecord The context resource
   * @param {Date} params.date The Date corresponding to the mouse position in the time axis.
   * @param {HTMLElement} params.eventElement The context event's DOM element.
   * @param {Event} params.event The triggering DOM `contextmenu` event.
   */
  getScheduleMenuItems() {}

  //endregion

  //region Scheduler specific date mapping functions

  internalAddEvent(startDate, resourceRecord, row) {
    const me = this,
      resourceRecords = [resourceRecord],
      eventRecord = new me.eventStore.modelClass({
        startDate,
        endDate: DateHelper.add(startDate, 1, me.timeAxis.unit)
      });

    me.onEventCreated(eventRecord);

    if (me.eventEdit) {
      const eventData = me.currentOrientation.getTimeSpanRenderData(eventRecord, resourceRecord),
        proxyEl = (me.eventEdit.dragProxyElement = DomHelper.createElement({
          parent: me.foregroundCanvas,
          className: 'b-sch-dragcreator-proxy',
          style: `width:${eventData.width}px;height:${eventData.height}px`
        }));

      DomHelper.setTranslateXY(proxyEl, eventData.left, ((row && row.top) || 0) + eventData.top);

      me.editEvent(eventRecord, resourceRecord, proxyEl);
      return;
    }

    /**
     * Fires before an event is added. Can be triggered by schedule double click, drag create action, or by the event editor.
     * @event beforeEventAdd
     * @param {Scheduler.view.Scheduler} source The Scheduler instance
     * @param {Scheduler.model.EventModel} eventRecord The record about to be added
     * @param {Scheduler.model.ResourceModel[]} resources **Deprecated** Use `resourceRecords` instead
     * @param {Scheduler.model.ResourceModel[]} resourceRecords Resources that the record is assigned to
     * @preventable
     */
    if (me.trigger('beforeEventAdd', { eventRecord, resourceRecords, resources: resourceRecords }) !== false) {
      me.eventStore.add(eventRecord);
      me.eventStore.assignEventToResource(eventRecord, resourceRecord);
    }
  }

  /**
   * Checks if a date range is allocated or not for a given resource.
   * @param {Date} start The start date
   * @param {Date} end The end date
   * @param {Scheduler.model.EventModel} excludeEvent An event to exclude from the check (or null)
   * @param {Scheduler.model.ResourceModel} resource The resource
   * @return {Boolean} True if the timespan is available for the resource
   * @category Dates
   */
  isDateRangeAvailable(start, end, excludeEvent, resource) {
    return this.eventStore.isDateRangeAvailable(start, end, excludeEvent, resource);
  }

  //endregion
}

Scheduler._$name = 'Scheduler';
BryntumWidgetAdapterRegister.register('scheduler', Scheduler);

VersionHelper.setVersion('scheduler', '2.2.3');

// Actions that trigger rerendering of group summary rows
const refreshActions = {
  add: 1,
  remove: 1,
  update: 1,
  removeAll: 1,
  filter: 1
};

/**
 * @module Scheduler/feature/GroupSummary
 */

// noinspection JSClosureCompilerSyntax
/**
 * A special version of the Grid GroupSummary feature that enables summaries within scheduler. To use a single summary
 * it is easiest to configure {@link #config-renderer}, for multiple summaries see {@link #config-summaries}.
 *
 * This feature is <strong>disabled</strong> by default. It is **not** supported in vertical mode.
 *
 * @extends Grid/feature/GroupSummary test
 *
 * @classtype groupsummary
 * @externalexample scheduler/GroupSummary.js
 * @demo groupsummary
 * @typings Grid/feature/GroupSummary -> Grid/feature/GridGroupSummary
 */
class GroupSummary$1 extends GroupSummary {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Show tooltip containing summary values and labels
       * @config {Boolean}
       * @default
       */
      showTooltip: true,

      /**
       * Array of summary configs, with format
       * `[{ label: 'Label', renderer : ({startDate, endDate, eventStore, resourceStore, events, element}) }]`.
       * @config {Object[]}
       */
      summaries: null,

      /**
       * Easier way to configure when using a single summary. Accepts a renderer function with the format specified
       * in {@link #config-summaries}
       * @config {Function}
       */
      renderer: null
    };
  }

  static get pluginConfig() {
    return {
      chain: ['render']
    };
  }

  //endregion

  //region Init

  construct(scheduler, config) {
    const me = this;

    if (scheduler.isVertical) {
      throw new Error('GroupSummary feature is not supported in vertical mode');
    }

    me.scheduler = scheduler;

    super.construct(scheduler, config);

    if (!me.summaries && me.renderer) {
      me.summaries = [{ renderer: me.renderer }];
    }

    me.isScheduler = scheduler instanceof Scheduler;

    if (me.isScheduler) {
      scheduler.eventStore.on({
        change: me.onEventStoreChange,
        thisObj: me
      });
      scheduler.timeAxis.on({
        reconfigure: me.onTimeAxisChange,
        thisObj: me
      });
      scheduler.timeAxisViewModel.on({
        update: me.onTimeAxisChange,
        thisObj: me
      });
    }
  }

  doDestroy() {
    if (this._tip) {
      this._tip.destroy();
    }

    super.doDestroy();
  }

  //endregion

  //region Events

  onTimeAxisChange() {
    this.rerenderGroupSummaries();
  }

  onEventStoreChange({ action }) {
    // Scheduler does minimal update on event changes, it will not rerender the summary rows.
    // Need to handle that here
    if (refreshActions[action]) {
      this.rerenderGroupSummaries();
    }
  }

  rerenderGroupSummaries() {
    // TODO: Sort out the affected rows by checking events resources
    this.scheduler.rowManager.rows.forEach((row) => {
      if (row.isGroupFooter) {
        row.render();
      }
    });
  }

  //endregion

  //region Render

  /**
   * Called before rendering row contents, used to reset rows no longer used as group summary rows
   * @private
   */
  onBeforeRenderRow({ row, record }) {
    if (row.isGroupFooter && !record.meta.hasOwnProperty('groupFooterFor')) {
      const timeaxisCell = row.elements.normal.querySelector('.b-sch-timeaxis-cell');

      // remove summary cells if exist
      if (timeaxisCell) {
        timeaxisCell.innerHTML = '';
      }
    }

    super.onBeforeRenderRow(...arguments);
  }

  /**
   * Called by parent class to fill timeaxis with summary contents. Generates tick "cells" and populates them with
   * summaries.
   * ```
   * <div class="b-timeaxis-group-summary">
   *     <div class="b-timeaxis-tick">
   *         <div class="b-timeaxix-summary-value">x</div>
   *         ...
   *     </div>
   *     ...
   * </div>
   * ```
   * @private
   */
  generateHtml(column, records, cls) {
    if (column.type === 'timeAxis') {
      const me = this,
        scheduler = me.scheduler,
        tickSize = scheduler.tickSize;

      let html = '';

      scheduler.timeAxis.forEach((tick) => {
        const // events for current tick
          events = scheduler.eventStore.getEventsInTimeSpan(tick.startDate, tick.endDate, true, true),
          // filter those events to current groups
          groupEvents = events.filter((event) => event.resources.some((resource) => records.includes(resource)));

        // TODO: could turn this into a template

        const sumHtml = me.summaries
          .map((config) => {
            // summary renderer used to calculate and format value
            const value = config.renderer({
              startDate: tick.startDate,
              endDate: tick.endDate,
              eventStore: scheduler.eventStore,
              resourceStore: scheduler.resourceStore,
              events: groupEvents
            });

            return `<div class="b-timeaxis-summary-value">${value}</div>`;
          })
          .join('');

        html += `<div class="b-timeaxis-tick" style="width: ${tickSize}px">${sumHtml}</div>`;
      });

      return `<div class="b-timeaxis-group-summary">${html}</div>`;
    }

    return super.generateHtml(column, records, cls);
  }

  /**
   * Overrides parents function to return correct summary count, used when sizing row
   * @private
   */
  updateSummaryHtml(cellElement, column, records) {
    const count = super.updateSummaryHtml(cellElement, column, records);

    if (column.type === 'timeAxis') {
      let result = {
        count: 0,
        height: 0
      };

      this.summaries.forEach((config) => {
        if (config.height) {
          result.height += config.height;
        } else {
          result.count++;
        }
      });

      return result;
    }

    return count;
  }

  /**
   * Generates tooltip contents for hovered summary tick
   * @private
   */
  getTipHtml({ forElement }) {
    const me = this,
      index = Array.from(forElement.parentElement.children).indexOf(forElement),
      tick = me.scheduler.timeAxis.getAt(index);

    let tipHtml = `<header>${me.L('Summary for')} ${me.scheduler.getFormattedDate(tick.startDate)}</header>`,
      showTip = false;

    DomHelper.forEachSelector(forElement, '.b-timeaxis-summary-value', (element, i) => {
      const label = me._labels[i],
        text = element.innerText.trim();

      tipHtml += `<label>${label || ''}</label><div class="b-timeaxis-summary-value">${text}</div>`;

      if (element.innerHTML) showTip = true;
    });

    return showTip ? tipHtml : null;
  }

  /**
   * Initialize tooltip on render
   * @private
   */
  render() {
    const me = this,
      { scheduler } = me;

    if (me.isScheduler) {
      // if any sum config has a label, init tooltip
      if (me.summaries && me.summaries.some((config) => config.label) && me.showTooltip && !me._tip) {
        me._labels = me.summaries.map((config) => config.label || '');

        me._tip = new Tooltip({
          id: `${scheduler.id}-groupsummary-tip`,
          cls: 'b-timeaxis-summary-tip',
          hoverDelay: 0,
          hideDelay: 0,
          forElement: scheduler.timeAxisSubGridElement,
          anchorToTarget: true,
          forSelector: '.b-timeaxis-group-summary .b-timeaxis-tick',
          clippedBy: [scheduler.timeAxisSubGridElement, scheduler.bodyContainer],
          getHtml: me.getTipHtml.bind(me)
        });
      }
    }
  }

  //endregion
}

// Needed for module bundle, which turns class name into GroupSummary$1 and registers it wrong
GroupSummary$1._$name = 'GroupSummary';

// Override Grids GroupSummary with this improved version
GroupSummary$1._$name = 'GroupSummary';
GridFeatureManager.registerFeature(GroupSummary$1, false, 'Scheduler');

/**
 * @module Scheduler/feature/HeaderZoom
 */

/**
 * Enables users to click and drag to zoom to a date range in Scheduler's header time axis.
 *
 * This feature is **disabled** by default.
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @example
 * let scheduler = new Scheduler({
 *   features : {
 *     headerZoom      : true
 *   }
 * });
 *
 * @classtype HeaderZoom
 * @externalexample scheduler/HeaderZoom.js
 */
class HeaderZoom extends InstancePlugin {
  //region Plugin config

  // Plugin configuration. This plugin chains some of the functions in Scheduler.
  static get pluginConfig() {
    return {
      chain: ['onElementMouseDown', 'onElementMouseMove', 'onElementMouseUp']
    };
  }

  //endregion

  onElementMouseDown(event) {
    const me = this,
      scheduler = me.client;

    // only react to mouse input, and left button
    if (event.touches || event.button !== 0) {
      return;
    }

    // only react to mousedown directly on timeaxis cell
    if (event.target.matches('.b-sch-header-timeaxis-cell')) {
      const headerEl = scheduler.subGrids.normal.header.headersElement;

      me.startX = event.clientX;

      me.element = DomHelper.createElement({
        parent: headerEl,
        tag: 'div',
        className: 'b-headerzoom-rect'
      });

      me.headerElementRect = Rectangle.from(headerEl);
    }
  }

  onElementMouseMove(event) {
    const me = this;

    // Synthetic mousemove event has no button for IE11
    // Detect if a mouseup happened outside our element (or browser window for that matter). Note 'buttons' is not supported by Safari
    if (event.buttons === 0 && !BrowserHelper.isSafari && (!BrowserHelper.isIE11 || event.isTrusted)) {
      me.onElementMouseUp(event);
      return;
    }

    if (typeof me.startX === 'number') {
      const x = Math.max(event.clientX, me.headerElementRect.left),
        left = Math.min(me.startX, x),
        width = Math.abs(me.startX - x),
        rect = new Rectangle(
          left - me.headerElementRect.x + me.client.scrollLeft,
          0,
          width,
          me.headerElementRect.height
        );

      DomHelper.setTranslateX(me.element, rect.left);
      me.element.style.width = rect.width + 'px';
    }
  }

  onElementMouseUp(event) {
    const me = this;

    if (typeof me.startX === 'number') {
      const timeline = me.client,
        rect = Rectangle.from(me.element),
        startDate = timeline.getDateFromCoordinate(rect.left, 'round', false),
        endDate = timeline.getDateFromCoordinate(rect.right, 'round', false);

      me.element && me.element.remove();
      me.startX = null;

      me.client.zoomToSpan({
        startDate,
        endDate
      });
    }
  }
}

HeaderZoom._$name = 'HeaderZoom';
GridFeatureManager.registerFeature(HeaderZoom, false, 'Scheduler');

/**
 * @module Scheduler/feature/Labels
 */

const sides = ['top', 'left', 'right', 'bottom'],
  editorAlign = {
    top: 'b-b',
    right: 'l-l',
    bottom: 't-t',
    left: 'r-r'
  },
  topBottom = {
    top: 1,
    bottom: 1
  };

/**
 * Displays labels at positions {@link #config-top}, {@link #config-right}, {@link #config-bottom} and {@link #config-left}.
 *
 * Text in labels can be set from a field on the {@link Scheduler.model.EventModel EventModel}
 * or the {@link Scheduler.model.ResourceModel ResourceModel} or using a custom renderer.
 *
 * Since `top` and `bottom` labels occupy space that would otherwise be used by the event we recommend using bigger rowHeights
 * (>55px for both labels with default styling) and zero barMargins because `top`/`bottom` labels give space around events anyway.
 *
 * This feature is **disabled** by default. It is **not** supported in vertical mode.
 *
 * @extends Common/mixin/InstancePlugin
 * @demo labels
 * @externalexample scheduler/Labels.js
 */
class Labels extends InstancePlugin {
  //region Config

  // Default configuration.
  static get defaultConfig() {
    return {
      /**
       * CSS class to apply to label elements
       * @config {String}
       * @default
       */
      labelCls: 'b-sch-label',

      /**
       * Top label configuration object. May contain the following properties:
       * - field : [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) The name of a field in one of the associated records,  {@link Scheduler.model.EventModel EventModel} or  {@link Scheduler.model.ResourceModel ResourceModel}. The record from which the field value is drawn will be ascertained by checking for field definitions by the specified name.<br>
       * - renderer : [Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) A function, which when passed an object containing `eventRecord`, `resourceRecord` and `labelElement` properties, returns the HTML to display as the label.<br>
       * - thisObj : [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) The `this` reference to use in the `renderer`.
       * - editor : [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) / {@link Common.widget.Field Field} If the label is to be editable, a field configuration object with a `type` property, or an instantiated Field. **The `field` property is mandatory for editing to work**.
       * @config {Object}
       * @default
       */
      top: null,

      /**
       * Right label configuration object. May contain the following properties:
       * - field : [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) The name of a field in one of the associated records,  {@link Scheduler.model.EventModel EventModel} or  {@link Scheduler.model.ResourceModel ResourceModel}. The record from which the field value is drawn will be ascertained by checking for field definitions by the specified name.<br>
       * - renderer : [Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) A function, which when passed an object containing `eventRecord`, `resourceRecord` and `labelElement` properties, returns the HTML to display as the label.<br>
       * - thisObj : [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) The `this` reference to use in the `renderer`.
       * - editor : [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) / {@link Common.widget.Field Field} If the label is to be editable, a field configuration object with a `type` property, or an instantiated Field. **The `field` property is mandatory for editing to work**.
       * @config {Object}
       * @default
       */
      right: null,

      /**
       * Bottom label configuration object. May contain the following properties:
       * - field : [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) The name of a field in one of the associated records,  {@link Scheduler.model.EventModel EventModel} or  {@link Scheduler.model.ResourceModel ResourceModel}. The record from which the field value is drawn will be ascertained by checking for field definitions by the specified name.<br>
       * - renderer : [Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) A function, which when passed an object containing `eventRecord`, `resourceRecord` and `labelElement` properties, returns the HTML to display as the label.<br>
       * - thisObj : [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) The `this` reference to use in the `renderer`.
       * - editor : [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) / {@link Common.widget.Field Field} If the label is to be editable, a field configuration object with a `type` property, or an instantiated Field. **The `field` property is mandatory for editing to work**.
       * @config {Object}
       * @default
       */
      bottom: null,

      /**
       * Left label configuration object. May contain the following properties:
       * - field : [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) The name of a field in one of the associated records,  {@link Scheduler.model.EventModel EventModel} or  {@link Scheduler.model.ResourceModel ResourceModel}. The record from which the field value is drawn will be ascertained by checking for field definitions by the specified name.<br>
       * - renderer : [Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) A function, which when passed an object containing `eventRecord`, `resourceRecord` and `labelElement` properties, returns the HTML to display as the label.<br>
       * - thisObj : [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) The `this` reference to use in the `renderer`.
       * - editor : [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) / {@link Common.widget.Field Field} If the label is to be editable, a field configuration object with a `type` property, or an instantiated Field. **The `field` property is mandatory for editing to work**.
       * @config {Object}
       * @default
       */
      left: null,

      thisObj: null,

      /**
       * What action should be taken when focus moves leaves the cell editor, for example when clicking outside.
       * May be `'complete'` or `'cancel`'.
       * @config {String}
       * @default
       */
      blurAction: 'cancel'
    };
  }

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {};
  }

  //endregion

  //region Init & destroy

  construct(scheduler, config) {
    const me = this;

    if (scheduler.isVertical) {
      throw new Error('Labels feature is not supported in vertical mode');
    }

    me.scheduler = scheduler;
    me.labelElements = {};

    super.construct(scheduler, config);

    const { top, bottom, left, right } = me;

    if (top || bottom || left || right) {
      me.schedulerDetatcher = scheduler.on({
        eventpaint: 'onEventPaint',
        eventrepaint: 'onEventPaint',
        taskpaint: 'onEventPaint',
        taskrepaint: 'onEventPaint',
        thisObj: me
      });

      me.updateHostClasslist();

      // rowHeight warning, not in use
      //const labelCount = !!me.topLabel + !!me.bottomLabel;
      //if (scheduler.rowHeight < 60 - labelCount * 12) console.log('')
    }
  }

  updateHostClasslist() {
    const { top, bottom } = this,
      { classList } = this.scheduler.element;

    classList.remove('b-labels-topbottom');
    classList.remove('b-labels-top');
    classList.remove('b-labels-bottom');

    // OR is correct. This means that there are labels above OR below.
    if (top || bottom) {
      classList.add('b-labels-topbottom');
      if (top) {
        classList.add('b-labels-top');
      }
      if (bottom) {
        classList.add('b-labels-bottom');
      }
    }
  }

  onEventDblClick(eventDblclick) {
    const me = this,
      { event } = eventDblclick,
      target = event.target.closest('.b-sch-label');

    if (target && !me.scheduler.readOnly) {
      const { side } = target.dataset,
        labelConfig = me[side],
        { editor, field, recordType } = labelConfig;

      if (editor) {
        if (!(editor instanceof Editor)) {
          labelConfig.editor = new Editor({
            appendTo: me.scheduler.element,
            blurAction: me.blurAction,
            inputField: editor,
            scrollAction: 'realign'
          });
        }

        labelConfig.editor.startEdit({
          target,
          align: editorAlign[side],
          matchSize: false,
          record: eventDblclick[`${recordType}Record`],
          field
        });

        event.stopImmediatePropagation();
        return false;
      }
    }
  }

  set top(top) {
    this._top = this.processLabelSpec(top, 'top');
    this.updateHostClasslist();
  }
  get top() {
    return this._top;
  }

  set right(right) {
    this._right = this.processLabelSpec(right, 'right');
    this.updateHostClasslist();
  }
  get right() {
    return this._right;
  }

  set bottom(bottom) {
    this._bottom = this.processLabelSpec(bottom, 'bottom');
    this.updateHostClasslist();
  }
  get bottom() {
    return this._bottom;
  }

  set left(left) {
    this._left = this.processLabelSpec(left, 'left');
    this.updateHostClasslist();
  }
  get left() {
    return this._left;
  }

  processLabelSpec(labelSpec, side) {
    if (typeof labelSpec === 'function') {
      labelSpec = {
        renderer: labelSpec
      };
    } else if (typeof labelSpec === 'string') {
      labelSpec = {
        field: labelSpec
      };
    }
    // Allow us to mutate ownProperties in the labelSpec without mutating outside object
    else if (labelSpec) {
      labelSpec = Object.setPrototypeOf({}, labelSpec);
    } else {
      return;
    }

    const { scheduler } = this,
      { eventStore, resourceStore, taskStore, id } = scheduler,
      { field, editor } = labelSpec;

    // If there are milestones, and we are changing the available height
    // either by adding a top/bottom label, or adding a top/bottom label
    // then during the next dependency refresh, milestone width must be recalculated.
    if (topBottom[side]) {
      scheduler.milestoneWidth = null;
    }

    // Find the field definition or property from whichever store and cache the type.
    if (field) {
      let fieldDef;

      if (eventStore && !taskStore) {
        fieldDef = eventStore.modelClass.fieldMap[field];
        if (fieldDef) {
          labelSpec.fieldDef = fieldDef;
          labelSpec.recordType = 'event';
        }
        // Check if it references a property
        else if (Reflect.has(eventStore.modelClass.prototype, field)) {
          labelSpec.recordType = 'event';
        }
      }

      if (!fieldDef && taskStore) {
        fieldDef = taskStore.modelClass.fieldMap[field];
        if (fieldDef) {
          labelSpec.fieldDef = fieldDef;
          labelSpec.recordType = 'task';
        }
        // Check if it references a property
        else if (Reflect.has(resourceStore.modelClass.prototype, field)) {
          labelSpec.recordType = 'task';
        }
      }

      if (!fieldDef && resourceStore) {
        fieldDef = resourceStore.modelClass.fieldMap[field];
        if (fieldDef) {
          labelSpec.fieldDef = fieldDef;
          labelSpec.recordType = 'resource';
        }
        // Check if it references a property
        else if (Reflect.has(resourceStore.modelClass.prototype, field)) {
          labelSpec.recordType = 'resource';
        }
      }

      if (editor) {
        if (typeof editor === 'boolean') {
          scheduler.editor = {
            type: 'textfield'
          };
        } else if (typeof editor === 'string') {
          scheduler.editor = {
            type: editor
          };
        }
        scheduler.on({
          eventdblclick: 'onEventDblClick',
          taskdblclick: 'onEventDblClick',
          thisObj: this
        });
      }
    }

    return labelSpec;
  }

  doDestroy() {
    this.schedulerDetatcher && this.schedulerDetatcher();
    super.doDestroy();
  }

  /**
   * Disable this feature
   * @property {Boolean}
   */
  get disabled() {
    return this._disabled;
  }

  set disabled(disabled) {
    this._disabled = disabled;

    if (this.client.rendered) {
      this.client.refresh();
    }
  }

  //endregion

  //region Events

  /**
   * Called when a new event element is created or updated. Make correct label state.
   * @private
   */
  onEventPaint(paintEvent) {
    // Tear down old label setup (we may have been reconfigured)
    DomHelper.removeEachSelector(paintEvent.element, '.b-sch-label');

    if (!this.disabled) {
      // Insert all configured labels
      for (const side of sides) {
        if (this[side]) {
          this.appendLabel(side, paintEvent.element, paintEvent);
        }
      }
    }
  }

  //endregion

  //region Labels

  /**
   * Appends a label to a wrapping element
   * @private
   * @param side
   * @param appendTo
   * @param eventRecord
   */
  appendLabel(side, appendTo, paintEvent) {
    this.labelElements[side] = DomHelper.createElement({
      tag: 'label',
      dataset: { side },
      parent: appendTo
    });

    this.updateLabel(side, paintEvent);
  }

  /**
   * Updates a labels content
   * @private
   * @param side
   * @param eventRecord
   */
  updateLabel(side, paintEvent) {
    const me = this,
      { field, fieldDef, recordType, renderer, thisObj } = me[side],
      labelElement = me.labelElements[side];

    let value;

    // Correct class name in case of element recycling from another render condition.
    labelElement.className = `${me.labelCls} ${me.labelCls}-${side}`;

    // If there's a renderer, use that by preference
    if (renderer) {
      value = renderer.call(thisObj || me.thisObj || me, Object.assign({ labelElement }, paintEvent));
    } else {
      value = paintEvent[`${recordType}Record`][field];

      // If it's a date, format it according to the Scheduler's defaults
      if (fieldDef && fieldDef.type === 'date' && !renderer) {
        value = DateHelper.format(value, me.scheduler.displayDateFormat);
      }
    }

    labelElement.innerHTML = value || '\xa0';
  }

  //endregion
}

// TODO: Refactor the SASS, so that the auto-generated class name of ''b-' + cls.name.toLowerCase() can be used.
Labels.featureClass = 'b-sch-labels';

Labels._$name = 'Labels';
GridFeatureManager.registerFeature(Labels, false, ['Scheduler', 'Gantt']);

/**
 * @module Scheduler/feature/AbstractTimeRanges
 */

/**
 * Abstract base class, you should not use this class directly.
 * @abstract
 * @mixes Common/mixin/Delayable
 * @extends Common/mixin/InstancePlugin
 */
class AbstractTimeRanges extends Delayable(InstancePlugin) {
  //region Config

  static get defaultConfig() {
    return {
      // CSS class to apply to range elements
      rangeCls: 'b-sch-range',

      // CSS class to apply to line elements (0-duration time range)
      lineCls: 'b-sch-line',

      /**
       * Store that holds timeRanges (using the {@link Scheduler.model.TimeSpan} model or subclass thereof).
       * A store will be automatically created if none is specified
       * @config {Object|Common.data.Store}
       */
      store: {
        modelClass: TimeSpan
      },

      /**
       * Set to `true` to enable dragging and resizing of range elements in the header. Only relevant when {@link #config-showHeaderElements} is true.
       * @config {Boolean}
       * @defaultValue
       */
      enableResizing: false,

      /**
       * Specifies whether or not to show tooltip while resizing range elements
       * @config {Boolean}
       * @default
       */
      showTooltip: true,

      /**
       * `true` to render range elements into the time axis header
       * @config {Boolean}
       * @default
       */
      showHeaderElements: true,

      dragTipTemplate: (data) => `
                <div class="b-sch-tip-${data.valid ? 'valid' : 'invalid'}">
                    <div class="b-sch-tip-name">${data.name || ''}</div>
                    ${data.startClockHtml}
                    ${data.endClockHtml || ''}
                </div>
            `,

      baseCls: 'b-sch-timerange',

      // a unique cls used by subclasses to get custom styling of the elements rendered
      cls: ''
    };
  }

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['render', 'getHeaderMenuItems']
    };
  }

  //endregion

  //region Init & destroy

  construct(client, config) {
    const me = this;

    super.construct(client, config);

    // Add a unique cls used by subclasses to get custom styling of the elements rendered
    // This makes sure that each class only removed its own elements from the DOM
    me.cls = me.cls || `b-timerange-${me.constructor.$name}`;

    me.baseSelector = `.${me.baseCls}.${me.cls}`;

    // header elements are required for interaction
    if (me.enableResizing) {
      me.showHeaderElements = true;
    }
  }

  doDestroy() {
    const me = this;

    me.storeDetacher && me.storeDetacher();
    me.timeAxisViewModelDetacher && me.timeAxisViewModelDetacher();
    me.timeAxisDetacher && me.timeAxisDetacher();

    me.clockTemplate && me.clockTemplate.destroy();
    me.tip && me.tip.destroy();

    me.drag && me.drag.destroy();
    me.resize && me.resize.destroy();

    super.doDestroy();
  }

  //endregion

  //region Draw

  render() {
    const me = this;

    me.timeAxisViewModel = me.client.timeAxisViewModel;

    me.timeAxisViewModelDetacher = me.timeAxisViewModel.on({
      reconfigure: me.onTimeAxisViewModelUpdate,
      update: me.onTimeAxisViewModelUpdate,
      thisObj: me
    });

    me.timeAxisDetacher = me.client.timeAxis.on({
      includeChange: me.onTimeAxisViewModelUpdate,
      thisObj: me
    });

    if (me.enableResizing) {
      me.drag = new DragHelper({
        name: 'rangeDrag',
        mode: me.client.isVertical ? 'translateY' : 'translateX',
        constrain: true,
        outerElement: me.headerContainerElement,
        targetSelector: `${me.baseSelector}`,
        isElementDraggable: (el, event) => !me.client.readOnly && me.isElementDraggable(el, event),

        listeners: {
          dragstart: me.onDragStart,
          drag: me.onDrag,
          drop: me.onDrop,
          abort: me.onInvalidDrop,
          thisObj: me
        }
      });

      me.resize = new ResizeHelper({
        direction: me.client.mode,
        targetSelector: `${me.baseSelector}.b-sch-range`,
        outerElement: me.headerContainerElement,
        listeners: {
          resizestart: me.onResizeStart,
          resizing: me.onResizeDrag,
          resize: me.onResize,
          thisObj: me
        }
      });
    }

    me.renderRanges();
  }

  renderRanges() {
    const me = this,
      element = me.client.foregroundCanvas;

    // Scheduler/Gantt might not yet be rendered
    if (element) {
      const { headerContainerElement, store } = me;

      // remove existing timeRanges
      DomHelper.removeEachSelector(element, me.baseSelector);
      DomHelper.removeEachSelector(headerContainerElement, me.baseSelector);

      if (!me.disabled) {
        // add timeRanges
        for (let range of store) {
          me.renderRange(range, true);
        }
      }
    }
  }

  renderRange(range, injectIntoDom) {
    const me = this,
      client = me.client;

    if (!client.rendered) {
      return;
    }

    if (
      (range.duration && client.timeAxis.timeSpanInAxis(range.startDate, range.endDate)) ||
      (range.startDate && client.timeAxis.dateInAxis(range.startDate))
    ) {
      const startPos = client.getCoordinateFromDate(DateHelper.max(range.startDate, client.timeAxis.startDate), {
          respectExclusion: true
        }),
        endPos =
          range.duration &&
          client.getCoordinateFromDate(DateHelper.min(range.endDate, client.timeAxis.endDate), {
            respectExclusion: true,
            isEnd: true
          }),
        labelTpl = `<label>${range.name || '&nbsp;'}</label>`,
        config = {
          className: `${me.baseCls} ${me.cls} ${endPos ? me.rangeCls : me.lineCls} ${range.cls || ''}`,
          dataset: {
            id: range.id
          },
          style: client.isVertical
            ? `transform: translateY(${startPos}px); ${endPos ? `height:${endPos - startPos}px` : ''};`
            : `transform: translateX(${startPos}px); ${endPos ? `width:${endPos - startPos}px` : ''};`,
          retainElement: true // To prevent DomHelper.sync from reusing the element
        },
        bodyElement = DomHelper.createElement(
          Object.assign({}, config, {
            parent: injectIntoDom && client.foregroundCanvas,
            style: config.style + (range.style || ''),
            html: me.showHeaderElements ? '' : labelTpl
          })
        );

      let headerElement;

      if (me.showHeaderElements) {
        headerElement = DomHelper.createElement(
          Object.assign(
            {
              parent: injectIntoDom && me.headerContainerElement,
              html: range.name ? labelTpl : ''
            },
            config
          )
        );
      }

      const result = { bodyElement, headerElement };

      if (injectIntoDom) {
        // Make the label run vertically if it overflows the width
        me.rotateLabel(result);
      }
      return result;
    }
  }

  rotateLabel({ bodyElement }) {
    const label = bodyElement.firstChild;

    // Lines have no label
    if (!label) {
      return;
    }

    // Remove any rotation so with can be measured.
    label.classList.remove('b-vertical');

    const rotate = this.client.isVertical
      ? label.offsetHeight < bodyElement.offsetHeight
      : label.offsetWidth > bodyElement.offsetWidth;

    // If it overflows, rotate it.
    label.classList[rotate ? 'add' : 'remove']('b-vertical');
  }

  // returns one body el (+ optionally one header el) that represents a time range, or null if timeRanges is not currently rendered
  getElementsByRecord(idOrRecord) {
    const id = typeof idOrRecord === 'string' ? idOrRecord : idOrRecord.id,
      bodyElement = this.client.foregroundCanvas.querySelector(`${this.baseSelector}[data-id="${id}"]`),
      headerElement = this.headerContainerElement.querySelector(`${this.baseSelector}[data-id="${id}"]`);

    return bodyElement ? { bodyElement, headerElement } : null;
  }

  getBodyElementByRecord(idOrRecord) {
    const id = typeof idOrRecord === 'string' ? idOrRecord : idOrRecord.id;

    return this.client.foregroundCanvas.querySelector(`${this.baseSelector}[data-id="${id}"]`);
  }

  getRecordByElement(el) {
    return this.store.getById(el.dataset.id);
  }

  get headerContainerElement() {
    // Render into the subGrid´s header element or the vertical timeaxis depending on mode
    return this.client.isVertical
      ? this.client.timeView.element.parentElement
      : this.client.timeAxisColumn.element.parentElement;
  }

  //endregion

  /**
   * Get/set if header elements should be rendered
   * @property {boolean}
   */
  get showHeaderElements() {
    return this._showHeaderElements;
  }

  set showHeaderElements(show) {
    this._showHeaderElements = show;

    if (!this.client.element) return;

    if (show) {
      this.client.element.classList.add('b-sch-timeranges-with-headerelements');
    } else {
      this.client.element.classList.remove('b-sch-timeranges-with-headerelements');
    }
    this.renderRanges();
  }

  //endregion

  //region Menu items

  /**
   * @private
   */
  getHeaderMenuItems(column, items) {
    return [];
  }

  //endregion

  //region Disable

  /**
   * Get/set the features disabled state
   * @property {Boolean}
   */
  get disabled() {
    return super.disabled;
  }

  set disabled(disabled) {
    super.disabled = disabled;

    this.renderRanges();
  }

  /**
   * Returns the {@link Common.data.Store store} used by this feature
   * @property {Common.data.Store}
   */
  get store() {
    return this._store;
  }

  set store(store) {
    const me = this;

    me._store = Store.getStore(store, Store);

    let renderRanges = false;

    // if we had some store assigned before we need to detach it
    if (me.storeDetacher) {
      me.storeDetacher();
      // then we'll need to render ranges provided by the new store
      renderRanges = true;
    }

    me.storeDetacher = me._store.on({
      change: me.onStoreChanged,
      thisObj: me
    });

    // render ranges if needed
    renderRanges && this.renderRanges();
  }

  //endregion

  //region Events

  onTimeAxisViewModelUpdate() {
    this.renderRanges();
  }

  onStoreChanged(event) {
    const me = this;

    if (me.isConfiguring) {
      return;
    }

    // Only animate changes that happen as a result of a pure data change, i.e. not after a drag drop
    if (event.action === 'update') {
      const existingElements = me.getElementsByRecord(event.record),
        redrawnElements = me.renderRange(event.record, !existingElements);

      if (existingElements && !redrawnElements) {
        existingElements.bodyElement.remove();
        existingElements.headerElement && existingElements.headerElement.remove();
      }

      if (!existingElements || !redrawnElements) return;

      me.client.runWithTransition(() => {
        DomHelper.sync(redrawnElements.bodyElement, existingElements.bodyElement);

        if (me.showHeaderElements) {
          DomHelper.sync(redrawnElements.headerElement, existingElements.headerElement);
        }

        // Make the label run vertically if it overflows the width
        me.rotateLabel(existingElements);
      });
    } else {
      me.renderRanges();
    }
  }

  //endregion

  //region Drag drop
  showTip(context) {
    const me = this;

    if (me.showTooltip) {
      me.clockTemplate = new ClockTemplate({
        timeAxisViewModel: me.client.timeAxisViewModel
      });

      me.tip = new Tooltip({
        cls: 'b-interaction-tooltip',
        align: 'b-t',
        autoShow: true,
        forElement: context.element,
        getHtml: () => me.getTipHtml(context.record, context.element)
      });
    }
  }

  isElementDraggable(el) {
    el = el.closest(this.baseSelector);

    return el && !el.classList.contains('b-over-resize-handle');
  }

  onDragStart({ context }) {
    const me = this,
      record = me.getRecordByElement(context.element.closest(me.baseSelector)),
      rangeBodyEl = me.getBodyElementByRecord(record),
      drag = me.drag;

    Object.assign(context, {
      record,
      rangeBodyEl,
      originRangeX: DomHelper.getTranslateX(rangeBodyEl),
      originRangeY: DomHelper.getTranslateY(rangeBodyEl)
    });

    if (me.client.isVertical) {
      drag.minY = 0;

      // Moving the range, you can drag the start marker down until the end of the range hits the time axis end
      drag.maxY = me.timeAxisViewModel.totalSize - context.rangeBodyEl.offsetHeight;
    } else {
      drag.minX = 0;

      // Moving the range, you can drag the start marker right until the end of the range hits the time axis end
      drag.maxX = me.timeAxisViewModel.totalSize - context.rangeBodyEl.offsetWidth;
    }

    me.showTip(context);
  }

  onDrag({ context }) {
    // sync body element with header element (x + width)
    if (this.client.isVertical) {
      DomHelper.setTranslateY(context.rangeBodyEl, DomHelper.getTranslateY(context.element));
    } else {
      DomHelper.setTranslateX(context.rangeBodyEl, DomHelper.getTranslateX(context.element));
    }

    if (this.showTooltip) {
      this.tip.realign();
    }
  }

  onDrop({ context }) {
    if (!context.valid) {
      return this.onInvalidDrop({ context });
    }

    const me = this,
      record = context.record,
      box = context.rangeBodyEl.getBoundingClientRect(),
      newStart = me.client.getDateFromCoordinate(me.client.isVertical ? box.top : box.left, 'round', false),
      wasModified = record.startDate - newStart !== 0;

    if (wasModified) {
      record.setStartDate(newStart);
    } else {
      me.onInvalidDrop();
    }

    if (me.tip) {
      me.tip.destroy();
      me.tip = null;
    }
  }

  onInvalidDrop() {
    const me = this;

    me.drag.reset();
    me.renderRanges();

    if (me.tip) {
      me.tip.destroy();
      me.tip = null;
    }
  }

  // endregion

  // region resize
  onResizeStart({ context }) {
    const me = this,
      record = me.getRecordByElement(context.element.closest(me.baseSelector)),
      rangeBodyEl = me.getBodyElementByRecord(record);

    Object.assign(context, {
      record,
      rangeBodyEl
    });

    me.showTip(context);
  }

  onResizeDrag({ context }) {
    const me = this;

    if (me.client.isVertical) {
      if (context.edge === 'top') {
        DomHelper.setTranslateY(context.rangeBodyEl, context.newY);
      }

      context.rangeBodyEl.style.height = context.newHeight + 'px';
    } else {
      if (context.edge === 'left') {
        DomHelper.setTranslateX(context.rangeBodyEl, context.newX);
      }

      context.rangeBodyEl.style.width = context.newWidth + 'px';
    }

    if (me.showTooltip) {
      me.tip.realign();
    }
  }

  onResize({ context }) {
    if (!context.valid) return this.onInvalidDrop({ context });

    const me = this,
      { client } = me,
      record = context.record,
      box = context.element.getBoundingClientRect(),
      startPos = client.isVertical ? box.top : box.left,
      endPos = client.isVertical ? box.bottom : box.right,
      newStart = client.getDateFromCoordinate(startPos, 'round', false),
      isStart = context.edge === 'left' || context.edge === 'top',
      newEnd = client.getDateFromCoordinate(endPos, 'round', false),
      wasModified = (isStart && record.startDate - newStart !== 0) || (newEnd && record.endDate - newEnd !== 0);

    if (wasModified && newEnd > newStart) {
      if (isStart) {
        // could be that the drag operation placed the range with start/end outside the axis
        record.setStartDate(newStart, false);
      } else {
        record.setEndDate(newEnd, false);
      }
    } else {
      me.onInvalidResize();
    }

    if (me.tip) {
      me.tip.destroy();
      me.tip = null;
    }
  }

  onInvalidResize() {
    const me = this;

    me.resize.reset();
    me.renderRanges();

    if (me.tip) {
      me.tip.destroy();
      me.tip = null;
    }
  }

  /**
   * Gets html to display in tooltip during drag drop.
   */
  getTipHtml(record, element) {
    const me = this,
      { client } = me,
      box = element.getBoundingClientRect(),
      startPos = client.isVertical ? box.top : box.left,
      endPos = client.isVertical ? box.bottom : box.right,
      startDate = client.getDateFromCoordinate(startPos, 'round', false),
      endDate = record.endDate && client.getDateFromCoordinate(endPos, 'round', false),
      startText = client.getFormattedDate(startDate),
      endText = endDate && client.getFormattedEndDate(endDate, startDate);

    return me.dragTipTemplate({
      name: record.name || '',
      startDate: startDate,
      endDate: endDate,
      startText: startText,
      endText: endText,
      startClockHtml: me.clockTemplate.template({
        date: startDate,
        text: startText,
        cls: 'b-sch-tooltip-startdate'
      }),
      endClockHtml:
        endText &&
        me.clockTemplate.template({
          date: endDate,
          text: endText,
          cls: 'b-sch-tooltip-enddate'
        })
    });
  }

  //endregion
}
AbstractTimeRanges._$name = 'AbstractTimeRanges';

/**
 * @module Scheduler/feature/NonWorkingTime
 */

/**
 * Feature that allows styling of weekends (and other non working time) by adding timeRanges for those days.
 *
 * This feature is **disabled** by default
 *
 * @extends Scheduler/feature/AbstractTimeRanges
 * @demo configuration
 * @externalexample scheduler/NonWorkingTime.js
 */
class NonWorkingTime extends AbstractTimeRanges {
  //region Default config

  static get defaultConfig() {
    return {
      /**
       * Highlight weekends
       * @config {Boolean}
       * @default
       */
      highlightWeekends: true,

      showHeaderElements: true,

      cls: 'b-sch-nonworkingtime'
    };
  }

  //endregion

  //region Init & destroy

  construct(client, config) {
    const me = this;

    super.construct(client, config);

    if (!me.calendar || !client.calendar) {
      me.calendar = new Calendar();
    }

    me.bindCalendar(me.calendar);
  }

  doDestroy() {
    this.bindCalendar(null);
    super.doDestroy();
  }

  //endregion

  //region Calendar

  bindCalendar(calendar) {
    const me = this;

    if (me.calendarDetacher) me.calendarDetacher();

    if (calendar) {
      me.calendarDetacher = calendar.on({
        change: me.renderRanges,
        thisObj: me,
        delay: 1
      });
    }

    me.calendar = calendar;

    me.renderRanges();
  }

  //endregion

  //region Draw

  renderRanges() {
    const me = this;

    if (me.store && !me.store.isDestroyed) {
      const shouldPaint = DateHelper.as(me.client.timeAxis.unit, 1, 'week') >= 1;

      me.store.removeAll(true);

      if (me.calendar && me.highlightWeekends && shouldPaint) {
        me.store.add(
          me.calendar.getHolidaysRanges(me.client.timeAxis.startDate, me.client.timeAxis.endDate, true),
          true
        );
      }
    }

    super.renderRanges();
  }

  //endregion
}

NonWorkingTime._$name = 'NonWorkingTime';
GridFeatureManager.registerFeature(NonWorkingTime, false, ['Scheduler', 'Gantt']);

/**
 * @module Scheduler/feature/Pan
 */

/**
 * Makes the scheduler's timeline pannable by dragging with the mouses.
 *
 * This feature is **disabled** by default.
 *
 * **NOTE:** Incompatible with {@link Scheduler.feature.EventDragCreate EventDragCreate} feature.
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @example
 * // enable Pan
 * let scheduler = new Scheduler({
 *   features : {
 *     pan : true,
 *     eventDragCreate : false
 *   }
 * });
 *
 * @classtype pan
 */
class Pan extends InstancePlugin {
  // region Init

  static get defaultConfig() {
    return {
      /**
       * Set to false to only pan horizontally
       * @config {Boolean}
       * @default
       */
      vertical: true
    };
  }

  construct(timeline, config) {
    this.timeline = timeline;

    if (timeline.features.eventDragCreate) throw new Error('Cannot combine Pan and eventDragCreate features');

    const targetSelectors = ['.b-grid-cell', '.b-timeline-subgrid'];

    this.targetSelector = targetSelectors.join(',');

    super.construct(timeline, config);
  }

  //endregion

  //region Plugin config

  // Plugin configuration. This plugin chains some of the functions in Scheduler.
  static get pluginConfig() {
    return {
      chain: ['onElementMouseDown', 'onElementMouseMove', 'onElementMouseUp']
    };
  }

  //endregion

  onElementMouseDown(event) {
    const me = this,
      timeline = me.timeline,
      dragFeature = Object.values(timeline.features).find((feature) => feature instanceof DragBase),
      enablePanOnEvents = timeline.readOnly || !dragFeature || dragFeature.disabled;

    // only react to mouse input, and left button
    if (event.touches || event.button !== 0) {
      return;
    }

    // only react to mousedown directly on grid cell, subgrid element or if drag is disabled - the events too
    if (
      event.target.matches(me.targetSelector) ||
      (enablePanOnEvents && event.target.closest(timeline.eventSelector))
    ) {
      me.mouseX = event.clientX;
      me.mouseY = event.clientY;
    }
  }

  onElementMouseMove(event) {
    const me = this;

    // Synthetic mousemove event has no button for IE11
    // Detect if a mouseup happened outside our element (or browser window for that matter). Note 'buttons' is not supported by Safari
    if (event.buttons === 0 && !BrowserHelper.isSafari && (!BrowserHelper.isIE11 || event.isTrusted)) {
      me.onElementMouseUp();
      return;
    }

    if (typeof me.mouseX === 'number') {
      const xScroller = me.timeline.subGrids.normal.scrollable,
        yScroller = me.timeline.scrollable,
        x = event.clientX,
        y = event.clientY;

      event.preventDefault();

      if (me.vertical) {
        yScroller.scrollBy(0, me.mouseY - y);
      }

      xScroller.scrollBy(me.mouseX - x);

      me.mouseX = x;
      me.mouseY = y;
    }
  }

  onElementMouseUp(event) {
    this.mouseX = this.mouseY = null;
  }

  //endregion
}

Pan._$name = 'Pan';
GridFeatureManager.registerFeature(Pan, false, ['Scheduler', 'Gantt']);

/**
 * @module Scheduler/feature/ResourceTimeRanges
 */

/**
 * Feature that draws resource time ranges, shaded areas displayed behind events. These zones are similar to events in
 * that they have a start and end date but different in that they do not take part in the event layout and they always
 * occupy full row height.
 *
 * Each time range is represented by an instances of {@link Scheduler.model.ResourceTimeRangeModel}, held in a
 * {@link Scheduler.data.ResourceTimeRangeStore}. Currently the they are readonly UI-wise, but can be manipulated on
 * the data level. To style the rendered elements, use the {@link Scheduler.model.TimeSpan#field-cls cls} field or use the {@link Scheduler.model.ResourceTimeRangeModel#field-timeRangeColor} field.
 *
 * Data can be provided either using the {@link #config-store} config:
 *
 * ```javascript
 * new Scheduler({
 *   features :  {
 *       resourceTimeRanges : {
 *          store : new Scheduler.data.ResourceTimeRangeStore({
 *              readUrl : './resourceTimeRanges/'
 *          })
 *       }
 *   }
 * })
 * ```
 *
 * or the `resourceTimeRanges` config on the Scheduler config object:
 *
 * ```javascript
 * new Scheduler({
 *   features :  {
 *       resourceTimeRanges : true
 *   },
 *
 *   // Data specified directly on the Scheduler instance
 *   resourceTimeRanges : [
 *     // Either specify startDate & endDate or startDate & duration when defining a range
 *     { startDate : new Date(2019,0,1), endDate : new Date(2019,0,3), name : 'Occupied', timeRangeColor : 'red' },
 *     { startDate : new Date(2019,0,3), duration : 2, durationUnit : 'd', name : 'Available' },
 *   ]
 * })
 * ```
 *
 * This feature is **disabled** by default
 *
 * @extends Common/mixin/InstancePlugin
 * @demo resourcetimeranges
 * @externalexample scheduler/ResourceTimeRanges.js
 */
class ResourceTimeRanges extends InstancePlugin {
  //region Config

  static get defaultConfig() {
    return {
      idPrefix: 'resourcetimerange',
      rangeCls: 'b-sch-resourcetimerange',

      /**
       * Store that holds resource time ranges (using ResourceTimeRangeModel or subclass thereof). A store will be
       * automatically created if none is specified
       * @config {Scheduler.data.ResourceTimeRangeStore}
       */
      store: false,

      /**
       * Time range definitions (data to ResourceTimeRangeModels). Will be added to store. Can also be specified
       * on Scheduler for convenience
       * @config {Scheduler.model.ResourceTimeRangeModel[]|Object[]}
       */
      resourceTimeRanges: null
    };
  }

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['getEventsToRender', 'onEventDataGenerated', 'noFeatureElementsInAxis']
    };
  }

  // Let Scheduler know if we have ResourceTimeRanges in view or not
  noFeatureElementsInAxis() {
    const { timeAxis } = this.scheduler;
    return !this.store.storage.values.some((t) => timeAxis.isTimeSpanInAxis(t));
  }

  //endregion

  //region Init

  construct(scheduler, config) {
    const me = this;

    me.scheduler = scheduler;

    super.construct(scheduler, config);

    // expose getter/setter for resourceTimeRanges on scheduler
    Object.defineProperty(scheduler, 'resourceTimeRanges', {
      get: () => me.store.records,
      set: (resourceTimeRanges) => (me.store.data = resourceTimeRanges)
    });
  }

  /**
   * Called during construction to do product specific store setup
   * @private
   */
  set store(store) {
    const me = this,
      { scheduler } = me;

    me._store = store = store || new ResourceTimeRangeStore();

    if (!scheduler.resourceTimeRangeStore) {
      scheduler.resourceTimeRangeStore = store;
    }

    // ResourceZones can be set on scheduler or feature, for convenience
    if (scheduler.resourceTimeRanges) {
      store.add(scheduler.resourceTimeRanges);
      delete scheduler.resourceTimeRanges;
    }

    // Link to schedulers resourceStore if not already linked to one
    if (!store.resourceStore) {
      store.resourceStore = scheduler.resourceStore;
    }

    me.storeDetacher && me.storeDetacher();

    me.storeDetacher = me.store.on({
      change: me.onStoreChange,
      thisObj: me
    });
  }

  get store() {
    return this._store;
  }

  //endregion

  // Called on render of resources events to get events to render. Add any ranges
  // (chained function from Scheduler)
  getEventsToRender(resource, events) {
    if (resource.timeRanges && resource.timeRanges.length) {
      events.push(...resource.timeRanges);
    }
    return events;
  }

  // Called for each event during render, allows manipulation of render data. Adjust any resource time ranges
  // (chained function from Scheduler)
  onEventDataGenerated(renderData) {
    const me = this,
      record = renderData.event || renderData.eventRecord; // Differs by mode

    if (record.isResourceTimeRange) {
      if (me.scheduler.isVertical) {
        renderData.width = me.scheduler.resourceColumnWidth;
      } else {
        renderData.top = 0;
        // Avoid colliding ids by using a prefix
        renderData.id = `${me.scheduler.id}-${me.idPrefix}-${record.id}`;
      }

      // Flag that we should fill entire row/col
      renderData.fillSize = true;
      // Needed for caching
      renderData.eventId = `${me.idPrefix}-${record.id}`;
      // Add our own cls
      renderData.wrapperCls[me.rangeCls] = 1;
      renderData.wrapperCls[`b-sch-color-${record.timeRangeColor}`] = record.timeRangeColor;
      // Add label
      renderData.body = document.createDocumentFragment();
      renderData.body.textContent = record.name;
    }
  }

  // Called when a ResourceTimeRangeModel is manipulated, relays to Scheduler#onInternalEventStoreChange which updates to UI
  onStoreChange(event) {
    this.scheduler.onInternalEventStoreChange(event);
  }
}

// No feature based styling needed, do not add a cls to Scheduler
ResourceTimeRanges.featureClass = '';

ResourceTimeRanges._$name = 'ResourceTimeRanges';
GridFeatureManager.registerFeature(ResourceTimeRanges, false, 'Scheduler');

/**
 * @module Scheduler/feature/SimpleEventEdit
 */

/**
 * Feature that displays a text field to edit the event name. You can control the flow of this by listening to the events relayed by this class from the underlying {@link Common.widget.Editor}.
 * To use this feature, you also need to disable the built-in default editing feature:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         eventEdit       : false,
 *         simpleEventEdit : true
 *     }
 * });
 * ```
 *
 * This feature is **disabled** by default
 *
 * @extends Common/mixin/InstancePlugin
 * @demo simpleeditor
 * @externalexample scheduler/SimpleEventEdit.js
 */
class SimpleEventEdit extends InstancePlugin {
  // region Events
  /**
   * Fired before the editor is shown to start an edit operation. Returning `false` from a handler vetoes the edit operation.
   * @event beforeStart
   * @preventable
   * @property {Object} value - The value to be edited.
   * @property {Common.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fired when an edit operation has begun.
   * @event start
   * @property {Object} value - The starting value of the field.
   * @property {Common.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fired when an edit completion has been requested, either by `ENTER`, or focus loss (if configured to complete on blur).
   * The completion may be vetoed, in which case, focus is moved back into the editor.
   * @event beforeComplete
   * @property {Object} oldValue - The original value.
   * @property {Object} value - The new value.
   * @property {Common.widget.Editor} source - The Editor that triggered the event.
   * @preventable
   */
  /**
   * Edit has been completed, and any associated record or element has been updated.
   * @event complete
   * @property {Object} oldValue - The original value.
   * @property {Object} value - The new value.
   * @property {Common.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fired when cancellation has been requested, either by `ESC`, or focus loss (if configured to cancel on blur).
   * The cancellation may be vetoed, in which case, focus is moved back into the editor.
   * @event beforeCancel
   * @property {Object} oldValue - The original value.
   * @property {Object} value - The new value.
   * @property {Common.widget.Editor} source - The Editor that triggered the event.
   * @preventable
   */
  /**
   * Edit has been canceled without updating the associated record or element.
   * @event cancel
   * @property {Object} oldValue - The original value.
   * @property {Object} value - The value of the field.
   * @property {Common.widget.Editor} source - The Editor that triggered the event.
   */
  // endregion

  //region Config

  static get defaultConfig() {
    return {
      /**
       * The event that shall trigger showing the editor. Defaults to `eventdblclick`, set to `` or null to disable editing of existing events.
       * @config {String}
       * @default
       * @category Editor
       */
      triggerEvent: 'eventdblclick',

      /**
       * The current {@link Scheduler.model.EventModel} record, which is being edited by the event editor.
       * @property {Scheduler.model.EventModel}
       * @readonly
       */
      eventRecord: null,

      /**
       * The {@link Scheduler.model.EventModel} field to edit
       * @config {String}
       * @category Editor
       */
      field: 'name',

      /**
       * The editor configuration, where you can control which widget to show
       * @config {Object}
       * @category Editor
       */
      editorConfig: null
    };
  }

  static get pluginConfig() {
    return {
      chain: ['onEnterKey'],
      assign: ['editEvent']
    };
  }

  //endregion

  //region Editing

  construct(scheduler, config) {
    const me = this;

    me.scheduler = scheduler;
    me.eventStore = scheduler.eventStore;

    scheduler.eventEdit = me;

    super.construct(scheduler, config);

    me.clientListenersDetacher = scheduler.on({
      [me.triggerEvent]: ({ eventRecord, eventElement }) =>
        me.editEvent(eventRecord, eventRecord.resource, eventElement),
      dragcreateend: me.onDragCreateEnd,
      thisObj: me
    });
  }

  doDestroy() {
    this.clientListenersDetacher();

    this.editor && this.editor.destroy();

    super.doDestroy();
  }

  // region Editor
  /**
   * Opens an Editor for the passed event. This function is exposed on Scheduler and can be called as
   * `scheduler.editEvent()`.
   * @param {Scheduler.model.EventModel} eventRecord The Event to edit
   * @param {Scheduler.model.ResourceModel} [resourceRecord] The Resource record for the event.
   */
  editEvent(eventRecord, resourceRecord, element) {
    const me = this,
      scheduler = me.scheduler;

    if (scheduler.readOnly) {
      return;
    }

    eventRecord = eventRecord instanceof AssignmentModel ? eventRecord.event : eventRecord;

    me.resource = resourceRecord;
    me.event = eventRecord;
    me.element = element;

    scheduler.element.classList.add('b-eventeditor-editing');

    if (!me.editor) {
      me.editor = new Editor(
        Object.assign(
          {
            appendTo: me.scheduler.element,
            scrollAction: 'realign',
            cls: 'b-simpleeventeditor',
            listeners: {
              complete: me.onEditorComplete,
              cancel: me.onEditorCancel,
              thisObj: me
            }
          },
          me.editorConfig
        )
      );

      me.relayEvents(me.editor, ['beforestart', 'start', 'beforecomplete', 'complete', 'beforecancel', 'cancel']);
    }

    me.editor.startEdit({
      target: element,
      record: eventRecord,
      field: me.field
    });
  }

  onEditorComplete() {
    const me = this;

    if (me.event.stores.length === 0) {
      me.eventStore.add(me.editor.record);
      me.event.assign(me.resource);
      me.element.remove();
    }
    me.scheduler.element.classList.remove('b-eventeditor-editing');
  }

  onEditorCancel() {
    if (this.event.stores.length === 0) {
      this.element.remove();
    }
    this.scheduler.element.classList.remove('b-eventeditor-editing');
  }

  //endregion

  // chained from EventNavigation
  onEnterKey({ assignmentRecord, eventRecord }) {
    const element = assignmentRecord
        ? this.scheduler.getElementFromAssignmentRecord(assignmentRecord)
        : this.scheduler.getElementFromEventRecord(eventRecord),
      resourceRecord = (assignmentRecord || eventRecord).resource;

    this.editEvent(eventRecord, resourceRecord, element);
  }

  //endregion

  onDragCreateEnd({ newEventRecord, resourceRecord, proxyElement }) {
    const me = this;

    // Call scheduler template method
    me.scheduler.onEventCreated(newEventRecord);

    // Clone proxy after showing editor so it's not deleted
    const dragProxyElement = proxyElement.cloneNode(true);
    dragProxyElement.removeAttribute('id');

    proxyElement.parentElement.appendChild(dragProxyElement);

    me.element = dragProxyElement;

    me.editEvent(newEventRecord, resourceRecord, dragProxyElement);
  }
}

SimpleEventEdit._$name = 'SimpleEventEdit';
GridFeatureManager.registerFeature(SimpleEventEdit, false, 'Scheduler');

/**
 * @module Grid/feature/Summary
 */

/**
 * Displays a summary row in the grid footer. Specify type of summary on columns, available types are:
 * <dl class="wide">
 * <dt>sum <dd>Sum of all values in the column
 * <dt>add <dd>Alias for sum
 * <dt>count <dd>Number of rows
 * <dt>countNotEmpty <dd>Number of rows containing a value
 * <dt>average <dd>Average of all values in the column
 * <dt>function <dd>A custom function, used with store.reduce. Should take arguments (sum, record)
 * </dl>
 * Columns can also specify a summaryRenderer to format the calculated sum.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * ```
 * { text : 'Score', data : 'score', width : 80, sum : true }
 * { text : 'Rank', data : 'rank', width : 80, sum : 'average', summaryRenderer: sum => return 'Average rank ' + sum }
 * ```
 *
 * Also it is possible to set up multiple summaries as array of summary configs:
 * ```
 * { text : 'Rank', data : 'rank', summaries : [{ sum : 'average', label : 'Average' }, { sum : 'count', label : 'Count' }] }
 * ```
 *
 * @extends Common/mixin/InstancePlugin
 *
 * @demo features
 * @classtype summary
 * @externalexample feature/Summary.js
 */
class Summary extends SummaryFormatter(InstancePlugin) {
  //region Init

  construct(grid, config) {
    const me = this;

    Object.assign(me, {
      grid: grid,
      store: grid.store
    });

    super.construct(grid, config);

    me.store.on({
      change: me.onStoreChanged,
      thisObj: me
    });

    // footers aren't added by default, add
    me.grid.eachSubGrid((subGrid) => {
      if (!subGrid.footer) {
        subGrid.footer = new Footer({
          subGrid,
          parent: subGrid // Contained widgets need to know their parents
        });
      }
    });
  }

  doDestroy() {
    super.doDestroy();
  }

  //endregion

  //region Plugin config

  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['renderRows']
    };
  }

  //endregion

  //region Render

  renderRows() {
    this.updateSummaries();
  }

  /**
   * Updates summaries. Summaries are displayed as tables in footer (styling left out to keep brief):
   * ```
   * <table>
   *     <tr><td colspan="2">0</td></tr> // { sum : 'min' } Only a calculation, span entire table
   *     <tr><td>Max</td><td>10</td></tr> // { sum : 'max', label: 'Max' } Label + calculation
   *     <tr><td>Max</td><td>10</td></tr> // { sum : 'sum', label: 'Max' } Label + calculation
   * </table>
   * ```
   * @private
   */
  updateSummaries() {
    const me = this,
      cells = DomHelper.children(me.grid.element, '.b-grid-footer'),
      store = me.store,
      records = store.storage.values.filter((r) => !r.meta.specialRow);

    // reset seeds, to not have ever increasing sums :)
    me.grid.columns.forEach((column) => {
      column.summaries &&
        column.summaries.forEach((config) => {
          if ('seed' in config) {
            if (!('initialSeed' in config)) {
              config.initialSeed = config.seed;
            }

            if (['number', 'string', 'date'].includes(typeof config.initialSeed)) {
              config.seed = config.initialSeed;
            } else {
              // create shallow copy
              config.seed = Object.assign({}, config.initialSeed);
            }
          }
        });
    });

    cells.forEach((cellElement) => {
      const column = me.grid.columns.get(cellElement.dataset.column),
        html = me.generateHtml(column, records, 'b-grid-footer-summary');

      if (column.summaries ? column.summaries.length : column.sum ? 1 : 0) {
        // First time, set table
        if (!cellElement.children.length) {
          cellElement.innerHTML = html;
        }
        // Following times, sync changes
        else {
          DomHelper.sync(html, cellElement.firstElementChild);
        }
      }
    });
  }

  //endregion

  //region Events

  /**
   * Updates summaries on store changes (except record update, handled below)
   * @private
   */
  onStoreChanged({ action, changes }) {
    let shouldUpdate = true;

    if (action === 'update') {
      // only update summary when a field that affects summary is changed
      // TODO: this should maybe be removed, another column might depend on the value for its summary?
      shouldUpdate = Object.keys(changes).some((field) => {
        const colField = this.grid.columns.get(field);
        // check existence, since a field not used in a column might have changed
        return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));
      });
    }

    if (shouldUpdate) {
      this.updateSummaries();
    }
  }

  //endregion
}

Summary.featureClass = 'b-summary';

Summary._$name = 'Summary';
GridFeatureManager.registerFeature(Summary);

/**
 * @module Scheduler/feature/Summary
 */

// noinspection JSClosureCompilerSyntax
/**
 * A special version of the Grid Summary feature. This feature displays a summary row in the grid footer.
 * For regular columns in the locked section - specify type of summary on columns, available types are:
 * <dl class="wide">
 * <dt>sum <dd>Sum of all values in the column
 * <dt>add <dd>Alias for sum
 * <dt>count <dd>Number of rows
 * <dt>countNotEmpty <dd>Number of rows containing a value
 * <dt>average <dd>Average of all values in the column
 * <dt>function <dd>A custom function, used with store.reduce. Should take arguments (sum, record)
 * </dl>
 * Columns can also specify a summaryRender to format the calculated sum.
 *
 * To summarize events, either provide a {@link #config-renderer} or use {@link #config-summaries}
 *
 * This feature is <strong>disabled</strong> by default. It is **not** supported in vertical mode.
 *
 * @extends Grid/feature/Summary
 *
 * @classtype summary
 * @externalexample scheduler/Summary.js
 * @demo summary
 * @typings Grid/feature/Summary -> Grid/feature/GridSummary
 */
class Summary$1 extends Summary {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Show tooltip containing summary values and labels
       * @config {Boolean}
       * @default
       */
      showTooltip: true,

      /**
       * Array of summary configs, with format
       * `[{ label: 'Label', renderer : ({startDate, endDate, eventStore, resourceStore, events, element}) }]`.
       * @config {Object[]}
       */
      summaries: null,

      /**
       * Easier way to configure When using single summary, accepts a renderer function with the format specified
       * in {@link #config-summaries}
       * @config {Function}
       */
      renderer: null
    };
  }

  //endregion

  //region Init

  construct(scheduler, config) {
    const me = this;

    if (scheduler.isVertical) {
      throw new Error('Summary feature is not supported in vertical mode');
    }

    me.scheduler = scheduler;

    super.construct(scheduler, config);

    if (!me.summaries) me.summaries = [{ renderer: me.renderer }];

    // Feature might be run from Grid (in docs), should not crash
    // https://app.assembla.com/spaces/bryntum/tickets/6801/details
    if (scheduler instanceof Scheduler) {
      scheduler.eventStore.on({
        change: me.updateScheduleSummaries,
        thisObj: me
      });

      scheduler.resourceStore.on({
        change: me.updateScheduleSummaries,
        thisObj: me
      });

      scheduler.timeAxisViewModel.on({
        update: me.renderRows,
        thisObj: me
      });
    }
  }

  //endregion

  //region Render

  renderRows() {
    super.renderRows();
    this.render();
  }

  /**
   * Updates summaries.
   * @private
   */
  updateScheduleSummaries() {
    const me = this,
      scheduler = me.scheduler,
      summaryContainer = scheduler.element.querySelector('.b-grid-footer.b-sch-timeaxiscolumn');

    if (summaryContainer) {
      DomHelper.forEachSelector(summaryContainer, '.b-timeaxis-tick', (element, i) => {
        const tick = scheduler.timeAxis.getAt(i),
          events = scheduler.eventStore.getEventsInTimeSpan(tick.startDate, tick.endDate, true, true);

        let html = '',
          tipHtml = `<header>${me.L('Summary for')} ${scheduler.getFormattedDate(tick.startDate)}</header>`;

        me.summaries.forEach((config) => {
          const value = config.renderer({
              startDate: tick.startDate,
              endDate: tick.endDate,
              eventStore: scheduler.eventStore,
              resourceStore: scheduler.resourceStore,
              events,
              element
            }),
            valueHtml = `<div class="b-timeaxis-summary-value">${value}</div>`;

          if (me.summaries.length > 1 || value !== '') html += valueHtml;
          tipHtml += `<label>${config.label || ''}</label>` + valueHtml;
        });

        element.innerHTML = html;
        element._tipHtml = tipHtml;
      });
    }
  }

  render() {
    const me = this,
      scheduler = me.scheduler,
      summaryEl = scheduler.element.querySelector('.b-grid-footer.b-sch-timeaxiscolumn');

    if (summaryEl) {
      // if any sum config has a label, init tooltip
      if (me.summaries.some((config) => config.label) && me.showTooltip && !me._tip) {
        me._tip = new Tooltip({
          id: `${scheduler.id}-summary-tip`,
          cls: 'b-timeaxis-summary-tip',
          hoverDelay: 0,
          hideDelay: 100,
          forElement: summaryEl,
          anchorToTarget: true,
          trackMouse: false,
          forSelector: '.b-timeaxis-tick',
          getHtml: ({ forElement }) => forElement._tipHtml
        });
      }

      summaryEl.innerHTML = `<div class="b-timeaxis-tick" style="width: ${scheduler.tickSize}px"></div>`.repeat(
        scheduler.timeAxis.count
      );

      me.updateScheduleSummaries();
    }
  }

  //endregion
}

// Needed for module bundle, which turns class name into Summary$1 and registers it wrong
Summary$1._$name = 'Summary';

// Override Grids Summary with this improved version
Summary$1._$name = 'Summary';
GridFeatureManager.registerFeature(Summary$1, false, 'Scheduler');

/**
 * @module Scheduler/feature/TimeRanges
 */

/**
 * Feature that renders global ranges of time in the timeline. Use this feature to visualize a `range` like a 1 hr lunch or some important point in time
 * (a `line`, i.e. a range with 0 duration). This feature can also show a current time indicator if you set {@link #config-showCurrentTimeLine} to true. To style
 * the rendered elements, use the {@link Scheduler.model.TimeSpan#field-cls cls} field of the `TimeSpan` class.
 *
 * Each time range is represented by an instances of {@link Scheduler.model.TimeSpan}, held in a simple {@link Common.data.Store}.
 * If {@link Scheduler.data.CrudManager} is specified for the scheduler, the {@link #config-store} will be added at the end of the CrudManager
 * {@link Scheduler.crud.AbstractCrudManager#property-stores} collection.
 *
 * This feature is **disabled** by default
 *
 * @extends Scheduler/feature/AbstractTimeRanges
 * @classtype timeRanges
 * @demo timeranges
 * @externalexample scheduler/TimeRanges.js
 */
class TimeRanges extends AbstractTimeRanges {
  //region Config

  static get defaultConfig() {
    return {
      /**
       * Store that holds timeRanges (using the {@link Scheduler.model.TimeSpan} model or subclass thereof).
       * A store will be automatically created if none is specified
       * @config {Object|Common.data.Store}
       */
      store: {
        modelClass: TimeSpan,
        storeId: 'timeRanges'
      },

      updateCurrentTimeLineInterval: 10000,

      /**
       * The date format to show in the header for the current time line, see {@link #config-showCurrentTimeLine}
       * @config {String}
       * @default
       */
      currentDateFormat: 'HH:mm',
      /**
       * Range definitions (data to {@link Scheduler.model.TimeSpan} models). Will be added to store.
       * @config {Scheduler.model.TimeSpan[]|Object[]}
       */
      timeRanges: null,

      /**
       * Show a line indicating current time
       * @config {Boolean}
       * @default
       */
      showCurrentTimeLine: false
    };
  }

  //endregion

  //region Init & destroy

  construct(client, config) {
    const me = this;

    super.construct(client, config);

    if (!client._timeRangesExposed) {
      // expose getter/setter for timeRanges on scheduler/gantt
      Object.defineProperty(client, 'timeRanges', {
        get: () => me.store.records,
        set: (timeRanges) => (me.store.data = timeRanges)
      });
      client._timeRangesExposed = true;
    }
  }

  startConfigure(config) {
    const { client } = this;

    // If the client's project has a timeRangeStore, we must use that
    if (client.project) {
      const store = client.project.timeRangeStore;

      if (store) {
        config.store = store;
      }
    }
  }

  //endregion

  //region Current time line

  initCurrentTimeLine() {
    const me = this,
      now = new Date();

    if (me.currentTimeLine || !me.showCurrentTimeLine) {
      return;
    }

    me.currentTimeLine = new me.store.modelClass({
      id: 'currentTime',
      cls: 'b-sch-current-time',
      startDate: now,
      name: DateHelper.format(now, me.currentDateFormat)
    });

    me.currentTimeInterval = me.setInterval(() => {
      me.currentTimeLine.startDate = new Date();
      me.currentTimeLine.name = DateHelper.format(me.currentTimeLine.startDate, me.currentDateFormat);
      me.onStoreChanged({ action: 'update', record: me.currentTimeLine });
    }, me.updateCurrentTimeLineInterval);

    if (me.client.rendered) {
      me.renderRanges();
    }
  }

  hideCurrentTimeLine() {
    const me = this;

    if (!me.currentTimeLine) {
      return;
    }

    me.clearInterval(me.currentTimeInterval);
    me.currentTimeLine = null;

    if (me.client.rendered) {
      me.renderRanges();
    }
  }

  renderRanges() {
    const me = this;

    super.renderRanges();

    if (me.showCurrentTimeLine && !me.disabled) {
      me.renderRange(me.currentTimeLine, true);
    }
  }

  /**
   * Get/set the current time line display state
   * @property {boolean}
   */
  get showCurrentTimeLine() {
    return this._showCurrentTimeLine;
  }

  set showCurrentTimeLine(show) {
    this._showCurrentTimeLine = show;

    if (show) {
      this.initCurrentTimeLine();
    } else {
      this.hideCurrentTimeLine();
    }
  }

  //endregion

  //region Menu items

  /**
   * Adds a menu item to show/hide current time line.
   * @param column Column
   * @param items Menu items
   * @returns {Object[]} Menu items
   * @private
   */
  getHeaderMenuItems(column, items) {
    const me = this;

    if (!items.some((item) => item.isCurrentTimeline) && column.type === 'timeAxis') {
      items.push({
        isCurrentTimeline: true,
        text: me.L('showCurrentTimeLine'),
        checked: me.showCurrentTimeLine,
        onToggle: ({ checked }) => {
          me.showCurrentTimeLine = checked;
        }
      });
    }
  }

  //endregion

  //region Disable

  /**
   * Get/set the features disabled state
   * @property {Boolean}
   */
  get disabled() {
    return this._disabled;
  }

  set disabled(disabled) {
    this._disabled = disabled;

    if (this.client.rendered) {
      this.renderRanges();
    }
  }

  /**
   * Returns the {@link Common.data.Store store} used by this feature
   * @property {Common.data.Store}
   */
  get store() {
    return this._store;
  }

  set store(store) {
    const me = this,
      client = me.client;

    if (!store.storeId) {
      store.storeId = 'timeRanges';
    }

    super.store = store;

    // timeRanges can be set on scheduler/gantt or feature, for convenience. Should only be processed by the TimeRanges
    // and not any subclasses
    if (client.timeRanges && !client._timeRangesExposed) {
      me._store.add(client.timeRanges);
      delete client.timeRanges;
    }

    if (me.timeRanges) {
      me._store.add(me.timeRanges);
      delete me.timeRanges;
    }
  }

  //endregion
}

TimeRanges._$name = 'TimeRanges';
GridFeatureManager.registerFeature(TimeRanges, false, ['Scheduler', 'Gantt']);

/**
 * @module Scheduler/column/ResourceInfoColumn
 */

/**
 * Displays resource information. Defaults to showing image + name + event count, but what to show is configurable.
 * Be sure to specify {@link Scheduler.view.mixin.SchedulerEventRendering#config-resourceImagePath} to instruct the
 * column where to look for the images.
 * @externalexample scheduler/ResourceInfoColumn.js
 * @classType resourceInfo
 * @extends Grid/column/Column
 */
class ResourceInfoColumn extends Column {
  static get type() {
    return 'resourceInfo';
  }

  static get fields() {
    return [
      'showEventCount',
      'showRole',
      'showImage',
      'imagePath',
      'validNames',
      'defaultImageName',
      'autoScaleThreshold'
    ];
  }

  static get defaults() {
    return {
      /**
       * Show image. Looks for image name in fields on the resource in the following order: 'imageUrl', 'image', 'name'.
       * Set `showImage` to a field name to use a custom field. Set `imagePath` to specify where to load
       * images from. If no extension found, defaults to .jpg.
       * @config {Boolean}
       * @default
       */
      showImage: true,

      /**
       * Show number of events assigned to the resource below the name.
       * @config {Boolean}
       * @default
       */
      showEventCount: true,

      /**
       * Show resource role below the name. Specify `true` to display data from the `role` field, or specify a field
       * name to read this value from.
       * @config {Boolean|String}
       * @default
       */
      showRole: false,

      /**
       * Path to load images from. Defaults to using the value of {@link Scheduler.view.mixin.SchedulerEventRendering#config-resourceImagePath}
       * @config {String}
       * @deprecated 2.2
       */
      imagePath: null,

      /**
       * Valid image names. Set to `null` to allow all names.
       * @config {String[]}
       * @default
       */
      validNames: [
        'amit',
        'angelo',
        'arcady',
        'arnold',
        'celia',
        'chang',
        'dan',
        'dave',
        'emilia',
        'george',
        'gloria',
        'henrik',
        'hitomi',
        'jong',
        'kate',
        'lee',
        'linda',
        'lisa',
        'lola',
        'macy',
        'madison',
        'malik',
        'mark',
        'maxim',
        'mike',
        'rob',
        'steve'
      ],

      /**
       * Generic user image, used when an invalid name is specified
       * @config {String}
       * @deprecated 2.2
       */
      defaultImageName: null,

      /**
       * Specify 0 to prevent the column from adapting its content according to the used row height, or specify a
       * a threshold (row height) at which scaling should start.
       * @config {Number}
       * @default
       */
      autoScaleThreshold: 40,

      field: 'name',
      htmlEncode: false,
      width: 140,

      autoSyncHtml: true
    };
  }

  construct() {
    const me = this;

    super.construct(...arguments);

    if (me.grid.element) {
      me.addErrorListener();
    } else {
      me.grid.on({
        paint: me.addErrorListener,
        thisObj: me,
        once: true
      });
    }
  }

  set imagePath(path) {
    this.set('imagePath', path);
  }

  get imagePath() {
    return this.get('imagePath') || this.grid.resourceImagePath;
  }

  set defaultImageName(name) {
    this.set('defaultImageName', name);
  }

  get defaultImageName() {
    return this.get('defaultImageName') || this.grid.defaultResourceImageName;
  }

  addErrorListener() {
    const missingImgUrl = `${this.imagePath}${this.defaultImageName}`;

    EventHelper.on({
      element: this.grid.element,
      delegate: '.b-resource-image',
      error: (event) => {
        const target = event.target;

        if (target.src !== target._lastMissingUrl) {
          target._lastMissingUrl = target.src;

          target.src = missingImgUrl;
        }
      },
      capture: true
    });
  }

  template(record) {
    const me = this,
      { showImage, showRole, showEventCount } = me,
      roleField = typeof showRole === 'string' ? showRole : 'role',
      role = record[roleField],
      count = record.events.length,
      value = record.get(me.field);

    let imageUrl;

    if (showImage) {
      if (record.imageUrl) {
        imageUrl = record.imageUrl;
      } else {
        // record.image supposed to be a file name, located at imagePath
        let imageName =
          typeof showImage === 'string'
            ? showImage
            : record.image || (value && value.toLowerCase()) || me.defaultImageName;

        imageUrl = me.imagePath + imageName;

        // Image name supposed to have an extension
        if (!imageName.includes('.')) {
          // If validNames is specified, check that imageName is valid
          if (!me.validNames || me.validNames.includes(imageName)) {
            imageUrl += '.jpg';
          }
          // If name is not valid, use generic image
          else {
            imageUrl = me.imagePath + me.defaultImageName;
          }
        }
      }
    }

    return ` 
            <div class="b-resource-info">
                ${imageUrl ? `<img class="b-resource-image" draggable="false" src="${imageUrl}">` : ''}
                <dl>
                <dt>${value}</dt>
                ${showRole ? `<dd class="b-resource-role">${role}</dd>` : ''}
                ${showEventCount ? `<dd class="b-resource-events">${me.L('eventCountText', count)}</dd>` : ''}
                </dl>
            </div>
        `;
  }

  renderer({ grid, record, cellElement }) {
    if (record.meta.specialRow) {
      return '';
    }

    if (this.autoScaleThreshold && grid.rowHeight < this.autoScaleThreshold) {
      cellElement.style.fontSize = grid.rowHeight / 40 + 'em';
    } else {
      cellElement.style.fontSize = '';
    }

    return this.template(record);
  }
}

ColumnStore.registerColumnType(ResourceInfoColumn);
ResourceInfoColumn._$name = 'ResourceInfoColumn';

//TODO: If we want to improve on this, add settings as attributes, replace data-field with field etc.

/**
 * @module Scheduler/customElements/SchedulerTag
 */

/**
 * Import this file to be able to use the tag **&lt;bryntum-scheduler&gt;** to create a scheduler. This is more of a
 * proof of concept than a ready to use class. Dataset from **&lt;data&gt;** and **&lt;bryntum-scheduler&gt;** tags is
 * applied to record and scheduler config, which means, that you can pass any documented config there, not only
 * demonstrated here. Dataset attributes are translated as follows:
 *
 *  * data-view-preset -> viewPreset
 *  * data-start-date -> startDate
 *
 *  etc.
 * ## Example
 * ```
 * &lt;bryntum-scheduler data-view-preset="weekAndDay" data-start-date="2018-04-02" data-end-date="2018-04-09"&gt;
 *  &lt;column data-field="name"&gt;Name&lt;/column&gt;
 *      &lt;data&gt;
 *          &lt;events&gt;
 *              &lt;data data-id="1" data-resource-id="1" data-start-date="2018-04-03" data-end-date="2018-04-05"&gt;&lt;/data&gt;
 *              &lt;data data-id="2" data-resource-id="2" data-start-date="2018-04-04" data-end-date="2018-04-06"&gt;&lt;/data&gt;
 *              &lt;data data-id="3" data-resource-id="3" data-start-date="2018-04-05" data-end-date="2018-04-07"&gt;&lt;/data&gt;
 *          &lt;/events&gt;
 *          &lt;resources&gt;
 *              &lt;data data-id="1" data-name="Daniel"&gt;&lt;/data&gt;
 *              &lt;data data-id="2" data-name="Steven"&gt;&lt;/data&gt;
 *              &lt;data data-id="3" data-name="Sergei"&gt;&lt;/data&gt;
 *          &lt;/resources&gt;
 *      &lt;/data&gt;
 * &lt;/bryntum-scheduler&gt;
 * ```
 */
// This is required to make trial build function normally
const TagBase = window.customElements ? HTMLElement : Object;

class SchedulerTag extends TagBase {
  constructor() {
    super();

    const me = this,
      columns = [],
      resources = [],
      events = [];

    // create columns and data
    for (let tag of me.children) {
      if (tag.tagName === 'COLUMN') {
        const width = parseInt(tag.dataset.width),
          flex = parseInt(tag.dataset.flex),
          column = {
            field: tag.dataset.field,
            text: tag.innerHTML
          };

        if (width) column.width = width;
        else if (flex) column.flex = flex;
        else column.flex = 1;

        columns.push(column);
      } else if (tag.tagName === 'DATA') {
        for (let storeType of tag.children) {
          for (let record of storeType.children) {
            const row = {};

            Object.assign(row, record.dataset);

            if (storeType.tagName === 'EVENTS') {
              events.push(row);
            } else if (storeType.tagName === 'RESOURCES') {
              resources.push(row);
            }
          }
        }
      }
    }

    const // go over to the dark side
      shadowRoot = this.attachShadow({ mode: 'open' }),
      // include css and target div in shadow dom
      link = document.createElement('link');

    link.rel = 'stylesheet';
    link.href = '../../build/scheduler.default.css';

    link.onload = () => {
      const div = document.createElement('div');

      div.id = 'container';
      div.style.width = '100%';
      div.style.height = '100%';

      shadowRoot.appendChild(div);

      // Listen to focus events on shadow root to handle focus inside the shadow dom
      setupFocusListeners(shadowRoot);

      const config = {
        appendTo: div,
        columns: columns,
        resources,
        events
      };
      Object.assign(config, me.dataset);

      // render as usual
      const scheduler = new Scheduler(config);

      // for testing, set first scheduler as global variable
      if (!window.scheduler) window.scheduler = scheduler;
    };

    shadowRoot.appendChild(link);
  }
}

// Try-catch to make trial work
try {
  window.customElements && window.customElements.define('bryntum-scheduler', SchedulerTag);
} catch (error) {}
SchedulerTag._$name = 'SchedulerTag';

/* eslint-disable */
// leave in, comment removed in bryntum-loader. also needs to go at top since polyfill is used by other code
//import "nodelist-foreach-polyfill";

if (!window.bryntum) window.bryntum = {};

export {
  Localizable,
  LocaleManagerSingelton as LocaleManager,
  AjaxHelper,
  ArrayHelper,
  BrowserHelper,
  CSSHelper,
  DateHelper,
  DomHelper,
  DomClassList,
  DragHelper,
  EventHelper,
  FunctionHelper,
  IdHelper,
  ObjectHelper,
  ResizeHelper,
  StringHelper,
  TemplateHelper,
  VersionHelper,
  WidgetHelper,
  Point,
  Rectangle,
  ResizeMonitor,
  GlobalEvents,
  DataGenerator,
  RandomGenerator,
  DemoBot,
  Fullscreen,
  Scroller,
  Delayable,
  Events,
  InstancePlugin,
  Override,
  Pluggable,
  State,
  BooleanCombo,
  Button,
  ButtonGroup,
  CalendarPanel,
  Checkbox,
  Combo,
  Container,
  Field,
  FileField,
  FilePicker,
  FlagField,
  DateField,
  DatePicker,
  DisplayField,
  DurationField,
  List,
  ChipView,
  Mask,
  Menu,
  MenuItem,
  NumberField,
  Tool,
  Panel,
  Popup,
  Ripple,
  Slider,
  TabPanel,
  TextField,
  TextAreaField,
  TimeField,
  TimePicker,
  Toast,
  Tooltip,
  Widget,
  BryntumWidgetAdapter,
  BryntumWidgetAdapterRegister,
  AjaxStore,
  Model,
  Store,
  StateTrackingManager,
  Transaction,
  Column,
  CheckColumn,
  DateColumn,
  PercentColumn,
  RatingColumn,
  RowNumberColumn,
  TemplateColumn,
  TimeColumn,
  TreeColumn,
  WidgetColumn,
  TimeAxisColumn,
  ResourceInfoColumn,
  GridFeatureManager,
  CellEdit,
  CellTooltip,
  ColumnPicker,
  ColumnReorder,
  ColumnResize,
  ContextMenu,
  Filter,
  FilterBar,
  Group,
  QuickFind,
  Search,
  Sort,
  RegionResize,
  RowReorder,
  Stripe,
  Tree,
  Grid,
  TreeGrid,
  AjaxTransport,
  AbstractCrudManager,
  JsonEncoder,
  ColumnStore,
  AssignmentStore,
  Calendar,
  CrudManager,
  DependencyStore,
  EventStore,
  ResourceStore,
  ResourceTimeRangeStore,
  TimeAxis,
  ColumnLines,
  Dependencies,
  DependencyEdit,
  EventContextMenu,
  EventDrag,
  EventDragCreate,
  EventDragSelect,
  EventEdit,
  EventFilter,
  EventResize,
  EventTooltip,
  GroupSummary$1 as GroupSummary,
  HeaderContextMenu,
  HeaderZoom,
  Labels,
  NonWorkingTime,
  Pan,
  ResourceTimeRanges,
  ScheduleTooltip,
  SimpleEventEdit,
  Summary$1 as Summary,
  TimeRanges,
  AssignmentModel,
  CalendarDayModel,
  DependencyBaseModel,
  DependencyModel,
  EventModel,
  ResourceModel,
  ResourceTimeRangeModel,
  TimeSpan,
  PresetManager,
  ViewPreset,
  RectangularPathFinder,
  TimeAxisViewModel,
  HorizontalTimeAxis,
  Scheduler,
  RowManager,
  SchedulerTag
};
//# sourceMappingURL=scheduler.module.js.map
